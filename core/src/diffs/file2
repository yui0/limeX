diff --git a/src/ChangeLog b/src/ChangeLog
index 775d3bf..3906a31 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,9 @@
+27 Nov 2010
+	* added GdFindConvBlit, GdPrintBitmap, set_data_format functions
+	* require data_format on all screen drivers, used by GdArea
+	* added fast convblit handling to GdArea routine for 32,24,16bpp
+	* added Update to fblin8, palette mode fixes, fix X11 for palette mode
+	* cleaned up drivers and source, removed commented-out stretchblit
 24 Nov 2010
 	* removed PSDOP_xxx and GdDrawAreaInternal, all DrawArea entry points
 	* convered portrait mode drawarea to convblit, used only for 1,2,4,8 bpp subdrivers
diff --git a/src/DEPRECATED b/src/DEPRECATED
index b40a6b1..f67b6aa 100644
--- a/src/DEPRECATED
+++ b/src/DEPRECATED
@@ -1,4 +1,4 @@
-DEPRECATED FILES AND DRIVERS	11/21/2010
+DEPRECATED FILES AND DRIVERS	11/27/2010
 
 After v0.92, the internal drawing model has changed.  Instead
 of allowing screen drivers to implement drawpixel, drawhline,
@@ -34,11 +34,11 @@ scr_win32.c		- Win32 port, needs rewrite ala X11 driver
 vgaplan4.c		- Direct VGA Access
 memplan4.c		- Direct VGA Access
 elkplan4.c		- Elks OS
+fblin18.c		- 18bpp driver 666 format for ASM PXA270 with 18bit LCD
 
 
 POSSIBLE OBSOLETE DRIVERS - NEED TESTING/UPDATING
 fblin32alpha.c	- configurable 32bpp ABGR or ARGB, reads/writes DWORD only
-fblin18.c		- 18bpp driver 666 format for ASM PXA270 with 18bit LCD
 fblin12.c		- 12bpp driver for Cirrus Logic
 fblin4hp.c		- fast 4bpp driver for Vr41xx Palm
 fblin4orion.c	- 4access Communications Orion machines
diff --git a/src/FIXME b/src/FIXME
index bc8fc30..1f0d500 100644
--- a/src/FIXME
+++ b/src/FIXME
@@ -1,10 +1,15 @@
+**move some BGRA GdArea convblits to driver layer
+check 255 alpha on 8888_8888 copy
+check whether seperate portrait mode blits required
+plans for GdArea Translation, GdReadArea blit?
+
 bin/mdemo requires extra mouse press/move to redraw on X11
 remove seperate driver procs and combine to single SUBDRIVER in screendevice
 rename orgsubdriver, left_subdriver etc
-add fast blit for GdArea/GrArea, remove printfs
 debug fltk test/pixmap putTruecolorImage GrArea problem
 
 Look at RGB2PIXEL in convblit_mask/8888.c, will this work on all systems?
+	RGB2PIXEL kluged for MWPF_PALETTE compiles, set to 0 as not supported
 
 fix x11 driver kluges 
 need different way of SUBDRIVER left/right/down etc switching
@@ -15,8 +20,6 @@ fix vncserver.c support (drawarea, etc)
 GdBitmap/drawbitmap fallback for < 16bpp
 	fix psd->bpp >= 16 kluge in gen_drawtext (non convblit driver fallback to GdBitmap)
 
-GdArea fix add PSDOP_COPY back convblit instead of GdDrawAreaInternal
-	HWPF_PIXELVAL uses fast copy routine
 FT2 don't use antialias settings if no HAVEOP_ALPHACOL driver entry point
 
 16bpp convblits are endian-specific
@@ -31,13 +34,10 @@ remove FT1 from Config/configs*
 config option to eliminate not needed subdrivers?
 
 move data_format in MWIMAGEHDR	after changing convbmp
-fix data_format in scr_x11.c, scr_fb.c
 deprecate old screen drivers, fontmapper, !DYNAMICREGIONS, fblin32alpha.c
 	fix mwin/winfonts.c::EnumFonts GdGetFontList/GdFreeFontList/GdTextSizeEx for FT1
 	add GdGetTextSizeEx/GdGetFontList to FT2 from FT1
 
-plans for GdArea, GdReadArea, GdTranslation
-
 drawarea alphamap, copytrans, copyall(=convblit copy vs srcover)
 	check srcover vs copy for RGBA8888 images
 
diff --git a/src/chess.sh b/src/chess.sh
index 8499bb2..d308589 100755
--- a/src/chess.sh
+++ b/src/chess.sh
@@ -1,3 +1,3 @@
 
 # Nano-X applications, press <BREAK> key to exit
-bin/nano-X & bin/nanowm & bin/tuxchess & bin/nxroach
+bin/nano-X -N & bin/nanowm & bin/tuxchess & bin/nxroach
diff --git a/src/drivers/fb.c b/src/drivers/fb.c
index 588103d..7d039f5 100644
--- a/src/drivers/fb.c
+++ b/src/drivers/fb.c
@@ -50,18 +50,14 @@ select_fb_subdriver(PSD psd)
 		case 16:
 			pdriver = fblinear16;
 			break;
-		case 18: // addon VB May 2007 : 18bpp fb linear driver FIXME
 		case 24:
 			pdriver = fblinear24;
-printf("selecting 24bpp subdriver\n");
 			break;
 		case 32:
-			if (psd->pixtype == MWPF_TRUECOLOR8888 || psd->pixtype == MWPF_TRUECOLORABGR) {
+			if (psd->pixtype == MWPF_TRUECOLOR8888 || psd->pixtype == MWPF_TRUECOLORABGR)
 				pdriver = fblinear32alpha;
-			} else {
+			else
 				pdriver = fblinear32;
-printf("selecting 32bpp subdriver\n");
-			}
 			break;
 		}
 	}
@@ -78,3 +74,53 @@ printf("selecting 32bpp subdriver\n");
 	/* return driver selected*/
 	return pdriver[0];
 }
+
+/* set standard data_format from bpp and pixtype*/
+int
+set_data_format(PSD psd)
+{
+	int data_format = 0;
+
+	switch(psd->pixtype) {
+	case MWPF_PALETTE:
+		switch (psd->bpp) {
+		case 8:
+			data_format = MWIF_PAL8;
+			break;
+		case 4:
+			data_format = MWIF_PAL4;
+			break;
+		case 2:
+			data_format = MWIF_PAL2;
+			break;
+		case 1:
+			data_format = MWIF_PAL1;
+			break;
+		}
+		break;
+	case MWPF_TRUECOLOR8888:
+	case MWPF_TRUECOLOR0888:
+		data_format = MWIF_BGRA8888;
+		break;
+	case MWPF_TRUECOLORABGR:
+		data_format = MWIF_RGBA8888;
+		break;
+	case MWPF_TRUECOLOR888:
+		data_format = MWIF_BGR888;
+		break;
+	case MWPF_TRUECOLOR565:
+		data_format = MWIF_RGB565;
+		break;
+	case MWPF_TRUECOLOR555:
+		data_format = MWIF_RGB565;
+		break;
+	case MWPF_TRUECOLOR332:
+		data_format = MWIF_RGB332;
+		break;
+	case MWPF_TRUECOLOR233:
+		data_format = MWIF_BGR233;
+		break;
+	}
+
+	return data_format;
+}
diff --git a/src/drivers/fb.h b/src/drivers/fb.h
index a6b4b42..b1f80f0 100644
--- a/src/drivers/fb.h
+++ b/src/drivers/fb.h
@@ -568,6 +568,7 @@ void	get_subdriver(PSD psd, PSUBDRIVER subdriver);
 
 /* fb.c*/
 PSUBDRIVER select_fb_subdriver(PSD psd);
+int		set_data_format(PSD psd);
 
 /* fbportrait_xxx.c*/
 extern SUBDRIVER fbportrait_left;
diff --git a/src/drivers/fblin8.c b/src/drivers/fblin8.c
index 73ad326..7fc4dad 100644
--- a/src/drivers/fblin8.c
+++ b/src/drivers/fblin8.c
@@ -58,6 +58,9 @@ linear8_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 		((ADDR8)psd->addr)[x + y * psd->linelen] = c;
 	else
 		applyOp(gr_mode, c, &((ADDR8)psd->addr)[ x + y * psd->linelen], ADDR8);
+
+	if (psd->Update)
+		psd->Update(psd, x, y, 1, 1);
 	DRAWOFF;
 }
 
@@ -78,6 +81,7 @@ static void
 linear8_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	register ADDR8 addr = ((ADDR8)psd->addr) + x1 + y * psd->linelen;
+	MWCOORD X1 = x1;
 #if DEBUG
 	assert (addr != 0);
 	assert (x1 >= 0 && x1 < psd->xres);
@@ -95,6 +99,9 @@ linear8_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 			++addr;
 		}
 	}
+
+	if (psd->Update)
+		psd->Update(psd, X1, y, x2-X1+1, 1);
 	DRAWOFF;
 }
 
@@ -103,6 +110,7 @@ static void
 linear8_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	int	linelen = psd->linelen;
+	MWCOORD Y1 = y1;
 	register ADDR8 addr = ((ADDR8)psd->addr) + x + y1 * linelen;
 #if DEBUG
 	assert (psd->addr != 0);
@@ -124,6 +132,9 @@ linear8_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 			addr += linelen;
 		}
 	}
+
+	if (psd->Update)
+		psd->Update(psd, x, Y1, 1, y2-Y1+1);
 	DRAWOFF;
 }
 
@@ -136,7 +147,8 @@ linear8_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	ADDR8	src;
 	int	dlinelen = dstpsd->linelen;
 	int	slinelen = srcpsd->linelen;
-
+	int H = h;
+#if DEBUG
 	assert (dstpsd->addr != 0);
 	assert (dstx >= 0 && dstx < dstpsd->xres);
 	assert (dsty >= 0 && dsty < dstpsd->yres);
@@ -149,7 +161,7 @@ linear8_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	assert (dsty+h <= dstpsd->yres);
 	assert (srcx+w <= srcpsd->xres);
 	assert (srcy+h <= srcpsd->yres);
-
+#endif
 	dst = ((ADDR8)dstpsd->addr) + dstx + dsty * dlinelen;
 	src = ((ADDR8)srcpsd->addr) + srcx + srcy * slinelen;
 
@@ -211,74 +223,11 @@ copy:
 			src += slinelen - w;
 		}
 	}
-	DRAWOFF;
-}
 
-#if 0000 /* DEPRECATED*/
-/* srccopy stretchblt*/
-static void
-linear8_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw,
-	MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw,
-	MWCOORD srch, int op)
-{
-	ADDR8	dst;
-	ADDR8	src;
-	int	dlinelen = dstpsd->linelen;
-	int	slinelen = srcpsd->linelen;
-	int	i, ymax;
-	int	row_pos, row_inc;
-	int	col_pos, col_inc;
-	unsigned char pixel = 0;
-
-	assert (dstpsd->addr != 0);
-	assert (dstx >= 0 && dstx < dstpsd->xres);
-	assert (dsty >= 0 && dsty < dstpsd->yres);
-	assert (dstw > 0);
-	assert (dsth > 0);
-	assert (srcpsd->addr != 0);
-	assert (srcx >= 0 && srcx < srcpsd->xres);
-	assert (srcy >= 0 && srcy < srcpsd->yres);
-	assert (srcw > 0);
-	assert (srch > 0);
-	assert (dstx+dstw <= dstpsd->xres);
-	assert (dsty+dsth <= dstpsd->yres);
-	assert (srcx+srcw <= srcpsd->xres);
-	assert (srcy+srch <= srcpsd->yres);
-
-	DRAWON;
-	row_pos = 0x10000;
-	row_inc = (srch << 16) / dsth;
-
-	/* stretch blit using integer ratio between src/dst height/width*/
-	for (ymax = dsty+dsth; dsty<ymax; ++dsty) {
-
-		/* find source y position*/
-		while (row_pos >= 0x10000L) {
-			++srcy;
-			row_pos -= 0x10000L;
-		}
-
-		dst = ((ADDR8)dstpsd->addr) + dstx + dsty*dlinelen;
-		src = ((ADDR8)srcpsd->addr) + srcx + (srcy-1)*slinelen;
-
-		/* copy a row of pixels*/
-		col_pos = 0x10000;
-		col_inc = (srcw << 16) / dstw;
-		for (i=0; i<dstw; ++i) {
-			/* get source x pixel*/
-			while (col_pos >= 0x10000L) {
-				pixel = *src++;
-				col_pos -= 0x10000L;
-			}
-			*dst++ = pixel;
-			col_pos += col_inc;
-		}
-
-		row_pos += row_inc;
-	}
+	if (dstpsd->Update)
+		dstpsd->Update(dstpsd, dstx, dsty, w, H);
 	DRAWOFF;
 }
-#endif /* DEPRECATED*/
 
 /*
  * This stretchblit code was originally written for the TriMedia
@@ -532,8 +481,10 @@ linear8_stretchblitex(PSD dstpsd,
 			}
 		}
 		break;
-
 	}
+
+	if (dstpsd->Update)
+		dstpsd->Update(dstpsd, dest_x_start, dest_y_start, width, height);
 }
 
 /* FIXME create lookup table whenever palette changed*/
@@ -757,6 +708,8 @@ linear8_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 		}
 	}
 
+	if (psd->Update)
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
 	DRAWOFF;
 
 #undef MWI_IS_BIT_BEFORE_OR_EQUAL
@@ -944,6 +897,8 @@ linear8_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 		}
 	}
 
+	if (psd->Update)
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
 	DRAWOFF;
 
 #undef MWI_IS_BIT_BEFORE_OR_EQUAL
@@ -1002,6 +957,9 @@ linear8_convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc)
 		alpha += src_row_step;
 		dst += dst_row_step;
 	}
+
+	if (psd->Update)
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
 	DRAWOFF;
 }
 
@@ -1016,10 +974,10 @@ static SUBDRIVER fblinear8_none = {
 	linear8_stretchblitex,
 	linear8_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
 	linear8_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
-	NULL,		/* BlitCopyMaskMonoWordMSB*/
+	NULL,		/* BlitCopyMaskMonoWordMSB*/	/* core, PCF, FNT will use GdBitmap fallback*/
 	linear8_convblit_blend_mask_alpha_byte,		/* FT2/T1 anti-alias*/
-	NULL,		/* BlitSrcOverRGBA8888*/
-	NULL		/* BlitCopyRGB888*/
+	NULL,		/* BlitSrcOverRGBA8888*/		/* images will use GdDrawImageInternal fallback*/
+	NULL		/* BlitCopyRGB888*/				/* images will use GdDrawImageInternal fallback*/
 };
 
 PSUBDRIVER fblinear8[4] = {
diff --git a/src/drivers/fbportrait_down.c b/src/drivers/fbportrait_down.c
index fef0e7f..e542dd8 100644
--- a/src/drivers/fbportrait_down.c
+++ b/src/drivers/fbportrait_down.c
@@ -101,7 +101,7 @@ fbportrait_down_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!dstpsd->BlitBlendMaskAlphaByte)
+	if (!dstpsd->orgsubdriver->BlitBlendMaskAlphaByte)
 		return;
 
 	/* create new gc with flipped coords*/
@@ -154,7 +154,7 @@ fbportrait_down_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteMSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteMSB)
 		return;
 
 	/* create new gc with flipped coords*/
@@ -210,7 +210,7 @@ fbportrait_down_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteLSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteLSB)
 		return;
 
 	/* create new gc with flipped coords*/
diff --git a/src/drivers/fbportrait_left.c b/src/drivers/fbportrait_left.c
index 24bd546..16e6c75 100644
--- a/src/drivers/fbportrait_left.c
+++ b/src/drivers/fbportrait_left.c
@@ -99,7 +99,7 @@ fbportrait_left_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!dstpsd->BlitBlendMaskAlphaByte)
+	if (!dstpsd->orgsubdriver->BlitBlendMaskAlphaByte)
 		return;
 
 	/* create new gc with rotated coords*/
@@ -153,7 +153,7 @@ fbportrait_left_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteMSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteMSB)
 		return;
 
 	/* create new gc with rotated coords*/
@@ -209,7 +209,7 @@ fbportrait_left_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteLSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteLSB)
 		return;
 
 	/* create new gc with rotated coords*/
diff --git a/src/drivers/fbportrait_right.c b/src/drivers/fbportrait_right.c
index 1a603b0..059a70a 100644
--- a/src/drivers/fbportrait_right.c
+++ b/src/drivers/fbportrait_right.c
@@ -96,7 +96,7 @@ fbportrait_right_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!dstpsd->BlitBlendMaskAlphaByte)
+	if (!dstpsd->orgsubdriver->BlitBlendMaskAlphaByte)
 		return;
 
 	/* create new gc with rotated coords*/
@@ -149,7 +149,7 @@ fbportrait_right_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteMSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteMSB)
 		return;
 
 	/* create new gc with rotated coords*/
@@ -205,7 +205,7 @@ fbportrait_right_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	MWBLITPARMS	l_gc;
 
-	if (!psd->BlitCopyMaskMonoByteLSB)
+	if (!psd->orgsubdriver->BlitCopyMaskMonoByteLSB)
 		return;
 
 	/* create new gc with rotated coords*/
diff --git a/src/drivers/genmem.c b/src/drivers/genmem.c
index 469452e..b29499a 100644
--- a/src/drivers/genmem.c
+++ b/src/drivers/genmem.c
@@ -65,6 +65,86 @@ gen_initmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
 	mempsd->addr = addr;
 }
 
+/*
+ * Calculate size and linelen of memory gc.
+ * If bpp or planes is 0, use passed psd's bpp/planes.
+ * Note: linelen is calculated to be DWORD aligned for speed
+ * for bpp <= 8.  Linelen is converted to bytelen for bpp > 8.
+ */
+int
+GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height, int planes,
+	int bpp, int *psize, int *plinelen, int *ppitch)
+{
+	int	bytelen, linelen, tmp;
+
+	if(!planes)
+		planes = psd->planes;
+	if(!bpp)
+		bpp = psd->bpp;
+	/* 
+	 * swap width and height in left/right portrait modes,
+	 * so imagesize is calculated properly
+	 */
+	if(psd->portrait & (MWPORTRAIT_LEFT|MWPORTRAIT_RIGHT)) {
+		tmp = width;
+		width = height;
+		height = tmp;
+	}
+
+	/*
+	 * use bpp and planes to create size and linelen.
+	 * linelen is in bytes for bpp 1, 2, 4, 8, and pixels for bpp 16,24,32.
+	 */
+	if(planes == 1) {
+		switch(bpp) {
+		case 1:
+			linelen = (width+7)/8;
+			bytelen = linelen = (linelen+3) & ~3;
+			break;
+		case 2:
+			linelen = (width+3)/4;
+			bytelen = linelen = (linelen+3) & ~3;
+			break;
+		case 4:
+			linelen = (width+1)/2;
+			bytelen = linelen = (linelen+3) & ~3;
+			break;
+		case 8:
+			bytelen = linelen = (width+3) & ~3;
+			break;
+		case 16:
+			linelen = width;
+			bytelen = width * 2;
+			break;
+		case 24:
+		case 18:
+			linelen = width;
+			bytelen = width * 3;
+			break;
+		case 32:
+			linelen = width;
+			bytelen = width * 4;
+			break;
+		default:
+			return 0;
+		}
+	} else if(planes == 4) {
+		/* FIXME assumes VGA 4 planes 4bpp*/
+		/* we use 4bpp linear for memdc format*/
+		linelen = (width+1)/2;
+		linelen = (linelen+3) & ~3;
+		bytelen = linelen;
+	} else {
+		*psize = *plinelen = 0;
+		return 0;
+	}
+
+	*psize = bytelen * height;
+	*plinelen = linelen;
+	*ppitch = bytelen;
+	return 1;
+}
+
 /* 
  * Initialize memory device with passed parms,
  * select suitable framebuffer subdriver,
diff --git a/src/drivers/scr_ecos.c b/src/drivers/scr_ecos.c
index 78746dd..6f10029 100644
--- a/src/drivers/scr_ecos.c
+++ b/src/drivers/scr_ecos.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
  *
- * Microwindows Screen Driver for Linux kernel framebuffers
+ * Microwindows Screen Driver for eCos
  *
  * Portions used from Ben Pfaff's BOGL <pfaffben@debian.org>
  *
@@ -84,17 +84,6 @@ fb_open(PSD psd)
 
     psd->xres = psd->xvirtres = li.width;
     psd->yres = psd->yvirtres = li.height;
-#if PORTRAIT
-    /* automatic portrait mode if y resolution is greater than x res*/
-    /* * commented out, PORTRAIT_MODE=[R,L] used for compile time option***/
-    /* *if(psd->yres > psd->xres)
-        gr_portraitmode = 1;***/
-#endif
-    /* set planes from fb type*/
-    if (1 /*type == FB_TYPE_PACKED_PIXELS*/)
-        psd->planes = 1;   /* FIXME */
-    else psd->planes = 0;	/* force error later*/
-
     psd->bpp = li.bpp;
     psd->ncolors = (psd->bpp >= 24)? (1 << 24): (1 << psd->bpp);
 
@@ -103,6 +92,7 @@ fb_open(PSD psd)
     psd->size = 0;		/* force subdriver init of size*/
 
     psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
+    psd->planes = 1;
 
 #if PORTRAIT
     /* determine whether to run in portrait mode*/
@@ -115,11 +105,11 @@ fb_open(PSD psd)
     }
 #endif
 
-	psd->data_format = 0;			// FIXME
     /* set pixel format*/
     switch (li.type) {
     case FB_TRUE_RGB565:
         psd->pixtype = MWPF_TRUECOLOR565;
+		psd->data_format = MWIF_RGB565;
         break;
     default:
         EPRINTF("Unsupported display type: %d\n", li.type);
diff --git a/src/drivers/scr_fb.c b/src/drivers/scr_fb.c
index 8cdaf13..9f007e7 100644
--- a/src/drivers/scr_fb.c
+++ b/src/drivers/scr_fb.c
@@ -192,7 +192,6 @@ fb_open(PSD psd)
 
 	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
 
-	psd->data_format = 0;			// FIXME coming soon
 	/* set pixel format*/
 	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
 		switch(psd->bpp) {
@@ -217,13 +216,15 @@ fb_open(PSD psd)
 				psd->pixtype = MWPF_TRUECOLOR8888;
 			break;
 		default:
-			EPRINTF("Unsupported %ld color (%d bpp) truecolor framebuffer\n",
-				psd->ncolors, psd->bpp);
+			EPRINTF("Unsupported %ld color (%d bpp) truecolor framebuffer\n", psd->ncolors, psd->bpp);
 			goto fail;
 		}
 	} else 
 		psd->pixtype = MWPF_PALETTE;
 
+	/* set standard data format from bpp and pixtype*/
+	psd->data_format = set_data_format(psd);
+
 	EPRINTF("%dx%dx%dbpp linelen %d type %d visual %d colors %ld pixtype %d\n", psd->xres, psd->yres,
 		(psd->pixtype == MWPF_TRUECOLOR555)? 15: psd->bpp, psd->linelen, type, visual,
 		psd->ncolors, psd->pixtype);
diff --git a/src/drivers/scr_fbsd.c b/src/drivers/scr_fbsd.c
index 409b512..f16c139 100644
--- a/src/drivers/scr_fbsd.c
+++ b/src/drivers/scr_fbsd.c
@@ -143,7 +143,7 @@ static PSD FBSD_open(PSD psd)
     psd -> linelen = VGLDisplay->Xsize;
     psd -> planes  = 1;
     psd -> pixtype = MWPIXEL_FORMAT;
-	psd -> data_format = 0;			// FIXME
+	psd -> data_format = MWIF_PAL8;
     psd -> bpp = 8;
 
 /*     switch(psd->pixtype) { */
@@ -172,7 +172,7 @@ static PSD FBSD_open(PSD psd)
     psd->addr = NULL;
     psd->flags = PSF_SCREEN|PSF_HAVEBLIT;
 
-    savebits=*psd;
+    savebits = *psd;
     savebits.flags=PSF_MEMORY | PSF_HAVEBLIT;
     /* select a fb subdriver matching our planes and bpp */
     subdriver = select_fb_subdriver(&savebits);
diff --git a/src/drivers/scr_mosync.c b/src/drivers/scr_mosync.c
index 1e481a2..f372304 100644
--- a/src/drivers/scr_mosync.c
+++ b/src/drivers/scr_mosync.c
@@ -89,7 +89,6 @@ fb_open(PSD psd)
 		else
 			psd->pixtype = MWPF_TRUECOLOR565;
 		break;
-	case 18:
 	case 24:
 		psd->pixtype = MWPF_TRUECOLOR888;
 		break;
@@ -97,12 +96,13 @@ fb_open(PSD psd)
 		psd->pixtype = MWPF_TRUECOLOR0888;
 		break;
 	default:
-		EPRINTF(
-		"Unsupported %ld color (%d bpp) truecolor framebuffer\n",
-			psd->ncolors, psd->bpp);
+		EPRINTF("Unsupported %ld color (%d bpp) truecolor framebuffer\n", psd->ncolors, psd->bpp);
 		return NULL;
 	}
 
+	/* set standard data format from bpp and pixtype*/
+	psd->data_format = set_data_format(psd);
+
 	/* select a framebuffer subdriver based on planes and bpp*/
 	subdriver = select_fb_subdriver(psd);
 	if (!subdriver) {
diff --git a/src/drivers/scr_psp.c b/src/drivers/scr_psp.c
index 5b57775..405b866 100644
--- a/src/drivers/scr_psp.c
+++ b/src/drivers/scr_psp.c
@@ -73,6 +73,7 @@ fb_open(PSD psd)
     psd->linelen = 512 * 4;
     psd->flags = PSF_SCREEN;
     psd->pixtype = MWPF_TRUECOLORABGR;
+	psd->data_format = MWIF_RGBA8888;
 
     subdriver = select_fb_subdriver(psd);
     if (!subdriver) {
diff --git a/src/drivers/scr_rtems.c b/src/drivers/scr_rtems.c
index 20586f9..46a7c12 100644
--- a/src/drivers/scr_rtems.c
+++ b/src/drivers/scr_rtems.c
@@ -91,9 +91,8 @@ fb_open(PSD psd)
 		return NULL;
 	}
 
-	if( ioctl( fb, FBIOGET_FSCREENINFO, &fb_fix ) || ioctl( fb, FBIOGET_VSCREENINFO, &fb_var ) )
-	{
-	        EPRINTF("Error getting screen info\n" );
+	if (ioctl(fb, FBIOGET_FSCREENINFO, &fb_fix) || ioctl(fb, FBIOGET_VSCREENINFO, &fb_var )) {
+		EPRINTF("Error getting screen info\n" );
 		return NULL;
 	}
 	/* setup screen device from framebuffer info*/
@@ -117,13 +116,8 @@ fb_open(PSD psd)
 	psd->linelen = fb_fix.line_length;
 	psd->size = 0;		/* force subdriver init of size*/
 
-#if HAVEBLIT
 	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
-#else
-	psd->flags = PSF_SCREEN;
-#endif
 
-	psd->data_format = 0;			// FIXME
 	/* set pixel format*/
 	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
 		switch(psd->bpp) {
@@ -140,30 +134,24 @@ fb_open(PSD psd)
 			psd->pixtype = MWPF_TRUECOLOR0888;
 			break;
 		default:
-			EPRINTF(
-			"Unsupported %d color (%d bpp) truecolor framebuffer\n",
-				psd->ncolors, psd->bpp);
+			EPRINTF("Unsupported %d color (%d bpp) truecolor framebuffer\n", psd->ncolors, psd->bpp);
 			goto fail;
 		}
 	} else psd->pixtype = MWPF_PALETTE;
 
-	psd->size = (psd->size + getpagesize () - 1)
-			/ getpagesize () * getpagesize ();
+	/* set standard data format from bpp and pixtype*/
+	psd->data_format = set_data_format(psd);
+
+	psd->size = (psd->size + getpagesize () - 1) / getpagesize () * getpagesize ();
 
 	/* maps FB memory to user space */
 	psd->addr = fb_fix.smem_start;
 
-	/*if( ufb_mmap_to_user_space( fb, &psd->addr,
-                              ( void *)fb_info.smem_start, fb_info.smem_len ) )
-	{
-	        EPRINTF("Error mapping FB memory to user space\n" );
+	/*if( ufb_mmap_to_user_space( fb, &psd->addr, (void *)fb_info.smem_start, fb_info.smem_len)) {
+		EPRINTF("Error mapping FB memory to user space\n" );
 		goto fail;
 	}*/
 
-	/*DPRINTF("%dx%dx%d linelen %d type %d visual %d bpp %d\n", psd->xres,
-	 	psd->yres, psd->ncolors, psd->linelen, type, visual,
-		psd->bpp);*/
-
 	/* select a framebuffer subdriver based on planes and bpp*/
 	subdriver = select_fb_subdriver(psd);
 	if (!subdriver) {
@@ -174,10 +162,8 @@ fb_open(PSD psd)
 
 	/*exec.func_no = FB_FUNC_ENTER_GRAPHICS;
         exec.param = 0;
-
-	if( ioctl( fb, FB_EXEC_FUNCTION , ( void *)&exec ) )
-	{
-	        EPRINTF("Error entering graphics\n");
+	if( ioctl(fb, FB_EXEC_FUNCTION , ( void *)&exec)) {
+		EPRINTF("Error entering graphics\n");
 		return NULL;
 	}*/
 
@@ -185,10 +171,8 @@ fb_open(PSD psd)
 	 * set and initialize subdriver into screen driver
 	 * psd->size is calculated by subdriver init
 	 */
-	if(!set_subdriver(psd, subdriver, TRUE ))
-	{
-		EPRINTF("Driver initialize failed type %d visual %d bpp %d\n",
-			type, visual, psd->bpp);
+	if(!set_subdriver(psd, subdriver, TRUE)) {
+		EPRINTF("Driver initialize failed type %d visual %d bpp %d\n", type, visual, psd->bpp);
 		goto fail;
 	}
 
diff --git a/src/drivers/scr_x11.c b/src/drivers/scr_x11.c
index 6021c3e..85535aa 100644
--- a/src/drivers/scr_x11.c
+++ b/src/drivers/scr_x11.c
@@ -575,7 +575,6 @@ X11_open(PSD psd)
 	psd->xres = psd->xvirtres = x11_width;
 	psd->yres = psd->yvirtres = x11_height;
 	psd->planes = 1;
-	psd->data_format = 0;			// FIXME
 	psd->pixtype = MWPIXEL_FORMAT;
 	switch (psd->pixtype) {
 #if MWPIXEL_FORMAT == MWPF_PALETTE
@@ -601,6 +600,9 @@ X11_open(PSD psd)
 		break;
 	}
 
+	/* set standard data format from bpp and pixtype*/
+	psd->data_format = set_data_format(psd);
+
 	/* Calculate the correct linelen here */
 	GdCalcMemGCAlloc(psd, psd->xres, psd->yres, psd->planes,
 			 psd->bpp, &psd->size, &psd->linelen, &psd->pitch);
@@ -779,7 +781,7 @@ update_from_savebits(PSD psd, int destx, int desty, int w, int h)
 			dbuf += linedelta;
 		}
 	}
-#elif (MWPIXEL_FORMAT == MWPF_TRUECOLOR0888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR8888)
+#elif (MWPIXEL_FORMAT == MWPF_TRUECOLOR0888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR8888) || (MWPIXELFORMAT== MWPF_TRUECOLORABGR)
 	{
 		ADDR32 dbuf = ((ADDR32) psd->addr) + destx + desty * psd->linelen;
 		int linedelta = psd->linelen - w;
@@ -792,14 +794,17 @@ update_from_savebits(PSD psd, int destx, int desty, int w, int h)
 			dbuf += linedelta;
 		}
 	}
-#else /* also handle MWPF_TRUECOLORBGRA here to preserve alpha*/
+#else /* MWPF_PALETTE*/
 	{
+		ADDR8 dbuf = ((ADDR8) psd->addr) + destx + desty * psd->linelen;
+		int linedelta = psd->linelen - w;
 		for (y = 0; y < h; y++) {
 			for (x = 0; x < w; x++) {
-				MWPIXELVAL c = psd->ReadPixel(psd, destx + x, desty + y);
+				MWPIXELVAL c = *dbuf++;
 				unsigned long pixel = PIXELVAL_to_pixel(c);
 				XPutPixel(img, x, y, pixel);
 			}
+			dbuf += linedelta;
 		}
 	}
 #endif
diff --git a/src/engine/convblit_8888.c b/src/engine/convblit_8888.c
index 7567236..156607a 100644
--- a/src/engine/convblit_8888.c
+++ b/src/engine/convblit_8888.c
@@ -19,17 +19,17 @@
 #define B		2
 #define A		3
 
-#define NONE	0		/* portrait parm*/
-#define LEFT	1
-#define RIGHT	2
-#define DOWN	3
+#define NONE	MWPORTRAIT_NONE
+#define LEFT	MWPORTRAIT_LEFT
+#define RIGHT	MWPORTRAIT_RIGHT
+#define DOWN	MWPORTRAIT_DOWN
 
 #define COPY	0		/* mode parm*/
 #define SRCOVER	1
 
 /*
  * Conversion blit for COPY or SRCOVER from RGBA or RGB input to
- * 32 or 24bpp output, and rotate according to portrait specified.
+ * 32, 24 or 16bpp output, and rotate according to portrait specified.
  *
  * The gcc inline mechanism will compile this function with the
  * result of no switch and few if statements, as most use constant comparisons,
@@ -103,7 +103,12 @@ static inline void convblit_8888(PSD psd, PMWBLITPARMS gc, int mode,
 			if (mode == COPY || (alpha = s[SA]) == 255)		/* copy source*/
 			{
 				if (DSZ == 2)
-					((unsigned short *)d)[0] = RGB2PIXEL(s[SR], s[SG], s[SB]);
+				{
+					if (SSZ == 2)
+						((unsigned short *)d)[0] = ((unsigned short *)s)[0];
+					else
+						((unsigned short *)d)[0] = RGB2PIXEL(s[SR], s[SG], s[SB]);
+				}
 				else
 				{
 					if (DA >= 0)			/* compiler will optimize out completely*/
@@ -214,13 +219,20 @@ void convblit_copy_rgb888_bgra8888_down(PSD psd, PMWBLITPARMS gc)
 	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 4, B,G,R,A, DOWN);
 }
 
-#if LATER
-/* Conversion blit copy 32bpp RGBA image to 32bpp BGRA image*/
+/* GdArea required blits, all handle portrait*/
+/* Copy 32bpp XXXX image to 32bpp XXXX image*/
+void convblit_copy_8888_8888(PSD psd, PMWBLITPARMS gc)
+{
+	// -1 below means use 255 for alpha
+	//convblit_8888(psd, gc, COPY, 4, R,G,B,-1, 4, R,G,B,A, psd->portrait);
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 4, R,G,B,A, psd->portrait);
+}
+
+/* Copy 32bpp RGBA image to 32bpp BGRA image*/
 void convblit_copy_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc)
 {
-	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 4, B,G,R,A, NONE);
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 4, B,G,R,A, psd->portrait);
 }
-#endif
 
 /*---------- 24bpp BGR output ----------*/
 
@@ -266,13 +278,24 @@ void convblit_copy_rgb888_bgr888_down(PSD psd, PMWBLITPARMS gc)
 	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, B,G,R,-1, DOWN);
 }
 
-#if LATER
-/* Conversion blit copy 32bpp RGBA image to 24bpp BGR image*/
+/* GdArea required blits, all handle portrait*/
+/* Copy 24bpp XXX image to 24bpp XXX image*/
+void convblit_copy_888_888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, R,G,B,-1, psd->portrait);
+}
+
+/* Copy 32bpp BGRA image to 24bpp BGR image*/
+void convblit_copy_bgra8888_bgr888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 4, B,G,R,A, 3, B,G,R,-1, psd->portrait);
+}
+
+/* Copy 32bpp RGBA image to 24bpp BGR image*/
 void convblit_copy_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc)
 {
-	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 3, B,G,R,-1, NONE);
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 3, B,G,R,-1, psd->portrait);
 }
-#endif
 
 /*---------- 16bpp BGR output ----------*/
 
@@ -317,3 +340,16 @@ void convblit_copy_rgb888_16bpp_down(PSD psd, PMWBLITPARMS gc)
 {
 	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 2, 0,0,0,-1, DOWN);
 }
+
+/* GdArea required blits, all handle portrait*/
+/* Copy 16bpp image to 16bpp image*/
+void convblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 2, 0,0,0,-1, 2, 0,0,0,-1, psd->portrait);
+}
+
+/* Copy 32bpp RGBA image to 16bpp image*/
+void convblit_copy_rgba8888_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 2, 0,0,0,-1, psd->portrait);
+}
diff --git a/src/engine/devblit.c b/src/engine/devblit.c
index 87ed4bf..d2ac72b 100644
--- a/src/engine/devblit.c
+++ b/src/engine/devblit.c
@@ -25,9 +25,6 @@ extern MWPIXELVAL gr_foreground;      /* current foreground color */
 extern MWPIXELVAL gr_background;      /* current background color */
 extern MWBOOL 	  gr_usebg;    	      /* TRUE if background drawn in pixmaps */
 
-typedef void (*BlitFunc)(PSD, PMWBLITPARMS);
-static void GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, BlitFunc convblit);
-
 /**
  * Draw a rectangular area using the current clipping region and the
  * specified bit map.  This differs from rectangle drawing in that the
@@ -145,8 +142,8 @@ GdBitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 }
 
 /* call conversion blit with clipping and cursor fix*/
-static void
-GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, BlitFunc convblit)
+void
+GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, MWBLITFUNC convblit)
 {
 	MWCOORD x = gc->dstx;
 	MWCOORD y = gc->dsty;
@@ -241,18 +238,14 @@ GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, BlitFunc convblit)
 	gc->srcy = srcy;
 }
 
-void
-GdConversionBlit(PSD psd, PMWBLITPARMS parms)
+/* find a conversion blit based on data format and blit op*/
+MWBLITFUNC
+GdFindConvBlit(PSD psd, int data_format, int op)
 {
-	BlitFunc convblit;
-	int op = 0;
+	MWBLITFUNC convblit = NULL;
 
-	/* setup destination for convblit*/
-	parms->dst_pitch = psd->pitch;
-	parms->data_out = psd->addr;
-
-	/* temp transfer parms to old driver struct*/
-	switch (parms->data_format) {
+	/* determine which blit to use*/
+	switch (data_format) {
 	case MWIF_ALPHABYTE:			/* ft2 alias, t1lib alias*/
 		convblit = psd->BlitBlendMaskAlphaByte;		/* conv 8bpp alpha with fg/bg*/
 		break;
@@ -263,36 +256,81 @@ GdConversionBlit(PSD psd, PMWBLITPARMS parms)
 
 	case MWIF_MONOWORDMSB:			/* core mwcfont, pcf*/
 		convblit = psd->BlitCopyMaskMonoWordMSB;	/* conv mono word MSBFirst*/
-		if (!convblit) {
-			DPRINTF("GdConversionBlit: no convblit, using GdBitmap fallback\n");
-			GdBitmap(psd, parms->dstx, parms->dsty, parms->width, parms->height, parms->data);
-			return;
-		}
 		break;
 
 	case MWIF_MONOBYTELSB:			/* t1lib non-alias*/
 		convblit = psd->BlitCopyMaskMonoByteLSB;	/* conv mono byte LSBFirst*/
 		break;
 
-	case MWIF_RGBA8888:				/* png 32bpp w/alpha*/
-		convblit = psd->BlitSrcOverRGBA8888;		/* image, src 32bpp w/alpha - srcover*/
+	case MWIF_RGBA8888:				/* png 32bpp w/alpha, GdArea MWPF_RGB/MWPF_TRUECOLORABGR*/
+		if (op == MWROP_SRC_OVER) {
+			convblit = psd->BlitSrcOverRGBA8888;	/* image, src 32bpp w/alpha - srcover*/
+			break;
+		}
+		//FIXME convblit = psd->BlitCopyRGBA8888;
+		if (op == MWROP_COPY) switch (psd->bpp) {
+		case 32:
+			convblit = convblit_copy_rgba8888_bgra8888;	/* 32bpp RGBA to 32bpp BGRA copy*/
+			break;
+		case 24:
+			convblit = convblit_copy_rgba8888_bgr888;	/* 32bpp RGBX to 24bpp BGR copy*/
+			break;
+		case 16:
+			convblit = convblit_copy_rgba8888_16bpp;	/* 32bpp RGBX to 16bpp copy*/
+			break;
+		}
+		break;
+
+	case MWIF_BGRA8888:				/* GdArea MWPF_TRUECOLOR8888/MWPF_TRUECOLOR0888*/
+		/* assume copy*/
+		if (psd->data_format == MWIF_BGRA8888)
+			convblit = convblit_copy_8888_8888;		/* 32bpp to 32bpp copy*/
+		else if (psd->data_format == MWIF_BGR888)	/* GdArea MWPF_PIXELVAL conversion*/
+			convblit = convblit_copy_bgra8888_bgr888; /* 32bpp BGRX to 24bpp BGR copy*/
 		break;
 
 	case MWIF_RGB888:				/* png 24bpp no alpha*/
 		convblit = psd->BlitCopyRGB888;				/* image, src 24bpp - copy*/
 		break;
 
-	default:
-		EPRINTF("GdConversionBlit: unsupported data format 0x%x\n", parms->data_format);
-		return;
+	case MWIF_BGR888:				/* GdArea MWPF_TRUECOLOR888*/
+		if (psd->data_format == MWIF_BGR888)
+			convblit = convblit_copy_888_888;		/* 24bpp to 24bpp copy*/
+		break;
+
+	case MWIF_RGB565:				/* GdArea MWPF_TRUECOLOR565*/
+	case MWIF_RGB555:				/* GdArea MWPF_TRUECOLOR555*/
+		if (psd->data_format == data_format)
+			convblit = convblit_copy_16bpp_16bpp;	/* 16bpp to 16bpp copy*/
+		break;
 	}
 
-	/* call conversion blit routine*/
+	return convblit;
+}
+
+void
+GdConversionBlit(PSD psd, PMWBLITPARMS parms)
+{
+	/* first find blit based on data format and blit op*/
+	MWBLITFUNC convblit = GdFindConvBlit(psd, parms->data_format, parms->op);
+
+	/* call conversion blit routine with clipping*/
 	if (convblit) {
+		/* setup destination parms*/
+		parms->dst_pitch = psd->pitch;
+		parms->data_out = psd->addr;
+
 		GdConvBlitInternal(psd, parms, convblit);
 		return;
 	}
 
+	/* check for fallback routines*/
+	if (parms->data_format == MWIF_MONOWORDMSB) {			/* core mwcfont, pcf*/
+		DPRINTF("GdConversionBlit: no convblit, using GdBitmap fallback\n");
+		GdBitmap(psd, parms->dstx, parms->dsty, parms->width, parms->height, parms->data);
+		return;
+	}
+
 	DPRINTF("GdConversionBlit: No convblit available\n");
 }
 
@@ -333,6 +371,7 @@ GdBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD width, MWCOORD height,
 	/* temporary assert() until rotation blits completed*/
 	assert(dstpsd->portrait == srcpsd->portrait);
 	
+//printf("GdBlit %d,%d %d,%d\n", dstx, dsty, width, height);
 	/* clip blit rectangle to source screen/bitmap size*/
 	/* we must do this because there isn't any source clipping setup*/
 	if(srcx < 0) {
@@ -363,6 +402,7 @@ GdBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD width, MWCOORD height,
 		return;
 
 	case CLIP_INVISIBLE:
+printf("GdBlit invis\n");
 		return;
 	}
 
@@ -911,3 +951,46 @@ GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 	GdFixCursor(dstpsd);
 	/* GdFixCursor(srcpsd); */
 }
+
+#if DEBUG
+void GdPrintBitmap(PMWBLITPARMS gc, int SSZ)
+{
+	unsigned char *src;
+	int height;
+	unsigned int v;
+
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
+
+	printf("Image %d,%d SSZ %d\n", gc->width, gc->height, SSZ);
+	height = gc->height;
+	while (--height >= 0)
+	{
+		register unsigned char *s = src;
+		int w = gc->width;
+
+		while (--w >= 0)
+		{
+			switch (SSZ) {
+			case 2:
+				v = s[0] | (s[1] << 8);
+				v = PIXEL565RED(v) + PIXEL565GREEN(v) + PIXEL565BLUE(v);
+				printf("%c", "_.:;oVM@X"[v]);
+				break;
+			case 3:
+				v = (s[0] + s[1] + s[2]) / 3;
+				printf("%c", "_.:;oVM@X"[v >> 5]);
+				break;
+			case 4:
+				//if (s[4])
+					v = (s[0] + s[1] + s[2]) / 3;
+				//else v = 256;
+				printf("%c", "_.:;oVM@X"[v >> 5]);
+				break;
+			}
+			s += SSZ;				/* src: next pixel right*/
+		}
+		printf("\n");
+		src += gc->src_pitch;		/* src: next line down*/
+	}
+}
+#endif
diff --git a/src/engine/devdraw.c b/src/engine/devdraw.c
index 8ee0e70..fbaa812 100644
--- a/src/engine/devdraw.c
+++ b/src/engine/devdraw.c
@@ -18,6 +18,7 @@
 #include <assert.h>
 #include "swap.h"
 #include "device.h"
+#include "convblit.h"
 
 extern MWPIXELVAL gr_foreground;      /* current foreground color */
 extern MWPIXELVAL gr_background;      /* current background color */
@@ -639,6 +640,56 @@ GdMakePaletteConversionTable(PSD psd,MWPALENTRY *palette,int palsize,
 	}
 }
 
+static void GdDrawImageByPoint(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage);
+/**
+ * Draw a color bitmap image in 1, 4, 8, 24 or 32 bits per pixel.  The
+ * Microwindows color image format is DWORD padded bytes, with
+ * the upper bits corresponding to the left side (identical to
+ * the MS Windows format).  This format is currently different
+ * than the MWIMAGEBITS format, which uses word-padded bits
+ * for monochrome display only, where the upper bits in the word
+ * correspond with the left side.
+ *
+ * @param psd Drawing surface.
+ * @param x Destination X co-ordinate for left of image.
+ * @param y Destination Y co-ordinate for top of image.
+ * @param pimage Structure describing the image.
+ */
+void
+GdDrawImage(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
+{
+	int			op = MWROP_COPY;
+	MWBLITFUNC	convblit;
+	MWBLITPARMS parms;
+
+	/* use srcover for supported images with alpha*/
+	if (pimage->data_format == MWIF_RGBA8888)	// FIXME check MWIF_ALPHA
+		op = MWROP_SRC_OVER;
+
+	/* find conversion blit based on data format*/
+	convblit = GdFindConvBlit(psd, pimage->data_format, op);
+
+	/* if not using new MWIF_ format and convblit drivers, must draw pixel by pixel*/
+	if (!convblit) {
+		DPRINTF("GdDrawImage: not RGBA/RGB format or no convblit, using slow GdDrawImageByPoint\n");
+		GdDrawImageByPoint(psd, x, y, pimage);			/* old pixel-by-pixel drawing*/
+		return;
+	}
+
+	/* use fast conversion blit*/
+	parms.op = op;
+	parms.data_format = pimage->data_format;
+	parms.dstx = x;
+	parms.dsty = y;
+	parms.width = pimage->width;
+	parms.height = pimage->height;
+	parms.srcx = 0;
+	parms.srcy = 0;
+	parms.src_pitch = pimage->pitch;
+	parms.data = pimage->imagebits;
+	GdConversionBlit(psd, &parms);
+}
+
 /*
  * Alpha drawing using C bitfields.  Experimental,
  * uses bitfields rather than explicit bit-twiddling.
@@ -697,62 +748,9 @@ typedef union {
 	unsigned short v; 
 } RGB555;	
 
-static void GdDrawImageInternal(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage);
-/**
- * Draw a color bitmap image in 1, 4, 8, 24 or 32 bits per pixel.  The
- * Microwindows color image format is DWORD padded bytes, with
- * the upper bits corresponding to the left side (identical to
- * the MS Windows format).  This format is currently different
- * than the MWIMAGEBITS format, which uses word-padded bits
- * for monochrome display only, where the upper bits in the word
- * correspond with the left side.
- *
- * @param psd Drawing surface.
- * @param x Destination X co-ordinate for left of image.
- * @param y Destination Y co-ordinate for top of image.
- * @param pimage Structure describing the image.
- */
-void
-GdDrawImage(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
-{
-	MWBLITPARMS parms;
-
-	/* if not using new MWIF_ format and convblit drivers, must draw pixel by pixel*/
-	switch (pimage->data_format) {
-	case MWIF_RGBA8888:
-		if (psd->BlitSrcOverRGBA8888)
-			goto fastblit;
-		break;
-
-	case MWIF_RGB888:
-		if (psd->BlitCopyRGB888)
-			goto fastblit;
-		break;
-	}
-
-	if (pimage->data_format)
-		DPRINTF("GdDrawImage: no convblit, using DrawImageInternal fallback\n");
-	else DPRINTF("GdDrawImage: image not RGBA/RGB format, using slow GdDrawImageInternal\n");
-
-	GdDrawImageInternal(psd, x, y, pimage);			/* old pixel-by-pixel drawing*/
-	return;
-
-fastblit:
-	/* use fast conversion blit*/
-	parms.data_format = pimage->data_format;
-	parms.dstx = x;
-	parms.dsty = y;
-	parms.width = pimage->width;
-	parms.height = pimage->height;
-	parms.srcx = 0;
-	parms.srcy = 0;
-	parms.src_pitch = pimage->pitch;
-	parms.data = pimage->imagebits;
-	GdConversionBlit(psd, &parms);
-}
-
+/* slow draw point by point with clipping*/
 static void
-GdDrawImageInternal(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
+GdDrawImageByPoint(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
 {
 	MWCOORD minx;
 	MWCOORD maxx;
@@ -1239,6 +1237,8 @@ GdReadArea(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 	GdFixCursor(psd);
 }
 
+static void GdAreaByPoint(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
+							void *pixels, int pixtype);
 /**
  * Draw a rectangle of color values, clipping if necessary.
  * If a color matches the background color,
@@ -1279,86 +1279,116 @@ GdReadArea(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
  * @param pixtype Format of pixels.
  */
 void
-GdArea(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height, void *pixels,
-	int pixtype)
+GdArea(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height, void *pixels, int pixtype)
 {
-	unsigned char *PIXELS = pixels;	/* for ANSI compilers, can't use void*/
-	int32_t cellstodo;			/* remaining number of cells */
-	int32_t count;			/* number of cells of same color */
-	int32_t cc;			/* current cell count */
-	int32_t rows;			/* number of complete rows */
-	MWCOORD minx;			/* minimum x value */
-	MWCOORD maxx;			/* maximum x value */
-	MWPIXELVAL savecolor;		/* saved foreground color */
-	MWBOOL dodraw;			/* TRUE if draw these points */
-	MWCOLORVAL rgbcolor = 0L;
-	int pixsize;
-	unsigned char r, g, b;
-
-printf("GdArea %d,%d %d,%d (type %d)\n", x, y, width, height, pixtype);
-#if 0 // FIXME
-	/* check for hw pixel format and low level driver drawarea call*/
-	if (pixtype == MWPF_HWPIXELVAL && (psd->flags & PSF_HAVEOP_COPY)) {
-		driver_gc_t hwgc;
-
-		hwgc.data = PIXELS;
-		hwgc.src_linelen = width;
-		hwgc.usebg = gr_usebg;
-		hwgc.bg_color = gr_background;
-		hwgc.dstx = x;
-		hwgc.dsty = y;
-		hwgc.width = width;
-		hwgc.height = height;
-		hwgc.srcx = 0;
-		hwgc.srcy = 0;
-		hwgc.op = PSDOP_COPY;
-		GdDrawAreaInternal(psd, &hwgc);
-
-		GdFixCursor(psd);
-		return;
-	}
-#endif
-	/* no fast low level routine, draw point-by-point...*/
-	minx = x;
-	maxx = x + width - 1;
-
-	/* Set up area clipping, and just return if nothing is visible */
-	if (GdClipArea(psd, minx, y, maxx, y + height - 1) == CLIP_INVISIBLE )
-		return;
+	int pixsize = 4;
+	int	data_format = 0;
+	MWBLITFUNC convblit = NULL;
+	MWBLITPARMS parms;
 
 	/* convert MWPF_HWPIXELVAL to real pixel type*/
 	if (pixtype == MWPF_HWPIXELVAL)
 		pixtype = psd->pixtype;
 
-	/* Calculate size of packed pixels*/
+	/* Calculate size of packed pixels and possible fast blitter*/
 	switch(pixtype) {
 	case MWPF_RGB:
-		pixsize = sizeof(MWCOLORVAL);
+	case MWPF_TRUECOLORABGR:
+		data_format = MWIF_RGBA8888;
 		break;
 	case MWPF_PIXELVAL:
 		pixsize = sizeof(MWPIXELVAL);
-		break;
-	case MWPF_PALETTE:
-	case MWPF_TRUECOLOR233:
-	case MWPF_TRUECOLOR332:
-		pixsize = sizeof(unsigned char);
+		switch (pixsize) {
+		case 4:
+			if (psd->bpp == 32)
+				data_format = psd->data_format;		/* will use 32bpp copy*/
+			else if (psd->data_format == MWIF_BGR888)
+				data_format = MWIF_BGRA8888;		/* try 32bpp BGRA to 24bpp BGR copy*/
+			break;
+		case 2:
+			if (psd->bpp == 16)
+				data_format = psd->data_format;		/* will use 16bpp copy*/
+			break;
+		case 1:
+			break;
+		}
 		break;
 	case MWPF_TRUECOLOR8888:
 	case MWPF_TRUECOLOR0888:
-	case MWPF_TRUECOLORABGR:
-		pixsize = sizeof(uint32_t);
+		data_format = MWIF_BGRA8888;
 		break;
 	case MWPF_TRUECOLOR888:
+		data_format = MWIF_BGR888;
 		pixsize = 3;
 		break;
 	case MWPF_TRUECOLOR565:
+		data_format = MWIF_RGB565;
+		pixsize = 2;
+		break;
 	case MWPF_TRUECOLOR555:
-		pixsize = sizeof(unsigned short);
+		data_format = MWIF_RGB565;
+		pixsize = 2;
 		break;
+	case MWPF_PALETTE:
+	case MWPF_TRUECOLOR233:
+	case MWPF_TRUECOLOR332:
 	default:
+		/* no convblit supported*/
+		break;
+	}
+
+	/* find conversion blit based on data format*/
+	if (data_format)
+		convblit = GdFindConvBlit(psd, data_format, MWROP_COPY);
+
+	if (!convblit) {
+		DPRINTF("GdArea: no convblit or format not supported, using slow GdAreaByPoint fallback\n");
+		GdAreaByPoint(psd, x, y, width, height, pixels, pixtype);	/* old pixel by pixel*/
 		return;
 	}
 
+	/* prepare blit parameters*/
+	parms.op = MWROP_COPY;
+	parms.data_format = 0;
+	parms.width = width;
+	parms.height = height;
+	parms.dstx = x;
+	parms.dsty = y;
+	parms.srcx = 0;
+	parms.srcy = 0;
+	parms.src_pitch = width * pixsize;
+	//parms.fg_colorval = gr_foreground_rgb;	/* these are ignored in copy blits*/
+	//parms.bg_colorval = gr_background_rgb;
+	//parms.fg_pixelval = gr_foreground;
+	//parms.bg_pixelval = gr_background;
+	//parms.usebg = gr_usebg;
+	parms.data = pixels;
+	parms.dst_pitch = psd->pitch;		/* usually set in GdConversionBlit*/
+	parms.data_out = psd->addr;
+//GdPrintBitmap(&parms, pixsize);
+	GdConvBlitInternal(psd, &parms, convblit);
+}
+
+static void
+GdAreaByPoint(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height, void *pixels, int pixtype)
+{
+	unsigned char *PIXELS = pixels;	/* for ANSI compilers, can't use void*/
+	MWCOORD minx = x;
+	MWCOORD maxx = x + width - 1;
+	int32_t cellstodo;			/* remaining number of cells */
+	int32_t count;			/* number of cells of same color */
+	int32_t cc;			/* current cell count */
+	int32_t rows;			/* number of complete rows */
+	MWPIXELVAL savecolor;		/* saved foreground color */
+	MWBOOL dodraw;			/* TRUE if draw these points */
+	MWCOLORVAL rgbcolor = 0L;
+	unsigned char r, g, b;
+
+	/* Set up area clipping, and just return if nothing is visible */
+	if (GdClipArea(psd, minx, y, maxx, y + height - 1) == CLIP_INVISIBLE )
+		return;
+
+	/* no fast low level routine, draw point-by-point...*/
   savecolor = gr_foreground;
   cellstodo = (long)width * height;
   while (cellstodo > 0) {
@@ -1513,106 +1543,7 @@ breakwhile:
   GdFixCursor(psd);
 }
 
-#if NOTYET
-/* Copy a rectangular area from one screen area to another.
- * This bypasses clipping.
- */
-void
-GdCopyArea(PSD psd, MWCOORD srcx, MWCOORD srcy, MWCOORD width, MWCOORD height,
-	MWCOORD destx, MWCOORD desty)
-{
-	if (width <= 0 || height <= 0)
-		return;
-
-	if (srcx == destx && srcy == desty)
-		return;
-	GdCheckCursor(psd, srcx, srcy, srcx + width - 1, srcy + height - 1);
-	GdCheckCursor(psd, destx, desty, destx + width - 1, desty + height - 1);
-	psd->CopyArea(psd, srcx, srcy, width, height, destx, desty);
-	GdFixCursor(psd);
-}
-#endif
-
-/*
- * Calculate size and linelen of memory gc.
- * If bpp or planes is 0, use passed psd's bpp/planes.
- * Note: linelen is calculated to be DWORD aligned for speed
- * for bpp <= 8.  Linelen is converted to bytelen for bpp > 8.
- */
-int
-GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height, int planes,
-	int bpp, int *psize, int *plinelen, int *ppitch)
-{
-	int	bytelen, linelen, tmp;
-
-	if(!planes)
-		planes = psd->planes;
-	if(!bpp)
-		bpp = psd->bpp;
-	/* 
-	 * swap width and height in left/right portrait modes,
-	 * so imagesize is calculated properly
-	 */
-	if(psd->portrait & (MWPORTRAIT_LEFT|MWPORTRAIT_RIGHT)) {
-		tmp = width;
-		width = height;
-		height = tmp;
-	}
-
-	/*
-	 * use bpp and planes to create size and linelen.
-	 * linelen is in bytes for bpp 1, 2, 4, 8, and pixels for bpp 16,24,32.
-	 */
-	if(planes == 1) {
-		switch(bpp) {
-		case 1:
-			linelen = (width+7)/8;
-			bytelen = linelen = (linelen+3) & ~3;
-			break;
-		case 2:
-			linelen = (width+3)/4;
-			bytelen = linelen = (linelen+3) & ~3;
-			break;
-		case 4:
-			linelen = (width+1)/2;
-			bytelen = linelen = (linelen+3) & ~3;
-			break;
-		case 8:
-			bytelen = linelen = (width+3) & ~3;
-			break;
-		case 16:
-			linelen = width;
-			bytelen = width * 2;
-			break;
-		case 24:
-		case 18:
-			linelen = width;
-			bytelen = width * 3;
-			break;
-		case 32:
-			linelen = width;
-			bytelen = width * 4;
-			break;
-		default:
-			return 0;
-		}
-	} else if(planes == 4) {
-		/* FIXME assumes VGA 4 planes 4bpp*/
-		/* we use 4bpp linear for memdc format*/
-		linelen = (width+1)/2;
-		linelen = (linelen+3) & ~3;
-		bytelen = linelen;
-	} else {
-		*psize = *plinelen = 0;
-		return 0;
-	}
-
-	*psize = bytelen * height;
-	*plinelen = linelen;
-	*ppitch = bytelen;
-	return 1;
-}
-
+#if LATER
 /**
  * Translate a rectangle of color values
  *
@@ -1779,3 +1710,4 @@ GdTranslateArea(MWCOORD width, MWCOORD height, void *in, int inpixtype,
 		    outbuf += outpitch - width;
 	}
 }
+#endif /* LATER*/
diff --git a/src/include/convblit.h b/src/include/convblit.h
index d2b2ca2..368dc11 100644
--- a/src/include/convblit.h
+++ b/src/include/convblit.h
@@ -16,6 +16,10 @@ void convblit_copy_rgb888_bgra8888_left(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_bgra8888_right(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_bgra8888_down(PSD psd, PMWBLITPARMS gc);
 
+/* GdArea auto-portait blits*/
+void convblit_copy_8888_8888(PSD psd, PMWBLITPARMS gc);				// 32bpp to 32bpp copy
+void convblit_copy_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA to 32bpp BGRA copy
+
 /* ----- 24bpp output -----*/
 void convblit_srcover_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc);
 void convblit_srcover_rgba8888_bgr888_left(PSD psd, PMWBLITPARMS gc);
@@ -27,6 +31,11 @@ void convblit_copy_rgb888_bgr888_left(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_bgr888_right(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_bgr888_down(PSD psd, PMWBLITPARMS gc);
 
+/* GdArea auto-portait blits*/
+void convblit_copy_888_888(PSD psd, PMWBLITPARMS gc);				// 24bpp to 24bpp copy
+void convblit_copy_bgra8888_bgr888(PSD psd, PMWBLITPARMS gc);		// 32bpp BGRA to 24bpp BGR copy
+void convblit_copy_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA to 24bpp BGR copy
+
 /* ----- 16bpp output -----*/
 void convblit_srcover_rgba8888_16bpp(PSD psd, PMWBLITPARMS gc);
 void convblit_srcover_rgba8888_16bpp_left(PSD psd, PMWBLITPARMS gc);
@@ -38,10 +47,9 @@ void convblit_copy_rgb888_16bpp_left(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_16bpp_right(PSD psd, PMWBLITPARMS gc);
 void convblit_copy_rgb888_16bpp_down(PSD psd, PMWBLITPARMS gc);
 
-#if LATER
-void convblit_copy_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA copy
-void convblit_copy_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc);
-#endif
+/* GdArea auto-portait blits*/
+void convblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc);			// 16bpp to 16bpp copy
+void convblit_copy_rgba8888_16bpp(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA to 16bpp copy
 
 /* convblit_mask.c*/
 /* 1bpp and 8bpp (alphablend) mask conversion blits - for font display*/
diff --git a/src/include/device.h b/src/include/device.h
index 1682559..758d441 100644
--- a/src/include/device.h
+++ b/src/include/device.h
@@ -90,32 +90,29 @@
 #error VTSWITCH depends on MW_FEATURE_TIMERS - disable VTSWITCH in config or enable MW_FEATURE_TIMERS in this file
 #endif
 
+typedef void (*MWBLITFUNC)(PSD, PMWBLITPARMS);		/* proto for blitter functions*/
+
 /* screen subdriver entry points: one required for each draw function*/
 typedef struct {
-	int	 (*Init)(PSD psd);
+	int	 	 (*Init)(PSD psd);
 	void 	 (*DrawPixel)(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c);
 	MWPIXELVAL (*ReadPixel)(PSD psd, MWCOORD x, MWCOORD y);
-	void 	 (*DrawHorzLine)(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y,
-			MWPIXELVAL c);
-	void	 (*DrawVertLine)(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2,
-			MWPIXELVAL c);
-	void	 (*FillRect)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,
-			MWCOORD y2,MWPIXELVAL c);
-	void	 (*Blit)(PSD destpsd, MWCOORD destx, MWCOORD desty, MWCOORD w,
-			MWCOORD h,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
-	void 	 (*StretchBlitEx) (PSD dstpsd, PSD srcpsd,
-			MWCOORD dest_x_start, int dest_y_start,
-			MWCOORD width, int height,
-			int x_denominator, int y_denominator,
+	void 	 (*DrawHorzLine)(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+	void	 (*DrawVertLine)(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+	void	 (*FillRect)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2, MWCOORD y2,MWPIXELVAL c);
+	void	 (*Blit)(PSD destpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
+				PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
+	void 	 (*StretchBlitEx)(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+			MWCOORD width, int height, int x_denominator, int y_denominator,
 			int src_x_fraction, int src_y_fraction,
 			int x_step_fraction, int y_step_fraction, int op);
 	/* new fast blit functions*/
-	void	(*BlitCopyMaskMonoByteMSB)(PSD psd, PMWBLITPARMS parms);	/* ft non-alias*/
-	void	(*BlitCopyMaskMonoByteLSB)(PSD psd, PMWBLITPARMS parms);	/* t1 non-alias*/
-	void	(*BlitCopyMaskMonoWordMSB)(PSD psd, PMWBLITPARMS parms);	/* core/pcf non-alias*/
-	void	(*BlitBlendMaskAlphaByte)(PSD psd, PMWBLITPARMS parms);		/* ft2/t1 antialias*/
-	void	(*BlitSrcOverRGBA8888)(PSD psd, PMWBLITPARMS parms);		/* png RGBA image w/alpha*/
-	void	(*BlitCopyRGB888)(PSD psd, PMWBLITPARMS parms);				/* png RGB image no alpha*/
+	MWBLITFUNC BlitCopyMaskMonoByteMSB;				/* ft non-alias*/
+	MWBLITFUNC BlitCopyMaskMonoByteLSB;				/* t1 non-alias*/
+	MWBLITFUNC BlitCopyMaskMonoWordMSB;				/* core/pcf non-alias*/
+	MWBLITFUNC BlitBlendMaskAlphaByte;				/* ft2/t1 antialias*/
+	MWBLITFUNC BlitSrcOverRGBA8888;					/* png RGBA image w/alpha*/
+	MWBLITFUNC BlitCopyRGB888;						/* png RGB image no alpha*/
 } SUBDRIVER, *PSUBDRIVER;
 
 /*
@@ -175,12 +172,12 @@ typedef struct _mwscreendevice {
 	PSUBDRIVER right_subdriver;
 	PSUBDRIVER down_subdriver;
 	/* new fast blit functions for text and images*/
-	void	(*BlitCopyMaskMonoByteMSB)(PSD psd, PMWBLITPARMS parms);	/* ft non-alias*/
-	void	(*BlitCopyMaskMonoByteLSB)(PSD psd, PMWBLITPARMS parms);	/* t1 non-alias*/
-	void	(*BlitCopyMaskMonoWordMSB)(PSD psd, PMWBLITPARMS parms);	/* core/pcf non-alias*/
-	void	(*BlitBlendMaskAlphaByte)(PSD psd, PMWBLITPARMS parms);		/* ft2/t1 antialias*/
-	void	(*BlitSrcOverRGBA8888)(PSD psd, PMWBLITPARMS parms);		/* png RGBA image w/alpha*/
-	void	(*BlitCopyRGB888)(PSD psd, PMWBLITPARMS parms);				/* png RGB image no alpha*/
+	MWBLITFUNC BlitCopyMaskMonoByteMSB;				/* ft non-alias*/
+	MWBLITFUNC BlitCopyMaskMonoByteLSB;				/* t1 non-alias*/
+	MWBLITFUNC BlitCopyMaskMonoWordMSB;				/* core/pcf non-alias*/
+	MWBLITFUNC BlitBlendMaskAlphaByte;				/* ft2/t1 antialias*/
+	MWBLITFUNC BlitSrcOverRGBA8888;					/* png RGBA image w/alpha*/
+	MWBLITFUNC BlitCopyRGB888;						/* png RGB image no alpha*/
 } SCREENDEVICE;
 
 /* PSD flags*/
@@ -251,8 +248,6 @@ void	GdLine(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2,
 		MWBOOL bDrawLastPoint);
 void	GdRect(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
 void	GdFillRect(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
-void	GdBitmap(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
-		const MWIMAGEBITS *imagebits);
 MWBOOL	GdColorInPalette(MWCOLORVAL cr,MWPALENTRY *palette,int palsize);
 void	GdMakePaletteConversionTable(PSD psd,MWPALENTRY *palette,int palsize,
 		MWPIXELVAL *convtable,int fLoadType);
@@ -263,26 +258,30 @@ void	GdReadArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
 		MWPIXELVAL *pixels);
 void	GdArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
 		void *pixels, int pixtype);
-void	GdConversionBlit(PSD psd, PMWBLITPARMS parms);
 void	GdTranslateArea(MWCOORD width, MWCOORD height, void *in, int inpixtype,
 		MWCOORD inpitch, void *out, int outpixtype, int outpitch);
-void	GdCopyArea(PSD psd,MWCOORD srcx,MWCOORD srcy,MWCOORD width,
-		MWCOORD height, MWCOORD destx, MWCOORD desty);
+void	drawpoint(PSD psd, MWCOORD x, MWCOORD y);
+void	drawrow(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y);
+extern SCREENDEVICE scrdev;
+
+/* drivers/fb.c*/
+int	GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height,
+		int planes, int bpp, int *size, int *linelen, int *pitch);
+
+/* devblit.c*/
+void	drawbitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
+		const MWIMAGEBITS *imagebits);
+void	GdBitmap(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
+		const MWIMAGEBITS *imagebits);
+MWBLITFUNC GdFindConvBlit(PSD psd, int data_format, int op);
+void	GdConversionBlit(PSD psd, PMWBLITPARMS parms);
+void	GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, MWBLITFUNC convblit);
 void	GdBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD width,
 		MWCOORD height,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int rop);
-/***void	GdStretchBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw,
-		MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy,
-		MWCOORD srcw, MWCOORD srch, int rop);***/
 void	GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 		MWCOORD d2_y, PSD srcpsd, MWCOORD s1_x, MWCOORD s1_y,
 		MWCOORD s2_x, MWCOORD s2_y, int rop);
-int	GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height,
-		int planes, int bpp, int *size, int *linelen, int *pitch);
-void	drawbitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
-		const MWIMAGEBITS *imagebits);
-void	drawpoint(PSD psd, MWCOORD x, MWCOORD y);
-void	drawrow(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y);
-extern SCREENDEVICE scrdev;
+void	GdPrintBitmap(PMWBLITPARMS gc, int SSZ);	/* debug only*/
 
 /* devarc.c*/
 /* requires float*/
diff --git a/src/include/mwtypes.h b/src/include/mwtypes.h
index 423656a..e253712 100644
--- a/src/include/mwtypes.h
+++ b/src/include/mwtypes.h
@@ -110,18 +110,22 @@
 #define MWIF_ARGB8888		0x00020000L		/* 32bpp ARGB image byte order (new)*/
 #define MWIF_RGBA8888		0x00030000L		/* 32bpp RGBA image byte order (old TRUECOLORABGR)*/
 //#define MWIF_ABGR8888		0x00040000L		/* 32bpp ABGR image byte order (new)*/
-//#define MWIF_BGR8888		0x00050000L		/* 32bpp BGR image order no alpha*/
+//#define MWIF_BGRX8888		0x00050000L		/* 32bpp BGR image order no alpha (new)*/
 #define MWIF_BGR888			0x00060000L		/* 24bpp BGR image byte order  (old TRUECOLOR888)*/
 #define MWIF_RGB888			0x00070000L		/* 24bpp RGB image byte order  (png no alpha)*/
 #define MWIF_RGB565			0x00080000L		/* 16bpp 5/6/5 RGB packed l.endian (old TRUECOLOR565)*/
-//#define MWIF_RGB565_BR	0x00090000L		/* 16bpp 5/6/5 RGB packed b.endian (new)*/
+//#define MWIF_RGB565_BE	0x00090000L		/* 16bpp 5/6/5 RGB packed b.endian (new)*/
 #define MWIF_RGB555			0x000A0000L		/* 16bpp 5/5/5 RGB packed l.endian (old TRUECOLOR555)*/
-//#define MWIF_RGB555_BR	0x000B0000L		/* 16bpp 5/5/5 RGB packed b.endian (new)*/
+//#define MWIF_RGB555_BE	0x000B0000L		/* 16bpp 5/5/5 RGB packed b.endian (new)*/
 #define MWIF_BGR555			0x000C0000L		/* 16bpp 5/5/5 BGR packed l.endian (old TRUECOLOR1555)*/
-//#define MWIF_BGR555_BR	0x000D0000L		/* 16bpp 5/5/5 BGR packed b.endian (new)*/
-#define MWIF_BGR332			0x000E0000L		/*  8bpp 3/3/2 RGB packed (old TRUECOLOR332)*/
+//#define MWIF_BGR555_BE	0x000D0000L		/* 16bpp 5/5/5 BGR packed b.endian (new)*/
+#define MWIF_RGB332			0x000E0000L		/*  8bpp 3/3/2 RGB packed (old TRUECOLOR332)*/
 #define MWIF_BGR233			0x000F0000L		/*  8bpp 2/3/3 BGR packed (old TRUECOLOR233)*/
-#define MWIF_PAL8			0x00100000L		/*  8bpp palette (old MWPF_PALETTE)*/
+#define MWIF_PAL1			0x00100000L		/*  1bpp palette (old MWPF_PALETTE)*/
+#define MWIF_PAL2			0x00200000L		/*  2bpp palette (old MWPF_PALETTE)*/
+#define MWIF_PAL4			0x00400000L		/*  4bpp palette (old MWPF_PALETTE)*/
+#define MWIF_PAL8			0x00800000L		/*  8bpp palette (old MWPF_PALETTE)*/
+#define MWIF_PAL			0x00F00000L		/* requires palette*/
 
 /* Line modes */
 #define MWLINE_SOLID      0
@@ -1249,6 +1253,14 @@ typedef struct {
 #define PIXEL2BLUE(p)		PIXEL233BLUE(p)
 #endif
 
+#if MWPIXEL_FORMAT == MWPF_PALETTE
+//only required for compiling in palette pixel size, not supported in convblits
+//extern MWPALENTRY	gr_palette[256];
+//extern int32_t	gr_ncolors;
+//#define RGB2PIXEL(r,g,b)	GdFindNearestColor(gr_palette, gr_ncolors, MWRGB(r,g,b))
+#define RGB2PIXEL(r,g,b)	0
+#endif
+
 /*
  * Common colors - note any color including these may not be
  * available on palettized systems, and the system will
diff --git a/src/nanox/srvfunc.c b/src/nanox/srvfunc.c
index 88c9d14..5962a6d 100644
--- a/src/nanox/srvfunc.c
+++ b/src/nanox/srvfunc.c
@@ -2766,11 +2766,10 @@ GrLine(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x1, GR_COORD y1, GR_COORD x2,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdLine(dp->psd, dp->x + x1, dp->y + y1,
-				dp->x + x2, dp->y + y2, TRUE);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdLine(dp->psd, dp->x + x1, dp->y + y1, dp->x + x2, dp->y + y2, TRUE);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2791,10 +2790,10 @@ GrRect(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, GR_SIZE width,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-      	        case GR_DRAW_TYPE_PIXMAP:
-			GdRect(dp->psd, dp->x + x, dp->y + y, width, height);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdRect(dp->psd, dp->x + x, dp->y + y, width, height);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2813,10 +2812,10 @@ GrFillRect(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdFillRect(dp->psd, dp->x + x, dp->y + y, width,height);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdFillRect(dp->psd, dp->x + x, dp->y + y, width,height);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2835,10 +2834,10 @@ GrEllipse(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, GR_SIZE rx,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, FALSE);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, FALSE);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2857,10 +2856,10 @@ GrFillEllipse(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, GR_SIZE rx,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, TRUE);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, TRUE);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2880,12 +2879,10 @@ GrArc(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdArc(dp->psd, dp->x + x, dp->y + y, rx, ry, ax, ay,
-					bx, by, type);
-
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdArc(dp->psd, dp->x + x, dp->y + y, rx, ry, ax, ay, bx, by, type);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2904,11 +2901,10 @@ GrArcAngle(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdArcAngle(dp->psd, dp->x + x, dp->y + y, rx, ry,
-				angle1, angle2, type);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdArcAngle(dp->psd, dp->x + x, dp->y + y, rx, ry, angle1, angle2, type);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2932,11 +2928,10 @@ GrBitmap(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, GR_SIZE width,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdBitmap(dp->psd, dp->x + x, dp->y + y, width, height,
-				imagebits);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdBitmap(dp->psd, dp->x + x, dp->y + y, width, height, imagebits);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2952,10 +2947,10 @@ GrDrawImageBits(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdDrawImage(dp->psd, dp->x + x, dp->y + y, pimage);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdDrawImage(dp->psd, dp->x + x, dp->y + y, pimage);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -2972,11 +2967,10 @@ GrDrawImageFromFile(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
- 	        case GR_DRAW_TYPE_PIXMAP:
-			GdDrawImageFromFile(dp->psd, dp->x + x, dp->y + y,
-				width, height, path, flags);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdDrawImageFromFile(dp->psd, dp->x + x, dp->y + y, width, height, path, flags);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -3079,12 +3073,10 @@ GrDrawImageToFit(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
- 	        case GR_DRAW_TYPE_PIXMAP:
-			GdDrawImageToFit(dp->psd, dp->x + x, dp->y + y,
-				width, height, imageid);
-			break;
-	   
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdDrawImageToFit(dp->psd, dp->x + x, dp->y + y, width, height, imageid);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -3100,12 +3092,11 @@ GrDrawImagePartToFit(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD dx, GR_COORD dy,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
- 	        case GR_DRAW_TYPE_PIXMAP:
-			GdDrawImagePartToFit(dp->psd, dp->x + dx, dp->y + dy,
-				dwidth, dheight,sx,sy,swidth,sheight, imageid);
-			break;
-	   
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdDrawImagePartToFit(dp->psd, dp->x + dx, dp->y + dy,
+			dwidth, dheight,sx,sy,swidth,sheight, imageid);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -3168,12 +3159,10 @@ GrArea(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, GR_SIZE width,
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-printf("GrArea win %d gc %d %d,%d\n", id, gc, dp->x, dp->y);
-			GdArea(dp->psd, dp->x + x, dp->y + y, width, height,
-				pixels, pixtype);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdArea(dp->psd, dp->x + x, dp->y + y, width, height, pixels, pixtype);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -3188,32 +3177,31 @@ GrCopyArea(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	GR_COORD srcx, GR_COORD srcy, int op)
 {
   	GR_GC		*gcp;
-	GR_BOOL         exposure = GR_TRUE;
-
+	GR_BOOL		exposure = GR_TRUE;
 	GR_DRAWABLE	*dp;
-        GR_WINDOW	*swp;
-        GR_PIXMAP	*spp = NULL;
-        GR_DRAW_TYPE	type;
-        PSD 		srcpsd;
+	GR_WINDOW	*swp;
+	GR_PIXMAP	*spp = NULL;
+	GR_DRAW_TYPE	type;
+	PSD 		srcpsd;
 
 	SERVER_LOCK();
    
-        srcpsd = NULL;
+	srcpsd = NULL;
 
-        swp = GsFindWindow(srcid);
-        type = GsPrepareDrawing(id, gc, &dp);
+	swp = GsFindWindow(srcid);
+	type = GsPrepareDrawing(id, gc, &dp);
 	if (type == GR_DRAW_TYPE_NONE) {
 		SERVER_UNLOCK();
 		return;
 	}
 
-        if (swp) {
+	if (swp) {
 		srcpsd = swp->psd;
 		srcx += swp->x;
 		srcy += swp->y;
 	} else {
-	       spp = GsFindPixmap(srcid);
-	       if (spp)
+		spp = GsFindPixmap(srcid);
+		if (spp)
 		     srcpsd = spp->psd;
 	}
 	if (!srcpsd) {
@@ -3257,8 +3245,7 @@ GrCopyArea(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 		 */
 		if (GdRectInRegion(clipregion, &rc) != MWRECT_ALLIN) {
 EPRINTF("nano-X: skipping blit, sending expose event\n");
-			GsDeliverExposureEvent(swp, dp->x+x, dp->y+y,
-				width, height);
+			GsDeliverExposureEvent(swp, dp->x+x, dp->y+y, width, height);
 			SERVER_UNLOCK();
 			return;
 		}
@@ -3272,6 +3259,7 @@ EPRINTF("nano-X: skipping blit, sending expose event\n");
 	}
 
 	/* perform blit*/
+//printf("COPYAREA %d->%d %d,%d  %d,%d  %d,%d\n", srcid, id, dp->x, dp->y, x, y, width, height);
 	GdCheckCursor(srcpsd, srcx, srcy, srcx+width, srcy+height); /* FIXME*/
 	GdBlit(dp->psd, dp->x+x, dp->y+y, width, height, srcpsd, srcx, srcy,op);
 	GdFixCursor(srcpsd); /* FIXME*/
@@ -3342,10 +3330,10 @@ GrPoint(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y)
 	SERVER_LOCK();
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdPoint(dp->psd, dp->x + x, dp->y + y);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdPoint(dp->psd, dp->x + x, dp->y + y);
+		break;
 	}
 
 	SERVER_UNLOCK();
@@ -3366,19 +3354,18 @@ GrPoints(GR_DRAW_ID id, GR_GC_ID gc, GR_COUNT count, GR_POINT *pointtable)
 	SERVER_LOCK();
    
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-	                psd = dp->psd;
-	                break;
-		default:
-			SERVER_UNLOCK();
-			return;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		psd = dp->psd;
+		break;
+	default:
+		SERVER_UNLOCK();
+		return;
 	}
 
 	pp = pointtable;
-	for (i = count; i-- > 0; pp++) {
+	for (i = count; i-- > 0; pp++)
 		GdPoint(psd, pp->x + dp->x, pp->y + dp->y);
-	}
 
 	SERVER_UNLOCK();
 }
@@ -3399,13 +3386,13 @@ GrPoly(GR_DRAW_ID id, GR_GC_ID gc, GR_COUNT count, GR_POINT *pointtable)
 	SERVER_LOCK();
    
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-	                psd = dp->psd;
-	                break;
-		default:
-			SERVER_UNLOCK();
-			return;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		psd = dp->psd;
+		break;
+	default:
+		SERVER_UNLOCK();
+		return;
 	}
 
 	/*
@@ -3447,18 +3434,18 @@ GrFillPoly(GR_DRAW_ID id, GR_GC_ID gc, GR_COUNT count, GR_POINT *pointtable)
 	GR_DRAWABLE	*dp;
 	GR_POINT	*pp;
 	GR_COUNT	i;
-        PSD 		psd;
+	PSD 		psd;
 
 	SERVER_LOCK();
    
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-	                psd = dp->psd;
-			break;
-		default:
-			SERVER_UNLOCK();
-			return;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		psd = dp->psd;
+		break;
+	default:
+		SERVER_UNLOCK();
+		return;
 	}
 
 	/*
@@ -3484,7 +3471,7 @@ GrFillPoly(GR_DRAW_ID id, GR_GC_ID gc, GR_COUNT count, GR_POINT *pointtable)
 		pp->x -= dp->x;
 		pp->y -= dp->y;
 	}
-#endif   
+#endif
 
 	SERVER_UNLOCK();
 }
@@ -3506,10 +3493,10 @@ GrText(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y, void *str,
 		flags |= MWTF_BASELINE;
 
 	switch (GsPrepareDrawing(id, gc, &dp)) {
-		case GR_DRAW_TYPE_WINDOW:
-	        case GR_DRAW_TYPE_PIXMAP:
-			GdText(dp->psd, dp->x + x, dp->y + y, str, count,flags);
-			break;
+	case GR_DRAW_TYPE_WINDOW:
+	case GR_DRAW_TYPE_PIXMAP:
+		GdText(dp->psd, dp->x + x, dp->y + y, str, count,flags);
+		break;
 	}
 
 	SERVER_UNLOCK();
