diff --git a/src/ChangeLog b/src/ChangeLog
index 1d8cc14..14e29b9 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,22 @@
+	* fix nanowm cursor to resize in window bottom right to indicate resize
+	* added window x,y and root window rootx,rooty to GR_GENERAL_EVENT
+		(mouse enter event should be a mouse event, not general event)
+	* added WM_PROPS_NORESIZE window property to disallow window resizing
+24 May 2010
+	* rewrote adobe type1 (T1LIB) and truetype (freetype2) font subdrivers to use fast blit
+		blit project halfway done - will move GdBitmap to driver blit for PCF/CORE fonts
+		will remove/replace PSDOP_* and and combine drawarea/blit driver routines
+		all drivers will support mono lsb/msb and blendfgbg blit, meaning all fonts supported
+	* wrote drawarea_bitmap_bytes_lsb_first (t1lib) rotations for all fbportrait_xxx.c
+	* rewrote adobe type 1 font driver (font_t1lib.c), new fonts/type1 dir
+		added T1LIB_FONT_DIR to config (defaults fonts/type1)
+		requires blit_mono_byte_lsb routine in drawarea
+	* added width and height scaling to t1lib and freetype2 fonts (was height only)
+		added width parm to GrCreateFontFromBuffer, GrCopyFont
+		use GrCreateFontEx, GrSetFontSizeEx to set height and width for scaleable fonts (t1,ft2)
+	* freetype2 driver uses TTFONTDIR environ var for default font dir
+	* freetype 1 driver deprecated - use freetype 2 instead
+	* fix .fnt loader padding bug (again)
 23 May 2010
 	* split engine/devdraw.c into engine/devblit.c for blit changes
 	* major driver reorganization, DrawArea parameters change
diff --git a/src/FIXME b/src/FIXME
index 9d8e238..7f194f9 100644
--- a/src/FIXME
+++ b/src/FIXME
@@ -1,18 +1,16 @@
 fblin32alpha.c/fblin32.c:
 	fix SRC_OVER in applyOp
 	check alpha offset in passed pixmap alpha channel
-	add MWMODE_* compositing handling (currently only SRC_OVER alpha blend)
+	add MWROP_* compositing handling (currently only SRC_OVER alpha blend)
 	check whether alpha != 0 check needed
 	determine whether both fblin32alpha.c and fblin32.c needed
 		fblin32alpha.c always draws alpha in drawpixel, drawh, drawv
 		#define ALPHABLEND, what does it do now?
-	add uint32 to fblin32.c
 	update stretchblitex in fblin32.c for SRC_OVER
 	check fblin24.c, fblin16.c against fblin32.c/a
 	look at code generated for = vs += muldiv255, and fblin32alpha longword calcs
 add MWPF_TRUECOLORBGRA to static fb_var_screeninfo to select BGRA linear32alpha subdriver
 change image id's to pixmaps (win32 and nano-X)
-add PSF_HAVEOP_ALPHACOL, FT2 driver downgrades to non-antialias when needed
 fix add INVERT2BPP to config, combine with INVERT4BPP or reverse palette, INVERT() macro
 add X11 keyboard and mouse support to fbe
 init_alpha_lookup needs reinit if palette changed
@@ -25,10 +23,18 @@ investigate endian problem of ever reading color data as DWORD
 add ximage X11 debug statements
 enhance x11 driver to use fast blit from savebits
 leftBearing < 0 not handled in PCF loader nor MWCFONT structs, add l/r bearing returns?
+T1LIB appears to never discard font memory!
 
 moving window on bin/malpha waits until second buttondown
+add PSF_HAVEOP_ALPHACOL, FT2 driver downgrades to non-antialias when needed
 MWROP_BLENDCONSTANT needs alpha passed (not 150)
 PSDOP_ALPHAMAP needs gc->misc
+add .fnt/.fnt.gz or .pcf/.pcf.gz to FNT and PCF file spec
+DEPRECATE FT1, FONTMAPPER, !DYNAMICREGIONS
+fix config files to update new font info
+look at auto Antialias in GdCreateFont, handle for T1, FT2
+handle width=0 with aspect ratio of device
+test speed gen16_drawtext to use GdConvertBlit rather than GdBitmap
 
 fix bin/mwdvetest crash on closebox after static dialog
 fix bin/mwdvetest crash on ESC exit from main dialog
diff --git a/src/Makefile.rules b/src/Makefile.rules
index 17bff66..ba6f0e0 100644
--- a/src/Makefile.rules
+++ b/src/Makefile.rules
@@ -136,6 +136,7 @@ endif
 
 ifeq ($(HAVE_T1LIB_SUPPORT), Y)
 DEFINES += -DHAVE_T1LIB_SUPPORT=1
+DEFINES += -DT1LIB_FONT_DIR="\"$(T1LIB_FONT_DIR)"\"
 MW_CORE_LIBS += $(LIBT1LIB)
 ifneq ($(INCT1LIB),)
 INCLUDEDIRS += -I$(INCT1LIB)
diff --git a/src/config b/src/config
index bece4f3..c963972 100644
--- a/src/config
+++ b/src/config
@@ -160,43 +160,41 @@ INCTIFF                  = .
 LIBTIFF                  = /usr/lib/libtiff.a
 
 ####################################################################
-# native .fnt loadable font support
+# PCF font support - .pcf/.pcf.gz loadable X11 fonts
 ####################################################################
-HAVE_FNT_SUPPORT         = Y
-HAVE_FNTGZ_SUPPORT       = Y
-FNT_FONT_DIR             = "fonts/bdf"
+HAVE_PCF_SUPPORT         = Y
+HAVE_PCFGZ_SUPPORT       = Y
+PCF_FONT_DIR             = "fonts/pcf"
 
 ####################################################################
-# T1 adobe type1 font support thru t1lib
+# Truetype fonts - .ttf loadable fonts thru Freetype 2.x
 ####################################################################
-HAVE_T1LIB_SUPPORT       = N
-INCT1LIB                 = /usr/include
-LIBT1LIB                 = /usr/lib/libt1.a
+HAVE_FREETYPE_2_SUPPORT  = Y
+INCFT2LIB                = /usr/include
+LIBFT2LIB                = /usr/lib/libfreetype.a
+FREETYPE_FONT_DIR        = "fonts/truetype"
 
 ####################################################################
-# TrueType font support thru FreeType 1.x
+# T1 adobe type1 fonts - .pfb/.afm loadable thru t1lib
+# t1lib.config must be setup and in T1LIB_FONT_DIR
 ####################################################################
-HAVE_FREETYPE_SUPPORT    = N
-INCFTLIB                 = /usr/include/freetype1
-LIBFTLIB                 = /usr/lib/libttf.so
-FREETYPE_FONT_DIR        = "fonts/truetype"
+HAVE_T1LIB_SUPPORT       = N
+T1LIB_FONT_DIR           = "fonts/type1"
+INCT1LIB                 = /usr/include
+LIBT1LIB                 = /usr/lib/libt1.a
 
 ####################################################################
-# Support for many kinds of font thru FreeType 2.x
-# Must also set FREETYPE_FONT_DIR in the Freetype 1.x section
+# FNT font support - .fnt/.fnt.gz loadable fonts (native bdf-converted)
 ####################################################################
-HAVE_FREETYPE_2_SUPPORT  = Y
-INCFT2LIB                = /usr/include
-LIBFT2LIB                = /usr/lib/libfreetype.a
+HAVE_FNT_SUPPORT         = Y
+HAVE_FNTGZ_SUPPORT       = Y
+FNT_FONT_DIR             = "fonts/fnt"
 
 ####################################################################
-# PCF font support 
-# Selecting HAVE_PCFGZ_SUPPORT will allow you to directly read
-# .pcf.gz files, but it will add libz to the size of the server
+# Japanese EUC-JP support using loadable MGL font
 ####################################################################
-HAVE_PCF_SUPPORT         = Y
-HAVE_PCFGZ_SUPPORT       = Y
-PCF_FONT_DIR             = "fonts/pcf"
+HAVE_EUCJP_SUPPORT       = N
+EUCJP_FONT_DIR           = "fonts/japanese"
 
 ####################################################################
 # Chinese Han Zi Ku loadable font support
@@ -205,32 +203,26 @@ HAVE_HZK_SUPPORT         = N
 HZK_FONT_DIR             = "fonts/chinese"
 
 ####################################################################
-# Chinese BIG5 compiled in font support (big5font.c)
+# DBCS Chinese BIG5 compiled in font support (big5font.c)
 ####################################################################
 HAVE_BIG5_SUPPORT        = N
 
 ####################################################################
-# Chinese GB2312 compiled in font support (gb2312font.c)
+# DBCS Chinese GB2312 compiled in font support (gb2312font.c)
 ####################################################################
 HAVE_GB2312_SUPPORT      = N
 
 ####################################################################
-# Japanese JISX0213 compiled in font support (jisx0213-12x12.c)
+# DBCS Japanese JISX0213 compiled in font support (jisx0213-12x12.c)
 ####################################################################
 HAVE_JISX0213_SUPPORT    = N
 
 ####################################################################
-# Korean HANGUL font support (jo16x16.c)
+# DBCS Korean HANGUL font support (jo16x16.c)
 ####################################################################
 HAVE_KSC5601_SUPPORT     = N
 
 ####################################################################
-# Japanese EUC-JP support using loadable MGL font
-####################################################################
-HAVE_EUCJP_SUPPORT       = N
-EUCJP_FONT_DIR           = "fonts/japanese"
-
-####################################################################
 # Fribidi and shape/joining support for right to left rendering
 ####################################################################
 HAVE_FRIBIDI_SUPPORT     = N
diff --git a/src/demos/nanox/demo2.c b/src/demos/nanox/demo2.c
index c7b40f7..db17ee8 100644
--- a/src/demos/nanox/demo2.c
+++ b/src/demos/nanox/demo2.c
@@ -36,8 +36,8 @@ main(int ac,char **av)
 	GrSetWMProperties(w, &props);
 
 	gc = GrNewGC();
-	/*font = GrCreateFont("/tmp/lubI24.fnt", 0, NULL);*/
-	font = GrCreateFont("fonts/pcf/lubI24.pcf", 0, NULL);
+	/*font = GrCreateFontEx("/tmp/lubI24.fnt", 0, 0, NULL);*/
+	font = GrCreateFontEx("fonts/pcf/lubI24.pcf", 0, 0, NULL);
 	GrSetGCFont(gc, font);
 
 	GrSelectEvents(w, GR_EVENT_MASK_EXPOSURE | GR_EVENT_MASK_CLOSE_REQ
diff --git a/src/demos/nanox/fontdemo.c b/src/demos/nanox/fontdemo.c
index c5b446a..fcd23b3 100644
--- a/src/demos/nanox/fontdemo.c
+++ b/src/demos/nanox/fontdemo.c
@@ -16,8 +16,6 @@
 #define BGCOLOR		WHITE
 
 GR_WINDOW_ID	w;
-GR_GC_ID	gc;
-GR_FONT_ID	font;
 GR_BOOL		aa = GR_TRUE;
 char		fontname[200] = FONTNAME;
 
@@ -25,25 +23,42 @@ static void
 do_paint(GR_EVENT_EXPOSURE *ep)
 {
 	int	i, y = 0;
+	GR_GC_ID	gc;
+	GR_FONT_ID	font;
+	GR_WINDOW_INFO winfo;
+
+	GrGetWindowInfo(w, &winfo);
+
+	gc = GrNewGC();
+	GrSetGCUseBackground(gc, GR_FALSE);
+
+	GrSetGCForeground(gc, BGCOLOR);
+	GrFillRect(w, gc, 0, 0, winfo.width, winfo.height);
+
+	GrSetGCForeground(gc, FGCOLOR);
 
 	for (i=3; i<=30; ++i) {
-		GR_FONT_INFO	info;
-		char		buf[64];
+		int 	width, height;
+		char	buf[64];
+		GR_FONT_INFO	finfo;
+
+		height = i * winfo.height / 530;
+		width = i * winfo.width / 640;
+		font = GrCreateFontEx(fontname, height, width, NULL);
 
-		font = GrCreateFont(fontname, i, NULL);
-		if (aa)
-			GrSetFontAttr(font, GR_TFANTIALIAS|GR_TFKERNING, 0);
+		GrSetFontAttr(font, aa? (GR_TFANTIALIAS|GR_TFKERNING): 0, -1);
 		/*GrSetFontRotation(font, 150);*/
 		GrSetGCFont(gc, font);
 
-		sprintf(buf, "%d The Quick Brown Fox Jumps Over The Lazy Dog", i);
+		sprintf(buf, "%d/%d The Quick Brown Fox Jumps Over The Lazy Dog", height, width);
 		GrText(w, gc, 0, y, buf, -1, GR_TFASCII|GR_TFTOP);
 
-		GrGetFontInfo(font, &info);
-		y += info.height;
+		GrGetFontInfo(font, &finfo);
+		y += finfo.height;
 
 		GrDestroyFont(font);
 	}
+	GrDestroyGC(gc);
 }
 
 int
@@ -58,14 +73,9 @@ main(int ac, char **av)
 	w = GrNewWindowEx(GR_WM_PROPS_APPWINDOW, "fontdemo", GR_ROOT_WINDOW_ID,
 		10, 10, 640, 530, BGCOLOR);
 	GrSelectEvents(w, GR_EVENT_MASK_EXPOSURE|GR_EVENT_MASK_BUTTON_DOWN|
-		GR_EVENT_MASK_CLOSE_REQ);
+		GR_EVENT_MASK_KEY_DOWN|GR_EVENT_MASK_CLOSE_REQ);
 	GrMapWindow(w);
 
-	gc = GrNewGC();
-	GrSetGCUseBackground(gc, GR_FALSE);
-	GrSetGCForeground(gc, FGCOLOR);
-	GrSetGCBackground(gc, BGCOLOR);
-
 	while (1) {
 		GR_EVENT event;
 
@@ -76,15 +86,15 @@ main(int ac, char **av)
 			break;
 
 		case GR_EVENT_TYPE_BUTTON_DOWN:
-			{
-			GR_WINDOW_INFO info;
-
-			aa = !aa;
-			GrGetWindowInfo(w, &info);
-			GrSetGCForeground(gc, BGCOLOR);
-			GrFillRect(w, gc, 0, 0, info.width, info.height);
-			GrSetGCForeground(gc, FGCOLOR);
-			do_paint(&event.exposure);	/*FIXME*/
+			do_paint(&event.exposure);
+			break;
+
+    	case GR_EVENT_TYPE_KEY_DOWN:
+      		switch(event.keystroke.ch) {
+        	case 'a':
+				aa = !aa;
+				do_paint(&event.exposure);
+          		break;
 			}
 			break;
 
diff --git a/src/demos/nanox/ft2test.c b/src/demos/nanox/ft2test.c
index 3d6c23c..b2acc3d 100644
--- a/src/demos/nanox/ft2test.c
+++ b/src/demos/nanox/ft2test.c
@@ -33,7 +33,7 @@ void
 test_ft2_antialias(void)
 {
 	GR_GC_ID gc = GrNewGC();
-	int id = GrCreateFont((GR_CHAR *)FONT, 40, NULL);
+	int id = GrCreateFontEx((GR_CHAR *)FONT, 40, 40, NULL);
 
 	GrSetFontAttr(id, GR_TFANTIALIAS, 0);
 	GrSetGCFont(gc, id);
diff --git a/src/demos/nanox/ftdemo.c b/src/demos/nanox/ftdemo.c
index 0517566..62d456b 100644
--- a/src/demos/nanox/ftdemo.c
+++ b/src/demos/nanox/ftdemo.c
@@ -10,15 +10,21 @@
 #define ANTIALIAS	0		/* set =1 to enable anti aliasing*/
 
 #if HAVE_T1LIB_SUPPORT
-#define FONTNAME "bchr.pfb"
+#define FONTNAME "fonts/type1/bchr.pfb"
 #elif (HAVE_FREETYPE_SUPPORT | HAVE_FREETYPE_2_SUPPORT)
 #define FONTNAME "lt1-r-omega-serif"
 //#define FONTNAME "cour"
 #elif HAVE_PCF_SUPPORT
 //#define FONTNAME	"jiskan24.pcf.gz"
-//#define FONTNAME	"helvB12.pcf.gz"
+#define FONTNAME	"helvB12.pcf.gz"
 //#define FONTNAME	"helvB12_lin.pcf.gz"
 //#define FONTNAME	"fonts/bdf/symb18.pcf"
+#elif HAVE_FNT_SUPPORT
+#define FONTNAME	"timBI18.fnt"
+#elif HAVE_EUCJP_SUPPORT
+#define FONTNAME	"k16x16.fnt"
+#elif HAVE_HZK_SUPPORT
+#define FONTNAME	"HZKFONT"
 #else
 #define FONTNAME GR_FONT_SYSTEM_VAR
 #endif
@@ -71,8 +77,8 @@ int main(int argc, char **argv)
   }
   fclose(file);
 
-  fontid = GrCreateFont(FONTNAME, 20, NULL);
-  fontid2 = GrCreateFont(FONTNAME, 36, NULL);
+  fontid = GrCreateFontEx(FONTNAME, 20, 20, NULL);
+  fontid2 = GrCreateFontEx(FONTNAME, 36, 36, NULL);
 
   Render(window);
  
@@ -139,11 +145,7 @@ void Render(GR_WINDOW_ID window)
  
    /* Draw menu */
    GrSetGCFont(gid, fontid);
-#if ANTIALIAS
-   GrSetFontAttr(fontid, GR_TFKERNING | GR_TFANTIALIAS, 0);
-#else
-   GrSetFontAttr(fontid, GR_TFKERNING, 0);
-#endif
+   GrSetFontAttr(fontid, aa? (GR_TFKERNING | GR_TFANTIALIAS): GR_TFKERNING, -1);
    GrText(window, gid, 5, 20, "+ Rotate string clockwise", 25, GR_TFASCII);
    GrText(window, gid, 5, 40, "-  Rotate string counter-clockwise", 34, GR_TFASCII);
    GrText(window, gid, 5, 60, "a Toggle anti-aliasing", 22, GR_TFASCII);
diff --git a/src/demos/nanox/logfont.c b/src/demos/nanox/logfont.c
index 562a2e6..763f470 100644
--- a/src/demos/nanox/logfont.c
+++ b/src/demos/nanox/logfont.c
@@ -88,9 +88,9 @@ int main(int argc, char **argv)
 	      else
 		      strcpy(lf.lfFaceName, FONT);
 
-	      fontid = GrCreateFont(0, 0, &lf);
+	      fontid = GrCreateFontEx(0, 0, 0, &lf);
 	      /* GrSetFontSize(fontid, 1+(int)(80.0 * rand() / (RAND_MAX+1.0))); */
-	      GrSetFontSize(fontid,26);
+	      GrSetFontSizeEx(fontid, 26, 26);
 	      /*GrSetFontRotation(fontid, 330);*/ /* 33 degrees*/
   	      GrSetFontAttr(fontid, GR_TFKERNING | GR_TFANTIALIAS, 0);
   	      GrSetGCFont(gc, fontid);
diff --git a/src/demos/nanox/npanel.c b/src/demos/nanox/npanel.c
index b6e403d..043fe60 100644
--- a/src/demos/nanox/npanel.c
+++ b/src/demos/nanox/npanel.c
@@ -125,7 +125,7 @@ main(int argc,char **argv)
 	bgc = GrNewGC();
 
 	GrSetGCForeground(bgc, GRAY);
-	GrSetGCFont(gc, GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL));
+	GrSetGCFont(gc, GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL));
 
 	GrGetGCTextSize(gc, "A", 1, GR_TFASCII, &fwidth, &fheight, &fbase);
 	width = fwidth * 8 + 4;
diff --git a/src/demos/nanox/nterm.c b/src/demos/nanox/nterm.c
index f0922c5..4f1322c 100644
--- a/src/demos/nanox/nterm.c
+++ b/src/demos/nanox/nterm.c
@@ -75,8 +75,8 @@ int main(int argc, char ** argv)
 
 	GrSetGCForeground(gc1, GRAY);
 	GrSetGCBackground(gc1, LTBLUE);
-	GrSetGCFont(gc1, GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL));
-	/*GrSetGCFont(gc1, GrCreateFont(GR_FONT_OEM_FIXED, 0, NULL));*/
+	GrSetGCFont(gc1, GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL));
+	/*GrSetGCFont(gc1, GrCreateFontEx(GR_FONT_OEM_FIXED, 0, 0, NULL));*/
 	GrSetGCForeground(gc3, WHITE);
 	GrSetGCBackground(gc3, BLACK);
 
diff --git a/src/demos/nanox/nxterm.c b/src/demos/nanox/nxterm.c
index 86f9a62..92b2862 100644
--- a/src/demos/nanox/nxterm.c
+++ b/src/demos/nanox/nxterm.c
@@ -976,9 +976,9 @@ int main(int argc, char **argv)
 			rowmask = 0xffff;
     }
     
-    regFont = GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL);
-    /*regFont = GrCreateFont(GR_FONT_OEM_FIXED, 0, NULL);*/
-    /*boldFont = GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL);*/
+    regFont = GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL);
+    /*regFont = GrCreateFontEx(GR_FONT_OEM_FIXED, 0, 0, NULL);*/
+    /*boldFont = GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL);*/
     GrGetFontInfo(regFont, &fi);
 
     winw = col*fi.maxwidth;
diff --git a/src/demos/nanox/pcfdemo.c b/src/demos/nanox/pcfdemo.c
index 1b55ae9..94ae351 100644
--- a/src/demos/nanox/pcfdemo.c
+++ b/src/demos/nanox/pcfdemo.c
@@ -71,7 +71,7 @@ main(int argc, char **argv)
 	if (GrOpen() == -1)
 		return (-1);
 
-	font = GrCreateFont(argv[1], 12, 0);
+	font = GrCreateFontEx(argv[1], 12, 12, 0);
 	if (!font)
 		printf("Unable to load %s\n", argv[1]);
 
diff --git a/src/demos/nanox/t1demo.c b/src/demos/nanox/t1demo.c
index d731b8c..7955d93 100644
--- a/src/demos/nanox/t1demo.c
+++ b/src/demos/nanox/t1demo.c
@@ -39,11 +39,11 @@
 #define FONT5 ""
 #elif HAVE_T1LIB_SUPPORT
 #define MAXFONTS 5
-#define FONT1 "bchr"
-#define FONT2 "bchb"
-#define FONT3 "dcr10"
-#define FONT4 "dcbx10"
-#define FONT5 "bchri"
+#define FONT1 "fonts/type1/bchr.pfb"
+#define FONT2 "fonts/type1/bchb.pfb"
+#define FONT3 "fonts/type1/dcr10.pfb"
+#define FONT4 "fonts/type1/dcbx10.pfb"
+#define FONT5 "fonts/type1/bchri.pfb"
 #elif (HAVE_FREETYPE_SUPPORT | HAVE_FREETYPE_2_SUPPORT)
 #define MAXFONTS 5
 #define FONT1 "lt1-r-omega-serif"
@@ -105,8 +105,7 @@ main(int ac, char **av)
 	window = GrNewWindowEx(GR_WM_PROPS_APPWINDOW,
 		"t1demo loadable fonts (truetype, t1lib, pcf, mgl, hzk)",
 		GR_ROOT_WINDOW_ID, 50, 50, WIDTH, HEIGHT, BLACK);
-	GrSelectEvents(window,
-		GR_EVENT_MASK_EXPOSURE | GR_EVENT_MASK_CLOSE_REQ);
+	GrSelectEvents(window, GR_EVENT_MASK_EXPOSURE | GR_EVENT_MASK_CLOSE_REQ);
 	GrMapWindow(window);
 
 	gc = GrNewGC();
@@ -133,8 +132,8 @@ main(int ac, char **av)
 			exit(0);
 		}
 
-		fontid = GrCreateFont(names[fnum=RAND(MAXFONTS)], 0, NULL);
-		GrSetFontSize(fontid, RAND(80) + 1);
+		fontid = GrCreateFontEx(names[fnum=RAND(MAXFONTS)], 0, 0, NULL);
+		GrSetFontSizeEx(fontid, RAND(80) + 1, RAND(80) + 1);
 		GrSetFontRotation(fontid, 330);		/* 33 degrees */
 		GrSetFontAttr(fontid, GR_TFKERNING | GR_TFANTIALIAS, 0);
 		GrSetGCFont(gc, fontid);
diff --git a/src/demos/nbreaker/init.c b/src/demos/nbreaker/init.c
index ffa1e59..f9f74fa 100644
--- a/src/demos/nbreaker/init.c
+++ b/src/demos/nbreaker/init.c
@@ -148,7 +148,7 @@ static void setup_default_state(nbstate *state)
 	state->scores.fhi = 0;
 	state->scores.p = 0;
 	state->gc = GrNewGC();
-	fid = GrCreateFont(SCORE_FONT, 0, NULL);
+	fid = GrCreateFontEx(SCORE_FONT, 0, 0, NULL);
 	GrGetFontInfo(fid, &fi);
 	state->scores.h = (2 * SCORE_BORDER) + fi.height;
 	GrSetGCFont(state->gc, fid);
diff --git a/src/demos/nxscribble/nxscribble.c b/src/demos/nxscribble/nxscribble.c
index fc7d287..52619ec 100644
--- a/src/demos/nxscribble/nxscribble.c
+++ b/src/demos/nxscribble/nxscribble.c
@@ -65,7 +65,7 @@ main(int argc, char **argv)
 		gct = GrNewGC();
 		GrSetGCForeground(gct, GREEN);
 		GrGetGCTextSize(gct, "A",1, GR_TFASCII, &width, &height, &base);
-		GrSetGCFont(gct, GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL));
+		GrSetGCFont(gct, GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL));
 		gctb = GrNewGC();
 		GrSetGCForeground(gctb, BLACK);
 	}
diff --git a/src/demos/nxscribble/scribwidget.c b/src/demos/nxscribble/scribwidget.c
index 17c6f5e..ee50ac3 100644
--- a/src/demos/nxscribble/scribwidget.c
+++ b/src/demos/nxscribble/scribwidget.c
@@ -145,7 +145,7 @@ create_scribble(void)
     new->gc = GrNewGC();
     GrSetGCForeground(new->gc, GrGetSysColor(GR_COLOR_APPTEXT));
     GrSetGCBackground(new->gc, GrGetSysColor(GR_COLOR_APPWINDOW));
-    GrSetGCFont(new->gc, GrCreateFont(GR_FONT_SYSTEM_FIXED, 0, NULL));
+    GrSetGCFont(new->gc, GrCreateFontEx(GR_FONT_SYSTEM_FIXED, 0, 0, NULL));
 
     ResetStroke (new);
     return new;
diff --git a/src/drivers/fblin16.c b/src/drivers/fblin16.c
index e1a5b4c..bb8151a 100644
--- a/src/drivers/fblin16.c
+++ b/src/drivers/fblin16.c
@@ -672,8 +672,7 @@ linear16_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 			/* Do pixels of partial first byte */
 			if (hard_prefix) {
 				for (m = prefix_mask; m < prefix_last; m <<= 1) {
-					*dst++ = (m & *src) ? fg_color :
-						bg_color;
+					*dst++ = (m & *src) ? fg_color : bg_color;
 				}
 				src++;
 			}
diff --git a/src/drivers/fbportrait_down.c b/src/drivers/fbportrait_down.c
index 60ba181..66ff216 100644
--- a/src/drivers/fbportrait_down.c
+++ b/src/drivers/fbportrait_down.c
@@ -87,14 +87,22 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
+	/* create new gc with flipped coords*/
 	l_gc.dstx = dstpsd->xvirtres - gc->dstx - gc->width;
 	l_gc.dsty = dstpsd->yvirtres - gc->dsty - gc->height;
-
 	l_gc.srcx = 0;
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_ALPHACOL;
-	l_gc.src_linelen = l_gc.width;
+	l_gc.src_linelen = gc->width;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.width = gc->width;
+	l_gc.height = gc->height;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
 	if (!(l_gc.data = ALLOCA(l_gc.width * l_gc.height)))
 		return;
 
@@ -111,7 +119,8 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 			out_y = (out_h - 1) - in_y;
 			out_x = (out_w - 1) - in_x;
 
-			alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			//alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			alpha_out[(out_y * l_gc.src_linelen) + out_x] = alpha_in[(in_y * gc->src_linelen) + in_x];
 		}
 	}
 
@@ -130,12 +139,21 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
+	/* create new gc with flipped coords*/
 	l_gc.dstx = psd->xvirtres - gc->dstx - gc->width;
 	l_gc.dsty = psd->yvirtres - gc->dsty - gc->height;
 	l_gc.srcx = 0;
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_BITMAP_BYTES_MSB_FIRST;
+	l_gc.src_linelen = gc->width;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.width = gc->width;
+	l_gc.height = gc->height;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
 
 	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
 		return;
@@ -167,6 +185,61 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+static void
+fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+{
+	ADDR8 pixel_in, pixel_out;
+	MWCOORD	in_x, in_y, in_w, in_h;
+	MWCOORD	out_x, out_y, out_w, out_h;
+	driver_gc_t	l_gc;
+
+	/* create new gc with flipped coords*/
+	l_gc.dstx = psd->xvirtres - gc->dstx - gc->width;
+	l_gc.dsty = psd->yvirtres - gc->dsty - gc->height;
+	l_gc.srcx = 0;
+	l_gc.srcy = 0;
+	l_gc.src_linelen = gc->width;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.width = gc->width;
+	l_gc.height = gc->height;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
+	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
+		return;
+	memset(l_gc.data, 0, l_gc.height * l_gc.src_linelen);
+
+	pixel_in = ((ADDR8)gc->data) + gc->src_linelen * gc->srcy + gc->srcx;
+	in_w = gc->width;
+	in_h = gc->height;
+
+	pixel_out = l_gc.data;
+	out_w = l_gc.width;
+	out_h = l_gc.height;
+
+	/* rotate_down_1bpp*/
+	for (in_y = 0; in_y < in_h; in_y++) {
+		for (in_x = 0; in_x < in_w; in_x++) {
+			out_y = (out_h - 1) - in_y;
+			out_x = (out_w - 1) - in_x;
+
+			//pixel_out[(out_y * out_w) + out_x] = pixel_in[(in_y * in_w) + in_x];
+			if (pixel_in[in_y*gc->src_linelen + (in_x >> 3)] & (0x01 << (in_x&7)))
+				pixel_out[out_y*l_gc.src_linelen + (out_x >> 3)] |= (0x01 << (out_x&7));
+		}
+	}
+
+	psd->orgsubdriver->DrawArea(psd, &l_gc);
+
+	FREEA(l_gc.data);
+}
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
+
 static void
 fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
@@ -185,6 +258,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
+
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+	case PSDOP_BITMAP_BYTES_LSB_FIRST:
+		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		break;
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
 }
 
diff --git a/src/drivers/fbportrait_left.c b/src/drivers/fbportrait_left.c
index c44535e..64f3560 100644
--- a/src/drivers/fbportrait_left.c
+++ b/src/drivers/fbportrait_left.c
@@ -143,16 +143,22 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
-	l_gc.dstx = gc->dsty;
-	l_gc.dsty = dstpsd->xvirtres - gc->dstx - gc->width;
+	/* create new gc with rotated coords*/
 	l_gc.width = gc->height;
 	l_gc.height = gc->width;
-	l_gc.srcx = 0;
+	l_gc.dstx = gc->dsty;
+	l_gc.dsty = dstpsd->xvirtres - gc->dstx - gc->width;
+	l_gc.srcx = 0;	//FIXME rotate may fail with srcx/srcy not zero
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_ALPHACOL;
-
 	l_gc.src_linelen = l_gc.width;	/* 1 byte alpha channel*/
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
 	if (!(l_gc.data = ALLOCA(l_gc.width * l_gc.height)))
 		return;
 
@@ -170,7 +176,8 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 			out_y = (out_h - 1) - in_x;
 			out_x = in_y;
 
-			alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			//alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			alpha_out[(out_y * l_gc.src_linelen) + out_x] = alpha_in[(in_y * gc->src_linelen) + in_x];
 		}
 	}
 
@@ -189,16 +196,22 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
-	l_gc.dstx = gc->dsty;
-	l_gc.dsty = psd->xvirtres - gc->dstx - gc->width;
+	/* create new gc with rotated coords*/
 	l_gc.width = gc->height;
 	l_gc.height = gc->width;
+	l_gc.dstx = gc->dsty;
+	l_gc.dsty = psd->xvirtres - gc->dstx - gc->width;
 	l_gc.srcx = 0;	//FIXME rotate may fail with srcx/srcy not zero
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_BITMAP_BYTES_MSB_FIRST;
-
 	l_gc.src_linelen = (l_gc.width + 7) / 8;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
 	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
 		return;
 	memset(l_gc.data, 0, l_gc.height * l_gc.src_linelen);
@@ -229,6 +242,61 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+static void
+fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+{
+	ADDR8 pixel_in, pixel_out;
+	MWCOORD	in_x, in_y, in_w, in_h;
+	MWCOORD	out_x, out_y, out_w, out_h;
+	driver_gc_t	l_gc;
+
+	/* create new gc with rotated coords*/
+	l_gc.width = gc->height;
+	l_gc.height = gc->width;
+	l_gc.dstx = gc->dsty;
+	l_gc.dsty = psd->xvirtres - gc->dstx - gc->width;
+	l_gc.srcx = 0;	//FIXME rotate may fail with srcx/srcy not zero
+	l_gc.srcy = 0;
+	l_gc.src_linelen = (l_gc.width + 7) / 8;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
+	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
+		return;
+	memset(l_gc.data, 0, l_gc.height * l_gc.src_linelen);
+
+	pixel_in = ((ADDR8)gc->data) + gc->src_linelen * gc->srcy + gc->srcx;
+	in_w = gc->width;
+	in_h = gc->height;
+
+	pixel_out = l_gc.data;
+	out_w = l_gc.width;
+	out_h = l_gc.height;
+
+	/* rotate_left_1bpp*/
+	for (in_y = 0; in_y < in_h; in_y++) {
+		for (in_x = 0; in_x < in_w; in_x++) {
+			out_y = (out_h - 1) - in_x;
+			out_x = in_y;
+
+			//pixel_out[(out_y * out_w) + out_x] = pixel_in[(in_y * in_w) + in_x];
+			if (pixel_in[in_y*gc->src_linelen + (in_x >> 3)] & (0x01 << (in_x&7)))
+				pixel_out[out_y*l_gc.src_linelen + (out_x >> 3)] |= (0x01 << (out_x&7));
+		}
+	}
+
+	psd->orgsubdriver->DrawArea(psd, &l_gc);
+
+	FREEA(l_gc.data);
+}
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
+
 static void
 fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
@@ -247,6 +315,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
+
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+	case PSDOP_BITMAP_BYTES_LSB_FIRST:
+		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		break;
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
 }
 
diff --git a/src/drivers/fbportrait_right.c b/src/drivers/fbportrait_right.c
index 871c58c..8395af2 100644
--- a/src/drivers/fbportrait_right.c
+++ b/src/drivers/fbportrait_right.c
@@ -96,16 +96,22 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t *gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
-	l_gc.dstx = dstpsd->yvirtres - gc->dsty - gc->height;
-	l_gc.dsty = gc->dstx;
+	/* create new gc with rotated coords*/
 	l_gc.width = gc->height;
 	l_gc.height = gc->width;
-
+	l_gc.dstx = dstpsd->yvirtres - gc->dsty - gc->height;
+	l_gc.dsty = gc->dstx;
 	l_gc.srcx = 0;
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_ALPHACOL;
 	l_gc.src_linelen = l_gc.width;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
 	if (!(l_gc.data = ALLOCA(l_gc.width * l_gc.height)))
 		return;
 
@@ -122,7 +128,8 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t *gc)
 			out_y = in_x;
 			out_x = (out_w - 1) - in_y;
 
-			alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			//alpha_out[(out_y * out_w) + out_x] = alpha_in[(in_y * in_w) + in_x];
+			alpha_out[(out_y * l_gc.src_linelen) + out_x] = alpha_in[(in_y * gc->src_linelen) + in_x];
 		}
 	}
 
@@ -141,16 +148,22 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 	MWCOORD	out_x, out_y, out_w, out_h;
 	driver_gc_t	l_gc;
 
-	l_gc = *gc;
-	l_gc.dstx = psd->yvirtres - gc->dsty - gc->height;
-	l_gc.dsty = gc->dstx;
+	/* create new gc with rotated coords*/
 	l_gc.width = gc->height;
 	l_gc.height = gc->width;
+	l_gc.dstx = psd->yvirtres - gc->dsty - gc->height;
+	l_gc.dsty = gc->dstx;
 	l_gc.srcx = 0;
 	l_gc.srcy = 0;
-	l_gc.op = PSDOP_BITMAP_BYTES_MSB_FIRST;
-
 	l_gc.src_linelen = (l_gc.width + 7) / 8;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
 	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
 		return;
 	memset(l_gc.data, 0, l_gc.height * l_gc.src_linelen);
@@ -181,6 +194,61 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+static void
+fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+{
+	ADDR8 pixel_in, pixel_out;
+	MWCOORD	in_x, in_y, in_w, in_h;
+	MWCOORD	out_x, out_y, out_w, out_h;
+	driver_gc_t	l_gc;
+
+	/* create new gc with rotated coords*/
+	l_gc.width = gc->height;
+	l_gc.height = gc->width;
+	l_gc.dstx = psd->yvirtres - gc->dsty - gc->height;
+	l_gc.dsty = gc->dstx;
+	l_gc.srcx = 0;
+	l_gc.srcy = 0;
+	l_gc.src_linelen = (l_gc.width + 7) / 8;
+
+	/* copy the rest*/
+	l_gc.op = gc->op;
+	l_gc.fg_color = gc->fg_color;
+	l_gc.bg_color = gc->bg_color;
+	l_gc.usebg = gc->usebg;
+	l_gc.dst_linelen = gc->dst_linelen;
+
+	if (!(l_gc.data = ALLOCA(l_gc.height * l_gc.src_linelen)))
+		return;
+	memset(l_gc.data, 0, l_gc.height * l_gc.src_linelen);
+
+	pixel_in = ((ADDR8)gc->data) + gc->src_linelen * gc->srcy + gc->srcx;
+	in_w = gc->width;
+	in_h = gc->height;
+
+	pixel_out = l_gc.data;
+	out_w = l_gc.width;
+	out_h = l_gc.height;
+
+	/* rotate_right_1bpp*/
+	for (in_y = 0; in_y < in_h; in_y++) {
+		for (in_x = 0; in_x < in_w; in_x++) {
+			out_y = in_x;
+			out_x = (out_w - 1) - in_y;
+
+			//pixel_out[(out_y * out_w) + out_x] = pixel_in[(in_y * in_w) + in_x];
+			if (pixel_in[in_y*gc->src_linelen + (in_x >> 3)] & (0x01 << (in_x&7)))
+				pixel_out[out_y*l_gc.src_linelen + (out_x >> 3)] |= (0x01 << (out_x&7));
+		}
+	}
+
+	psd->orgsubdriver->DrawArea(psd, &l_gc);
+
+	FREEA(l_gc.data);
+}
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
+
 static void
 fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
@@ -199,6 +267,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
+
+#if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
+	case PSDOP_BITMAP_BYTES_LSB_FIRST:
+		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		break;
+#endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
 }
 
diff --git a/src/drivers/genfont.c b/src/drivers/genfont.c
index a81cf48..dded6a0 100644
--- a/src/drivers/genfont.c
+++ b/src/drivers/genfont.c
@@ -26,6 +26,8 @@ extern MWCFONT font_X6x13;			/* MWFONT_SYSTEM_FIXED (should be ansi)*/
 /* handling routines for MWCOREFONT*/
 static MWFONTPROCS fontprocs = {
 	MWTF_ASCII,		/* routines expect ascii*/
+	NULL,			/* init*/
+	NULL,			/* createfont*/
 	gen_getfontinfo,
 	gen_gettextsize,
 	gen_gettextbits,
@@ -34,6 +36,7 @@ static MWFONTPROCS fontprocs = {
 	NULL,			/* setfontsize*/
 	NULL,			/* setfontrotation*/
 	NULL,			/* setfontattr*/
+	NULL			/* duplicate*/
 };
 
 /*
@@ -56,11 +59,11 @@ static MWFONTPROCS fontprocs = {
 
 /* first font is default font*/
 MWCOREFONT gen_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
+	{&fontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
+	{&fontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
 	/* deprecated redirections for the time being*/
-	{&fontprocs, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
-	{&fontprocs, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
+	{&fontprocs, 0, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
+	{&fontprocs, 0, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
 };
 
 /*GB: pointer to an user builtin font table. */
diff --git a/src/engine/devblit.c b/src/engine/devblit.c
index 775c2ca..e54f168 100644
--- a/src/engine/devblit.c
+++ b/src/engine/devblit.c
@@ -139,6 +139,63 @@ GdBitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 	GdFixCursor(psd);
 }
 
+void
+GdConversionBlit(PSD psd, PMWBLITPARMS parms)
+{
+	driver_gc_t	gc;
+	int op;
+
+	/* temp transfer parms to old driver struct*/
+	switch (parms->data_format) {
+	case MWIF_MONOBYTEMSB:			/* ft2 non-alias*/
+		//convblit_copy_mono_byte_msb_argb(parms);	/* conv mono byte MSBFirst to ARGB*/
+		op = PSDOP_BITMAP_BYTES_MSB_FIRST;
+		break;
+
+	//case MWIF_MONOWORDMSB:			/* core mwcfont, pcf*/
+		//convblit_copy_mono_word_msb_argb(parms);	/* conv mono word MSBFirst to ARGB*/
+		//break;
+
+	case MWIF_8BPP|MWIF_HASALPHA:	/* ft2 alias, t1lib alias*/
+		if (parms->op == MWROP_BLENDFGBG) {
+			//convblit_blend_8_fgbg_argb(parms);		/* conv 8bpp alpha with fg/bg to ARGB*/
+			op = PSDOP_ALPHACOL;
+			break;
+		}
+		/* fall thru*/
+	default:
+		printf("GdConversionBlit: No conversion blit available\n");
+		//FREEA(parms->data_out);
+		return;
+
+	case MWIF_MONOBYTELSB:			/* t1lib non-alias*/
+		//convblit_copy_mono_byte_lsb_argb(parms);	/* conv mono byte LSBFirst to ARGB*/
+		op = PSDOP_BITMAP_BYTES_LSB_FIRST;
+		break;
+	}
+
+	gc.op = op;
+	gc.width = parms->width;
+	gc.height = parms->height;
+	gc.dstx = parms->dstx;
+	gc.dsty = parms->dsty;
+	gc.srcx = parms->srcx;
+	gc.srcy = parms->srcy;
+	gc.fg_color = parms->fg_color;
+	gc.bg_color = parms->bg_color;
+	gc.usebg = parms->usebg;
+	gc.data = parms->data;
+
+	gc.src_linelen = parms->src_pitch;
+	//gc->dst_linelen = 
+
+	//parms->data_format;
+	//parms->dst_pitch;
+	//parms->data_out;
+
+	GdDrawAreaInternal(psd, &gc);
+}
+
 /*
  * A wrapper for psd->DrawArea which performs clipping.
  * The gc->dst[x,y,w,h] values are clipped.  The gc->src[x,y]
diff --git a/src/engine/devfont.c b/src/engine/devfont.c
index 594159b..b8ddf63 100644
--- a/src/engine/devfont.c
+++ b/src/engine/devfont.c
@@ -18,9 +18,13 @@
 #include <string.h>
 #include "device.h"
 #include "devfont.h"
-#include "../drivers/genfont.h"
+#include "genfont.h"
 #include "intl.h"
 
+#if (UNIX | DOS_DJGPP)
+#define strcmpi	strcasecmp
+#endif
+
 //#define DEBUG_TEXT_SHAPING
 
 /**
@@ -77,12 +81,13 @@ GdSetFont(PMWFONT pfont)
  *                 plogfont is specified.
  * @param height   The height of the font in pixels.  Ignored if
  *                 plogfont is specified.
+ * @param width    The width of the font in pixels.  Ignored if
+ *                 plogfont is specified.
  * @param plogfont A structure describing the font, or NULL.
  * @return         A new font, or NULL on error.
  */
 PMWFONT
-GdCreateFont(PSD psd, const char *name, MWCOORD height,
-	const PMWLOGFONT plogfont)
+GdCreateFont(PSD psd, const char *name, MWCOORD height, MWCOORD width, const PMWLOGFONT plogfont)
 {
 	int 		i;
 	int		fontht;
@@ -126,6 +131,7 @@ GdCreateFont(PSD psd, const char *name, MWCOORD height,
 		fontclass = plogfont->lfClass;
 #endif
 		height = plogfont->lfHeight;
+		width = plogfont->lfWidth;
 		if (plogfont->lfUnderline)
 			fontattr = MWTF_UNDERLINE;
 	}
@@ -174,117 +180,105 @@ GdCreateFont(PSD psd, const char *name, MWCOORD height,
 
 #if HAVE_FNT_SUPPORT
 	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_FNT) {
-		pfont = (PMWFONT) fnt_createfont(fontname, height, fontattr);
+		pfont = (PMWFONT)fnt_createfont(fontname, height, width, fontattr);
 		if (pfont) {
 			DPRINTF("fnt_createfont: using font %s\n", fontname);
-			return(pfont);
+			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("fnt_createfont: %s,%d not found\n",
-				fontname, height);
+			EPRINTF("fnt_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
 #if HAVE_PCF_SUPPORT
 	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_PCF) {
-		pfont = (PMWFONT) pcf_createfont(fontname, height, fontattr);
+		pfont = (PMWFONT)pcf_createfont(fontname, height, width, fontattr);
 		if (pfont) {
 			DPRINTF("pcf_createfont: using font %s\n", fontname);
-			return(pfont);
+			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("pcf_createfont: %s,%d not found\n",
-				fontname, height);
+			EPRINTF("pcf_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
 #if HAVE_FREETYPE_SUPPORT
  	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_FREETYPE) {
-		if (freetype_init(psd)) {
-			if (plogfont && abs(plogfont->lfHeight) > FFMINAA_HEIGHT &&
-				plogfont->lfQuality)
+		//if (freetype_init(psd)) {
+			if (plogfont && abs(plogfont->lfHeight) > FFMINAA_HEIGHT && plogfont->lfQuality)
 					fontattr |= MWTF_ANTIALIAS;
 
-			pfont = (PMWFONT)freetype_createfont(fontname, height,
-					fontattr);
+			pfont = (PMWFONT)freetype_createfont(fontname, height, width, fontattr);
 			if(pfont) {
 				/* FIXME kaffe kluge*/
 				pfont->fontattr |= MWTF_FREETYPE;
 				return pfont;
 			}
 			if (fontclass != MWLF_CLASS_ANY)
-	 			EPRINTF("freetype_createfont: %s,%d not found\n",
-					fontname, height);
-		}
+	 			EPRINTF("freetype_createfont: %s,%d not found\n", fontname, height);
+		//}
   	}
 #endif
 
 #if HAVE_FREETYPE_2_SUPPORT
  	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_FREETYPE) {
-		if (freetype_init(psd)) {
+		//if (freetype_init(psd)) {
 			/* FIXME auto antialias for height > 14 for kaffe*/
-			if (plogfont && plogfont->lfHeight > 14 &&
-				plogfont->lfQuality)
+			if (plogfont && abs(plogfont->lfHeight) > 14 && plogfont->lfQuality)
 					fontattr |= MWTF_ANTIALIAS;
 
-			pfont = (PMWFONT)freetype2_createfont(fontname, height,
-					fontattr);
+			pfont = (PMWFONT)freetype2_createfont(fontname, height, width, fontattr);
 			if(pfont) {
+				DPRINTF("freetype_createfont: using font %s\n", fontname);
 				/* FIXME kaffe kluge*/
 				pfont->fontattr |= MWTF_FREETYPE;
 				return pfont;
 			}
 			if (fontclass != MWLF_CLASS_ANY)
-				EPRINTF("freetype2_createfont: %s,%d not found\n",
-					fontname, height);
-		}
+				EPRINTF("freetype2_createfont: %s,%d not found\n", fontname, height);
+		//}
   	}
 #endif
 
 #if HAVE_T1LIB_SUPPORT
 	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_T1LIB) {
-		if (t1lib_init(psd)) {
-			pfont = (PMWFONT)t1lib_createfont(fontname, height,
-					fontattr);
+		//if (t1lib_init(psd)) {
+			pfont = (PMWFONT)t1lib_createfont(fontname, height, width, fontattr);
 			if(pfont)
 				return pfont;
 			if (fontclass != MWLF_CLASS_ANY)
-				EPRINTF("t1lib_createfont: %s,%d not found\n",
-					fontname, height);
-		}
+				EPRINTF("t1lib_createfont: %s,%d not found\n", fontname, height);
+		//}
   	}
 #endif
 
 #if HAVE_HZK_SUPPORT
 	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_HZK) {
-		/* Make sure the library is initialized */
-		if (hzk_init(psd)) {
-			pfont = (PMWFONT)hzk_createfont(fontname, height, fontattr);
+		//if (hzk_init(psd)) {
+			pfont = (PMWFONT)hzk_createfont(fontname, height, width, fontattr);
 			if(pfont)		
 				return pfont;
 			if (fontclass != MWLF_CLASS_ANY)
 				EPRINTF("hzk_createfont: %s,%d not found\n",
 					fontname, height);
-		}
+		//}
 	}
 #endif
 
 #if HAVE_EUCJP_SUPPORT
  	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_MGL) {
-		pfont = (PMWFONT)eucjp_createfont(fontname, height, fontattr);
+		pfont = (PMWFONT)eucjp_createfont(fontname, height, width, fontattr);
 		if (pfont) {
 			DPRINTF("eujcp_createfont: using font %s\n", fontname);
 			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("eucjp_createfont: %s,%d not found\n",
-				fontname, height);
+			EPRINTF("eucjp_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
 	if (fontclass == MWLF_CLASS_ANY) {
-		EPRINTF("createfont: %s,%d not found\n",
-				fontname, height);
+		EPRINTF("createfont: %s,%d not found\n", fontname, height);
 		EPRINTF("  (tried "
 			"builtin_createfont"
 #ifdef HAVE_FNT_SUPPORT
@@ -347,15 +341,12 @@ GdCreateFont(PSD psd, const char *name, MWCOORD height,
  * @return         The old size.
  */
 MWCOORD
-GdSetFontSize(PMWFONT pfont, MWCOORD fontsize)
+GdSetFontSize(PMWFONT pfont, MWCOORD height, MWCOORD width)
 {
-	MWCOORD oldfontsize = pfont->fontsize;
-	pfont->fontsize = fontsize;
-
 	if (pfont->fontprocs->SetFontSize)
-	    pfont->fontprocs->SetFontSize(pfont, fontsize);
+	    return pfont->fontprocs->SetFontSize(pfont, height, width);
 
-	return oldfontsize;
+	return 0;
 }
 
 /**
@@ -389,15 +380,10 @@ GdSetFontRotation(PMWFONT pfont, int tenthdegrees)
 int
 GdSetFontAttr(PMWFONT pfont, int setflags, int clrflags)
 {
-	MWCOORD	oldattr = pfont->fontattr;
-
-	pfont->fontattr &= ~clrflags;
-	pfont->fontattr |= setflags;
-
 	if (pfont->fontprocs->SetFontAttr)
-	    pfont->fontprocs->SetFontAttr(pfont, setflags, clrflags);
+	    return pfont->fontprocs->SetFontAttr(pfont, setflags, clrflags);
 	
-	return oldattr;
+	return 0;
 }
 
 /**
@@ -677,7 +663,7 @@ gen16_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 }
 #endif /* HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT*/
 
-#if HAVE_T1LIB_SUPPORT | HAVE_FREETYPE_SUPPORT
+#if HAVE_FREETYPE_SUPPORT
 /*
  * Produce blend table from src and dst based on passed alpha table
  * Used because we don't quite yet have GdArea with alphablending,
@@ -769,7 +755,7 @@ alphablend(PSD psd, OUTPIXELVAL *out, MWPIXELVAL src, MWPIXELVAL dst,
 	  	}
 	}
 }
-#endif /*HAVE_T1LIB_SUPPORT | HAVE_FREETYPE_SUPPORT*/
+#endif /*HAVE_FREETYPE_SUPPORT*/
 
 #if !HAVE_FREETYPE_SUPPORT
 int
@@ -1046,8 +1032,8 @@ GdGetTextSize(PMWFONT pfont, const void *str, int cc, MWCOORD *pwidth,
  * @return       New font, or NULL on error.
  */
 PMWFONT
-GdCreateFontFromBuffer(PSD psd, const unsigned char *buffer,
-		       unsigned length, const char *format, MWCOORD height)
+GdCreateFontFromBuffer(PSD psd, const unsigned char *buffer, unsigned length,
+	const char *format, MWCOORD height, MWCOORD width)
 {
 	PMWFONT pfont = NULL;
 
@@ -1062,8 +1048,8 @@ GdCreateFontFromBuffer(PSD psd, const unsigned char *buffer,
 	 * extension - e.g. TTF, PFR, ...)
 	 */
 
-	if (freetype_init(psd))
-		pfont = (PMWFONT)freetype2_createfontfrombuffer(buffer, length, height);
+	//if (freetype_init(psd))
+		pfont = (PMWFONT)freetype2_createfontfrombuffer(buffer, length, height, width);
 	if (!pfont)
 		EPRINTF("GdCreateFontFromBuffer: create failed.\n");
 #endif
@@ -1079,11 +1065,11 @@ GdCreateFontFromBuffer(PSD psd, const unsigned char *buffer,
  * @return         New font.
  */
 PMWFONT
-GdDuplicateFont(PSD psd, PMWFONT psrcfont, MWCOORD fontsize)
+GdDuplicateFont(PSD psd, PMWFONT psrcfont, MWCOORD height, MWCOORD width)
 {
 #if HAVE_FREETYPE_2_SUPPORT
 	if (psrcfont->fontprocs->Duplicate)
-		return psrcfont->fontprocs->Duplicate(psrcfont, fontsize);
+		return psrcfont->fontprocs->Duplicate(psrcfont, height, width);
 #endif
 	return psrcfont;
 }
diff --git a/src/engine/devfont.h b/src/engine/devfont.h
index 101135a..8f2bc24 100644
--- a/src/engine/devfont.h
+++ b/src/engine/devfont.h
@@ -7,62 +7,38 @@
  * Font engine header file
  */
 
-/* settable parameters*/
-#define T1LIB_USE_AA_HIGH
-
-#ifdef T1LIB_USE_AA_HIGH
-typedef unsigned long	OUTPIXELVAL;
-#else
-typedef MWPIXELVAL	OUTPIXELVAL;
-#endif
-
-#if (UNIX | DOS_DJGPP)
-#define strcmpi	strcasecmp
-#endif
-
-/* public utility routines*/
-void alphablend(PSD psd, OUTPIXELVAL *out, MWPIXELVAL src, MWPIXELVAL dst,
-	unsigned char *alpha, int count);
-
 /* font engine entry points*/
-PMWCOREFONT fnt_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT fnt_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 
 #if HAVE_T1LIB_SUPPORT
-typedef struct MWT1LIBFONT 	*PMWT1LIBFONT;
-int  t1lib_init(PSD psd);
-PMWT1LIBFONT t1lib_createfont(const char *name, MWCOORD height,int attr);
-#endif
-
-#if HAVE_FREETYPE_SUPPORT
-typedef struct MWFREETYPEFONT 	*PMWFREETYPEFONT;
-int  freetype_init(PSD psd);
-PMWFREETYPEFONT freetype_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT t1lib_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 #endif
 
 #if HAVE_FREETYPE_2_SUPPORT
-typedef struct MWFREETYPE2FONT_STRUCT MWFREETYPE2FONT;
-typedef MWFREETYPE2FONT *PMWFREETYPE2FONT;
-int freetype_init(PSD psd);
-PMWFREETYPE2FONT freetype2_createfont(const char *name,MWCOORD height,int attr);
-PMWFREETYPE2FONT freetype2_createfontfrombuffer(const unsigned char *buffer,
-						unsigned length,
-						MWCOORD height);
+PMWFONT freetype2_createfont(const char *name,MWCOORD height,MWCOORD width,int attr);
+PMWFONT freetype2_createfontfrombuffer(const unsigned char *buffer, unsigned length,
+	MWCOORD height, MWCOORD width);
 #endif
 
 #if HAVE_PCF_SUPPORT
-PMWCOREFONT pcf_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT pcf_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 #endif
 
 #if HAVE_HZK_SUPPORT
-typedef struct MWHZKFONT 	*PMWHZKFONT;
-int  hzk_init(PSD psd);
-PMWHZKFONT hzk_createfont(const char *name, MWCOORD height, int fontattr);
+PMWFONT hzk_createfont(const char *name, MWCOORD height, MWCOORD width, int fontattr);
 int UC16_to_GB(const unsigned char *uc16, int cc, unsigned char *ascii);
 #endif
 
 #if HAVE_EUCJP_SUPPORT
-typedef struct MWEUCJPFONT	*PMWEUCJPFONT;
-PMWEUCJPFONT eucjp_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT eucjp_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
+#endif
+
+#if HAVE_FREETYPE_SUPPORT		// DEPRECATED
+typedef MWPIXELVAL OUTPIXELVAL;
+void alphablend(PSD psd, OUTPIXELVAL *out, MWPIXELVAL src, MWPIXELVAL dst,
+	unsigned char *alpha, int count);
+int  freetype_init(PSD psd);
+PMWFONT freetype_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 #endif
 
 #if FONTMAPPER
@@ -71,7 +47,7 @@ int select_font(const PMWLOGFONT plogfont, const char **physname);
 #endif
 
 /* DBCS routines*/
-void dbcs_gettextbits(PMWFONT pfont, unsigned int ch, MWTEXTFLAGS flags,
+void dbcs_gettextbits(PMWFONT pfont, int ch, MWTEXTFLAGS flags,
 	const MWIMAGEBITS **retmap, MWCOORD *pwidth, MWCOORD *pheight,
 	MWCOORD *pbase);
 void dbcs_gettextsize(PMWFONT pfont, const unsigned short *str, int cc, MWTEXTFLAGS flags,
diff --git a/src/engine/devopen.c b/src/engine/devopen.c
index 406be09..2eede7c 100644
--- a/src/engine/devopen.c
+++ b/src/engine/devopen.c
@@ -139,7 +139,7 @@ GdOpenScreen(void)
 	GdSetBackgroundColor(psd, MWRGB(0, 0, 0));		/* BLACK*/
 	GdSetUseBackground(TRUE);
 	/* select first builtin font (usually MWFONT_SYSTEM_VAR)*/
-	GdSetFont(GdCreateFont(psd, NULL, 0, NULL));
+	GdSetFont(GdCreateFont(psd, NULL, 0, 0, NULL));
 
 	GdSetDash(0, 0);  /* No dashing to start */
 	GdSetStippleBitmap(0,0,0);  /* No stipple to start */
diff --git a/src/engine/font_dbcs.c b/src/engine/font_dbcs.c
index ee46326..e6910d2 100644
--- a/src/engine/font_dbcs.c
+++ b/src/engine/font_dbcs.c
@@ -12,11 +12,11 @@
 #include <stdlib.h>
 #include "device.h"
 #include "devfont.h"
-#include "../drivers/genfont.h"
+#include "genfont.h"
 
 #if HAVE_BIG5_SUPPORT
 static void
-big5_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
+big5_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
 	unsigned int	CH = ch >> 8;
@@ -60,7 +60,7 @@ big5_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
 
 #if HAVE_GB2312_SUPPORT
 static void
-euccn_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
+euccn_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
 	unsigned int	CH = ch >> 8;
@@ -89,7 +89,7 @@ euccn_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
 
 #if HAVE_JISX0213_SUPPORT
 static void
-jis_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
+jis_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
 	unsigned int	CH = ch >> 8;
@@ -137,7 +137,7 @@ jis_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
 
 #if HAVE_KSC5601_SUPPORT
 static void
-euckr_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
+euckr_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
 #ifdef BIG_ENDIAN
@@ -166,7 +166,7 @@ euckr_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
 #endif /* HAVE_KSC5601_SUPPORT*/
 
 void
-dbcs_gettextbits(PMWFONT pfont, unsigned int ch, MWTEXTFLAGS flags,
+dbcs_gettextbits(PMWFONT pfont, int ch, MWTEXTFLAGS flags,
 	const MWIMAGEBITS **retmap, MWCOORD *pwidth, MWCOORD *pheight,
 	MWCOORD *pbase)
 {
diff --git a/src/engine/font_eucjp.c b/src/engine/font_eucjp.c
index 4c5191b..bf4f1d2 100644
--- a/src/engine/font_eucjp.c
+++ b/src/engine/font_eucjp.c
@@ -19,11 +19,16 @@
 #endif
 #include "device.h"
 #include "devfont.h"
-#include "../drivers/genfont.h"
+#include "genfont.h"
+
+#ifndef EUCJP_FONT_DIR
+#define EUCJP_FONT_DIR	"fonts/japanese"	/* default MGLFONT .fnt font file directory*/
+#endif
 
 typedef struct MWEUCJPFONT {
 	PMWFONTPROCS fontprocs;	/* common hdr */
 	int fontsize;
+	int	fontwidth;
 	int fontrotation;
 	int fontattr;
 
@@ -37,9 +42,9 @@ typedef struct MWEUCJPFONT {
 	int abytes;
 	int fd;			/* file descriptor of font bitmap data */
 	char *font_base;
-} MWEUCJPFONT;
+} MWEUCJPFONT, *PMWEUCJPFONT;
 
-PMWEUCJPFONT eucjp_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT eucjp_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 static MWBOOL eucjp_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
 static void eucjp_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 		MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase);
@@ -51,6 +56,8 @@ static void eucjp_destroyfont(PMWFONT pfont);
 /* handling routines for MWEUCJPFONT*/
 static MWFONTPROCS eucjp_procs = {
 	MWTF_UC16,		/* routines expect unicode index*/
+	NULL,			/* init*/
+	eucjp_createfont,
 	eucjp_getfontinfo,
 	eucjp_gettextsize,
 	eucjp_gettextbits,
@@ -59,7 +66,7 @@ static MWFONTPROCS eucjp_procs = {
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
-	NULL,			/* duplicate not yet implemented */
+	NULL			/* duplicate*/
 };
 
 /*
@@ -67,8 +74,8 @@ static MWFONTPROCS eucjp_procs = {
  *
  * Many thanks to MGL fontkit/mgl_fontinfo.c
  */
-PMWEUCJPFONT
-eucjp_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT
+eucjp_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWEUCJPFONT pf;
 	int fd, r;
@@ -84,8 +91,7 @@ eucjp_createfont(const char *name, MWCOORD height, int attr)
 
 	fd = open(name, O_RDONLY);
 	if (fd < 0) {
-		strcpy(fname, EUCJP_FONT_DIR "/");
-		strcpy(fname + sizeof(EUCJP_FONT_DIR), name);
+		sprintf(fname, "%s/%s", EUCJP_FONT_DIR, name);
 		fd = open(fname, O_RDONLY);
 	}
 	if (fd < 0)
@@ -124,15 +130,14 @@ eucjp_createfont(const char *name, MWCOORD height, int attr)
 		printf("FONT_EUCJP: Not MGL font file(filesize doesn't match).\n");
 		goto EUCJP_FAIL;
 	}
-	pf->font_base =
-		(char *) mmap((caddr_t) 0, pf->koffset + pf->kbytes * 8064,
+	pf->font_base = (char *)mmap((caddr_t) 0, pf->koffset + pf->kbytes * 8064,
 			      PROT_READ, MAP_SHARED | MAP_FILE, fd, 0);
 	if (pf->font_base == MAP_FAILED) {
 		printf("FONT_EUCJP: Can't mmap font data.\n");
 		goto EUCJP_FAIL;
 	}
 
-	return pf;
+	return (PMWFONT)pf;
 
 EUCJP_FAIL:
 	free(pf);
diff --git a/src/engine/font_fnt.c b/src/engine/font_fnt.c
index dd23b2f..a995d34 100644
--- a/src/engine/font_fnt.c
+++ b/src/engine/font_fnt.c
@@ -1,38 +1,42 @@
 /* 
  * Loadable FNT font engine for Microwindows
- * Copyright (c) 2003, 2005 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 2003, 2005, 2010 Greg Haerr <greg@censoft.com>
  *
- * Load a .fnt (Microwindows native) binary font, store in incore format.
+ * Load a .fnt/.fnt.gz (Microwindows native) binary font, store in incore format.
  */
 #include <stdio.h>
 #include <string.h>
-#include "swap.h"
 #include "device.h"
 #include "devfont.h"
-#include "../drivers/genfont.h"
+#include "genfont.h"
+
+/* configurable defaults*/
+#ifndef FNT_FONT_DIR
+#define FNT_FONT_DIR	"fonts/fnt"		/* default .fnt file location*/
+#endif
 
 /*
  * .fnt loadable font file format definition
  *
  * format                     len	description
  * -------------------------  ----	------------------------------
- * UCHAR version[4]		4	magic number and version bytes
- * UCHAR name[64]	       64	font name, space padded
+ * UCHAR version[4]				4	magic number and version bytes
+ * UCHAR name[64]	       		64	font name, space padded
  * UCHAR copyright[256]	      256	copyright info, space padded
- * USHORT maxwidth		2	font max width in pixels
- * USHORT height		2	font height in pixels
- * USHORT ascent		2	font ascent (baseline) in pixels
+ * USHORT maxwidth				2	font max width in pixels
+ * USHORT height				2	font height in pixels
+ * USHORT ascent				2	font ascent (baseline) in pixels
  * USHORT pad                   2       unused, pad to 32-bit boundary
- * ULONG firstchar		4	first character code in font
- * ULONG defaultchar		4	default character code in font
- * ULONG size			4	# characters in font
- * ULONG nbits			4	# words imagebits data in file
- * ULONG noffset		4	# longs offset data in file
- * ULONG nwidth			4	# bytes width data in file
- * MWIMAGEBITS bits	  nbits*2	image bits variable data
+ * ULONG firstchar				4	first character code in font
+ * ULONG defaultchar			4	default character code in font
+ * ULONG size					4	# characters in font
+ * ULONG nbits					4	# words imagebits data in file
+ * ULONG noffset				4	# longs offset data in file
+ * ULONG nwidth					4	# bytes width data in file
+ * MWIMAGEBITS bits	  			nbits*2	image bits variable data
  * [MWIMAGEBITS padded to 32-bit boundary]
- * ULONG offset         noffset*4	offset variable data
- * UCHAR width		 nwidth*1	width variable data
+ * ULONG offset         		noffset*4	offset variable data
+ * UCHAR width		 			nwidth*1	width variable data
  */
 
 /* loadable font magic and version #*/
@@ -57,26 +61,35 @@
 #endif
 
 /* Handling routines for FNT fonts, use MWCOREFONT structure */
+PMWFONT fnt_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 static void fnt_unloadfont(PMWFONT font);
 static PMWCFONT fnt_load_font(const char *path);
 
 /* these procs used when font ASCII indexed*/
-static MWFONTPROCS fnt_fontprocs = {
+MWFONTPROCS fnt_fontprocs = {
 	MWTF_ASCII,		/* routines expect ascii */
+	NULL,			/* init*/
+	fnt_createfont,
 	gen_getfontinfo,
 	gen_gettextsize,
 	gen_gettextbits,
 	fnt_unloadfont,
+#if STANDALONE
+	gen16_drawtext, //FIXME
+#else
 	corefont_drawtext,
+#endif
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
-	NULL,			/* duplicate not supported */
+	NULL			/* duplicate not supported */
 };
 
 /* these procs used when font requires UC16 index*/
 static MWFONTPROCS fnt_fontprocs16 = {
 	MWTF_UC16,		/* large font, expect UC16*/
+	NULL,			/* init*/
+	fnt_createfont,
 	gen_getfontinfo,
 	gen16_gettextsize,
 	gen_gettextbits,
@@ -85,11 +98,12 @@ static MWFONTPROCS fnt_fontprocs16 = {
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
-	NULL,			/* duplicate not supported */
+	NULL			/* duplicate not supported */
 };
 
-PMWCOREFONT
-fnt_createfont(const char *name, MWCOORD height, int attr)
+/* load font and allocate MWCOREFONT structure*/
+PMWFONT
+fnt_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWCOREFONT	pf;
 	PMWCFONT	cfont;
@@ -106,14 +120,13 @@ fnt_createfont(const char *name, MWCOORD height, int attr)
 	}
 
 	/* determine if unicode-16 indexing required*/
-	uc16 = cfont->firstchar > 255 || 
-		(cfont->firstchar + cfont->size) > 255;
+	uc16 = cfont->firstchar > 255 || (cfont->firstchar + cfont->size) > 255;
 	pf->fontprocs = uc16? &fnt_fontprocs16: &fnt_fontprocs;
 
 	pf->fontsize = pf->fontrotation = pf->fontattr = 0;
 	pf->name = "FNT";
 	pf->cfont = cfont;
-	return pf;
+	return (PMWFONT)pf;
 }
 
 void
@@ -248,10 +261,8 @@ fnt_load_font(const char *path)
 	char fname[256];
 
 	ifp = FOPEN(path, "rb");
-
 	if (!ifp) {
-		strcpy(fname, FNT_FONT_DIR "/");
-		strcpy(fname + sizeof(FNT_FONT_DIR), path);
+		sprintf(fname, "%s/%s", FNT_FONT_DIR, path);
 		ifp = FOPEN(fname, "rb");
 		
 		/* Try to grab it from the MWFONTDIR directory */
@@ -260,7 +271,7 @@ fnt_load_font(const char *path)
 			if (env) {
 				sprintf(fname, "%s/%s", env, path);
 				
-				printf("Trying to get font from %s\n", fname);
+				DPRINTF("Trying to get font from %s\n", fname);
 				ifp = FOPEN(fname, "rb");
 			}
 		}
@@ -270,7 +281,6 @@ fnt_load_font(const char *path)
 		return NULL;
 
 	/* read magic and version #*/
-	memset(version, 0, sizeof(version));
 	if (READSTR(ifp, version, 4) != 4)
 		goto errout;
 	if (strcmp(version, VERSION) != 0)
@@ -287,7 +297,6 @@ fnt_load_font(const char *path)
 	if (!pf->name)
 		goto errout;
 	strcpy(pf->name, name);
-
 	/* copyright, not currently stored*/
 	if (READSTRPAD(ifp, copyright, 256) != 256)
 		goto errout;
@@ -345,10 +354,12 @@ fnt_load_font(const char *path)
 	for (i=0; i<nbits; ++i)
 		if (!READSHORT(ifp, (unsigned short *)&pf->bits[i]))
 			goto errout;
+
 	/* pad to longword boundary*/
-	if (FSEEK(ifp, 0, SEEK_CUR) & 02)
+	if (nbits & 01)
 		if (!READSHORT(ifp, &pad))
 			goto errout;
+
 	if (noffset)
 		for (i=0; i<pf->size; ++i)
 			if (!READLONG(ifp, (uint32_t *)&pf->offset[i]))
diff --git a/src/engine/font_freetype.c b/src/engine/font_freetype.c
index b4b5bc1..502f743 100644
--- a/src/engine/font_freetype.c
+++ b/src/engine/font_freetype.c
@@ -24,10 +24,11 @@
 #endif
 
 typedef struct MWFREETYPEFONT {
-	PMWFONTPROCS	fontprocs;	/* common hdr*/
+	PMWFONTPROCS fontprocs;	/* common hdr*/
 	MWCOORD		fontsize;
-	int		fontrotation;
-	int		fontattr;		
+	MWCOORD		fontwidth;
+	int			fontrotation;
+	int			fontattr;		
 
 	TT_Face 	face;		/* freetype stuff*/
 	TT_Instance	instance;
@@ -40,9 +41,8 @@ typedef struct MWFREETYPEFONT {
 	short 		last_pen_pos;
 } MWFREETYPEFONT;
 
-int  freetype_init(PSD psd);
-PMWFREETYPEFONT freetype_createfont(const char *name, MWCOORD height, int attr);
-
+static int  freetype_init(PSD psd);
+PMWFONT freetype_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 static MWBOOL freetype_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
 static void freetype_gettextsize(PMWFONT pfont, const void *text, int cc,
 		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
@@ -50,12 +50,15 @@ static void freetype_gettextsize(PMWFONT pfont, const void *text, int cc,
 static void freetype_destroyfont(PMWFONT pfont);
 static void freetype_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		const void *text, int cc, MWTEXTFLAGS flags);
-static void freetype_setfontsize(PMWFONT pfont, MWCOORD fontsize);
+static int freetype_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width);
 static void freetype_setfontrotation(PMWFONT pfont, int tenthdegrees);
+static int freetype_setfontattr(PMWFONT pfont, int setflags, int clrflags);
 		
 /* handling routines for MWFREETYPEFONT*/
 static MWFONTPROCS freetype_procs = {
 	MWTF_UC16,			/* routines expect unicode 16*/
+	freetype_init,
+	freetype_createfont,
 	freetype_getfontinfo,
 	freetype_gettextsize,
 	NULL,				/* gettextbits*/
@@ -63,8 +66,8 @@ static MWFONTPROCS freetype_procs = {
 	freetype_drawtext,
 	freetype_setfontsize,
 	freetype_setfontrotation,
-	NULL,				/* setfontattr*/
-	NULL,				/* duplicate not yet implemented */
+	freetype_setfontattr,
+	NULL				/* duplicate*/
 };
 
 static TT_Engine 	engine;		/* THE ONLY freetype engine */
@@ -75,7 +78,7 @@ extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
 extern MWBOOL gr_usebg;
 
-int
+static int
 freetype_init(PSD psd)
 {
 	static int inited = 0;
@@ -84,9 +87,8 @@ freetype_init(PSD psd)
 		return 1;
 	
 	/* Init freetype library */
-	if (TT_Init_FreeType (&engine) != TT_Err_Ok) {
+	if (TT_Init_FreeType (&engine) != TT_Err_Ok)
 		return 0;
-	}
 
 	/* Init kerning extension */
 	if (TT_Init_Kerning_Extension (engine) != TT_Err_Ok)
@@ -96,8 +98,8 @@ freetype_init(PSD psd)
 	return 1;
 }
 
-PMWFREETYPEFONT
-freetype_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT
+freetype_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWFREETYPEFONT 	pf;
 	unsigned short 		i, n;
@@ -106,6 +108,9 @@ freetype_createfont(const char *name, MWCOORD height, int attr)
 	char *			p;
 	char			fontname[128];
 
+	if (!freetype_init(psd))
+		return NULL;
+
 	/* check for pathname prefix*/
 	if (strchr(name, '/') != NULL)
 		strcpy(fontname, name);
@@ -196,11 +201,11 @@ freetype_createfont(const char *name, MWCOORD height, int attr)
 		goto out;
 	}
 	
-	GdSetFontSize((PMWFONT)pf, height);
-	GdSetFontRotation((PMWFONT)pf, 0);
-	GdSetFontAttr((PMWFONT)pf, attr, 0);
+	pf->fontprocs->SetFontSize((PMWFONT)pf, height, width);
+	pf->fontprocs->SetFontRotation((PMWFONT)pf, 0);
+	pf->fontprocs->SetFontAttr((PMWFONT)pf, 0, 0);
 
-	return pf;
+	return (PMWFONT)pf;
 
 out:
 	free(pf);
@@ -624,25 +629,28 @@ freetype_destroyfont(PMWFONT pfont)
 	free(pf);
 }
 
-static void
-freetype_setfontsize(PMWFONT pfont, MWCOORD fontsize)
+static int
+freetype_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width)
 {
 	PMWFREETYPEFONT	pf = (PMWFREETYPEFONT)pfont;
+	MWCOORD oldsize = pf->fontsize;
 	
-	pf->fontsize = fontsize;
+	pf->fontsize = height;
+	pf->fontwidth = width;
 
 	/* allow create font with height=0*/
-	if (!fontsize)
-		return;
+	if (!height)
+		return oldsize;
 	
 	/* We want real pixel sizes ... not points ...*/
-	TT_Set_Instance_PixelSizes( pf->instance, pf->fontsize,
-                                pf->fontsize, pf->fontsize * 64 );
+	TT_Set_Instance_PixelSizes( pf->instance, height, width, pf->fontsize * 64 );
 #if 0
 	/* set charsize (convert to points for freetype)*/
 	TT_Set_Instance_CharSize (pf->instance,
 		((pf->fontsize * 72 + 96/2) / 96) * 64);
 #endif
+
+	return oldsize;
 }
 
 static void
@@ -663,6 +671,18 @@ freetype_setfontrotation(PMWFONT pfont, int tenthdegrees)
 	pf->matrix.xy = -pf->matrix.yx;
 }
 
+static int
+freetype_setfontattr(PMWFONT pfont, int setflags, int clrflags)
+{
+	PMWFREETYPEFONT pf = (PMWFREETYPEFONT)pfont;
+	int oldattr = pf->fontattr;
+
+	pfont->fontattr &= ~clrflags;
+	pfont->fontattr |= setflags;
+
+	return oldattr;
+}
+
 /* FIXME: this routine should work for all font renderers...*/
 int
 GdGetTextSizeEx(PMWFONT pfont, const void *str, int cc,int nMaxExtent,
@@ -865,6 +885,8 @@ GdGetFontList(MWFONTLIST ***fonts, int *numfonts)
 	MWFONTLIST **list;
 	
 
+	//FIXME call full init here
+
 	if (TT_Err_Ok != TT_Init_FreeType(&engine)) {
 		printf("Unable to initialize freetype\n");
 		*numfonts = -1;
diff --git a/src/engine/font_freetype.cache.c b/src/engine/font_freetype.cache.c
index 63223a8..1304622 100644
--- a/src/engine/font_freetype.cache.c
+++ b/src/engine/font_freetype.cache.c
@@ -319,6 +319,7 @@ typedef struct mwfreetypefontcache {
 typedef struct MWFREETYPEFONT {
 	PMWFONTPROCS	fontprocs;	/* common hdr*/
 	MWCOORD		fontsize;
+	MWCOORD		fontwidth;
 	int		fontrotation;
 	int		fontattr;		
 
@@ -336,9 +337,8 @@ typedef struct MWFREETYPEFONT {
 #endif
 } MWFREETYPEFONT;
 
-int  freetype_init(PSD psd);
-PMWFREETYPEFONT freetype_createfont(const char *name, MWCOORD height, int attr);
-
+static int  freetype_init(PSD psd);
+PWMFONT freetype_createfont(const char *name, MWCOORD height, width, int attr);
 static MWBOOL freetype_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
 static void freetype_gettextsize(PMWFONT pfont, const void *text, int cc,
 		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
@@ -346,12 +346,15 @@ static void freetype_gettextsize(PMWFONT pfont, const void *text, int cc,
 static void freetype_destroyfont(PMWFONT pfont);
 static void freetype_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		const void *text, int cc, MWTEXTFLAGS flags);
-static void freetype_setfontsize(PMWFONT pfont, MWCOORD fontsize);
+static int freetype_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width);
 static void freetype_setfontrotation(PMWFONT pfont, int tenthdegrees);
+static int freetype_setfontattr(PMWFONT pfont, int setflags, int clrflags);
 		
 /* handling routines for MWFREETYPEFONT*/
 static MWFONTPROCS freetype_procs = {
 	MWTF_UC16,			/* routines expect unicode 16*/
+	freetype_init,
+	freetype_createfont,
 	freetype_getfontinfo,
 	freetype_gettextsize,
 	NULL,				/* gettextbits*/
@@ -359,8 +362,8 @@ static MWFONTPROCS freetype_procs = {
 	freetype_drawtext,
 	freetype_setfontsize,
 	freetype_setfontrotation,
-	NULL,				/* setfontattr*/
-	NULL,				/* duplicate not yet implemented */
+	freetype_setfontattr,
+	NULL				/* duplicate*/
 };
 
 static TT_Engine 	engine;		/* THE ONLY freetype engine */
@@ -392,8 +395,8 @@ freetype_init(PSD psd)
 	return 1;
 }
 
-PMWFREETYPEFONT
-freetype_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT
+freetype_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWFREETYPEFONT 	pf;
 	unsigned short 		i, n;
@@ -492,11 +495,11 @@ freetype_createfont(const char *name, MWCOORD height, int attr)
 		goto out;
 	}
 	
-	GdSetFontSize((PMWFONT)pf, height);
-	GdSetFontRotation((PMWFONT)pf, 0);
-	GdSetFontAttr((PMWFONT)pf, attr, 0);
+	pf->fontprocs->SetFontSize((PMWFONT)pf, height, width);
+	pf->fontprocs->SetFontRotation((PMWFONT)pf, 0);
+	pf->fontprocs->SetFontAttr((PMWFONT)pf, 0, 0);
 
-	return pf;
+	return (PMWFONT)pf;
 
 out:
 	free(pf);
@@ -993,25 +996,28 @@ freetype_destroyfont(PMWFONT pfont)
 	free(pf);
 }
 
-static void
-freetype_setfontsize(PMWFONT pfont, MWCOORD fontsize)
+static int
+freetype_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width)
 {
 	PMWFREETYPEFONT	pf = (PMWFREETYPEFONT)pfont;
+	MWCOORD oldsize = pf->fontsize;
 	
-	pf->fontsize = fontsize;
+	pf->fontsize = height;
+	pf->fontwidth = width;
 	
 	/* allow create font with height=0*/
-	if (!fontsize)
+	if (!height)
 		return;
 
 	/* We want real pixel sizes ... not points ...*/
-	TT_Set_Instance_PixelSizes( pf->instance, pf->fontsize,
-                                pf->fontsize, pf->fontsize * 64 );
+	TT_Set_Instance_PixelSizes( pf->instance, pf->fontsize, pf->fontsize, pf->fontsize * 64 );
 #if 0
 	/* set charsize (convert to points for freetype)*/
 	TT_Set_Instance_CharSize (pf->instance,
 		((pf->fontsize * 72 + 96/2) / 96) * 64);
 #endif
+
+	return oldsize;
 }
 
 static void
@@ -1032,6 +1038,18 @@ freetype_setfontrotation(PMWFONT pfont, int tenthdegrees)
 	pf->matrix.xy = -pf->matrix.yx;
 }
 
+static int
+freetype_setfontattr(PMWFONT pfont, int setflags, int clrflags)
+{
+	PMWFREETYPEFONT pf = (PMWFREETYPEFONT)pfont;
+	int oldattr = pf->fontattr;
+
+	pfont->fontattr &= ~clrflags;
+	pfont->fontattr |= setflags;
+
+	return oldattr;
+}
+
 /* FIXME: this routine should work for all font renderers...*/
 int
 GdGetTextSizeEx(PMWFONT pfont, const void *str, int cc,int nMaxExtent,
diff --git a/src/engine/font_freetype2.c b/src/engine/font_freetype2.c
index ff80fd0..babf482 100644
--- a/src/engine/font_freetype2.c
+++ b/src/engine/font_freetype2.c
@@ -3,7 +3,8 @@
  *
  * Originally written by Koninklijke Philips Electronics N.V.
  *
- * (Loosly) Based on the FreeType 1.x driver, font_freetype.c.
+ * (Loosely) Based on the FreeType 1.x driver, font_freetype.c.
+ * Copyright (c) 2010 Greg Haerr <greg@censoft.com>
  *
  * Portions contributed by Koninklijke Philips Electronics N.V.
  * These portions are Copyright 2002 Koninklijke Philips Electronics
@@ -26,6 +27,7 @@
  * 2.1.3 - works.
  * 2.3.5 - works, internally forces no cache option, needs porting of
  *	   missing 'font' member in FTC_ImageTypeReq struct.
+ * 2.3.9 - works and tested with caching
  */
 
 /*#define NDEBUG*/
@@ -34,11 +36,8 @@
 #include <string.h>
 #include <assert.h>
 #include <string.h>
-
 #include <dirent.h>
-
 #include "device.h"
-
 #include "devfont.h"
 
 #if (UNIX | DOS_DJGPP)
@@ -50,6 +49,14 @@ extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
 extern MWBOOL gr_usebg;
 
+#if STANDALONE
+typedef uint32_t COLORVAL;
+COLORVAL winsetfgcolor(PSD psd, COLORVAL color);		// FIXME kluge decls
+void winfillrect(PSD psd, int x, int y, int w, int h);
+#define GdSetForegroundColor	winsetfgcolor
+#define GdFillRect				winfillrect
+#endif
+
 /* **************************************************************************/
 /* FreeType 2.x                                                             */
 /* **************************************************************************/
@@ -59,7 +66,14 @@ extern MWBOOL gr_usebg;
 #include FT_TRIGONOMETRY_H
 #include FT_GLYPH_H
 
+/* configurable defaults*/
 #define FILL_BACKGROUND_ON_USEBG	1	/* fill background when usebg TRUE*/
+#define FACE_CACHE_MAX		3			/* Faces*/
+#define SIZES_CACHE_MAX		5			/* Sizes*/
+#define CACHE_SIZE			(512*1024)	/* Bytes - 512K*/
+#ifndef FREETYPE_FONT_DIR
+#define FREETYPE_FONT_DIR "fonts/truetype"		/* default truetype font directory*/
+#endif
 
 /* Checking FreeType version numbers */
 
@@ -99,7 +113,6 @@ extern MWBOOL gr_usebg;
 #define HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(major,minor,patch) \
 	(FREETYPE_VERSION_NUMBER_SIMPLE >= SIMPLIFY_VERSION_NUMBER(major,minor,patch))
 
-
 /*
  * Enable the Freetype 2 font cache.  Only applicable if
  * FreeType 2 itself is enabled.
@@ -115,7 +128,6 @@ extern MWBOOL gr_usebg;
  */
 #define HAVE_FREETYPE_2_CACHE 1			/* added 'font' member explicitly for >= v2.3*/
 
-
 /*
  * Enable the Freetype 2 character map cache.  Only applicable if
  * FreeType 2 itself is enabled, and HAVE_FREETYPE_2_CACHE is also
@@ -131,14 +143,6 @@ extern MWBOOL gr_usebg;
  */
 #define HAVE_FREETYPE_2_CMAP_CACHE 0
 
-
-#ifndef FREETYPE_FONT_DIR
-/**
- * The default Freetype font directory.
- */
-#define FREETYPE_FONT_DIR "/usr/local/microwin/fonts"
-#endif
-
 #if HAVE_FREETYPE_2_CACHE
 # include FT_CACHE_H
 # include FT_CACHE_SMALL_BITMAPS_H
@@ -147,44 +151,32 @@ extern MWBOOL gr_usebg;
 # endif
 #endif
 
-/**
- * The Freetype 2 font directory.
- */
-static char *freetype2_font_dir;
-
-
 typedef struct freetype2_fontdata_ freetype2_fontdata;
 
-struct freetype2_fontdata_
-{
+struct freetype2_fontdata_ {
 	int isBuffer;
-	union
-	{
+	union {
 		char *filename;
-
-		struct
-		{
+		struct {
 			unsigned char *data;
 			unsigned length;
-		}
-		buffer;
-	}
-	data;
+		} buffer;
+	} data;
 	int refcount;		/* Currently only used for buffers, not files */
 #if HAVE_FREETYPE_2_CACHE
 	freetype2_fontdata *next;
 #endif
 };
 
-struct MWFREETYPE2FONT_STRUCT
-{
-	PMWFONTPROCS fontprocs;	/* common hdr */
+typedef struct {
+	/* common hdr */
+	PMWFONTPROCS fontprocs;
 	MWCOORD fontsize;
+	MWCOORD fontwidth;
 	int fontrotation;
 	int fontattr;
 
 	/* freetype stuff */
-
 	char *filename;		/* NULL if buffered */
 	freetype2_fontdata *faceid;	/* only used if HAVE_FREETYPE_2_CACHE or buffered. */
 #if HAVE_FREETYPE_2_CACHE
@@ -202,26 +194,30 @@ struct MWFREETYPE2FONT_STRUCT
 #endif
 	FT_Matrix matrix;
 
-};
+} MWFREETYPE2FONT, *PMWFREETYPE2FONT;
 
+PMWFONT freetype2_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
+static int freetype2_init(PSD psd);
 static MWBOOL freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
-static void freetype2_gettextsize(PMWFONT pfont, const void *text, int cc,
-		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
-		MWCOORD *pbase);
+void freetype2_gettextsize(PMWFONT pfont, const void *text, int cc,
+		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase);
+static int freetype2_setfontattr(PMWFONT pfont, int setflags, int clrflags);
 static void freetype2_destroyfont(PMWFONT pfont);
 static void freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		const void *text, int cc, MWTEXTFLAGS flags);
-static void freetype2_setfontsize(PMWFONT pfont, MWCOORD fontsize);
+static int freetype2_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width);
 static void freetype2_setfontrotation(PMWFONT pfont, int tenthdegrees);
-static void freetype2_setfontattr(PMWFONT pfont, int setflags, int clrflags);
-static PMWFONT freetype2_duplicate(PMWFONT psrcfont, MWCOORD fontsize);
-
+static PMWFONT freetype2_duplicate(PMWFONT psrcfont, MWCOORD height, MWCOORD width);
+static PMWFREETYPE2FONT freetype2_createfont_internal(freetype2_fontdata * faceid,
+		char *filename, MWCOORD height, MWCOORD width);
 
 /**
  * The virtual method table for FreeType 2 fonts (i.e. class MWFREETYPE2FONT).
  */
-static MWFONTPROCS freetype2_procs = {
+MWFONTPROCS freetype2_fontprocs = {
 	MWTF_UC16,		/* routines expect unicode 16 */
+	freetype2_init,
+	freetype2_createfont,
 	freetype2_getfontinfo,
 	freetype2_gettextsize,
 	NULL,			/* gettextbits */
@@ -230,19 +226,19 @@ static MWFONTPROCS freetype2_procs = {
 	freetype2_setfontsize,
 	freetype2_setfontrotation,
 	freetype2_setfontattr,
-	freetype2_duplicate,
+	freetype2_duplicate
 };
 
-
-static PMWFREETYPE2FONT
-freetype2_createfont_internal(freetype2_fontdata * faceid,
-			      char *filename, MWCOORD height);
-
 /**
  * The freetype library instance - a singleton.
  */
 static FT_Library freetype2_library = NULL;
 
+/**
+ * The default freetype font directory
+ */
+static char *freetype2_font_dir;
+
 #if HAVE_FREETYPE_2_CACHE
 /**
  * The Freetype 2 cache subsystem requires a 1-1 mapping
@@ -303,9 +299,8 @@ static FTC_CMapCache freetype2_cache_cmap;
  * @param aface FIXME
  */
 static FT_Error
-freetype2_face_requester(FTC_FaceID face_id,
-			 FT_Library library,
-			 FT_Pointer request_data, FT_Face * aface)
+freetype2_face_requester(FTC_FaceID face_id, FT_Library library,
+	FT_Pointer request_data, FT_Face * aface)
 {
 	freetype2_fontdata *fontdata = (freetype2_fontdata *) face_id;	// simple typecast
 
@@ -315,15 +310,12 @@ freetype2_face_requester(FTC_FaceID face_id,
 		unsigned char * buffer = fontdata->data.buffer.data;
 		unsigned length = fontdata->data.buffer.length;
 		/* DPRINTF("Font magic = '%c%c%c%c', len = %u @ freetype2_face_requester\n", 
-		   (char)buffer[0], (char)buffer[1],
-		   (char)buffer[2], (char)buffer[3],
-		   length); */
+		   (char)buffer[0], (char)buffer[1], (char)buffer[2], (char)buffer[3], length); */
 		assert(buffer);
 		return FT_New_Memory_Face(library, buffer, length, 0, aface);
 	} else {
 		char * filename = fontdata->data.filename;
-		/* DPRINTF("Loading font from file '%s' @ freetype2_face_requester\n", 
-		   filename); */
+		/* DPRINTF("Loading font from file '%s' @ freetype2_face_requester\n", filename); */
 		assert(filename);
 		return FT_New_Face(library, filename, 0, aface);
 	}
@@ -342,13 +334,10 @@ freetype2_face_requester(FTC_FaceID face_id,
  * @return      The glyph index.
  */
 #define LOOKUP_CHAR(pf_,face_,ch_) \
-	(FTC_CMapCache_Lookup(freetype2_cache_cmap, \
-	&((pf_)->cmapdesc), \
-	(ch_)))
+	(FTC_CMapCache_Lookup(freetype2_cache_cmap, &((pf_)->cmapdesc), (ch_)))
 
 #else
-#define LOOKUP_CHAR(pf_,face_,ch_) \
-	(FT_Get_Char_Index((face_), (ch_)))
+#define LOOKUP_CHAR(pf_,face_,ch_) (FT_Get_Char_Index((face_), (ch_)))
 #endif
 
 /**
@@ -358,15 +347,15 @@ freetype2_face_requester(FTC_FaceID face_id,
  * @param psd Unused.
  * @return 0 on error, nonzero on success.
  */
-int
-freetype_init(PSD psd)
+static int
+freetype2_init(PSD psd)
 {
 	FT_Error err;
 
 	if (freetype2_library != NULL)
 		return 1;
 
-	if ((freetype2_font_dir = getenv("MWFONTS")) == NULL)
+	if ((freetype2_font_dir = getenv("TTFONTDIR")) == NULL)
 		freetype2_font_dir = FREETYPE_FONT_DIR;
 
 	/* Init freetype library */
@@ -379,39 +368,29 @@ freetype_init(PSD psd)
 	}
 #if HAVE_FREETYPE_2_CACHE
 	/* initialize cache manager */
-	err = FTC_Manager_New(freetype2_library, 3,	/* Faces */
-			      5,	/* Sizes */
-			      512 * 1024,	/* Bytes - 512K */
-			      &freetype2_face_requester, NULL,
-			      &freetype2_cache_manager);
+	err = FTC_Manager_New(freetype2_library, FACE_CACHE_MAX, SIZES_CACHE_MAX, CACHE_SIZE,
+		&freetype2_face_requester, NULL, &freetype2_cache_manager);
 	if (err != FT_Err_Ok) {
-		EPRINTF("Error 0x%x initializing FreeType 2 cache system\n",
-			err);
-
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
+		EPRINTF("Error 0x%x initializing FreeType 2 cache system\n", err);
 		return 0;
 	}
 
-	err = FTC_SBitCache_New(freetype2_cache_manager,
-				&freetype2_cache_sbit);
+	err = FTC_SBitCache_New(freetype2_cache_manager, &freetype2_cache_sbit);
 	if (err != FT_Err_Ok) {
-		EPRINTF("Error 0x%x initializing FreeType 2 sbit cache system\n", err);
-
 		freetype2_cache_sbit = NULL;
 		FTC_Manager_Done(freetype2_cache_manager);
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
+		EPRINTF("Error 0x%x initializing FreeType 2 sbit cache system\n", err);
 		return 0;
 	}
 #if HAVE_FREETYPE_2_CMAP_CACHE
-	err = FTC_CMapCache_New(freetype2_cache_manager,
-				&freetype2_cache_cmap);
+	err = FTC_CMapCache_New(freetype2_cache_manager, &freetype2_cache_cmap);
 	if (err != FT_Err_Ok) {
-		EPRINTF("Error 0x%x initializing FreeType 2 cmap cache system\n", err);
-
 		freetype2_cache_cmap = NULL;
 		// FIXME: Should we free the SBit cache here?
 		freetype2_cache_sbit = NULL;
@@ -419,6 +398,7 @@ freetype_init(PSD psd)
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
+		EPRINTF("Error 0x%x initializing FreeType 2 cmap cache system\n", err);
 		return 0;
 	}
 #endif
@@ -434,11 +414,12 @@ freetype_init(PSD psd)
  *             freetype2_font_dir will be prepended.  If no extension is
  *             specified, ".ttf" will be added.
  * @param height The height of the font, in pixels.
+ * @param width The width of the font, in pixels.
  * @param attr The font attributes - a bitmask.
  * @return The new font, or NULL on error.
  */
-PMWFREETYPE2FONT
-freetype2_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT
+freetype2_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWFREETYPE2FONT pf;
 	char *p;
@@ -448,42 +429,43 @@ freetype2_createfont(const char *name, MWCOORD height, int attr)
 	int first_time = 0;
 #endif
 
-	/* Init freetype library */
-	if (!freetype_init(NULL))
+	if (!freetype2_init(NULL))
 		return NULL;
 
 	fontname = malloc(6 + strlen(name) + strlen(freetype2_font_dir));
-	if (fontname == NULL)
+	if (!fontname)
 		return NULL;
 
-	/* check for pathname prefix */
-	if (strchr(name, '/') != NULL) {
+	/*
+	 * if name has partial path, use it directly, otherwise
+	 * prepend freetype default font directory to passed name
+	 */
+	if (strchr(name, '/') != NULL)
 		strcpy(fontname, name);
-	} else {
-		strcpy(fontname, freetype2_font_dir);
-		strcat(fontname, "/");
-		strcat(fontname, name);
-	}
+	else
+		sprintf(fontname, "%s/%s", freetype2_font_dir, name);
 
-	/* check for extension */
-	if ((p = strrchr(fontname, '.')) == NULL ||
-	    ((strcmpi(p, ".ttf") != 0) && (strcmpi(p, ".pfr") != 0))) {
+	/* check .ttf or .pfr, add .ttf if no extension*/
+	if ((p = strrchr(fontname, '.')) != NULL) {
+		if ((strcmpi(p, ".ttf") != 0) && (strcmpi(p, ".pfr") != 0))
+			return NULL;
+	} else
 		strcat(fontname, ".ttf");
-	}
+
 #if HAVE_FREETYPE_2_CACHE
 	faceid = freetype2_fonts;
-	while ( (faceid != NULL) && (0 != strcmpi(faceid->data.filename, fontname)) )
-	{
+	while ((faceid != NULL) && (0 != strcmpi(faceid->data.filename, fontname)))
 		faceid = faceid->next;
-	}
-	if (faceid == NULL) {
+
+	if (!faceid) {
 		/* Not found in list, so add it. */
-		DPRINTF("Nano-X-Freetype2: Adding new font: %s\n", fontname);
+		DPRINTF("freetype2_createfont: adding new font '%s'\n", fontname);
 		faceid = (freetype2_fontdata *) calloc(sizeof(*faceid), 1);
-		if (faceid == NULL) {
+		if (!faceid) {
 			free(fontname);
 			return NULL;
 		}
+
 		/* faceid->isBuffer = 0; - implied by calloc */
 		faceid->data.filename = fontname;
 
@@ -495,15 +477,14 @@ freetype2_createfont(const char *name, MWCOORD height, int attr)
 		 * we want to destroy the faceid.
 		 */
 		first_time = 1;
-	} else {
+	} else
 		free(fontname);
-	}
 	fontname = faceid->data.filename;
 #else
 	faceid = NULL;
 #endif
 
-	pf = freetype2_createfont_internal(faceid, fontname, height);
+	pf = freetype2_createfont_internal(faceid, fontname, height, width);
 	if (!pf) {
 #if HAVE_FREETYPE_2_CACHE
 		if (first_time) {
@@ -518,9 +499,8 @@ freetype2_createfont(const char *name, MWCOORD height, int attr)
 		return NULL;
 	}
 
-	GdSetFontAttr((PMWFONT) pf, attr, 0);
-
-	return pf;
+	pf->fontprocs->SetFontAttr((PMWFONT)pf, attr, 0);
+	return (PMWFONT)pf;
 }
 
 /**
@@ -529,49 +509,46 @@ freetype2_createfont(const char *name, MWCOORD height, int attr)
  * @param buffer The font data.  This will be copied by this function.
  * @param length The length of the font data.
  * @param height The height of the font, in pixels.
+ * @param width The width of the font, in pixels.
  * @return The new font, or NULL on error.
  */
-PMWFREETYPE2FONT
-freetype2_createfontfrombuffer(const unsigned char *buffer,
-			       unsigned length, MWCOORD height)
+PMWFONT
+freetype2_createfontfrombuffer(const unsigned char *buffer, unsigned size,
+	MWCOORD height, MWCOORD width)
 {
-	PMWFREETYPE2FONT pf;
-	freetype2_fontdata *faceid = NULL;
-	unsigned char *buffercopy;
+		PMWFREETYPE2FONT pf;
+		freetype2_fontdata *faceid = NULL;
+		unsigned char *buffercopy;
 
-	assert(buffer);
+		assert(buffer);
 
-	/* Init freetype library */
-	if (!freetype_init(NULL))
-		return NULL;
+		if (!freetype2_init(NULL))
+				return NULL;
 
-	faceid = (freetype2_fontdata *) calloc(sizeof(freetype2_fontdata), 1);
-	if (!faceid)
-		return NULL;
+		faceid = (freetype2_fontdata *) calloc(sizeof(freetype2_fontdata), 1);
+		if (!faceid)
+				return NULL;
 
-	buffercopy = (unsigned char *) malloc(length);
-	if (!buffercopy) {
-		free(faceid);
-		return NULL;
-	}
-	memcpy(buffercopy, buffer, length);
+		buffercopy = (unsigned char *) malloc(size);
+		if (!buffercopy) {
+				free(faceid);
+				return NULL;
+		}
+		memcpy(buffercopy, buffer, size);
 
-	faceid->isBuffer = TRUE;
-	faceid->data.buffer.length = length;
-	faceid->data.buffer.data = buffercopy;
-	faceid->refcount = 1;
+		faceid->isBuffer = TRUE;
+		faceid->data.buffer.length = size;
+		faceid->data.buffer.data = buffercopy;
+		faceid->refcount = 1;
 
-	/*DPRINTF("Font magic = '%c%c%c%c', len = %u @ freetype2_createfontfrombuffer\n", 
-	   (char)buffercopy[0], (char)buffercopy[1],
-	   (char)buffercopy[2], (char)buffercopy[3],
-	   length); */
+		/*DPRINTF("Font magic = '%c%c%c%c', len = %u @ freetype2_createfontfrombuffer\n", 
+		  (char)buffercopy[0], (char)buffercopy[1], (char)buffercopy[2], (char)buffercopy[3], size); */
 
-	pf = freetype2_createfont_internal(faceid, NULL, height);
-	if (!pf) {
-		free(faceid);
-	}
+		pf = freetype2_createfont_internal(faceid, NULL, height, width);
+		if (!pf)
+				free(faceid);
 
-	return pf;
+		return (PMWFONT)pf;
 }
 
 /**
@@ -584,13 +561,13 @@ freetype2_createfontfrombuffer(const unsigned char *buffer,
  * @param faceid   Information on how to load the font.
  * @param filename The filename, or NULL if loaded from memory.
  * @param height   The font height in pixels.
+ * @param width   The font width in pixels.
  * @return The new font, or NULL on error.
  *
  * @internal
  */
 static PMWFREETYPE2FONT
-freetype2_createfont_internal(freetype2_fontdata * faceid,
-			      char *filename, MWCOORD height)
+freetype2_createfont_internal(freetype2_fontdata * faceid, char *filename, MWCOORD height, MWCOORD width)
 {
 	PMWFREETYPE2FONT pf;
 #if HAVE_FREETYPE_2_CACHE
@@ -601,21 +578,20 @@ freetype2_createfont_internal(freetype2_fontdata * faceid,
 
 	/* allocate font structure */
 	pf = (PMWFREETYPE2FONT) calloc(sizeof(MWFREETYPE2FONT), 1);
-	if (!pf) {
+	if (!pf)
 		return NULL;
-	}
-	pf->fontprocs = &freetype2_procs;
 
+	pf->fontprocs = &freetype2_fontprocs;
 	pf->faceid = faceid;
 	pf->filename = filename;
 #if HAVE_FREETYPE_2_CACHE
 	pf->imagedesc.face_id = faceid;
-	pf->imagedesc.width = 0;	/* Will be set by GdSetFontSize */
-	pf->imagedesc.height = 0;	/* Will be set by GdSetFontSize */
+	pf->imagedesc.width = 0;	/* Will be set by SetFontSize */
+	pf->imagedesc.height = 0;	/* Will be set by SetFontSize */
 #if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,3)
-	pf->imagedesc.flags = 0;	/* Will be set by GdSetFontAttr */
+	pf->imagedesc.flags = 0;	/* Will be set by SetFontAttr */
 #else
-	pf->imagedesc.type = 0;	/* Will be set by GdSetFontAttr */
+	pf->imagedesc.type = 0;		/* Will be set by SetFontAttr */
 #endif
 #if HAVE_FREETYPE_2_CMAP_CACHE
 	pf->cmapdesc.face_id = faceid;
@@ -627,44 +603,41 @@ freetype2_createfont_internal(freetype2_fontdata * faceid,
 	if (filename) {
 		error = FT_New_Face(freetype2_library, filename, 0, &pf->face);
 		if (error != FT_Err_Ok) {
-			EPRINTF("Nano-X-Freetype2: Can't load font from file \"%s\" - %x\n", filename, error);
+			//EPRINTF("freetype2_createfont_internal: Can't load font from file '%s', error 0x%x\n",
+			        //filename, error);
 			goto out;
 		}
-		/*DPRINTF("Nano-X-Freetype2: Loading font from file \"%s\"\n", filename); */
 	} else {
 		error = FT_New_Memory_Face(freetype2_library,
 		    faceid->data.buffer.data, faceid->data.buffer.length, 0, &pf->face);
 		if (error != FT_Err_Ok) {
-			EPRINTF("Nano-X-Freetype2: Can't load font from memory - %x\n", error);
+			EPRINTF("freetype2_createfont_internal: Can't load font from memory, error 0x%x\n", error);
 			goto out;
 		}
-		/*DPRINTF("Nano-X-Freetype2: Loading font from memory\n"); */
 	}
 
 	error = FT_Select_Charmap(pf->face, ft_encoding_unicode);
 	if (error != FT_Err_Ok) {
-		EPRINTF("freetype2_createfont: no unicode map table - %x\n", error);
+		EPRINTF("freetype2_createfont_internal: No unicode map table, error 0x%x\n", error);
 		goto out;
 	}
 #endif
 
-	GdSetFontSize((PMWFONT) pf, height);
-	GdSetFontRotation((PMWFONT) pf, 0);
-	GdSetFontAttr((PMWFONT) pf, 0, 0);
+	pf->fontprocs->SetFontSize((PMWFONT)pf, height, width);
+	pf->fontprocs->SetFontRotation((PMWFONT)pf, 0);
+	pf->fontprocs->SetFontAttr((PMWFONT)pf, 0, 0);
 
 #if HAVE_FREETYPE_2_CACHE
 	/* Check that the font file exists and is valid */
-	/*DPRINTF("freetype2_createfont_internal(): testing\n");*/
 	pf->font.face_id = pf->imagedesc.face_id;
 	pf->font.pix_width = pf->imagedesc.width;
 	pf->font.pix_height = pf->imagedesc.height;
-	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
-	    &(pf->font), &face, &size);
+	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &pf->font, &face, &size);
 	pf->imagedesc.face_id = pf->font.face_id;
 	pf->imagedesc.width = pf->font.pix_width;
 	pf->imagedesc.height = pf->font.pix_height;
 	if (error != FT_Err_Ok) {
-		EPRINTF("Nano-X-Freetype2: Freetype 2 error %x trying to load font.\n", error);
+		//EPRINTF("freetype2_createfont_internal: error 0x%x trying to load font.\n", error);
 		free(pf);
 		return NULL;
 	}
@@ -672,11 +645,10 @@ freetype2_createfont_internal(freetype2_fontdata * faceid,
 
 	return pf;
 
-#if ! HAVE_FREETYPE_2_CACHE
-      out:
-	if (pf->face != NULL) {
+#if !HAVE_FREETYPE_2_CACHE
+out:
+	if (pf->face != NULL)
 		FT_Done_Face(pf->face);
-	}
 	free(pf);
 	return NULL;
 #endif
@@ -694,9 +666,8 @@ freetype2_destroyfont(PMWFONT pfont)
 
 	assert(pf);
 
-#if ! HAVE_FREETYPE_2_CACHE
+#if !HAVE_FREETYPE_2_CACHE
 	FT_Done_Face(pf->face);
-
 	if (pf->filename)
 		free(pf->filename);
 #endif
@@ -731,23 +702,23 @@ freetype2_destroyfont(PMWFONT pfont)
  * @return A new font, or NULL on error.
  */
 static PMWFONT
-freetype2_duplicate(PMWFONT psrcfont, MWCOORD height)
+freetype2_duplicate(PMWFONT psrcfont, MWCOORD height, MWCOORD width)
 {
 	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT) psrcfont;
 	PMWFREETYPE2FONT pnewf;
 
 	assert(pf);
 
-	if (height == 0) {
+	if (height == 0)
 		height = pf->fontsize;
-	}
+	if (width == 0)
+		width = pf->fontsize;
 
 	if (pf->filename) {
 		/* Font from disk file */
 		char *filename;
 #if HAVE_FREETYPE_2_CACHE
-		/* Stored in faceid, which is effectively static.  No need
-		 * to copy. */
+		/* Stored in faceid, which is effectively static.  No need to copy. */
 		filename = pf->filename;
 #else
 		/* Dynamically allocated, must copy. */
@@ -756,8 +727,7 @@ freetype2_duplicate(PMWFONT psrcfont, MWCOORD height)
 			return NULL;
 		strcpy(filename, pf->filename);
 #endif
-		pnewf = freetype2_createfont_internal(pf->faceid, filename,
-						      height);
+		pnewf = freetype2_createfont_internal(pf->faceid, filename, height, width);
 		if (!pnewf) {
 			free(filename);
 			return NULL;
@@ -765,18 +735,16 @@ freetype2_duplicate(PMWFONT psrcfont, MWCOORD height)
 	} else {
 		pf->faceid->refcount++;
 
-		pnewf = freetype2_createfont_internal(pf->faceid, NULL,
-						      height);
+		pnewf = freetype2_createfont_internal(pf->faceid, NULL, height, width);
 		if (!pnewf) {
 			pf->faceid->refcount--;
 			return NULL;
 		}
 	}
 
-	GdSetFontAttr((PMWFONT) pnewf, pf->fontattr, 0);
-	GdSetFontRotation((PMWFONT) pnewf, pf->fontrotation);
-
-	return (PMWFONT) pnewf;
+	pnewf->fontprocs->SetFontAttr((PMWFONT)pnewf, pf->fontattr, 0);
+	pnewf->fontprocs->SetFontRotation((PMWFONT)pnewf, pf->fontrotation);
+	return (PMWFONT)pnewf;
 }
 
 
@@ -786,24 +754,24 @@ freetype2_duplicate(PMWFONT psrcfont, MWCOORD height)
  * @param pfont    The font to update.
  * @param fontsize The new height in pixels.
  */
-static void
-freetype2_setfontsize(PMWFONT pfont, MWCOORD fontsize)
+static int
+freetype2_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width)
 {
 	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT) pfont;
+	MWCOORD oldsize = pf->fontsize;
 	MWCOORD pixel_height;
 	MWCOORD pixel_width;
 
-	assert(pf);
-
-	pf->fontsize = fontsize;
+	pf->fontsize = height;
+	pf->fontwidth = width;
 
-	/* allow create font with height=0*/
-	if (!fontsize)
-		return;
+	/* allow create font with zero height or width*/
+	if (!height)
+		return oldsize;
 
 	/* In future, set these differently to support different aspect ratios. */
-	pixel_height = fontsize;
-	pixel_width = fontsize;
+	pixel_height = height;
+	pixel_width = width;
 
 #if HAVE_FREETYPE_2_CACHE
 	pf->imagedesc.width  = pixel_width;
@@ -812,6 +780,8 @@ freetype2_setfontsize(PMWFONT pfont, MWCOORD fontsize)
 	/* We want real pixel sizes ... not points ... */
 	FT_Set_Pixel_Sizes(pf->face, pixel_width, pixel_height);
 #endif
+	
+	return oldsize;
 }
 
 
@@ -829,11 +799,10 @@ freetype2_setfontrotation(PMWFONT pfont, int tenthdegrees)
 	assert(pf);
 
 	/* Normalize so that 0 <= tenthdegrees < 3600 */
-	if ((tenthdegrees < 0) || (tenthdegrees >= 3600)) {
+	if (tenthdegrees < 0 || tenthdegrees >= 3600) {
 		tenthdegrees = tenthdegrees % 3600;
-		if (tenthdegrees < 0) {
+		if (tenthdegrees < 0)
 			tenthdegrees += 3600;
-		}
 	}
 	pf->fontrotation = tenthdegrees;
 
@@ -867,25 +836,28 @@ freetype2_setfontrotation(PMWFONT pfont, int tenthdegrees)
  * @param setflags Bits being set.  Overrides clrflags.
  * @param clrflags Bits being cleared.
  */
-static void
+static int
 freetype2_setfontattr(PMWFONT pfont, int setflags, int clrflags)
 {
-#if HAVE_FREETYPE_2_CACHE
-	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT) pfont;
+	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT)pfont;
+	int oldattr = pf->fontattr;
 
-	assert(pf);
+	assert(pfont);
+
+	pfont->fontattr &= ~clrflags;
+	pfont->fontattr |= setflags;
 
+#if HAVE_FREETYPE_2_CACHE
 #if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,3)
 	pf->imagedesc.flags = FT_LOAD_DEFAULT;
 	if (!(pf->fontattr & MWTF_ANTIALIAS))
-		pf->imagedesc.flags |= (FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO);
+		pf->imagedesc.flags |= FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO;
 #else
-	pf->imagedesc.type = ((pf->fontattr & MWTF_ANTIALIAS)? ftc_image_grays: ftc_image_mono);
+	pf->imagedesc.type = (pf->fontattr & MWTF_ANTIALIAS)? ftc_image_grays: ftc_image_mono;
 #endif
-#else
-	/* No cache.  Nothing to do, just check paramater is valid. */
-	assert(pfont);
 #endif
+
+	return oldattr;
 }
 
 
@@ -909,12 +881,8 @@ freetype2_setfontattr(PMWFONT pfont, int setflags, int clrflags)
  * @return            FreeType error code (0 on success).
  */
 static FT_Error
-freetype2_get_glyph_size(PMWFREETYPE2FONT pf,
-                         FT_Face face,
-                         int glyph_index,
-                         int *padvance,
-                         int *pascent,
-                         int *pdescent)
+freetype2_get_glyph_size(PMWFREETYPE2FONT pf, FT_Face face, int glyph_index,
+	int *padvance, int *pascent, int *pdescent)
 {
 	FT_Error error;
 
@@ -926,9 +894,7 @@ freetype2_get_glyph_size(PMWFREETYPE2FONT pf,
 	{
 		FTC_SBit sbit;
 
-		error = FTC_SBitCache_Lookup(freetype2_cache_sbit,
-					     &(pf->imagedesc),
-					     glyph_index, &sbit, NULL);
+		error = FTC_SBitCache_Lookup(freetype2_cache_sbit, &pf->imagedesc, glyph_index, &sbit, NULL);
 		if (error)
 			return error;
 		
@@ -961,7 +927,6 @@ freetype2_get_glyph_size(PMWFREETYPE2FONT pf,
 				return error;
 			
 			FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels, &bbox);
-			
 			FT_Done_Glyph(glyph);
 			
 			if (pascent)
@@ -993,14 +958,11 @@ freetype2_get_glyph_size(PMWFREETYPE2FONT pf,
  * @return         FreeType error code (0 on success).
  */
 static FT_Error
-freetype2_get_char_size(PMWFREETYPE2FONT pf,
-                        FT_Face face,
-                        int ch,
-                        int *padvance,
-                        int *pascent,
-                        int *pdescent)
+freetype2_get_char_size(PMWFREETYPE2FONT pf, FT_Face face, int ch,
+	int *padvance, int *pascent, int *pdescent)
 {
 	int glyph = LOOKUP_CHAR(pf, face, ch);
+
 	return freetype2_get_glyph_size(pf, face, glyph, padvance, pascent, pdescent);
 }
 
@@ -1025,10 +987,6 @@ freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
 #if HAVE_FREETYPE_2_CACHE
 	FT_Error error;
 #endif
-#if MW_FEATURE_DO_NOT_TRUST_FONT_ASCENT_AND_DESCENT
-	int font_ascent;
-	int font_descent;
-#endif
 
 	assert(pf);
 	assert(pfontinfo);
@@ -1037,13 +995,12 @@ freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
 	pf->font.face_id = pf->imagedesc.face_id;
 	pf->font.pix_width = pf->imagedesc.width;
 	pf->font.pix_height = pf->imagedesc.height;
-	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
-					&(pf->font), &face, &size);
+	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &pf->font, &face, &size);
 	pf->imagedesc.face_id = pf->font.face_id;
 	pf->imagedesc.width = pf->font.pix_width;
 	pf->imagedesc.height = pf->font.pix_height;
 	if (error) {
-		EPRINTF("Freetype 2 error 0x%x getting font info.\n", error);
+		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		return FALSE;
 	}
 #else
@@ -1051,25 +1008,17 @@ freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
 	size = face->size;
 #endif
 
-	bbox = &(face->bbox);
-	metrics = &(size->metrics);
+	bbox = &face->bbox;
+	metrics = &size->metrics;
 
-	if (!FT_IS_SCALABLE(face)) {
-		/* FIXME */
-		return FALSE;
-	}
+	if (!FT_IS_SCALABLE(face))
+		return FALSE; // FIXME
 
 	/* Fill up the fields */
 	pfontinfo->maxwidth = ROUND_26_6_TO_INT(metrics->max_advance);
-
-	pfontinfo->maxascent =
-		ROUND_26_6_TO_INT(FT_MulFix(bbox->yMax, metrics->y_scale));
-	pfontinfo->maxdescent =
-		ROUND_26_6_TO_INT(FT_MulFix(-bbox->yMin, metrics->y_scale));
-
-	pfontinfo->fixed =
-		((face->face_flags & FT_FACE_FLAG_FIXED_WIDTH) != 0);
-
+	pfontinfo->maxascent = ROUND_26_6_TO_INT(FT_MulFix(bbox->yMax, metrics->y_scale));
+	pfontinfo->maxdescent = ROUND_26_6_TO_INT(FT_MulFix(-bbox->yMin, metrics->y_scale));
+	pfontinfo->fixed = ((face->face_flags & FT_FACE_FLAG_FIXED_WIDTH) != 0);
 	pfontinfo->baseline = ROUND_26_6_TO_INT(metrics->ascender);
 	pfontinfo->descent = ROUND_26_6_TO_INT(abs(metrics->descender));
 	pfontinfo->height = pfontinfo->baseline + pfontinfo->descent;
@@ -1088,23 +1037,18 @@ freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
 	//    pfontinfo->height,   pfontinfo->line_spacing
 	//    );
 
-	/* FIXME: Following are hacks... */
+	// FIXME: Following are hacks
 	pfontinfo->firstchar = 0;
 	pfontinfo->lastchar = 0xFFFFU;
 
 	for (ch = 0; ch < 256; ch++) {
 		int advance;
+
 		if (freetype2_get_char_size(pf, face, ch, &advance, NULL, NULL))
-		{
-			/* Error - assume default */
-			pfontinfo->widths[ch] = pfontinfo->maxwidth;
-		}
+			pfontinfo->widths[ch] = pfontinfo->maxwidth; /* Error - assume default */
 		else
-		{
-			/* OK, found the value. */
 			pfontinfo->widths[ch] = advance;
-		}
-		//EPRINTF("pfontinfo->widths[%d]=%d\n", i, pfontinfo->widths[i]);
+		//DPRINTF("pfontinfo->widths[%d]=%d\n", i, pfontinfo->widths[i]);
 	}
 
 	return TRUE;
@@ -1122,9 +1066,9 @@ freetype2_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
  * @param cc    The number of characters (not bytes) in text.
  * @param flags Flags.
  */
-static void
+void
 freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
-		   const void *text, int cc, MWTEXTFLAGS flags)
+	const void *text, int cc, MWTEXTFLAGS flags)
 {
 	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT) pfont;
 	FT_Face face;
@@ -1138,25 +1082,22 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 	int curchar;
 	int use_kerning;
 	int last_glyph_code = 0;	/* Used for kerning */
-	driver_gc_t blit_instructions;
-	int blit_op;
+	MWBLITPARMS parms;
 
 	assert(pf);
-	assert(psd);
 	assert(text);
-
-	//DPRINTF("Nano-X-Freetype2: freetype2_drawtext(x=%d, y=%d) called\n", ax, ay);
+	assert(psd); // note in STANDALONE case, 'app_t' is passed as psd, must not inspect pointer!
 
 #if HAVE_FREETYPE_2_CACHE
 	pf->font.face_id = pf->imagedesc.face_id;
 	pf->font.pix_width = pf->imagedesc.width;
 	pf->font.pix_height = pf->imagedesc.height;
-	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &(pf->font), &face, &size);
+	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &pf->font, &face, &size);
 	pf->imagedesc.face_id = pf->font.face_id;
 	pf->imagedesc.width = pf->font.pix_width;
 	pf->imagedesc.height = pf->font.pix_height;
 	if (error) {
-		EPRINTF("Freetype 2 error 0x%x getting font for drawtext.\n", error);
+		EPRINTF("Freetype2 error 0x%x getting font for drawtext.\n", error);
 		return;
 	}
 #else
@@ -1166,20 +1107,23 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 
 	use_kerning = ((pf->fontattr & MWTF_KERNING) && FT_HAS_KERNING(face));
 
-	/* Initialize the parts of blit_instructions we won't change */
-	blit_instructions.fg_color = gr_foreground;
-	blit_instructions.bg_color = gr_background;
-	blit_instructions.usebg = gr_usebg;
-	blit_instructions.srcx = 0;
-	blit_instructions.srcy = 0;
-	blit_instructions.dst_linelen = 0;	/* Unused. */
-
-	// FIXME: don't use antialias settings if no alphacol driver
-	if ((pf->fontattr & MWTF_ANTIALIAS) /**&& (psd->flags & PSF_HAVEOP_ALPHACOL)**/)
-		blit_op = PSDOP_ALPHACOL;
-	else
-		blit_op = PSDOP_BITMAP_BYTES_MSB_FIRST;
-	blit_instructions.op = blit_op;
+	/* Initialize blit parms we won't change*/
+	parms.fg_color = gr_foreground;
+	parms.bg_color = gr_background;
+	parms.usebg = gr_usebg;
+	parms.srcx = 0;
+	parms.srcy = 0;
+	parms.dst_pitch = 0;		/* set later in GdConversionBlit*/
+	parms.data_out = 0;			/* set later in GdConversionBlit*/
+
+	// FIXME: don't use antialias settings if no alphacol driver (psd->flags & PSF_HAVEOP_ALPHACOL)
+	if (pf->fontattr & MWTF_ANTIALIAS) {
+		parms.data_format = MWIF_8BPP | MWIF_HASALPHA;	/* data is 8bpp alpha channel*/
+		parms.op = MWROP_BLENDFGBG;				/* blend fg/bg with alpha channel -> dst*/
+	} else {
+		parms.data_format = MWIF_MONOBYTEMSB;	/* data is 1bpp bytes, msb first*/
+		parms.op = MWROP_COPY;					/* copy to dst, 1=fg (0=bg if usebg)*/
+	}
 
 	/*
 	 * Offset the starting point if necessary, FreeType always aligns at baseline
@@ -1191,21 +1135,51 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 	else
 		pos.y = 0;
 
+	/* Use slow routine for rotated text or cache not supported*/
 	if ((pf->fontrotation != 0)
 #if !HAVE_FREETYPE_2_CACHE
-	    || 1	/* FIXME display broken when cache disabled*/
+	    || 1						/* FIXME display broken when cache disabled*/
 #endif
 #if HAVE_FREETYPE_2_CACHE
 	    || (!CAN_USE_FT2_CACHE(pf))	/* Cache does not support bitmaps >256x256 */
 #endif
-	   ) {
-		/* Use slow routine for rotated text */
+	   )
+	{
+		/* non-cache drawtext routine*/
 		FT_BitmapGlyph bitmapglyph;
 		FT_Bitmap *bitmap;
-		FT_Render_Mode render_mode = (blit_op == PSDOP_ALPHACOL)?
-			ft_render_mode_normal: ft_render_mode_mono;
+		FT_Render_Mode render_mode = (parms.data_format & MWIF_MONO)?
+			FT_RENDER_MODE_MONO: FT_RENDER_MODE_NORMAL;
+
+		// duplicated from below for the cache disabled mode which is broken FIXME
+#if FILL_BACKGROUND_ON_USEBG
+		/*
+		 * Pre-clear entire text box background when alpha blending
+		 * and 'use background' is TRUE.
+		 * The glyph box background pixels will also be drawn again in
+		 * GdConvertBlit.
+		 */
+		if (gr_usebg && pf->fontrotation == 0) {
+			MWCOORD fnt_h, fnt_w, fnt_b;
+#if STANDALONE
+			/* fill to gr_background color*/
+			MWPIXELVAL gr_save = winsetfgcolor(psd, gr_background);	
+#else
+			MWPIXELVAL gr_save = gr_background;
+			gr_foreground = gr_background;
+#endif
+			pfont->fontprocs->GetTextSize(pfont, text, cc, flags, &fnt_w, &fnt_h, &fnt_b);
+			ay -= pos.y >> 6;
+			GdFillRect(psd, ax, ay-fnt_b, fnt_w, fnt_h);
+			ay += pos.y >> 6;
+#if STANDALONE
+			winsetfgcolor(psd, gr_save);
+#else
+			gr_foreground = gr_save;
+#endif
+		}
+#endif /* FILL_BACKGROUND_ON_USEBG*/
 
-		/*DPRINTF("Nano-X-Freetype2: freetype2_drawtext() using SLOW routine\n"); */
 		pos.x = 0;
 		for (i = 0; i < cc; i++) {
 			curchar = LOOKUP_CHAR(pf, face, str[i]);
@@ -1213,15 +1187,13 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 			if (use_kerning && last_glyph_code && curchar) {
 				FT_Get_Kerning(face, last_glyph_code, curchar, ft_kerning_default, &kerning_delta);
 
-				//DPRINTF("Nano-X-Freetype2: freetype2_drawtext(): kerning_delta.x=%d, /64=%d\n", (int)kerning_delta.x, (int)kerning_delta.x/64);
-				pos.x += kerning_delta.x & (~63);
+				//DPRINTF("freetype2_drawtext(): kerning_delta.x=%d, /64=%d\n",
+				//(int)kerning_delta.x, (int)kerning_delta.x/64);
+				pos.x += kerning_delta.x & ~63;
 			}
 			last_glyph_code = curchar;
 
-			/* FIXME: Should use an image cache to optimize
-			 * rendering of rotated text.
-			 */
-
+			/* FIXME: Should use an image cache to optimize rendering of rotated text */
 			error = FT_Load_Glyph(face, curchar, FT_LOAD_DEFAULT);
 			if (error)
 				continue;
@@ -1230,20 +1202,18 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 			if (error)
 				continue;
 
-			// translate the glyph image now..
+			/* translate the glyph image*/
 			FT_Glyph_Transform(glyph, 0, &pos);
 
-			//DPRINTF("Nano-X-Freetype2: freetype2_drawtext(): glyph->advance.x=%d, >>16=%d\n", (int)glyph->advance.x, (int)glyph->advance.x>>16);
+			//DPRINTF("freetype2_drawtext(): glyph->advance.x=%d, >>16=%d\n",
+			//(int)glyph->advance.x, (int)glyph->advance.x>>16);
 
-			pos.x += (glyph->advance.x >> 10) & (~63);
+			pos.x += (glyph->advance.x >> 10) & ~63;
 
-			//if (pf->fontrotation) {
-				// rotate the glyph image now..
-				FT_Glyph_Transform(glyph, &pf->matrix, 0);
-			//}
+			/* rotate the glyph image*/
+			FT_Glyph_Transform(glyph, &pf->matrix, 0);
 
-			// convert glyph image to bitmap
-			//
+			/* convert glyph to bitmap image*/
 			error = FT_Glyph_To_Bitmap(&glyph, render_mode,
 						0,	// no additional translation
 						1);	// do not destroy copy in "image"
@@ -1251,16 +1221,17 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 				bitmapglyph = (FT_BitmapGlyph) glyph;
 				bitmap = &(bitmapglyph->bitmap);
 
-				blit_instructions.dstx = ax + bitmapglyph->left;
-				blit_instructions.dsty = ay - bitmapglyph->top;
-				blit_instructions.width = bitmap->width;
-				blit_instructions.height = bitmap->rows;
-				blit_instructions.src_linelen = bitmap->pitch;
-				blit_instructions.data = bitmap->buffer;
-				//DPRINTF("Nano-X-Freetype2: freetype2_draw_bitmap_%s(ax=%d, ay=%d, gl->l=%d, gl->t=%d)\n", ((pf->fontattr & MWTF_ANTIALIAS) ? "alpha" : "mono"), ax, ay, bitmapglyph->left, bitmapglyph->top);
+				parms.dstx = ax + bitmapglyph->left;
+				parms.dsty = ay - bitmapglyph->top;
+				parms.width = bitmap->width;
+				parms.height = bitmap->rows;
+				parms.src_pitch = bitmap->pitch;
+				parms.data = bitmap->buffer;
+				//DPRINTF("freetype2_draw_bitmap(ax=%d, ay=%d, gl->l=%d, gl->t=%d)\n",
+				// ax, ay, bitmapglyph->left, bitmapglyph->top);
 
-				if (blit_instructions.width > 0 && blit_instructions.height > 0)
-					GdDrawAreaInternal(psd, &blit_instructions);
+				if (parms.width > 0 && parms.height > 0)
+					GdConversionBlit(psd, &parms);
 
 				FT_Done_Glyph(glyph);
 			}
@@ -1276,71 +1247,81 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 #endif
 		MWCOORD startx, starty;
 
-		ay -= (pos.y >> 6);
-		startx = ax;
+		ay -= pos.y >> 6;
 		starty = ay;
+		startx = ax;
 
 #if FILL_BACKGROUND_ON_USEBG
-		/* clear background area if usebg set*/
-		/* this is done again in alphacol drawarea driver, but only for char box*/
+		/*
+		 * Pre-clear entire text box background when alpha blending
+		 * and 'use background' is TRUE.
+		 * The glyph box background pixels will also be drawn again in
+		 * GdConvertBlit.
+		 */
 		if (gr_usebg) {
 			MWCOORD fnt_h, fnt_w, fnt_b;
-			MWPIXELVAL gr_save = gr_foreground;
-
-			freetype2_gettextsize(pfont, text, cc, flags, &fnt_w, &fnt_h, &fnt_b);
-
-			// kluge must set gr_foreground for GdFillRect as we need clipping
+#if STANDALONE
+			/* fill to gr_background color*/
+			MWPIXELVAL gr_save = winsetfgcolor(psd, gr_background);	
+#else
+			MWPIXELVAL gr_save = gr_background;
 			gr_foreground = gr_background;
+#endif
+			pfont->fontprocs->GetTextSize(pfont, text, cc, flags, &fnt_w, &fnt_h, &fnt_b);
 			GdFillRect(psd, ax, ay-fnt_b, fnt_w, fnt_h);
+
+#if STANDALONE
+			winsetfgcolor(psd, gr_save);
+#else
 			gr_foreground = gr_save;
-		}
 #endif
+		}
+#endif /* FILL_BACKGROUND_ON_USEBG*/
 
 		for (i = 0; i < cc; i++) {
 			curchar = LOOKUP_CHAR(pf, face, str[i]);
 
 			if (use_kerning && last_glyph_code && curchar) {
 				FT_Get_Kerning(face, last_glyph_code, curchar, ft_kerning_default, &kerning_delta);
-				ax += (kerning_delta.x >> 6);
+				ax += kerning_delta.x >> 6;
 			}
 			last_glyph_code = curchar;
 
 #if HAVE_FREETYPE_2_CACHE
-			error = FTC_SBitCache_Lookup(freetype2_cache_sbit, &(pf->imagedesc), curchar, &sbit, NULL);
+			error = FTC_SBitCache_Lookup(freetype2_cache_sbit, &pf->imagedesc, curchar, &sbit, NULL);
 			if (error)
 				continue;
 
-			blit_instructions.dstx = ax + sbit->left;
-			blit_instructions.dsty = ay - sbit->top;
-			blit_instructions.width = sbit->width;
-			blit_instructions.height = sbit->height;
-			blit_instructions.src_linelen = sbit->pitch;
-			blit_instructions.data = sbit->buffer;
+			parms.dstx = ax + sbit->left;
+			parms.dsty = ay - sbit->top;
+			parms.width = sbit->width;
+			parms.height = sbit->height;
+			parms.src_pitch = sbit->pitch;
+			parms.data = sbit->buffer;
 
 			ax += sbit->xadvance;
 #else
-			error = FT_Load_Glyph(face, curchar, (blit_op == PSDOP_ALPHACOL)?
+			error = FT_Load_Glyph(face, curchar, (parms.data_format & MWIF_MONO)?
 					      (FT_LOAD_RENDER | FT_LOAD_MONOCHROME): FT_LOAD_RENDER);
 			if (error)
 				continue;
 
-			bitmap = &(face->glyph->bitmap);
-
-			blit_instructions.dstx = ax + face->glyph->bitmap_left;
-			blit_instructions.dsty = ay - face->glyph->bitmap_top;
-			blit_instructions.width = bitmap->width;
-			blit_instructions.height = bitmap->rows;
-			blit_instructions.src_linelen = bitmap->pitch;
-			blit_instructions.data = bitmap->buffer;
+			bitmap = &face->glyph->bitmap;
+			parms.dstx = ax + face->glyph->bitmap_left;
+			parms.dsty = ay - face->glyph->bitmap_top;
+			parms.width = bitmap->width;
+			parms.height = bitmap->rows;
+			parms.src_pitch = bitmap->pitch;
+			parms.data = bitmap->buffer;
 
 			/* Wierdness: After FT_Load_Glyph, face->glyph->advance.x is in 26.6.
 			 * After a translation with FT_Glyph_Transform, it is in 16.16.
 			 * Must be a FreeType 2.0.8 bug.
 			 */
-			ax += (face->glyph->advance.x >> 6);
+			ax += face->glyph->advance.x >> 6;
 #endif
-			if (blit_instructions.width > 0 && blit_instructions.height > 0)
-				GdDrawAreaInternal(psd, &blit_instructions);
+			if (parms.width > 0 && parms.height > 0)
+				GdConversionBlit(psd, &parms);
 
 		}
 		if (pf->fontattr & MWTF_UNDERLINE)
@@ -1363,10 +1344,8 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
  * @internal
  */
 static void
-freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
-                              const void *text, int cc,
-                              MWCOORD * pwidth, MWCOORD * pheight,
-                              MWCOORD * pbase)
+freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf, const void *text, int cc,
+	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
 	FT_Face face;
 	FT_Size size;
@@ -1388,13 +1367,12 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 	pf->font.face_id = pf->imagedesc.face_id;
 	pf->font.pix_width = pf->imagedesc.width;
 	pf->font.pix_height = pf->imagedesc.height;
-	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
-					&(pf->font), &face, &size);
+	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &pf->font, &face, &size);
 	pf->imagedesc.face_id = pf->font.face_id;
 	pf->imagedesc.width = pf->font.pix_width;
 	pf->imagedesc.height = pf->font.pix_height;
 	if (error) {
-		EPRINTF("Freetype 2 error 0x%x getting font info.\n", error);
+		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		*pwidth = 0;
 		*pheight = 0;
 		*pbase = 0;
@@ -1406,15 +1384,10 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 #endif
 
 	use_kerning = ((pf->fontattr & MWTF_KERNING) && FT_HAS_KERNING(face));
-
 	bbox.xMin = 0;
 	bbox.yMin = 0;
 	bbox.xMax = 0;
 	bbox.yMax = 0;
-
-	/*
-	 * Starting point
-	 */
 	pos.x = 0;
 	pos.y = 0;
 
@@ -1422,16 +1395,13 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 		curchar = LOOKUP_CHAR(pf, face, str[i]);
 
 		if (use_kerning && last_glyph_code && curchar) {
-			FT_Get_Kerning(face, last_glyph_code, curchar,
-				       ft_kerning_default, &kerning_delta);
+			FT_Get_Kerning(face, last_glyph_code, curchar, ft_kerning_default, &kerning_delta);
 
 			pos.x += kerning_delta.x & (~63);
 		}
 		last_glyph_code = curchar;
 
-		/* FIXME: Should use an image cache to optimize
-		 * rendering of rotated text.
-		 */
+		/* FIXME: Should use an image cache to optimize rendering of rotated text*/
 		error = FT_Load_Glyph(face, curchar, FT_LOAD_DEFAULT);
 		if (error)
 			continue;
@@ -1440,28 +1410,27 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 		if (error)
 			continue;
 
-		//DPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): glyph '%c' at %d,%d, advance=%d\n",
-		//       str[i], (pos.x>>6), (pos.y>>6), (glyph->advance.x >> 16));
+		/*DPRINTF("freetype2_gettextsize: glyph '%c' at %d,%d, advance=%d\n",
+		       str[i], pos.x>>6, pos.y>>6, glyph->advance.x >> 16);*/
 
-		// translate the glyph image now..
+		/* translate the glyph image now..*/
 		FT_Glyph_Transform(glyph, 0, &pos);
 
-		pos.x += (glyph->advance.x >> 10) & (~63);
+		pos.x += (glyph->advance.x >> 10) & ~63;
 
 		//if (pf->fontrotation) {
 			// rotate the glyph image now..
 			FT_Glyph_Transform(glyph, &pf->matrix, 0);
 		//}
 
-		if (i == 0) {
+		if (i == 0)
 			FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels, &bbox);
-		} else {
-			FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels,
-					  &glyph_bbox);
+		else {
+			FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels, &glyph_bbox);
 
-			//DPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): glyph cbox (%d,%d)-(%d,%d)\n",
-			//        (glyph_bbox.xMin/*>>6*/), (glyph_bbox.yMin/*>>6*/),
-			//        (glyph_bbox.xMax/*>>6*/), (glyph_bbox.yMax/*>>6*/));
+			//DPRINTF("freetype2_gettextsize: glyph cbox (%d,%d)-(%d,%d)\n",
+			//		(glyph_bbox.xMin/*>>6*/), (glyph_bbox.yMin/*>>6*/),
+			//		(glyph_bbox.xMax/*>>6*/), (glyph_bbox.yMax/*>>6*/));
 
 			if (glyph_bbox.xMin < bbox.xMin)
 				bbox.xMin = glyph_bbox.xMin;
@@ -1477,7 +1446,7 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 		}
 		FT_Done_Glyph(glyph);
 
-		//DPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): total cbox (%d,%d)-(%d,%d)\n",
+		//DPRINTF("freetype2_gettextsize: total cbox (%d,%d)-(%d,%d)\n",
 		//        (bbox.xMin/*>>6*/), (bbox.yMin/*>>6*/), (bbox.xMax/*>>6*/), (bbox.yMax/*>>6*/));
 	}
 
@@ -1485,8 +1454,7 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
 	*pheight = (bbox.yMax - bbox.yMin) /*>> 6 */ ;
 	*pbase = -(bbox.yMin /*>> 6 */ );
 
-	//DPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): numchars = %d, w = %d, h = %d, base = %d\n",
-	//        cc, *pwidth, *pheight, *pbase);
+	//DPRINTF("freetype2_gettextsize_rotated: width %d, height %d, base %d\n", *pwidth, *pheight, *pbase);
 }
 
 
@@ -1505,10 +1473,8 @@ freetype2_gettextsize_rotated(PMWFREETYPE2FONT pf,
  * @internal
  */
 static void
-freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
-                           const void *text, int char_count,
-                           MWCOORD * pwidth, MWCOORD * pheight,
-                           MWCOORD * pbase)
+freetype2_gettextsize_fast(PMWFREETYPE2FONT pf, const void *text, int char_count,
+	MWCOORD * pwidth, MWCOORD * pheight, MWCOORD * pbase)
 {
 	FT_Face face;
 	FT_Size size;
@@ -1530,14 +1496,12 @@ freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
 	pf->font.face_id = pf->imagedesc.face_id;
 	pf->font.pix_width = pf->imagedesc.width;
 	pf->font.pix_height = pf->imagedesc.height;
-	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
-					&(pf->font), &face, &size);
+	error = FTC_Manager_Lookup_Size(freetype2_cache_manager, &pf->font, &face, &size);
 	pf->imagedesc.face_id = pf->font.face_id;
 	pf->imagedesc.width = pf->font.pix_width;
 	pf->imagedesc.height = pf->font.pix_height;
 	if (error) {
-		EPRINTF("Freetype 2 error 0x%x getting font info.\n",
-			error);
+		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		*pwidth = 0;
 		*pheight = 0;
 		*pbase = 0;
@@ -1548,13 +1512,7 @@ freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
 	size = face->size;
 #endif
 
-	use_kerning = ((pf->fontattr & MWTF_KERNING)
-			   && FT_HAS_KERNING(face));
-
-
-	/*
-	 * Starting point
-	 */
+	use_kerning = (pf->fontattr & MWTF_KERNING) && FT_HAS_KERNING(face);
 	total_advance = 0;
 	max_ascent  = 0;
 	max_descent = 0;
@@ -1563,13 +1521,11 @@ freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
 		cur_glyph_code = LOOKUP_CHAR(pf, face, str[char_index]);
 
 		if (use_kerning && last_glyph_code && cur_glyph_code) {
-			FT_Get_Kerning(face, last_glyph_code, cur_glyph_code,
-					   ft_kerning_default,
-					   &kerning_delta);
+			FT_Get_Kerning(face, last_glyph_code, cur_glyph_code, ft_kerning_default, &kerning_delta);
 
-			/*EPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): %d + kerning %d (delta was %d unscaled).\n",
+			/*DPRINTF("freetype2_gettextsize_fast: %d + kerning %d (delta was %d unscaled).\n",
 			   (int)ax, (int)(kerning_delta.x >> 6), (int)kerning_delta.x); */
-			total_advance += (kerning_delta.x >> 6);
+			total_advance += kerning_delta.x >> 6;
 		}
 		last_glyph_code = cur_glyph_code;
 
@@ -1588,8 +1544,7 @@ freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
 	*pheight = max_ascent + max_descent;
 	*pbase = max_ascent;
 
-	/*EPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): numchars = %d, w = %d, h = %d, base = %d\n",
-	   cc, *pwidth, *pheight, *pbase); */
+	//DPRINTF("freetype2_gettextsize_fast: width %d, height %d, base %d\n", *pwidth, *pheight, *pbase);
 }
 
 
@@ -1604,9 +1559,9 @@ freetype2_gettextsize_fast(PMWFREETYPE2FONT pf,
  * @param pheight [out] the height in pixels
  * @param pbase   [out] the base in pixels
  */
-static void
+void
 freetype2_gettextsize(PMWFONT pfont, const void *text, int cc,MWTEXTFLAGS flags,
-		      MWCOORD * pwidth, MWCOORD * pheight, MWCOORD * pbase)
+	MWCOORD * pwidth, MWCOORD * pheight, MWCOORD * pbase)
 {
 	PMWFREETYPE2FONT pf = (PMWFREETYPE2FONT) pfont;
 
@@ -1616,17 +1571,16 @@ freetype2_gettextsize(PMWFONT pfont, const void *text, int cc,MWTEXTFLAGS flags,
 	assert(pheight);
 	assert(pbase);
 
+	/* use slower routine for rotated text or non-cached*/
 	if ((pf->fontrotation != 0)
 #if HAVE_FREETYPE_2_CACHE
 	    || (!CAN_USE_FT2_CACHE(pf))
 #endif
-		) {
-		/* Use slow routine for rotated text */
-		/* EPRINTF("Nano-X-Freetype2: freetype2_gettextsize() using SLOW routine\n"); */
-		freetype2_gettextsize_rotated(pf, text, cc, pwidth, pheight, pbase);
-	} else {
+	   )
+	{
+		freetype2_gettextsize_rotated(pf, text, cc, pwidth, pheight, pbase);	/* slower*/
+	} else
 		freetype2_gettextsize_fast(pf, text, cc, pwidth, pheight, pbase);
-	}
 }
 
 
diff --git a/src/engine/font_hzk.c b/src/engine/font_hzk.c
index 9210670..935dbe5 100644
--- a/src/engine/font_hzk.c
+++ b/src/engine/font_hzk.c
@@ -11,6 +11,10 @@
 #include "device.h"
 #include "devfont.h"
 
+#ifndef HZK_FONT_DIR
+#define HZK_FONT_DIR	"fonts/chinese"	/* default dir for {asc,hzk,hzx}{12,16} and *.KU files*/
+#endif
+
 /*
  * 12x12 and 16x16 ascii and chinese fonts
  * Big5 and GB2312 encodings supported
@@ -37,10 +41,11 @@ static char *afont_address;
 static char *cfont_address;
 
 typedef struct MWHZKFONT {
-	PMWFONTPROCS	fontprocs;	/* common hdr*/
+	PMWFONTPROCS fontprocs;	/* common hdr*/
 	MWCOORD		fontsize;
-	int		fontrotation;
-	int		fontattr;		
+	MWCOORD		fontwidth;
+	int			fontrotation;
+	int			fontattr;		
 
 	HZKFONT 	CFont;		/* hzkfont stuff */
 	HZKFONT 	AFont;
@@ -49,10 +54,10 @@ typedef struct MWHZKFONT {
 	int 		font_height;
 	char 		*afont_address;
 	char 		*cfont_address;
-} MWHZKFONT;
+} MWHZKFONT, *PMWHZKFONT;
 
-int  hzk_init(PSD psd);
-PMWHZKFONT hzk_createfont(const char *name, MWCOORD height,int fontattr);
+static int  hzk_init(PSD psd);
+PMWFONT hzk_createfont(const char *name, MWCOORD height, MWCOORD width, int fontattr);
 
 static MWBOOL hzk_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
 static void hzk_gettextsize(PMWFONT pfont, const void *text, int cc,
@@ -69,6 +74,8 @@ static void hzk_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 /* handling routines for MWHZKFONT*/
 static MWFONTPROCS hzk_procs = {
 	MWTF_ASCII,			/* routines expect ASCII*/
+	hzk_init,
+	hzk_createfont,
 	hzk_getfontinfo,
 	hzk_gettextsize,
 	NULL,				/* hzk_gettextbits*/
@@ -77,7 +84,7 @@ static MWFONTPROCS hzk_procs = {
 	NULL,				/* setfontsize*/
 	NULL, 				/* setfontrotation*/
 	NULL,				/* setfontattr*/
-	NULL,				/* duplicate not yet implemented */
+	NULL				/* duplicate*/
 };
 
 /* temp extern decls*/
@@ -250,8 +257,7 @@ UC16_to_GB(const unsigned char *uc16, int cc, unsigned char *ascii)
 
 static int hzk_id( PMWHZKFONT pf )
 {
-	switch(pf->font_height)
-	{
+	switch(pf->font_height) {
 	case 12:
 		return 0;
 	case 16: default:
@@ -453,8 +459,8 @@ hzk_init(PSD psd)
 	return 1;
 }
 
-PMWHZKFONT
-hzk_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT
+hzk_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	PMWHZKFONT	pf;
 
@@ -472,6 +478,7 @@ hzk_createfont(const char *name, MWCOORD height, int attr)
 	pf->fontprocs = &hzk_procs;
 
 	pf->fontsize = height;
+	pf->fontwidth = width;
 	pf->fontrotation = 0;
 	pf->fontattr = attr;
 
@@ -500,7 +507,7 @@ hzk_createfont(const char *name, MWCOORD height, int attr)
 	if(!LoadFont(pf))
   	      	return FALSE;
 
-	return pf;
+	return (PMWFONT)pf;
 }
 
 int IsBig5(int i)
@@ -576,8 +583,7 @@ expandcchar(PMWHZKFONT pf, int bg, int fg, unsigned char* c, MWPIXELVAL* bitmap)
 	else
     		seq=((c1 - 161)*94 + c2 - 161); 
 
-	font = pf->cfont_address + ((seq) *
-		  (pf->font_height * ((pf->cfont_width + 7) / 8)));
+	font = pf->cfont_address + ((seq) * (pf->font_height * ((pf->cfont_width + 7) / 8)));
 
      	for (y = 0; y < pf->font_height; y++)
         	for (x = 0; x < pf->cfont_width; x++) 
diff --git a/src/engine/font_pcf.c b/src/engine/font_pcf.c
index 80792c6..69f9707 100644
--- a/src/engine/font_pcf.c
+++ b/src/engine/font_pcf.c
@@ -47,10 +47,9 @@
 #include <string.h>
 #include <errno.h>
 #include <stdlib.h>
-#include "swap.h"
 #include "device.h"
 #include "devfont.h"
-#include "../drivers/genfont.h"
+#include "genfont.h"
 
 /* settable params*/
 #ifndef PCF_FONT_DIR
@@ -80,7 +79,7 @@ typedef	unsigned short (*FP_READ16)(FILEP file);
 typedef	uint32_t 		(*FP_READ32)(FILEP file);
 
 /* Handling routines for PCF fonts, use MWCOREFONT structure */
-PMWCOREFONT pcf_createfont(const char *name, MWCOORD height, int attr);
+PMWFONT pcf_createfont(const char *name, MWCOORD height, MWCOORD width, int attr);
 static void pcf_unloadfont(PMWFONT font);
 
 static void	get_endian_read_funcs(uint32_t format, FP_READ8 *p_fp_read8,
@@ -93,20 +92,28 @@ static uint32_t			readMSB32(FILEP file);
 /* these procs used when font ASCII indexed*/
 MWFONTPROCS pcf_fontprocs = {
 	MWTF_ASCII,
+	NULL,			/* init*/
+	pcf_createfont,
 	gen_getfontinfo,
 	gen_gettextsize,
 	gen_gettextbits,
 	pcf_unloadfont,
+#if STANDALONE
+	gen16_drawtext,
+#else
 	corefont_drawtext,
+#endif
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
-	NULL,			/* duplicate not yet implemented */
+	NULL			/* duplicate*/
 };
 
 /* these procs used when font requires UC16 index*/
 static MWFONTPROCS pcf_fontprocs16 = {
 	MWTF_UC16,		/* routines expect unicode 16 */
+	NULL,			/* init*/
+	pcf_createfont,
 	gen_getfontinfo,
 	gen16_gettextsize,
 	gen_gettextbits,
@@ -115,7 +122,7 @@ static MWFONTPROCS pcf_fontprocs16 = {
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
-	NULL,			/* duplicate not yet implemented */
+	NULL			/* duplicate*/
 };
 
 /* These are maintained statically for ease FIXME*/
@@ -535,7 +542,7 @@ pcf_read_encoding(FILE * file, struct encoding_entry **encoding)
 		e->map[n] = f_read16(file);
 		/*DPRINTF("ncode %x (%c) %x\n", n, n, e->map[n]);*/
 	}
-	DPRINTF("size %ud byte1 %d,%d byte2 %d,%d\n", e->count,
+	DPRINTF("size %d byte1 %d,%d byte2 %d,%d\n", e->count,
 		e->min_byte1, e->max_byte1, e->min_byte2, e->max_byte2);
 	return e->count;
 }
@@ -571,8 +578,7 @@ pcf_read_toc(FILE * file, struct toc_entry **toc, uint32_t *size)
 }
 
 /* create font and allocate MWCOREFONT struct*/
-PMWCOREFONT
-pcf_createfont(const char *name, MWCOORD height, int attr)
+PMWFONT pcf_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
 	FILE *file = NULL;
 	MWCOREFONT *pf = NULL;
@@ -821,7 +827,7 @@ err_exit:
 		FCLOSE(file);
 
 	if (err == 0 && pf)
-   		return pf;
+		return (PMWFONT)pf;
 
 	pcf_unloadfont((PMWFONT)pf);
 	return 0;
diff --git a/src/engine/font_t1lib.c b/src/engine/font_t1lib.c
index 1f07fcd..da357dc 100644
--- a/src/engine/font_t1lib.c
+++ b/src/engine/font_t1lib.c
@@ -3,15 +3,29 @@
  * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
  *
  * T1lib Adobe type1 routines originally contributed by Vidar Hokstad
+ * Rewritten heavily by g haerr
  */
 /*#define NDEBUG*/
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <t1lib.h>
 #include "device.h"
 #include "devfont.h"
 
+#if (UNIX | DOS_DJGPP)
+#define strcmpi strcasecmp
+#endif
+
+/* settable parameters*/
+#ifndef T1LIB_FONT_DIR
+#define T1LIB_FONT_DIR			"fonts/type1"
+#endif
+#define T1LIB_CONFIG_FILE		"t1lib.config"
+#define T1LIB_DEFAULT_ENCODING	"IsoLatin1.enc"
+#define T1LIB_USE_AA_HIGH		1				/* 17 vs 5 level alpha*/
+
 #ifndef T1LIB_VERSION
 #define T1LIB_VERSION 0
 #endif
@@ -19,38 +33,42 @@
 #define T1_GetNoFonts	T1_Get_no_fonts	/* name change after 1.0 (tested in 5.1.2)*/
 #endif
 
-typedef struct MWT1LIBFONT {
-	PMWFONTPROCS	fontprocs;	/* common hdr*/
-	MWCOORD		fontsize;
-	int		fontrotation;
-	int		fontattr;		
-
-	int		fontid;		/* t1lib stuff*/
-} MWT1LIBFONT;
+typedef struct {
+	PMWFONTPROCS fontprocs;	/* common hdr*/
+	MWCOORD		fontsize;	/* font height in pixels*/
+	MWCOORD		fontwidth;	/* font width in pixels*/
+	int			fontrotation;
+	int			fontattr;		
+	/* t1lib specific stuff*/
+	int			fontid;
+} MWT1LIBFONT, *PMWT1LIBFONT;
 
-int  t1lib_init(PSD psd);
-PMWT1LIBFONT t1lib_createfont(const char *name, MWCOORD height,int attr);
+static int  t1lib_init(PSD psd);
+PMWFONT t1lib_createfont(const char *name, MWCOORD height,MWCOORD width, int attr);
 
 static void t1lib_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		const void *text, int cc, MWTEXTFLAGS flags);
 static MWBOOL t1lib_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
 static void t1lib_gettextsize(PMWFONT pfont, const void *text, int cc,
-		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
-		MWCOORD *pbase);
+		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase);
+static int t1lib_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width);
+static int t1lib_setfontattr(PMWFONT pfont, int setflags, int clrflags);
 static void t1lib_destroyfont(PMWFONT pfont);
 
 /* handling routines for MWT1LIBFONT*/
-static MWFONTPROCS t1lib_procs = {
+MWFONTPROCS t1lib_fontprocs = {
 	MWTF_ASCII,			/* routines expect ascii*/
+	t1lib_init,
+	t1lib_createfont,
 	t1lib_getfontinfo,
 	t1lib_gettextsize,
 	NULL,				/* gettextbits*/
 	t1lib_destroyfont,
 	t1lib_drawtext,
-	NULL,				/* setfontsize*/
+	t1lib_setfontsize,
 	NULL,				/* setfontrotation*/
-	NULL,				/* setfontattr*/
-	NULL,				/* duplicate not yet implemented */
+	t1lib_setfontattr,	/* setfontattr*/
+	NULL,				/* duplicate*/
 };
 
 /* temp extern decls*/
@@ -58,71 +76,125 @@ extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
 extern MWBOOL gr_usebg;
 
-int
+static int
 t1lib_init(PSD psd)
 {
 	char **encoding;
+	char path[256];
 	static int inited = 0;
+#if T1LIB_USE_AA_HIGH      
+	static unsigned long highblend[17] = {
+	   	0x00, 0x00, 0x04, 0x0c, 0x10, 0x14, 0x18, 0x20,
+	   	0x30, 0x38, 0x40, 0x50, 0x70, 0x80, 0xa0, 0xc0, 0xff };
+#else
+	static unsigned long lowblend[5] = { 0x00, 0x44, 0x88, 0xcc, 0xff };
+#endif
 
 	if (inited)
 		return 1;
 
+	/* set default config file directory if not otherwise specified*/
+	if (!getenv("T1LIB_CONFIG")) {
+		sprintf(path, "%s/%s", T1LIB_FONT_DIR, T1LIB_CONFIG_FILE);
+		setenv("T1LIB_CONFIG", path, 1);
+	}
+	DPRINTF("setenv '%s'\n", getenv("T1LIB_CONFIG"));
+
+	/* non-antialias mono bitmaps are byte arrays w/no padding*/
 	T1_SetBitmapPad(8);
-	if (!T1_InitLib(0))
+
+	if (!T1_InitLib(NO_LOGFILE|IGNORE_FONTDATABASE)) {
+		DPRINTF("t1lib_init: library init failed error %d\n", T1_errno);
 		return 0;
+	}
 
 	/* set default Latin1 encoding*/
-	encoding = T1_LoadEncoding("IsoLatin1.enc");
-	T1_SetDefaultEncoding(encoding);
+	encoding = T1_LoadEncoding(T1LIB_DEFAULT_ENCODING);
+	if (encoding)
+		T1_SetDefaultEncoding(encoding);
 
-#ifdef T1LIB_USE_AA_HIGH	 
+	T1_AASetBitsPerPixel(8);		/* rasterize to 8bpp alpha values*/
+#if T1LIB_USE_AA_HIGH      
 	T1_AASetLevel(T1_AA_HIGH);
-#else
+	T1_AAHSetGrayValues(highblend);
+#else      
 	T1_AASetLevel(T1_AA_LOW);
-#endif	 
-#if 0
-	/* kluge: this is required if 16bpp drawarea driver is used*/
-	if(psd->bpp == 16)
-		T1_AASetBitsPerPixel(16);
-	else
+	T1_AASetGrayValues(lowblend[0],lowblend[1],lowblend[2],lowblend[3],lowblend[4]);
 #endif
-		T1_AASetBitsPerPixel(sizeof(MWPIXELVAL)*8);
 
 	inited = 1;
 	return 1;
 }
 
-PMWT1LIBFONT
-t1lib_createfont(const char *name, MWCOORD height, int attr)
+/* open font and allocate PMWT1LIBONT structure*/
+PMWFONT
+t1lib_createfont(const char *name, MWCOORD height, MWCOORD width, int attr)
 {
-	PMWT1LIBFONT	pf;
-	int		id;
-	char *		p;
-	char		buf[256];
+	int			id;
+	char 		*p, *fontname;
+	PMWT1LIBFONT pf;
+	int			ret, ret2;
+	char		fontpath[256];
+	char		t1name[256];
+
+	/* ensure library is inited*/
+	t1lib_init(NULL);
+
+	/* if no extension specified, add .pfb, otherwise check for .pfb*/
+	strcpy(fontpath, name);
+	if ((p = strrchr(fontpath, '.')) == NULL)
+		strcat(fontpath, ".pfb");
+	else {	
+		if (strcmpi(p+1, "pfb") != 0)
+			return NULL;		/* non .pfb file specified, not type1*/
+	}
 
-	/* match name against t1 font id's from t1 font database*/
+	/* check path and filename for .pfb file*/
+	if (access(fontpath, F_OK) != 0)
+		return NULL;
+
+	/* seperate font path and filename.pfb*/
+	fontname = fontpath;
+	if ((p = strrchr(fontname, '/')) != NULL) {
+		*p++ = '\0';
+		fontname = p;
+	}
+
+	/* check if font filename.pfb is already known*/
 	for(id=0; id<T1_GetNoFonts(); ++id) {
-		strncpy(buf, T1_GetFontFileName(id), sizeof(buf));
-
-		/* remove extension*/
-		for(p=buf; *p; ++p) {
-			if(*p == '.') {
-				*p = 0;
-				break;
-			}
-		}
+		strcpy(t1name, T1_GetFontFileName(id));		/* returns .pfb name*/
 
-		if(!strcmpi(name, buf)) {
-			/* allocate font structure*/
+		if(!strcmpi(fontname, t1name))
+			goto found;
+	}
+
+	/* font filename.pfb exists but not found, add pathname and file to database*/
+	ret = T1_AddToFileSearchPath(T1_PFAB_PATH|T1_AFM_PATH, T1_APPEND_PATH, fontpath);
+	ret2 = T1_AddFont(fontname);
+	DPRINTF("path %s, filename %s, ret %d, %d\n", fontpath, fontname, ret, ret2);
+	DPRINTF("# fonts %d\n", T1_GetNoFonts());
+		
+	/* match name against t1lib font id's from t1lib FontDataBase*/
+	for(id=0; id<T1_GetNoFonts(); ++id) {
+		strcpy(t1name, T1_GetFontFileName(id));
+
+		if(!strcmpi(fontname, t1name)) {
+found:
 			pf = (PMWT1LIBFONT)calloc(sizeof(MWT1LIBFONT), 1);
 			if (!pf)
 				return NULL;
-			pf->fontprocs = &t1lib_procs;
-			GdSetFontSize((PMWFONT)pf, height);
-			GdSetFontRotation((PMWFONT)pf, 0);
-			GdSetFontAttr((PMWFONT)pf, attr, 0);
+			pf->fontprocs = &t1lib_fontprocs;
+			//pf->fontprocs->SetFontSize((PMWFONT)pf, height, width);
+			//pf->fontprocs->SetFontRotation((PMWFONT)pf, 0);
+			//pf->fontprocs->SetFontAttr((PMWFONT)pf, attr, 0);
+			pf->fontsize = height;
+			pf->fontwidth = width;
+			//T1_ExtendFont(pf->fontid, (float)width_scale);
+			pf->fontrotation = 0;
+			pf->fontattr = attr;
 			pf->fontid = id;
-			return pf;
+			DPRINTF("t1lib_createfont: using %s/%s\n", fontpath, fontname);
+			return (PMWFONT)pf;
 		}
 	}
 	return NULL;
@@ -135,193 +207,125 @@ static void
 t1lib_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 	const void *text, int cc, MWTEXTFLAGS flags)
 {
-	PMWT1LIBFONT	pf = (PMWT1LIBFONT)pfont;
-	const unsigned char *str = text;
-   	MWCOORD		width;			/* width of text area */
-	MWCOORD 	height;			/* height of text area */
-	MWCOORD		underliney;
-        GLYPH * g; /* T1lib glyph structure. Memory handling by T1lib */
-#ifdef T1LIB_USE_AA_HIGH   
-        OUTPIXELVAL	gvals[17];
-
-        /* Blending array for antialiasing. The steeper the values increase
-	 * near the end, the sharper the characters look, but also more jagged
-	 */
-        static unsigned char blend[17] = {
-	   0x00, 0x00, 0x04, 0x0c, 0x10, 0x14, 0x18, 0x20,
-	   0x30, 0x38, 0x40, 0x50, 0x70, 0x80, 0xa0, 0xc0, 0xff
-	};
-#else   
-        OUTPIXELVAL	gvals[5];
-        static unsigned char blend[5] = { 0x00, 0x44, 0x88, 0xcc, 0xff };
-#endif   
-
-        /* Check if we should throw out some fonts */
-
-        if (pf->fontattr&MWTF_ANTIALIAS) {
-#ifdef T1LIB_USE_AA_HIGH      
-	   alphablend(psd, gvals, gr_foreground, gr_background, blend, 17);
-           T1_AAHSetGrayValues(gvals);
-#else      
-	   alphablend(psd, gvals, gr_foreground, gr_background, blend, 5);
-           T1_AASetGrayValues(gvals[0],gvals[1],gvals[2],gvals[3],gvals[4]);
-#endif
-	   g = T1_AASetString(pf->fontid,(char *)str,cc,0,
-		(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0,
-		pf->fontsize * 1.0, 0);
-
-	   if (g && g->bits) {
-	      /*MWPIXELVAL save = gr_background;*/
-	      width = g->metrics.rightSideBearing - g->metrics.leftSideBearing;
-	      height = g->metrics.ascent - g->metrics.descent;
-
-	      if(flags & MWTF_BASELINE)
-		y -= g->metrics.ascent;
-	      else if(flags & MWTF_BOTTOM)
-		y -= (height - 1);
-	      underliney = y + g->metrics.ascent;
-
-	      /* FIXME: Looks damn ugly if usebg is false.
-	       * Will be handled when using alphablending in GdArea...
-	       */
-	      /* clipping handled in GdArea*/
-	      /*FIXME kluge for transparency*/
-	      /*gr_background = gr_foreground + 1;*/
-	      /*gr_usebg = 0;*/
-	      GdArea(psd,x,y, width, height, g->bits, MWPF_PIXELVAL);
-	      /*gr_background = save;*/
-
-	      if (pf->fontattr & MWTF_UNDERLINE)
-		   GdLine(psd, x, underliney, x+width, underliney, FALSE);
-
-	   }
+	PMWT1LIBFONT pf = (PMWT1LIBFONT)pfont;
+	GLYPH 		*glyph; 		/* glyph structure, memory handling by T1lib */
+	MWBLITPARMS parms;
+
+	if (pf->fontattr & MWTF_ANTIALIAS) {
+		parms.data_format = MWIF_8BPP | MWIF_HASALPHA;	/* data is 8bpp alpha channel*/
+		parms.op = MWROP_BLENDFGBG;				/* blend fg/bg with alpha channel -> dst*/
+
+		glyph = T1_AASetString(pf->fontid, (char *)text, cc, 0,
+			(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0, (float)pf->fontsize, 0);
 	} else {
-	   /* Do non-aa drawing */
-	   g = T1_SetString(pf->fontid,(char *)str,cc,0,
-			(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0,
-			pf->fontsize * 1.0, 0);
-
-	   if (g && g->bits) {
-	      unsigned char * b;
-	      int xoff;
-	      int maxy;
-	      int xmod;
-	      
-	      /* I'm sure this sorry excuse for a bitmap rendering routine can
-	       * be optimized quite a bit ;)
-	       */
-	      width = g->metrics.rightSideBearing - g->metrics.leftSideBearing;
-	      height = g->metrics.ascent - g->metrics.descent;
-
-	      if(flags & MWTF_BASELINE)
-		y -= g->metrics.ascent;
-	      else if(flags & MWTF_BOTTOM)
-		y -= (height - 1);
-	      underliney = y + g->metrics.ascent;
-	      
-	      b = g->bits;
-	      maxy = y + height;
-	      
-/*	      if ((x + width) > psd->xvirtres) {
-		 xmod = (x + width - psd->xvirtres + 7) >> 3;
-		 width = width + x + width - psd->xvirtres;
-	      } else xmod = 0;
-*/
-	      xmod = 0;
-	      while (y < maxy) {
-		 unsigned char data;
-		 xoff = 0;
-		 while (xoff < width ) {
-		    if (!(xoff % 8)) {
-		       data = *b;
-		       b++;
-		    }
-		    
-		    if (GdClipPoint(psd, x+xoff,y)) {
-		       if (gr_usebg) {
-	 		  psd->DrawPixel(psd,x+xoff,y,
-			      data & (1 << (xoff % 8)) ?
-			            gr_foreground : gr_background);
-		       } else if (data & (1 << (xoff % 8))) {
-			  psd->DrawPixel(psd,x+xoff,y, gr_foreground);
-		       }
-		    }
-		    xoff++;
-		 }
-		 b += xmod;
-		 y++;
-	      }
-	      if (pf->fontattr & MWTF_UNDERLINE)
-		   GdLine(psd, x, underliney, x+xoff, underliney, FALSE);
-	   }
-        }
-
-   if (g && g->bits) {
-	   /* Save some memory */
-	   free(g->bits);
-           g->bits = 0; /* Make sure T1lib doesnt try to free it again */
-   }
-
-   GdFixCursor(psd);
-}
+		/* Do non-antialiased drawing */
+		parms.data_format = MWIF_MONOBYTELSB;	/* data is 1bpp bytes, lsb first*/
+		parms.op = MWROP_COPY;					/* copy to dst, 1=fg (0=bg if usebg)*/
 
-static MWBOOL
-t1lib_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
-{
-	int	i;
-	MWCOORD	width, height, baseline;
+		glyph = T1_SetString(pf->fontid, (char *)text, cc, 0,
+				(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0, (float)pf->fontsize, 0);
+	}
 
-	/* FIXME, guess all sizes*/
-	GdGetTextSize(pfont, "A", 1, &width, &height, &baseline, MWTF_ASCII);
-	pfontinfo->height = height;
-	pfontinfo->maxwidth = width;
-	pfontinfo->baseline = baseline;
+	if (glyph && glyph->bits) {
+		int width = glyph->metrics.rightSideBearing - glyph->metrics.leftSideBearing;
+		int height = glyph->metrics.ascent - glyph->metrics.descent;
+
+		if(flags & MWTF_BASELINE)
+			y -= glyph->metrics.ascent;
+		else if(flags & MWTF_BOTTOM)
+			y -= height - 1;
+
+		parms.fg_color = gr_foreground;
+		parms.bg_color = gr_background;
+		parms.usebg = gr_usebg;
+		parms.srcx = 0;
+		parms.srcy = 0;
+		parms.dst_pitch = 0;		/* set later in GdConversionBlit*/
+		parms.data_out = 0;			/* set later in GdConversionBlit*/
+		parms.dstx = x;
+		parms.dsty = y;
+		parms.height = height;
+		parms.width = width;
+		parms.data = (char *)glyph->bits;
+		if (pf->fontattr & MWTF_ANTIALIAS)
+			parms.src_pitch = width;
+		else
+			parms.src_pitch = (width + 7) >> 3;	/* pad to BYTE boundary*/
+		GdConversionBlit(psd, &parms);
+
+		if (pf->fontattr & MWTF_UNDERLINE) {
+			int underliney = y + glyph->metrics.ascent;
+			GdLine(psd, x, underliney, x+width, underliney, FALSE);
+		}
 
-	/* FIXME: Even worse guesses */
-	pfontinfo->linespacing = pfontinfo->height;
-	pfontinfo->descent = pfontinfo->height - pfontinfo->baseline;
-	pfontinfo->maxascent = pfontinfo->baseline;
-	pfontinfo->maxdescent = pfontinfo->descent;
+		/* cleanup*/
+		free(glyph->bits);
+		glyph->bits = NULL;
+	}
 
-	pfontinfo->firstchar = 32;
-	pfontinfo->lastchar = 255;
-	pfontinfo->fixed = TRUE;
-	for(i=0; i<256; ++i)
-		pfontinfo->widths[i] = width;
-	return TRUE;
+	GdFixCursor(psd);
 }
 
-/* Get the width and height of passed text string in the current font*/
+/* Get the width and height of passed text string in the passed font*/
 static void
 t1lib_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
-	PMWT1LIBFONT		pf = (PMWT1LIBFONT)pfont;
-	const unsigned char *	str = text;
-	GLYPH *			g;
-
-	g = T1_SetString(pf->fontid, (char *)str, cc, 0,
-			(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0, pf->fontsize * 1.0, 0);
-	*pwidth = g->metrics.rightSideBearing - g->metrics.leftSideBearing;
-	*pheight = g->metrics.ascent - g->metrics.descent;
-	*pbase = g->metrics.ascent;
-	if(g && g->bits) {
-		free(g->bits);
-		g->bits = 0;
+	PMWT1LIBFONT	pf = (PMWT1LIBFONT)pfont;
+	GLYPH *			glyph;
+
+	glyph = T1_SetString(pf->fontid, (char *)text, cc, 0,
+			(pf->fontattr&MWTF_KERNING)? T1_KERNING: 0, (float)pf->fontsize, 0);
+	if (!glyph) {
+		*pwidth = *pheight = *pbase = 20;
+		return;
+	}
+	*pwidth = glyph->metrics.rightSideBearing - glyph->metrics.leftSideBearing;
+	*pheight = glyph->metrics.ascent - glyph->metrics.descent;
+	*pbase = glyph->metrics.ascent;
+
+	if(glyph && glyph->bits) {
+		free(glyph->bits);
+		glyph->bits = NULL;
 	}
 #if 0
 	BBox 			b;
 
-	/* FIXME. Something is *VERY* wrong here */
-	b = T1_GetStringBBox(pf->fontid, str, cc, 0, (pf->fontattr&MWTF_KERNING)?T1_KERNING:0);
+	/* FIXME must change from char points (1000bp) to pixels*/
+	b = T1_GetStringBBox(pf->fontid, text, cc, 0, (pf->fontattr&MWTF_KERNING)?T1_KERNING:0);
+
+	printf("b.urx = %d, b.llx = %d\n",b.urx, b.llx);
+	printf("b.ury = %d, b.lly = %d\n",b.ury, b.lly);
 
-	DPRINTF("b.urx = %d, b.llx = %d\n",b.urx, b.llx);
-	DPRINTF("b.ury = %d, b.lly = %d\n",b.ury, b.lly);
+	/* NXLIB, X11*/
 	*pwidth = (b.urx - b.llx);
 	*pheight = (b.lly - b.ury);
 #endif
 }
 
+static int
+t1lib_setfontsize(PMWFONT pfont, MWCOORD height, MWCOORD width)
+{
+	PMWT1LIBFONT pf = (PMWT1LIBFONT)pfont;
+	MWCOORD oldsize = pf->fontsize;
+
+	pf->fontsize = height;
+	pf->fontwidth = width;
+
+	return oldsize;
+}
+
+static int
+t1lib_setfontattr(PMWFONT pfont, int setflags, int clrflags)
+{
+	int	oldattr = pfont->fontattr;
+
+	pfont->fontattr &= ~clrflags;
+	pfont->fontattr |= setflags;
+
+	return oldattr;
+}
+
 static void
 t1lib_destroyfont(PMWFONT pfont)
 {
@@ -330,3 +334,31 @@ t1lib_destroyfont(PMWFONT pfont)
 	T1_DeleteAllSizes(pf->fontid);
 	free(pf);
 }
+
+static MWBOOL
+t1lib_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
+{
+	PMWT1LIBFONT	pf = (PMWT1LIBFONT)pfont;
+	int				i;
+	MWCOORD			width, height, baseline;
+
+	/* FIXME guess all sizes*/
+	pfont->fontprocs->GetTextSize(pfont, "H", 1, MWTF_ASCII, &width, &height, &baseline);
+	pfontinfo->maxwidth = width;
+	pfontinfo->height = height;						/* character height only, not cell height*/
+	pfontinfo->baseline = baseline;
+
+	/* FIXME even worse guesses */
+	pfontinfo->descent = height - baseline;
+	pfontinfo->maxdescent = pfontinfo->descent;
+	pfontinfo->maxascent = baseline;
+	pfontinfo->linespacing = height + 4;			/* add margin for cell height/linespacing*/
+
+	pfontinfo->firstchar = 32;
+	pfontinfo->lastchar = 255;
+	pfontinfo->fixed = T1_GetIsFixedPitch(pf->fontid);
+
+	for(i=0; i<256; ++i)
+		pfontinfo->widths[i] = width;		/* FIXME lookup each width with gettextsize?*/
+	return TRUE;
+}
diff --git a/src/engine/image_jpeg.c b/src/engine/image_jpeg.c
index 53b899b..9a4e628 100644
--- a/src/engine/image_jpeg.c
+++ b/src/engine/image_jpeg.c
@@ -105,7 +105,7 @@ GdDecodeJPEG(buffer_t * src, PMWIMAGEHDR pimage, PSD psd, MWBOOL fast_grayscale)
 		return 0;	/* not JPEG image */
 
 	if (GdImageBufferRead(src, magic, 8) != 8
-	 || (strncmp(&magic[4], "JFIF", 4) != 0 && strncmp(&magic[4], "Exif", 4) != 0))
+	 || (strncmp((char *)&magic[4], "JFIF", 4) != 0 && strncmp((char *)&magic[4], "Exif", 4) != 0))
 		return 0;	/* not JPEG image */
 
 	GdImageBufferSeekTo(src, 0);
diff --git a/src/engine/image_pnm.c b/src/engine/image_pnm.c
index 943d85c..0b8b171 100644
--- a/src/engine/image_pnm.c
+++ b/src/engine/image_pnm.c
@@ -57,7 +57,7 @@ GdDecodePNM(buffer_t *src, PMWIMAGEHDR pimage)
 		return 0;
 
 	n = 0;
-	while((p = GdImageBufferGetString(src, buf, 256))) {
+	while((p = (unsigned char *)GdImageBufferGetString(src, buf, sizeof(buf)))) {
 		if(buf[0] == '#')
 			continue;
 		if(type == PNM_TYPE_PBM) {
diff --git a/src/fontdemo2.sh b/src/fontdemo2.sh
index c062de7..b041473 100755
--- a/src/fontdemo2.sh
+++ b/src/fontdemo2.sh
@@ -1,4 +1,5 @@
 
 # Nano-X applications, press <BREAK> key to exit
-T1LIB_CONFIG=./fonts/t1lib/t1lib.config bin/nano-X -L & bin/nanowm & bin/ftdemo
+#T1LIB_CONFIG=./fonts/type1/t1lib.config bin/nano-X -L & bin/nanowm & bin/ftdemo
+bin/nano-X -N & bin/nanowm & bin/ftdemo & bin/tux
 
diff --git a/src/fonts/type1/t1lib.config b/src/fonts/type1/t1lib.config
index f11e550..7288beb 100644
--- a/src/fonts/type1/t1lib.config
+++ b/src/fonts/type1/t1lib.config
@@ -1,9 +1,16 @@
 This is the global configuration file for t1lib.
-Must set environment variable T1LIB_CONFIG=<path to this file>
+If this file is moved to another location, the
+T1LIB_FONT_DIR must be set and/or the
+environment variable set T1LIB_CONFIG=<path to this file>.
 
 The paths to the following locations are relative to
 the application's current directory, not this file.
 
+Currently, the T1LIB font subdriver is written to ignore
+the fontdatabase, and allow any .pfb fonts, provided that the
+path to these fonts is in the afm and type1 entries below,
+seperated by colons.
+
 FONTDATABASE=fonts/type1/FontDataBase
 ENCODING=fonts/type1
 AFM=fonts/type1:/usr/share/fonts/X11/Type1
diff --git a/src/include/device.h b/src/include/device.h
index 330a18c..969b493 100644
--- a/src/include/device.h
+++ b/src/include/device.h
@@ -93,9 +93,9 @@
 /* Which low-level psd->DrawArea routines to include. */
 #define MW_FEATURE_PSDOP_COPY                   1
 #define MW_FEATURE_PSDOP_ALPHAMAP               0
-#define MW_FEATURE_PSDOP_ALPHACOL               0
-#define MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST 0
-#define MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST 0
+#define MW_FEATURE_PSDOP_ALPHACOL               1
+#define MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST 1
+#define MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST 1
 
 /* Override some of the above defines, for features which are required
  * for the Microwindows FreeType 2 font driver
@@ -421,13 +421,9 @@ void	GdClearFontList(void);
 int	GdAddFont(char *fndry, char *family, char *fontname, PMWLOGFONT lf,
 		  unsigned int flags);
 PMWFONT	GdSetFont(PMWFONT pfont);
-PMWFONT GdCreateFont(PSD psd, const char *name, MWCOORD height,
+PMWFONT GdCreateFont(PSD psd, const char *name, MWCOORD height, MWCOORD width,
 		const PMWLOGFONT plogfont);
-#if STANDALONE
 MWCOORD	GdSetFontSize(PMWFONT pfont, MWCOORD height, MWCOORD width);
-#else
-MWCOORD	GdSetFontSize(PMWFONT pfont, MWCOORD height); // DEPRECATED
-#endif
 void GdGetFontList(MWFONTLIST ***list, int *num);
 void GdFreeFontList(MWFONTLIST ***list, int num);
 int	GdSetFontRotation(PMWFONT pfont, int tenthdegrees);
@@ -444,8 +440,8 @@ int	GdGetTextSizeEx(PMWFONT pfont, const void *str, int cc,
 void	GdText(PSD psd,MWCOORD x,MWCOORD y,const void *str,int count,
 		MWTEXTFLAGS flags);
 PMWFONT	GdCreateFontFromBuffer(PSD psd, const unsigned char *buffer,
-		unsigned length, const char *format, MWCOORD height);
-PMWFONT	GdDuplicateFont(PSD psd, PMWFONT psrcfont, MWCOORD fontsize);
+		unsigned length, const char *format, MWCOORD height, MWCOORD width);
+PMWFONT	GdDuplicateFont(PSD psd, PMWFONT psrcfont, MWCOORD height, MWCOORD width);
 
 
 /* both devclip1.c and devclip2.c */
diff --git a/src/include/mwtypes.h b/src/include/mwtypes.h
index 8faaa7f..894fa66 100644
--- a/src/include/mwtypes.h
+++ b/src/include/mwtypes.h
@@ -320,10 +320,10 @@ typedef struct {
 	unsigned char *	physpixels;	/* address of real framebuffer*/
 	/* note winpixels is only correct in non-portrait modes*/
 	unsigned char *	winpixels;	/* address of 0,0 this window in fb*/
-	int	pixtype;	/* MWPF_ pixel type*/
-	int	bpp;		/* bits per pixel*/
-	int	bytespp;	/* bytes per pixel*/
-	int	pitch;		/* bytes per scan line for window (=fb pitch)*/
+	int	pixtype;		/* MWPF_ pixel type*/
+	int	bpp;			/* bits per pixel*/
+	int	bytespp;		/* bytes per pixel*/
+	int	pitch;			/* bytes per scan line for window (=fb pitch)*/
 	MWCOORD	x, y;		/* absolute window coordinates*/
 	int	portrait_mode;	/* current portrait mode*/
 	MWCOORD	xres;		/* real framebuffer resolution*/
@@ -354,10 +354,8 @@ typedef struct _mwfontinfo *	PMWFONTINFO;
 
 typedef struct {
 	MWTEXTFLAGS	encoding;	/* routines expect this encoding*/
-#if STANDALONE
 	MWBOOL	(*Init)(PSD psd);
 	PMWFONT	(*CreateFont)(const char *name, MWCOORD height, MWCOORD width, int attr);
-#endif
 	MWBOOL	(*GetFontInfo)(PMWFONT pfont, PMWFONTINFO pfontinfo);
 	void 	(*GetTextSize)(PMWFONT pfont, const void *text, int cc,
 			MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
@@ -367,24 +365,17 @@ typedef struct {
 	void	(*DestroyFont)(PMWFONT pfont);
 	void	(*DrawText)(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 			const void *str, int count, MWTEXTFLAGS flags);
-#if STANDALONE
-	void    (*SetFontSize)(PMWFONT pfont, MWCOORD height, MWCOORD width);
-#else
-	void    (*SetFontSize)(PMWFONT pfont, MWCOORD height); // DEPRECATED
-#endif
+	int     (*SetFontSize)(PMWFONT pfont, MWCOORD height, MWCOORD width);
 	void    (*SetFontRotation)(PMWFONT pfont, int tenthdegrees);
-	void    (*SetFontAttr)(PMWFONT pfont, int setflags, int clrflags);
-#if STANDALONE
+	int     (*SetFontAttr)(PMWFONT pfont, int setflags, int clrflags);
 	PMWFONT (*Duplicate) (PMWFONT psrcfont, MWCOORD height, MWCOORD width);
-#else
-	PMWFONT (*Duplicate) (PMWFONT psrcfont, MWCOORD height); // DEPRECATED
-#endif
 } MWFONTPROCS, *PMWFONTPROCS;
 
 /* new multi-renderer font struct*/
 typedef struct _mwfont {		/* common hdr for all font structures*/
 	PMWFONTPROCS	fontprocs;	/* font-specific rendering routines*/
 	MWCOORD			fontsize;	/* font height in pixels*/
+	MWCOORD			fontwidth;	/* font width in pixels*/
 	int				fontrotation; /* font rotation*/
 	int				fontattr;	/* font attributes: kerning/antialias*/
 	/* font-specific rendering data here*/
@@ -392,8 +383,10 @@ typedef struct _mwfont {		/* common hdr for all font structures*/
 
 /* builtin core font struct*/
 typedef struct {
-	PMWFONTPROCS	fontprocs;	/* common hdr*/
-	MWCOORD			fontsize;
+	/* common hdr*/
+	PMWFONTPROCS	fontprocs;
+	MWCOORD			fontsize;	/* font height in pixels*/
+	MWCOORD			fontwidth;	/* font width in pixels*/
 	int				fontrotation;
 	int				fontattr;
 	/* core font specific data*/
@@ -426,13 +419,13 @@ typedef struct { // DEPRECATED
 	MWCOORD width, height;
 	MWCOORD dstx, dsty;
 	MWCOORD srcx, srcy;
-	MWPIXELVAL bg_color;
 	MWPIXELVAL fg_color;
+	MWPIXELVAL bg_color;
 	int usebg;
 	void *data;
 
+	MWCOORD src_linelen;		// must be set in GdConversionBlit
 	MWCOORD dst_linelen;		// must be set in GdConversionBlit
-	MWCOORD src_linelen;
 } driver_gc_t;
 
 /**
@@ -587,19 +580,19 @@ typedef struct {
 
 /* windows-compatible MWLOGFONT structure*/
 typedef struct {
-	int	lfHeight;		/* desired height in pixels*/
-	int	lfWidth;		/* desired width in pixels or 0*/
-	int	lfEscapement;		/* rotation in tenths of degree*/
-	int	lfOrientation;		/* not used*/
-	int	lfWeight;		/* font weight*/
+	int32_t	lfHeight;		/* desired height in pixels*/
+	int32_t	lfWidth;		/* desired width in pixels or 0*/
+	int32_t	lfEscapement;	/* rotation in tenths of degree*/
+	int32_t	lfOrientation;	/* not used*/
+	int32_t	lfWeight;		/* font weight*/
 	MWUCHAR	lfItalic;		/* =1 for italic */
-	MWUCHAR	lfUnderline;		/* =1 for underline */
-	MWUCHAR	lfStrikeOut;		/* not used*/
+	MWUCHAR	lfUnderline;	/* =1 for underline */
+	MWUCHAR	lfStrikeOut;	/* not used*/
 	MWUCHAR	lfCharSet;		/* font character set*/
-	MWUCHAR	lfOutPrecision;		/* font type selection*/
-	MWUCHAR	lfClipPrecision;	/* not used*/
+	MWUCHAR	lfOutPrecision;	/* font type selection*/
+	MWUCHAR	lfClipPrecision;/* not used*/
 	MWUCHAR	lfQuality;		/* not used*/
-	MWUCHAR lfPitchAndFamily;	/* not used*/
+	MWUCHAR lfPitchAndFamily;/* not used*/
 	/* end of windows-compatibility*/
 
 	MWUCHAR lfClass;		/* font class (renderer) */
@@ -611,12 +604,12 @@ typedef struct {
 	MWUCHAR	lfPitch;		/* font pitch */
 	MWUCHAR	lfRoman;		/* =1 for Roman letters (upright) */
 	MWUCHAR	lfSerif;		/* =1 for Serifed font */
-	MWUCHAR	lfSansSerif;		/* =1 for Sans-serif font */
+	MWUCHAR	lfSansSerif;	/* =1 for Sans-serif font */
 	MWUCHAR	lfModern;		/* =1 for Modern font */
-	MWUCHAR	lfMonospace;		/* =1 for Monospaced font */
-	MWUCHAR	lfProportional;		/* =1 for Proportional font */
+	MWUCHAR	lfMonospace;	/* =1 for Monospaced font */
+	MWUCHAR	lfProportional;	/* =1 for Proportional font */
 	MWUCHAR	lfOblique;		/* =1 for Oblique (kind of Italic) */
-	MWUCHAR	lfSmallCaps;		/* =1 for small caps */
+	MWUCHAR	lfSmallCaps;	/* =1 for small caps */
 	/* End of fontmapper-only variables */
 
 	/* render-dependent full path or facename here*/
diff --git a/src/include/nano-X.h b/src/include/nano-X.h
index c928ea2..c75bc9d 100644
--- a/src/include/nano-X.h
+++ b/src/include/nano-X.h
@@ -191,6 +191,7 @@ typedef struct {
 #define GR_WM_PROPS_NODECORATE	 0x00000010L /* Don't redecorate window*/
 #define GR_WM_PROPS_NOAUTOMOVE	 0x00000020L /* Don't move window on 1st map*/
 #define GR_WM_PROPS_NOAUTORESIZE 0x00000040L /* Don't resize window on 1st map*/
+#define GR_WM_PROPS_NORESIZE	 0x00000080L /* Don't let user resize window*/
 
 /* default decoration style*/
 #define GR_WM_PROPS_APPWINDOW	0x00000000L /* Leave appearance to WM*/
@@ -447,6 +448,11 @@ typedef struct {
   GR_EVENT_TYPE type;		/**< event type */
   GR_WINDOW_ID wid;		/**< window id */
   GR_WINDOW_ID otherid;		/**< new/old focus id for focus events*/
+  						/**< for mouse enter only the following are valid:*/
+  GR_COORD rootx;		/**< root window x coordinate */
+  GR_COORD rooty;		/**< root window y coordinate */
+  GR_COORD x;			/**< window x coordinate of mouse */
+  GR_COORD y;			/**< window y coordinate of mouse */
 } GR_EVENT_GENERAL;
 
 /**
@@ -747,12 +753,12 @@ void		GrXorRegion(GR_REGION_ID dst_rgn, GR_REGION_ID src_rgn1,
 void		GrSetGCRegion(GR_GC_ID gc, GR_REGION_ID region);
 void		GrSetGCClipOrigin(GR_GC_ID gc, int x, int y);
 GR_BOOL		GrPointInRegion(GR_REGION_ID region, GR_COORD x, GR_COORD y);
-int		GrRectInRegion(GR_REGION_ID region, GR_COORD x, GR_COORD y,
+int			GrRectInRegion(GR_REGION_ID region, GR_COORD x, GR_COORD y,
 			GR_COORD w, GR_COORD h);
 GR_BOOL		GrEmptyRegion(GR_REGION_ID region);
 GR_BOOL		GrEqualRegion(GR_REGION_ID rgn1, GR_REGION_ID rgn2);
 void		GrOffsetRegion(GR_REGION_ID region, GR_SIZE dx, GR_SIZE dy);
-int		GrGetRegionBox(GR_REGION_ID region, GR_RECT *rect);
+int			GrGetRegionBox(GR_REGION_ID region, GR_RECT *rect);
 void		GrMapWindow(GR_WINDOW_ID wid);
 void		GrUnmapWindow(GR_WINDOW_ID wid);
 void		GrRaiseWindow(GR_WINDOW_ID wid);
@@ -764,19 +770,22 @@ void		GrReparentWindow(GR_WINDOW_ID wid, GR_WINDOW_ID pwid,
 void		GrGetWindowInfo(GR_WINDOW_ID wid, GR_WINDOW_INFO *infoptr);
 void		GrSetWMProperties(GR_WINDOW_ID wid, GR_WM_PROPERTIES *props);
 void		GrGetWMProperties(GR_WINDOW_ID wid, GR_WM_PROPERTIES *props);
-GR_FONT_ID	GrCreateFont(GR_CHAR *name, GR_COORD height,
-			GR_LOGFONT *plogfont);
+
+GR_FONT_ID	GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont); // DEPRECATED
+GR_FONT_ID	GrCreateFontEx(GR_CHAR *name, GR_COORD height, GR_COORD width, GR_LOGFONT *plogfont);
 GR_FONT_ID	GrCreateFontFromBuffer(const void *buffer, unsigned length,
-			const char *format, GR_COORD height);
-GR_FONT_ID	GrCopyFont(GR_FONT_ID fontid, GR_COORD height);
+			const char *format, GR_COORD height, GR_COORD width);
+GR_FONT_ID	GrCopyFont(GR_FONT_ID fontid, GR_COORD height, GR_COORD width);
 void		GrGetFontList(GR_FONTLIST ***fonts, int *numfonts);
 void		GrFreeFontList(GR_FONTLIST ***fonts, int numfonts);
-void		GrSetFontSize(GR_FONT_ID fontid, GR_COORD size);
+void		GrSetFontSize(GR_FONT_ID fontid, GR_COORD size); // DEPRECATED
+void		GrSetFontSizeEx(GR_FONT_ID fontid, GR_COORD height, GR_COORD width);
 void		GrSetFontRotation(GR_FONT_ID fontid, int tenthsdegrees);
 void		GrSetFontAttr(GR_FONT_ID fontid, int setflags, int clrflags);
 void		GrDestroyFont(GR_FONT_ID fontid);
 void		GrGetFontInfo(GR_FONT_ID font, GR_FONT_INFO *fip);
 GR_WINDOW_ID	GrGetFocus(void);
+
 void		GrSetFocus(GR_WINDOW_ID wid);
 void		GrClearArea(GR_WINDOW_ID wid, GR_COORD x, GR_COORD y,
 			GR_SIZE width, GR_SIZE height, GR_BOOL exposeflag);
@@ -786,12 +795,12 @@ int             GrGetTypedEvent(GR_WINDOW_ID wid, GR_EVENT_MASK mask,
 			GR_UPDATE_TYPE update, GR_EVENT *ep, GR_BOOL block);
 typedef GR_BOOL (*GR_TYPED_EVENT_CALLBACK)(GR_WINDOW_ID, GR_EVENT_MASK,
 			GR_UPDATE_TYPE, GR_EVENT *, void *);
-int             GrGetTypedEventPred(GR_WINDOW_ID wid, GR_EVENT_MASK mask, 
+int			GrGetTypedEventPred(GR_WINDOW_ID wid, GR_EVENT_MASK mask, 
 			GR_UPDATE_TYPE update, GR_EVENT * ep, GR_BOOL block, 
 			GR_TYPED_EVENT_CALLBACK matchfn, void *arg);
 void		GrGetNextEventTimeout(GR_EVENT *ep, GR_TIMEOUT timeout);
 void		GrCheckNextEvent(GR_EVENT *ep);
-int		GrPeekEvent(GR_EVENT *ep);
+int			GrPeekEvent(GR_EVENT *ep);
 void		GrPeekWaitEvent(GR_EVENT *ep);
 void		GrCopyEvent(GR_EVENT *dst, GR_EVENT *src);
 void		GrFreeEvent(GR_EVENT *ev);
@@ -824,14 +833,12 @@ void		GrSetGCBackground(GR_GC_ID gc, GR_COLOR background);
 void		GrSetGCBackgroundPixelVal(GR_GC_ID gc, GR_PIXELVAL background);
 void		GrSetGCUseBackground(GR_GC_ID gc, GR_BOOL flag);
 void		GrSetGCMode(GR_GC_ID gc, int mode);
-
 void            GrSetGCLineAttributes(GR_GC_ID, int);
 void            GrSetGCDash(GR_GC_ID, char *, int);
 void            GrSetGCFillMode(GR_GC_ID, int);
 void            GrSetGCStipple(GR_GC_ID, GR_BITMAP *, GR_SIZE, GR_SIZE);
 void            GrSetGCTile(GR_GC_ID, GR_WINDOW_ID, GR_SIZE, GR_SIZE);
 void            GrSetGCTSOffset(GR_GC_ID, GR_COORD, GR_COORD);
-
 void            GrSetGCGraphicsExposure(GR_GC_ID gc, GR_BOOL exposure);
 void		GrSetGCFont(GR_GC_ID gc, GR_FONT_ID font);
 void		GrGetGCTextSize(GR_GC_ID gc, void *str, int count,
diff --git a/src/include/nanowm.h b/src/include/nanowm.h
index e94983c..2806d22 100644
--- a/src/include/nanowm.h
+++ b/src/include/nanowm.h
@@ -17,7 +17,9 @@
 /* default window style for GR_WM_PROPS_APPWINDOW*/
 #define DEFAULT_WINDOW_STYLE	(GR_WM_PROPS_APPFRAME | GR_WM_PROPS_CAPTION | GR_WM_PROPS_CLOSEBOX)
 
-#ifdef WMDEBUG
+#define WMDEBUG	0
+
+#if WMDEBUG
 #define Dprintf printf
 #else
 #define Dprintf(ignore...)
@@ -120,6 +122,8 @@ void wm_container_exposure(win *window, GR_EVENT_EXPOSURE *event);
 void wm_container_buttondown(win *window, GR_EVENT_BUTTON *event);
 void wm_container_buttonup(win *window, GR_EVENT_BUTTON *event);
 void wm_container_mousemoved(win *window, GR_EVENT_MOUSE *event);
+void wm_container_mouse_enter(win *window, GR_EVENT_GENERAL *event);
+void wm_container_mouse_exit(win *window, GR_EVENT_GENERAL *event);
 
 #if 0000
 /*
diff --git a/src/mwin/winfont.c b/src/mwin/winfont.c
index 9833243..7c6f1a5 100644
--- a/src/mwin/winfont.c
+++ b/src/mwin/winfont.c
@@ -110,9 +110,9 @@ CreateFontIndirect(CONST LOGFONT *lplf)
 			strcat(mwlf.lfFaceName, "i");
 	}
 
-	hfont->pfont = GdCreateFont(&scrdev, NULL, 0, &mwlf);
+	hfont->pfont = GdCreateFont(&scrdev, NULL, 0, 0, &mwlf);
 	if (!hfont->pfont)
-		hfont->pfont = GdCreateFont(&scrdev, NULL, 0, NULL);
+		hfont->pfont = GdCreateFont(&scrdev, NULL, 0, 0, NULL);
 
 	return (HFONT)hfont;
 }
@@ -319,7 +319,7 @@ EnumFonts(
 			return 0;
 	}
 
-#if (HAVE_FREETYPE_SUPPORT | HAVE_FREETYPE_2_SUPPORT)
+#if HAVE_FREETYPE_SUPPORT
 	if (freetype_init(psd)) {
 		int		n = 0;
 		char		*p;
diff --git a/src/mwin/wingdi.c b/src/mwin/wingdi.c
index 5952fd7..1be1adb 100644
--- a/src/mwin/wingdi.c
+++ b/src/mwin/wingdi.c
@@ -1501,11 +1501,9 @@ GetStockObject(int nObject)
 		if(pObj->hdr.type == OBJ_FONT) {
 			pFont = (MWFONTOBJ *)pObj;
 			if(pFont->pfont == NULL) {
-				pFont->pfont = GdCreateFont(&scrdev,
-					pFont->name, 0, NULL);
+				pFont->pfont = GdCreateFont(&scrdev, pFont->name, 0, 0, NULL);
 				if (!pFont->pfont)
-					pFont->pfont = GdCreateFont(&scrdev,
-						NULL, 0, NULL);
+					pFont->pfont = GdCreateFont(&scrdev, NULL, 0, 0, NULL);
 			}
 			return pObj;
 		}
diff --git a/src/nanox/client.c b/src/nanox/client.c
index aa4f6ac..8151a30 100644
--- a/src/nanox/client.c
+++ b/src/nanox/client.c
@@ -2508,6 +2508,13 @@ GrSetGCUseBackground(GR_GC_ID gc, GR_BOOL flag)
 	UNLOCK(&nxGlobalLock);
 }
 
+/* DEPRECATED - use GrCreateFontEx*/
+GR_FONT_ID
+GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
+{
+	return GrCreateFontEx(name, height, height, plogfont);
+}
+
 /**
  * Attempts to locate a font with the desired attributes and returns a font
  * ID number which can be used to refer to it. If the plogfont argument is
@@ -2519,13 +2526,14 @@ GrSetGCUseBackground(GR_GC_ID gc, GR_BOOL flag)
  *
  * @param name  string containing the name of a built in font to look for
  * @param height  the desired height of the font
+ * @param width  the desired width of the font
  * @param plogfont  pointer to a LOGFONT structure
  * @return a font ID number which can be used to refer to the font
  *
  * @ingroup nanox_font
  */
 GR_FONT_ID
-GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
+GrCreateFontEx(GR_CHAR *name, GR_COORD height, GR_COORD width, GR_LOGFONT *plogfont)
 {
 	GR_FONT_ID	fontid;
 
@@ -2542,16 +2550,17 @@ GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
 	}
 	else
 	{
-		nxCreateFontReq *req;
+		nxCreateFontExReq *req;
 
 		if (!name)
 			name = "";
 
-		req = AllocReqExtra(CreateFont, strlen(name) + 1);
+		req = AllocReqExtra(CreateFontEx, strlen(name) + 1);
 		req->height = height;
+		req->width = width;
 		strcpy((char *)GetReqData(req), name);
 
-		if (TypedReadBlock(&fontid, sizeof(fontid), GrNumCreateFont) == -1)
+		if (TypedReadBlock(&fontid, sizeof(fontid), GrNumCreateFontEx) == -1)
 			fontid = 0;
 	}
 
@@ -2639,6 +2648,13 @@ GrFreeFontList(GR_FONTLIST ***fonts, int numfonts)
 	UNLOCK(&nxGlobalLock);
 }
 
+/* DEPRECATED - use GrSetFontSizeEx*/
+void
+GrSetFontSize(GR_FONT_ID fontid, GR_COORD height)
+{
+	GrSetFontSizeEx(fontid, height, height);
+}
+
 /**
  * Changes the size of the specified font to the specified size.
  *
@@ -2648,14 +2664,15 @@ GrFreeFontList(GR_FONTLIST ***fonts, int numfonts)
  * @ingroup nanox_font
  */
 void
-GrSetFontSize(GR_FONT_ID fontid, GR_COORD size)
+GrSetFontSizeEx(GR_FONT_ID fontid, GR_COORD height, GR_COORD width)
 {
-	nxSetFontSizeReq *req;
+	nxSetFontSizeExReq *req;
 
 	LOCK(&nxGlobalLock);
-	req = AllocReq(SetFontSize);
+	req = AllocReq(SetFontSizeEx);
 	req->fontid = fontid;
-	req->fontsize = size;
+	req->height = height;
+	req->width = width;
 	UNLOCK(&nxGlobalLock);
 }
 
@@ -4781,7 +4798,7 @@ GrSetTransform(GR_TRANSFORM *trans)
  */
 GR_FONT_ID
 GrCreateFontFromBuffer(const void *buffer, unsigned length,
-		       const char *format, GR_COORD height)
+	const char *format, GR_COORD height, GR_COORD width)
 {
 	GR_FONT_ID result;
 	nxCreateFontFromBufferReq *req;
@@ -4799,6 +4816,7 @@ GrCreateFontFromBuffer(const void *buffer, unsigned length,
 
 	req = AllocReq(CreateFontFromBuffer);
 	req->height = height;
+	req->width = width;
 	req->buffer_id = bufid;
 
 	if (format == NULL)
@@ -4827,7 +4845,7 @@ GrCreateFontFromBuffer(const void *buffer, unsigned length,
  * @ingroup nanox_font
  */
 GR_FONT_ID
-GrCopyFont(GR_FONT_ID fontid, GR_COORD height)
+GrCopyFont(GR_FONT_ID fontid, GR_COORD height, GR_COORD width)
 {
 	GR_FONT_ID result;
 	nxCopyFontReq *req;
@@ -4836,6 +4854,7 @@ GrCopyFont(GR_FONT_ID fontid, GR_COORD height)
 	req = AllocReq(CopyFont);
 	req->fontid = fontid;
 	req->height = height;
+	req->width = width;
 
 	if (TypedReadBlock(&result, sizeof(result), GrNumCopyFont) == -1)
 		result = 0;
diff --git a/src/nanox/nxproto.h b/src/nanox/nxproto.h
index cc46baf..30a7f74 100644
--- a/src/nanox/nxproto.h
+++ b/src/nanox/nxproto.h
@@ -621,23 +621,24 @@ typedef struct {
 	UINT32	op;
 } nxCopyAreaReq;
 
-#define GrNumSetFontSize        52
+#define GrNumSetFontSizeEx      52
 typedef struct {
 	BYTE8	reqType;
 	BYTE8	hilength;
 	UINT16	length;
 	IDTYPE	fontid;
-	INT16	fontsize;
-} nxSetFontSizeReq;
+	INT16	height;
+	INT16	width;
+} nxSetFontSizeExReq;
 
-#define GrNumCreateFont		53
+#define GrNumCreateFontEx		53
 typedef struct {
 	BYTE8	reqType;
 	BYTE8	hilength;
 	UINT16	length;
 	INT16	height;
-	INT16	padding;
-} nxCreateFontReq;
+	INT16	width;
+} nxCreateFontExReq;
 
 #define GrNumDestroyFont	54
 typedef struct {
@@ -1354,7 +1355,7 @@ typedef struct {
 	UINT32 buffer_id;
 	BYTE8 format[16];
 	INT16 height;
-	UINT16 padding;
+	INT16 width;
 } nxCreateFontFromBufferReq;
 
 #define GrNumCopyFont		124
@@ -1364,6 +1365,7 @@ typedef struct {
 	UINT16 length;
 	IDTYPE fontid;
 	INT16 height;
+	INT16 width;
 } nxCopyFontReq;
 
 #define GrNumDrawImagePartToFit     125
diff --git a/src/nanox/srvevent.c b/src/nanox/srvevent.c
index 5ca8876..e5c2e9a 100644
--- a/src/nanox/srvevent.c
+++ b/src/nanox/srvevent.c
@@ -777,7 +777,7 @@ update_again:
 /*
  * Try to deliver a general event such as focus in, focus out, mouse enter,
  * or mouse exit to the clients which have selected for it.  These events
- * only have the window id as data, and do not propagate upwards.
+ * do not propagate upwards.
  */
 void
 GsDeliverGeneralEvent(GR_WINDOW *wp, GR_EVENT_TYPE type, GR_WINDOW *other)
@@ -803,6 +803,14 @@ GsDeliverGeneralEvent(GR_WINDOW *wp, GR_EVENT_TYPE type, GR_WINDOW *other)
 		if (other)
 			gp->otherid = other->id;
 		else gp->otherid = 0;
+
+		/* add root window x, y mouse coordinates*/
+		gp->rootx = cursorx;
+		gp->rooty = cursory;
+
+		/* window x,y only valid for mouse enter*/
+		gp->x = cursorx - wp->x;
+		gp->y = cursory - wp->y;
 	}
 }
 
diff --git a/src/nanox/srvfunc.c b/src/nanox/srvfunc.c
index a09295c..2bfdcfe 100644
--- a/src/nanox/srvfunc.c
+++ b/src/nanox/srvfunc.c
@@ -1588,13 +1588,20 @@ GrGetRegionBox(GR_REGION_ID region, GR_RECT *rect)
 	return ret_val;
 }
 
+/* DEPRECATED - use GrCreateFontEx*/
+GR_FONT_ID
+GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
+{
+	return GrCreateFontEx(name, height, height, plogfont);
+}
+
 static int nextfontid = 1000;
 /*
  * Allocate a new GC with default parameters.
  * The GC is owned by the current client.
  */
 GR_FONT_ID
-GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
+GrCreateFontEx(GR_CHAR *name, GR_COORD height, GR_COORD width, GR_LOGFONT *plogfont)
 {
 	GR_FONT	*fontp;
 
@@ -1608,9 +1615,9 @@ GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
 	}
 
 	if (plogfont)
-		fontp->pfont = GdCreateFont(&scrdev, NULL, 0, plogfont);
+		fontp->pfont = GdCreateFont(&scrdev, NULL, 0, 0, plogfont);
 	else
-		fontp->pfont = GdCreateFont(&scrdev, (const char *)name, height, NULL);
+		fontp->pfont = GdCreateFont(&scrdev, (const char *)name, height, width, NULL);
 
 	/* if no font created, deallocate and return ID 0*/
 	if (!fontp->pfont) {
@@ -1635,8 +1642,8 @@ GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
  * The font is owned by the current client.
  */
 GR_FONT_ID
-GrCreateFontFromBuffer(const void *buffer, unsigned length,
-		       const char *format, GR_COORD height)
+GrCreateFontFromBuffer(const void *buffer, unsigned length, const char *format,
+	GR_COORD height, GR_COORD width)
 {
 	GR_FONT *fontp;
 
@@ -1654,8 +1661,7 @@ GrCreateFontFromBuffer(const void *buffer, unsigned length,
 	 *         (char) buffer[2], (char) buffer[3], length);
 	 */
 
-	fontp->pfont = GdCreateFontFromBuffer(&scrdev, buffer, length, format,
-				       height);
+	fontp->pfont = GdCreateFontFromBuffer(&scrdev, buffer, length, format, height, width);
 	if (fontp->pfont == NULL) {
 		/* Error loading font, probably corrupt data or unsupported format. */
 		free(fontp);
@@ -1677,7 +1683,7 @@ GrCreateFontFromBuffer(const void *buffer, unsigned length,
  * The font is owned by the current client.
  */
 GR_FONT_ID
-GrCopyFont(GR_FONT_ID fontid, GR_COORD height)
+GrCopyFont(GR_FONT_ID fontid, GR_COORD height, GR_COORD width)
 {
 	GR_FONT *srcfontp;
 	GR_FONT *fontp;
@@ -1693,9 +1699,9 @@ GrCopyFont(GR_FONT_ID fontid, GR_COORD height)
 
 	srcfontp = GsFindFont(fontid);
 	if (srcfontp)
-		fontp->pfont = GdDuplicateFont(&scrdev, srcfontp->pfont,height);
+		fontp->pfont = GdDuplicateFont(&scrdev, srcfontp->pfont, height, width);
 	else
-		fontp->pfont = GdCreateFont(&scrdev, NULL, height, NULL);
+		fontp->pfont = GdCreateFont(&scrdev, NULL, height, width, NULL);
 
 	fontp->id = nextfontid++;
 	fontp->owner = curclient;
@@ -1707,9 +1713,16 @@ GrCopyFont(GR_FONT_ID fontid, GR_COORD height)
 }
 #endif /*HAVE_FREETYPE_2_SUPPORT*/
 
+/* DEPRECATED - use GrSetFontSizeEx*/
+void
+GrSetFontSize(GR_FONT_ID fontid, GR_COORD height)
+{
+	GrSetFontSizeEx(fontid, height, height);
+}
+
 /* Set the font size for the passed font*/
 void
-GrSetFontSize(GR_FONT_ID fontid, GR_COORD size)
+GrSetFontSizeEx(GR_FONT_ID fontid, GR_COORD height, GR_COORD width)
 {
 	GR_FONT		*fontp;
 
@@ -1717,7 +1730,7 @@ GrSetFontSize(GR_FONT_ID fontid, GR_COORD size)
 
 	fontp = GsFindFont(fontid);
 	if (fontp)
-		GdSetFontSize(fontp->pfont, size);
+		GdSetFontSize(fontp->pfont, height, width);
 
 	SERVER_UNLOCK();
 }
diff --git a/src/nanox/srvmain.c b/src/nanox/srvmain.c
index 2533da0..ba29115 100644
--- a/src/nanox/srvmain.c
+++ b/src/nanox/srvmain.c
@@ -1274,9 +1274,9 @@ GsInitialize(void)
 	 */
 #if (HAVE_BIG5_SUPPORT | HAVE_GB2312_SUPPORT | HAVE_JISX0213_SUPPORT | HAVE_KSC5601_SUPPORT)
 	/* system fixed font looks better when mixed with builtin fixed fonts*/
-	stdfont = GdCreateFont(psd, MWFONT_SYSTEM_FIXED, 0, NULL);
+	stdfont = GdCreateFont(psd, MWFONT_SYSTEM_FIXED, 0, 0, NULL);
 #else
-	stdfont = GdCreateFont(psd, MWFONT_SYSTEM_VAR, 0, NULL);
+	stdfont = GdCreateFont(psd, MWFONT_SYSTEM_VAR, 0, 0, NULL);
 #endif
 
 	/*
diff --git a/src/nanox/srvnet.c b/src/nanox/srvnet.c
index 7f8b8d2..86d0877 100644
--- a/src/nanox/srvnet.c
+++ b/src/nanox/srvnet.c
@@ -775,14 +775,14 @@ GrSetGCTSOffsetWrapper(void *r)
 }
 
 static void
-GrCreateFontWrapper(void *r)
+GrCreateFontExWrapper(void *r)
 {
-	nxCreateFontReq *req = r;
+	nxCreateFontExReq *req = r;
 	GR_FONT_ID 	fontid;
 
-	fontid = GrCreateFont(GetReqData(req), req->height, NULL);
+	fontid = GrCreateFontEx(GetReqData(req), req->height, req->width, NULL);
 
-	GsWriteType(current_fd,GrNumCreateFont);
+	GsWriteType(current_fd, GrNumCreateFontEx);
 	GsWrite(current_fd, &fontid, sizeof(fontid));
 }
 
@@ -792,18 +792,18 @@ GrCreateLogFontWrapper(void *r)
 	nxCreateLogFontReq *req = r;
 	GR_FONT_ID fontid;
 
-	fontid = GrCreateFont(NULL, 0, &req->lf);
+	fontid = GrCreateFontEx(NULL, 0, 0, &req->lf);
 
 	GsWriteType(current_fd, GrNumCreateLogFont);
 	GsWrite(current_fd, &fontid, sizeof(fontid));
 }
 
 static void
-GrSetFontSizeWrapper(void *r)
+GrSetFontSizeExWrapper(void *r)
 {
-	nxSetFontSizeReq *req = r;
+	nxSetFontSizeExReq *req = r;
 
- 	GrSetFontSize(req->fontid, req->fontsize);
+ 	GrSetFontSizeEx(req->fontid, req->height, req->width);
 }
 
 static void
@@ -1584,7 +1584,7 @@ GrCreateFontFromBufferWrapper(void *r)
 		result = 0;
 	} else {
 		result = GrCreateFontFromBuffer(buffer->data, buffer->size,
-			(const char *)req->format, req->height);
+			(const char *)req->format, req->height, req->width);
 		
 		freeImageBuffer(buffer);
 	}
@@ -1599,7 +1599,7 @@ GrCopyFontWrapper(void *r)
 {
 #if HAVE_FREETYPE_2_SUPPORT
 	nxCopyFontReq *req = r;
-	GR_FONT_ID result = GrCopyFont(req->fontid, req->height);
+	GR_FONT_ID result = GrCopyFont(req->fontid, req->height, req->width);
 
 	GsWriteType(current_fd, GrNumCopyFont);
 	GsWrite(current_fd, &result, sizeof(result));
@@ -1669,8 +1669,8 @@ static const struct GrFunction GrFunctions[] = {
 	/*  49 */ {GrLoadImageFromFileWrapper, "GrLoadImageFromFile"},
 	/*  50 */ {GrNewPixmapWrapper, "GrNewPixmap"},
 	/*  51 */ {GrCopyAreaWrapper, "GrCopyArea"},
-	/*  52 */ {GrSetFontSizeWrapper, "GrSetFontSize"},
-	/*  53 */ {GrCreateFontWrapper, "GrCreateFont"},
+	/*  52 */ {GrSetFontSizeExWrapper, "GrSetFontSizeEx"},
+	/*  53 */ {GrCreateFontExWrapper, "GrCreateFontEx"},
 	/*  54 */ {GrDestroyFontWrapper, "GrDestroyFont"},
 	/*  55 */ {GrReqShmCmdsWrapper, "GrReqShmCmds"},
 	/*  56 */ {GrShmCmdsFlushWrapper, "GrShmCmdsFlush"},
diff --git a/src/nanox/wmaction.c b/src/nanox/wmaction.c
index db32d12..5c062dd 100644
--- a/src/nanox/wmaction.c
+++ b/src/nanox/wmaction.c
@@ -6,10 +6,13 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
+#define MWINCLUDECOLORS
 #include "nano-X.h"
 #include "nxdraw.h"
 #include "nanowm.h"
 
+static void set_resize_cursor(int wid);
+
 void wm_redraw_ncarea(win *window)
 {
 	GR_WINDOW_INFO info;
@@ -98,20 +101,15 @@ void wm_container_buttondown(win *window, GR_EVENT_BUTTON *event)
 	/* Set focus on button down*/
 	GrSetFocus(window->clientid);
 
-#if !NO_CORNER_RESIZE
-/*
- * Note: Resize seems to cause lots of trouble since the resize "handle"
- * does not seem to be visible/advertised.  Thus at any touch, the window
- * may get resized and it is often impossible to recover
- */
-
 	/* check for corner resize */
 	r.x = info.width - 5;
 	r.y = info.height - 5;
 	r.width = 5;
 	r.height = 5;
 
-	if(PtInRect(&r,event->x, event->y)) {
+	if (PtInRect(&r,event->x, event->y)
+	   && !(info.props & GR_WM_PROPS_NORESIZE) && !(cinfo.props & GR_WM_PROPS_NORESIZE)) {
+#if !NO_CORNER_RESIZE
 	  struct pos_size * pos;
 
 	  if(!window->data)
@@ -139,8 +137,9 @@ void wm_container_buttondown(win *window, GR_EVENT_BUTTON *event)
 	  pos->width = info.width;
 	  pos->height = info.height;
 	  return;
-	}
 #endif /* !NO_CORNER_RESIZE*/
+	} else
+		GrSetWindowCursor(window->wid, 0);
 
 	/* if not in caption, return (FIXME, not calc'd exactly)*/
 	if (!(info.props & GR_WM_PROPS_CAPTION))
@@ -271,13 +270,15 @@ void wm_container_mousemoved(win *window, GR_EVENT_MOUSE *event)
 {
 	struct pos_size *pos;
 	GR_GC_ID gc;
+	GR_RECT r;
 	GR_WINDOW_INFO info;
 
 	Dprintf("wm_container_mousemoved window %d\n", window->wid);
 
+	GrGetWindowInfo(window->wid, &info);
+
 	if(window->sizing) {
 	  struct pos_size * pos = (struct pos_size*)window->data;
-	  GrGetWindowInfo(window->wid, &info);
 
 	  /* erase old rectangle */
 	  gc = GrNewGC();
@@ -295,6 +296,18 @@ void wm_container_mousemoved(win *window, GR_EVENT_MOUSE *event)
 	  return;
 	}
 
+#if !NO_CORNER_RESIZE
+	/* check corner resize cursor on/off*/
+	r.x = info.width - 5;
+	r.y = info.height - 5;
+	r.width = 5;
+	r.height = 5;
+	if (PtInRect(&r,event->x, event->y))
+		set_resize_cursor(window->wid);
+	else
+		GrSetWindowCursor(window->wid, 0);
+#endif
+
 	if(!window->active)
 		return;
 
@@ -315,6 +328,93 @@ void wm_container_mousemoved(win *window, GR_EVENT_MOUSE *event)
 #endif
 }
 
+void wm_container_mouse_enter(win *window, GR_EVENT_GENERAL *event)
+{
+	GR_RECT		r;
+	GR_WINDOW_INFO info, cinfo;
+
+#if !NO_CORNER_RESIZE
+	/* Don't allow window move if NORESIZE property set*/
+	GrGetWindowInfo(window->wid, &info);
+	if (info.props & GR_WM_PROPS_NORESIZE)
+		return;
+	
+	GrGetWindowInfo(window->clientid, &cinfo);
+	if (cinfo.props & GR_WM_PROPS_NORESIZE)
+		return;
+
+	/* check for corner resize */
+	r.x = info.width - 5;
+	r.y = info.height - 5;
+	r.width = 5;
+	r.height = 5;
+	if (PtInRect(&r,event->x, event->y))
+		set_resize_cursor(window->wid);
+#endif
+}
+
+void wm_container_mouse_exit(win *window, GR_EVENT_GENERAL *event)
+{
+	if (!window->sizing)
+		GrSetWindowCursor(window->wid, 0);
+}
+
+/* cursor definition macros*/
+#define	_	((unsigned) 0)		/* off bits */
+#define	X	((unsigned) 1)		/* on bits */
+#define	MASK(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
+	((((((((((((((((((((((((((((((a * 2) + b) * 2) + c) * 2) + d) * 2) + e) * 2) + f) * 2) + g) * 2)\
+	       + h) * 2) + i) * 2) + j) * 2) + k) * 2) + l) * 2) + m) * 2) + n) * 2) + o) * 2) + p)
+
+static void set_resize_cursor(int wid)
+{
+	static int resize_cursor = 0;
+
+	if (!resize_cursor) {
+		GR_BITMAP	resize_fg[16];
+		GR_BITMAP	resize_bg[16];
+
+		resize_fg[0] =  MASK(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[1] =  MASK(_,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[2] =  MASK(_,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[3] =  MASK(_,X,X,X,_,_,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[4] =  MASK(_,X,X,_,X,_,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[5] =  MASK(_,X,_,_,_,X,_,_,_,_,_,_,_,_,_,_);
+		resize_fg[6] =  MASK(_,_,_,_,_,_,X,_,_,_,_,_,_,_,_,_);
+		resize_fg[7] =  MASK(_,_,_,_,_,_,_,X,_,_,_,_,_,_,_,_);
+		resize_fg[8] =  MASK(_,_,_,_,_,_,_,_,X,_,_,_,_,_,_,_);
+		resize_fg[9] =  MASK(_,_,_,_,_,_,_,_,_,X,_,_,_,_,_,_);
+		resize_fg[10] = MASK(_,_,_,_,_,_,_,_,_,_,X,_,_,_,X,_);
+		resize_fg[11] = MASK(_,_,_,_,_,_,_,_,_,_,_,X,_,X,X,_);
+		resize_fg[12] = MASK(_,_,_,_,_,_,_,_,_,_,_,_,X,X,X,_);
+		resize_fg[13] = MASK(_,_,_,_,_,_,_,_,_,_,_,X,X,X,X,_);
+		resize_fg[14] = MASK(_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,_);
+		resize_fg[15] = MASK(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_);
+
+		resize_bg[0] =  MASK(X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_);
+		resize_bg[1] =  MASK(X,X,X,X,X,X,X,_,_,_,_,_,_,_,_,_);
+		resize_bg[2] =  MASK(X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_);
+		resize_bg[3] =  MASK(X,X,X,X,X,_,_,_,_,_,_,_,_,_,_,_);
+		resize_bg[4] =  MASK(X,X,X,X,X,X,_,_,_,_,_,_,_,_,_,_);
+		resize_bg[5] =  MASK(X,X,X,_,X,X,X,_,_,_,_,_,_,_,_,_);
+		resize_bg[6] =  MASK(X,X,_,_,_,X,X,X,_,_,_,_,_,_,_,_);
+		resize_bg[7] =  MASK(_,_,_,_,_,_,X,X,X,_,_,_,_,_,_,_);
+		resize_bg[8] =  MASK(_,_,_,_,_,_,_,X,X,X,_,_,_,_,_,_);
+		resize_bg[9] =  MASK(_,_,_,_,_,_,_,_,X,X,X,_,_,_,X,X);
+		resize_bg[10] = MASK(_,_,_,_,_,_,_,_,_,X,X,X,_,X,X,X);
+		resize_bg[11] = MASK(_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,X);
+		resize_bg[12] = MASK(_,_,_,_,_,_,_,_,_,_,_,X,X,X,X,X);
+		resize_bg[13] = MASK(_,_,_,_,_,_,_,_,_,_,X,X,X,X,X,X);
+		resize_bg[14] = MASK(_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X);
+		resize_bg[15] = MASK(_,_,_,_,_,_,_,_,_,X,X,X,X,X,X,X);
+
+		resize_cursor = GrNewCursor(16, 16, 8, 8, WHITE, BLACK,
+			(MWIMAGEBITS *)resize_fg, (MWIMAGEBITS *)resize_bg);
+	}
+
+	GrSetWindowCursor(wid, resize_cursor);
+}
+
 #if 0000
 void topbar_exposure(win *window, GR_EVENT_EXPOSURE *event)
 {
diff --git a/src/nanox/wmclients.c b/src/nanox/wmclients.c
index a16c1b4..6c68413 100644
--- a/src/nanox/wmclients.c
+++ b/src/nanox/wmclients.c
@@ -142,7 +142,9 @@ int wm_new_client_window(GR_WINDOW_ID wid)
 
 	GrSelectEvents(pid, GR_EVENT_MASK_CHLD_UPDATE
 		| GR_EVENT_MASK_BUTTON_UP | GR_EVENT_MASK_BUTTON_DOWN
-		| GR_EVENT_MASK_MOUSE_POSITION | GR_EVENT_MASK_EXPOSURE);
+		| GR_EVENT_MASK_MOUSE_POSITION
+		| GR_EVENT_MASK_MOUSE_ENTER | GR_EVENT_MASK_MOUSE_EXIT
+		| GR_EVENT_MASK_EXPOSURE);
 
 	/* reparent client to container window (child is already mapped)*/
 	GrReparentWindow(wid, pid, xoffset, yoffset);
diff --git a/src/nanox/wmevents.c b/src/nanox/wmevents.c
index 1aadff6..53b0093 100644
--- a/src/nanox/wmevents.c
+++ b/src/nanox/wmevents.c
@@ -64,10 +64,10 @@ int wm_handle_event(GR_EVENT *event)
 	case GR_EVENT_TYPE_NONE:
 		break;
 	case GR_EVENT_TYPE_ERROR:
-		Dprintf("nanowm: error event code %d\n", event.error.code);
+		Dprintf("nanowm: error event code %d\n", event->error.code);
 		break;
     default:
-		Dprintf("nanowm: unexpected event %d\n", event.type);
+		Dprintf("nanowm: unexpected event %d\n", event->type);
 		break;
     }
     return 0;
@@ -154,6 +154,9 @@ int wm_mouse_enter(GR_EVENT_GENERAL *event)
 		return 0;
 
 	switch(window->type) {
+		case WINDOW_TYPE_CONTAINER:
+			wm_container_mouse_enter(window, event);
+			return 0; 	/* don't eat event*/
 		default:
 			Dprintf("Unhandled mouse enter from window %d "
 				"(type %d)\n", window->wid, window->type);
@@ -172,6 +175,9 @@ int wm_mouse_exit(GR_EVENT_GENERAL *event)
 		return 0;
 
 	switch(window->type) {
+		case WINDOW_TYPE_CONTAINER:
+			wm_container_mouse_exit(window, event);
+			return 0; 	/* don't eat event*/
 		default:
 			Dprintf("Unhandled mouse exit from window %d "
 				"(type %d)\n", window->wid, window->type);
