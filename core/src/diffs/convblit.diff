diff --git a/src/ChangeLog b/src/ChangeLog
index 36cd8ee..7709209 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,35 @@
+21 June 2010
+	* fast convblits for all font drawing and RGBA/RGA images on 16/24/32bpp, all rotations
+	* use fast convblit for PCF/FNT/builtin corefont text drawing
+	* replaced gen16_drawtext in PCF/FNT, and corefont_drawtext with gen_drawtext
+	* replaced gen16_gettextsize with gen_gettextsize in PCF/FNT
+	* temp add left, right, downsubdriver to SCREENDEVICE, kluge select_fb_driver for now
+	* added convblits to SUBDRIVER and SCREENDEVICE
+	* added 16bpp convblits (endian specific), muldiv255_16bpp macro (set with MWPIXEL_FORMAT)
+	* added portrait modes to all mask convblits
+18 June 2010
+	* use fast convblit for FT2/T1 text output on 24/32bpp, anti and non-aliased (rotations not complete)
+	* use gr_foreground_rgb in FT2 driver for mask convblits
+		drawarea stil uses MWPIXELVAL gr_foreground, so BLITPARMS must have both for now
+	* added convblit mask macros for 1bpp mask and 8bpp alpha mask blits
+	* rewrote convblits using static inline for high speed
+14 June 2010
+	* images output using fast convblits on 24/32bpp framebuffer
+	* changed bmp image decoder to return 24bpp RGB or 32bpp RGBA images no alpha
+	* changed pnm image decoder to return 24bpp RGB images
+	* changed xpm image decoder to return 32bpp RGBA8888 images w/alpha
+	* add data_format to MWIMAGEHDR, MWIMAGEINFO, SCREENINFO
+		working for image decoders, not implemented for screens/pixmaps yet
+	* completed png RGB/RGBA, tiff RGBA decoder image display using fast convblit
+		unset FASTJPEG as default, generate 24bpp RGB jpegs
+	* added fast conversion blit srcover/copy RGB/A for rotate left/right/down w/no copy in GdConvBlitInternal
+	* added Update entry point to SCREENDEVICE for X11 convblits
+	* added pitch, data_format to SCREENDEVICE, MapMemGC, GdCalcMemGCAlloc
+	* added convblit entry points for GdConvBlitInternal: convblit_srcover_rgba8888, copy_rgb888
+		any 32bpp RGBA or 24bpp RGB can now be displayed using fast blit (srcover and copy)
+	* added GdConvBlitInternal path from GdDrawImage for very fast image blitting (32bpp hw only)
+		if image decoder uses MWIF_ image format then GdConversionBlit/GdConvBlitInternal used
+		otherwise emulated with old GdDrawImage routine pixel by pixel
 11 June 2010
 	* fix freetype 2 off-by-one height bug (ascent + descent != height)
 10 June 2010
diff --git a/src/FIXME b/src/FIXME
index 238f184..006b571 100644
--- a/src/FIXME
+++ b/src/FIXME
@@ -1,3 +1,35 @@
+**fix kluge in select_fb_subdriver - extern fblinearXX_xxxx required
+	must add SUBDRIVER n/l/r/d into screendevice
+
+fix x11 driver kluges 
+need different way of SUBDRIVER left/right/down etc switching
+
+test VTSWITCH
+
+drawarea removal for non convblit drivers
+test drawarea fallback cases for < 16bpp
+GdBitmap/drawbitmap fallback for < 16bpp
+	fix psd->bpp >= 16 kluge in gen_drawtext (non convblit driver fallback to GdBitmap)
+
+16bpp convblits are endian-specific
+write convblits for 24/32bpp non-bgra systems (rename TRUECOLOR macros?)
+change driver fblinear_blit routines for 32bpp to BLITPARMS struct
+
+config option to eliminate not needed subdrivers?
+
+move data_format in MWIMAGEHDR	after changing convbmp
+fix data_format in scr_x11.c, scr_fb.c
+deprecate old screen drivers, debug driver?, fontmapper, !DYNAMICREGIONS
+
+plans for GdArea, GdReadArea, GdTranslation
+
+fixup other image formats: pnm, to RGB/RGBA, gif etc need palette conversion function
+	update mwin/bmp/convbmp.c when data_format changes for image_bmp.c
+convert palette images to RGBA when running on 24/32 systems (gif, bmp)
+
+autoportrait works great except for when change occurs and cursor still on?
+	(fblin32 blit: assert h < 0)
+
 fblin32alpha.c/fblin32.c:
 	fix SRC_OVER in applyOp
 	check alpha offset in passed pixmap alpha channel
@@ -18,7 +50,7 @@ add X11 keyboard and mouse support to fbe
 init_alpha_lookup needs reinit if palette changed
 
 add GdGetFontList for FT2 and others
-add BGRA and big endian to fbe
+add BGRA and big endian to fbe, all psd image formats
 investigate image vs truecolor ARGB naming schemes, detail support for each
 remove freetype_init from mwin/winfont.c
 investigate endian problem of ever reading color data as DWORD
@@ -44,7 +76,6 @@ fix bin/mwdvetest crash on ESC exit from main dialog
 look at MessageBoxTimeout, newlistbox.c. remove OLD_DRAWTEXT
 
 add SUBDRIVER entry into SCREENDEVICE
-last char drawn wrong on fontdemo2.sh portrait modes
 write rotation blits for portrait modes in drawarea drivers
 add restrict pointers for better optimization to fb drivers
 fix pcfdemo to allow drawing of undefined chars using jiskan24.pcf.gz crash
@@ -54,14 +85,13 @@ check GdDrawImage switch code on MWPF_TRUECOLORxxx values for speed
 move GdDrawImage switch out of inner loop for speed
 test GdDrawImage alpha blending support, not tested for big endian 565/555
 test alpha 0xFFRRGGBB in X11 and fblin32 non-alpha screen drivers
-test alpha channel draw on alpha screen drivers
 test ABGR pixel type (PSP port)
 	test ABGR w/freetype and t1lib alphablend
 	test ABGR and 8888 w/palette images and GETPALLETE
 	test ABGR w/snap_jpg and snap_ppm
 test MWIMAGE_BGR format images and add test .bmp and other files
 png decoder may fail on 8bpp grayscale images w/alpha, needs testing
-nanowm: change cursor on corner resize, static procnames or rename
+nanowm: static procnames or rename
 	nxclock doesn't update when LINK_APP_INTO_SERVER/NANOWM and mouse motion
 correct space char width=1 for FNT, CORE and FT fonts
 add Cyerbit.ttf fonts outside tree for testing
diff --git a/src/Version b/src/Version
index 5dd4fe4..4d871e2 100644
--- a/src/Version
+++ b/src/Version
@@ -1 +1 @@
-0.92pre1
+0.92pre2 (convblit)
diff --git a/src/config b/src/config
index c963972..8140e08 100644
--- a/src/config
+++ b/src/config
@@ -160,7 +160,7 @@ INCTIFF                  = .
 LIBTIFF                  = /usr/lib/libtiff.a
 
 ####################################################################
-# PCF font support - .pcf/.pcf.gz loadable X11 fonts
+# PCF font support - .pcf/.pcf.gz loadable fonts
 ####################################################################
 HAVE_PCF_SUPPORT         = Y
 HAVE_PCFGZ_SUPPORT       = Y
diff --git a/src/demos/nanox/ftdemo.c b/src/demos/nanox/ftdemo.c
index 62d456b..ef1cd9e 100644
--- a/src/demos/nanox/ftdemo.c
+++ b/src/demos/nanox/ftdemo.c
@@ -133,10 +133,13 @@ int main(int argc, char **argv)
 
 void Render(GR_WINDOW_ID window)
 {
+   GR_SCREEN_INFO info;
+
+   GrGetScreenInfo(&info);
    GrSetGCBackground(gid, WHITE);
    GrSetGCForeground (gid, WHITE);
    GrSetGCUseBackground(gid, GR_FALSE);
-   GrFillRect(window, gid, 0, 0, MAXW, MAXH);
+   GrFillRect(window, gid, 0, 0, info.cols, info.rows);
    GrSetGCForeground (gid, BLACK);
 
 //	GrSetGCForeground (gid, GREEN);
diff --git a/src/drivers/fb.c b/src/drivers/fb.c
index d232322..9d62735 100644
--- a/src/drivers/fb.c
+++ b/src/drivers/fb.c
@@ -21,15 +21,27 @@
 PSUBDRIVER 
 select_fb_subdriver(PSD psd)
 {
-	PSUBDRIVER  driver = NULL;
+	PSUBDRIVER driver = NULL;
+	PSUBDRIVER left = &fbportrait_left;
+	PSUBDRIVER right = &fbportrait_right;
+	PSUBDRIVER down = &fbportrait_down;
 	extern SUBDRIVER fblinear1;
 	extern SUBDRIVER fblinear2;
 	extern SUBDRIVER fblinear4;
 	extern SUBDRIVER fblinear8;
 	extern SUBDRIVER fblinear16;
+	extern SUBDRIVER fblinear16_left;
+	extern SUBDRIVER fblinear16_right;
+	extern SUBDRIVER fblinear16_down;
 	extern SUBDRIVER fblinear18;
 	extern SUBDRIVER fblinear24;
+	extern SUBDRIVER fblinear24_left;
+	extern SUBDRIVER fblinear24_right;
+	extern SUBDRIVER fblinear24_down;
 	extern SUBDRIVER fblinear32;
+	extern SUBDRIVER fblinear32_left;
+	extern SUBDRIVER fblinear32_right;
+	extern SUBDRIVER fblinear32_down;
 	extern SUBDRIVER fblinear32alpha;
 #if FBVGA
 	extern SUBDRIVER vgaplan4;
@@ -61,23 +73,39 @@ select_fb_subdriver(PSD psd)
 			break;
 		case 16:
 			driver = &fblinear16;
+			left = &fblinear16_left;
+			right = &fblinear16_right;
+			down = &fblinear16_down;
 			break;
 		case 18: // addon VB May 2007 : 18bpp fb linear driver
 			driver = &fblinear18;
 			break ;
 		case 24:
 			driver = &fblinear24;
+			left = &fblinear24_left;
+			right = &fblinear24_right;
+			down = &fblinear24_down;
+printf("selecting 24bpp subdriver\n");
 			break;
 		case 32:
 			if (psd->pixtype == MWPF_TRUECOLOR8888 || psd->pixtype == MWPF_TRUECOLORABGR) {
 				driver = &fblinear32alpha;
 			} else {
 				driver = &fblinear32;
+				left = &fblinear32_left;
+				right = &fblinear32_right;
+				down = &fblinear32_down;
+printf("selecting 32bpp subdriver\n");
 			}
 			break;
 		}
 	}
 
+	//FIXME KLUGE!!
+	psd->left_subdriver = left;
+	psd->right_subdriver = right;
+	psd->down_subdriver = down;
+
 	/* return driver selected*/
 	return driver;
 }
@@ -90,22 +118,19 @@ void
 set_portrait_subdriver(PSD psd)
 {
 	PSUBDRIVER subdriver;
-	extern SUBDRIVER fbportrait_left;
-	extern SUBDRIVER fbportrait_right;
-	extern SUBDRIVER fbportrait_down;
 
 	switch (psd->portrait) {
 	case MWPORTRAIT_NONE:
 		subdriver = psd->orgsubdriver;
 		break;
 	case MWPORTRAIT_LEFT:
-		subdriver = &fbportrait_left;
+		subdriver = psd->left_subdriver;
 		break;
 	case MWPORTRAIT_RIGHT:
-		subdriver = &fbportrait_right;
+		subdriver = psd->right_subdriver;
 		break;
 	case MWPORTRAIT_DOWN:
-		subdriver = &fbportrait_down;
+		subdriver = psd->down_subdriver;
 		break;
 	}
 	set_subdriver(psd, subdriver, FALSE);
diff --git a/src/drivers/fb.h b/src/drivers/fb.h
index cb10ec2..6c3c440 100644
--- a/src/drivers/fb.h
+++ b/src/drivers/fb.h
@@ -568,3 +568,47 @@ void	get_subdriver(PSD psd, PSUBDRIVER subdriver);
 /* fb.c*/
 PSUBDRIVER select_fb_subdriver(PSD psd);
 void set_portrait_subdriver(PSD psd);
+
+/* fbportrait_xxx.c*/
+SUBDRIVER fbportrait_left;
+SUBDRIVER fbportrait_right;
+SUBDRIVER fbportrait_down;
+
+void fbportrait_left_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
+MWPIXELVAL fbportrait_left_readpixel(PSD psd, MWCOORD x, MWCOORD y);
+void fbportrait_left_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+void fbportrait_left_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_left_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_left_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
+	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
+void fbportrait_left_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+	MWCOORD width, int height, int x_denominator, int y_denominator,
+	int src_x_fraction, int src_y_fraction,
+	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_left_drawarea(PSD dstpsd, driver_gc_t * gc);
+
+void fbportrait_right_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
+MWPIXELVAL fbportrait_right_readpixel(PSD psd, MWCOORD x, MWCOORD y);
+void fbportrait_right_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+void fbportrait_right_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_right_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_right_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
+	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
+void fbportrait_right_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+	MWCOORD width, int height, int x_denominator, int y_denominator,
+	int src_x_fraction, int src_y_fraction,
+	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_right_drawarea(PSD dstpsd, driver_gc_t * gc);
+
+void fbportrait_down_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
+MWPIXELVAL fbportrait_down_readpixel(PSD psd, MWCOORD x, MWCOORD y);
+void fbportrait_down_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+void fbportrait_down_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_down_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void fbportrait_down_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
+	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
+void fbportrait_down_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+	MWCOORD width, int height, int x_denominator, int y_denominator,
+	int src_x_fraction, int src_y_fraction,
+	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_down_drawarea(PSD dstpsd, driver_gc_t * gc);
diff --git a/src/drivers/fblin16.c b/src/drivers/fblin16.c
index bb8151a..c0f5219 100644
--- a/src/drivers/fblin16.c
+++ b/src/drivers/fblin16.c
@@ -17,6 +17,7 @@
 #include <string.h>
 
 #include "device.h"
+#include "convblit.h"
 #include "fb.h"
 
 #define USE_16BIT_ACCESS 0	/* =1 to force 16 bit display access*/
@@ -1245,5 +1246,65 @@ SUBDRIVER fblinear16 = {
 	gen_fillrect,
 	linear16_blit,
 	linear16_drawarea,
-	linear16_stretchblitex
+	linear16_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_16bpp,		/* ft2 non-alias*/
+	convblit_copy_mask_mono_byte_lsb_16bpp,		/* t1 non-alias*/
+	convblit_copy_mask_mono_word_msb_16bpp,		/* core/pcf non-alias*/
+	convblit_blend_mask_alpha_byte_16bpp,		/* ft2/t1 antialias*/
+	convblit_srcover_rgba8888_16bpp,			/* RGBA images w/alpha*/
+	convblit_copy_rgb888_16bpp					/* RGB images no alpha*/
+};
+
+SUBDRIVER fblinear16_left = {
+	NULL,
+	fbportrait_left_drawpixel,
+	fbportrait_left_readpixel,
+	fbportrait_left_drawhorzline,
+	fbportrait_left_drawvertline,
+	fbportrait_left_fillrect,
+	fbportrait_left_blit,
+	fbportrait_left_drawarea,
+	fbportrait_left_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_16bpp_left,
+	convblit_copy_mask_mono_byte_lsb_16bpp_left,
+	convblit_copy_mask_mono_word_msb_16bpp_left,
+	convblit_blend_mask_alpha_byte_16bpp_left,
+	convblit_srcover_rgba8888_16bpp_left,
+	convblit_copy_rgb888_16bpp_left
+};
+
+SUBDRIVER fblinear16_right = {
+	NULL,
+	fbportrait_right_drawpixel,
+	fbportrait_right_readpixel,
+	fbportrait_right_drawhorzline,
+	fbportrait_right_drawvertline,
+	fbportrait_right_fillrect,
+	fbportrait_right_blit,
+	fbportrait_right_drawarea,
+	fbportrait_right_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_16bpp_right,
+	convblit_copy_mask_mono_byte_lsb_16bpp_right,
+	convblit_copy_mask_mono_word_msb_16bpp_right,
+	convblit_blend_mask_alpha_byte_16bpp_right,
+	convblit_srcover_rgba8888_16bpp_right,
+	convblit_copy_rgb888_16bpp_right
+};
+
+SUBDRIVER fblinear16_down = {
+	NULL,
+	fbportrait_down_drawpixel,
+	fbportrait_down_readpixel,
+	fbportrait_down_drawhorzline,
+	fbportrait_down_drawvertline,
+	fbportrait_down_fillrect,
+	fbportrait_down_blit,
+	fbportrait_down_drawarea,
+	fbportrait_down_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_16bpp_down,
+	convblit_copy_mask_mono_byte_lsb_16bpp_down,
+	convblit_copy_mask_mono_word_msb_16bpp_down,
+	convblit_blend_mask_alpha_byte_16bpp_down,
+	convblit_srcover_rgba8888_16bpp_down,
+	convblit_copy_rgb888_16bpp_down
 };
diff --git a/src/drivers/fblin24.c b/src/drivers/fblin24.c
index ef9a4e9..22b0a84 100644
--- a/src/drivers/fblin24.c
+++ b/src/drivers/fblin24.c
@@ -8,6 +8,7 @@
 #include <assert.h>
 #include <string.h>
 #include "device.h"
+#include "convblit.h"
 #include "fb.h"
 
 /* Calc linelen and mmap size, return 0 on fail*/
@@ -1290,5 +1291,65 @@ SUBDRIVER fblinear24 = {
 	gen_fillrect,
 	linear24_blit,
 	linear24_drawarea,
-	linear24_stretchblitex
+	linear24_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgr,		/* ft2 non-alias*/
+	convblit_copy_mask_mono_byte_lsb_bgr,		/* t1 non-alias*/
+	convblit_copy_mask_mono_word_msb_bgr,		/* core/pcf non-alias*/
+	convblit_blend_mask_alpha_byte_bgr,			/* ft2/t1 antialias*/
+	convblit_srcover_rgba8888_bgr888,			/* RGBA images w/alpha*/
+	convblit_copy_rgb888_bgr888					/* RGB images no alpha*/
+};
+
+SUBDRIVER fblinear24_left = {
+	NULL,
+	fbportrait_left_drawpixel,
+	fbportrait_left_readpixel,
+	fbportrait_left_drawhorzline,
+	fbportrait_left_drawvertline,
+	fbportrait_left_fillrect,
+	fbportrait_left_blit,
+	fbportrait_left_drawarea,
+	fbportrait_left_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgr_left,
+	convblit_copy_mask_mono_byte_lsb_bgr_left,
+	convblit_copy_mask_mono_word_msb_bgr_left,
+	convblit_blend_mask_alpha_byte_bgr_left,
+	convblit_srcover_rgba8888_bgr888_left,
+	convblit_copy_rgb888_bgr888_left
+};
+
+SUBDRIVER fblinear24_right = {
+	NULL,
+	fbportrait_right_drawpixel,
+	fbportrait_right_readpixel,
+	fbportrait_right_drawhorzline,
+	fbportrait_right_drawvertline,
+	fbportrait_right_fillrect,
+	fbportrait_right_blit,
+	fbportrait_right_drawarea,
+	fbportrait_right_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgr_right,
+	convblit_copy_mask_mono_byte_lsb_bgr_right,
+	convblit_copy_mask_mono_word_msb_bgr_right,
+	convblit_blend_mask_alpha_byte_bgr_right,
+	convblit_srcover_rgba8888_bgr888_right,
+	convblit_copy_rgb888_bgr888_right
+};
+
+SUBDRIVER fblinear24_down = {
+	NULL,
+	fbportrait_down_drawpixel,
+	fbportrait_down_readpixel,
+	fbportrait_down_drawhorzline,
+	fbportrait_down_drawvertline,
+	fbportrait_down_fillrect,
+	fbportrait_down_blit,
+	fbportrait_down_drawarea,
+	fbportrait_down_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgr_down,
+	convblit_copy_mask_mono_byte_lsb_bgr_down,
+	convblit_copy_mask_mono_word_msb_bgr_down,
+	convblit_blend_mask_alpha_byte_bgr_down,
+	convblit_srcover_rgba8888_bgr888_down,
+	convblit_copy_rgb888_bgr888_down
 };
diff --git a/src/drivers/fblin32.c b/src/drivers/fblin32.c
index beb95ea..dd4bb9c 100644
--- a/src/drivers/fblin32.c
+++ b/src/drivers/fblin32.c
@@ -10,6 +10,7 @@
 #include <assert.h>
 #include <string.h>
 #include "device.h"
+#include "convblit.h"
 #include "fb.h"
 
 /* Calc linelen and mmap size, return 0 on fail*/
@@ -1086,5 +1087,65 @@ SUBDRIVER fblinear32 = {
 	gen_fillrect,
 	linear32_blit,
 	linear32_drawarea,
-	linear32_stretchblitex
+	linear32_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgra,		/* ft2 non-alias*/
+	convblit_copy_mask_mono_byte_lsb_bgra,		/* t1 non-alias*/
+	convblit_copy_mask_mono_word_msb_bgra,		/* core/pcf non-alias*/
+	convblit_blend_mask_alpha_byte_bgra,		/* ft2/t1 antialias*/
+	convblit_srcover_rgba8888_bgra8888,			/* RGBA images w/alpha*/
+	convblit_copy_rgb888_bgra8888				/* RGB images no alpha*/
+};
+
+SUBDRIVER fblinear32_left = {
+	NULL,
+	fbportrait_left_drawpixel,
+	fbportrait_left_readpixel,
+	fbportrait_left_drawhorzline,
+	fbportrait_left_drawvertline,
+	fbportrait_left_fillrect,
+	fbportrait_left_blit,
+	fbportrait_left_drawarea,
+	fbportrait_left_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgra_left,
+	convblit_copy_mask_mono_byte_lsb_bgra_left,
+	convblit_copy_mask_mono_word_msb_bgra_left,
+	convblit_blend_mask_alpha_byte_bgra_left,
+	convblit_srcover_rgba8888_bgra8888_left,
+	convblit_copy_rgb888_bgra8888_left
+};
+
+SUBDRIVER fblinear32_right = {
+	NULL,
+	fbportrait_right_drawpixel,
+	fbportrait_right_readpixel,
+	fbportrait_right_drawhorzline,
+	fbportrait_right_drawvertline,
+	fbportrait_right_fillrect,
+	fbportrait_right_blit,
+	fbportrait_right_drawarea,
+	fbportrait_right_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgra_right,
+	convblit_copy_mask_mono_byte_lsb_bgra_right,
+	convblit_copy_mask_mono_word_msb_bgra_right,
+	convblit_blend_mask_alpha_byte_bgra_right,
+	convblit_srcover_rgba8888_bgra8888_right,
+	convblit_copy_rgb888_bgra8888_right
+};
+
+SUBDRIVER fblinear32_down = {
+	NULL,
+	fbportrait_down_drawpixel,
+	fbportrait_down_readpixel,
+	fbportrait_down_drawhorzline,
+	fbportrait_down_drawvertline,
+	fbportrait_down_fillrect,
+	fbportrait_down_blit,
+	fbportrait_down_drawarea,
+	fbportrait_down_stretchblitex,
+	convblit_copy_mask_mono_byte_msb_bgra_down,
+	convblit_copy_mask_mono_byte_lsb_bgra_down,
+	convblit_copy_mask_mono_word_msb_bgra_down,
+	convblit_blend_mask_alpha_byte_bgra_down,
+	convblit_srcover_rgba8888_bgra8888_down,
+	convblit_copy_rgb888_bgra8888_down
 };
diff --git a/src/drivers/fbportrait_down.c b/src/drivers/fbportrait_down.c
index 66ff216..14a6738 100644
--- a/src/drivers/fbportrait_down.c
+++ b/src/drivers/fbportrait_down.c
@@ -13,37 +13,37 @@
 #include "device.h"
 #include "fb.h"
 
-static void
-fbportrait_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_down_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
 	x = psd->xvirtres-x-1;
 	psd->orgsubdriver->DrawPixel(psd, x, psd->yvirtres-y-1, c);
 }
 
-static MWPIXELVAL
-fbportrait_readpixel(PSD psd, MWCOORD x, MWCOORD y)
+MWPIXELVAL
+fbportrait_down_readpixel(PSD psd, MWCOORD x, MWCOORD y)
 {
 	x = psd->xvirtres-x-1;
 	return psd->orgsubdriver->ReadPixel(psd, x, psd->yvirtres-y-1);
 }
 
-static void
-fbportrait_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_down_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	x1 = psd->xvirtres-x1-1;
 	x2 = psd->xvirtres-x2-1;
 	psd->orgsubdriver->DrawHorzLine(psd, x2, x1, psd->yvirtres-y-1, c);
 }
 
-static void
-fbportrait_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
+void
+fbportrait_down_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	x = psd->xvirtres-x-1;
 	psd->orgsubdriver->DrawVertLine(psd, x, psd->yvirtres-y2-1, psd->yvirtres-y1-1, c);
 }
 
-static void
-fbportrait_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+void
+fbportrait_down_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
 {
 	//y2 = psd->yvirtres-y2-1;
 	//y1 = psd->yvirtres-y1-1;
@@ -53,8 +53,8 @@ fbportrait_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWP
 		psd->DrawHorzLine(psd, x1, x2, y1++, c);
 }
 
-static void
-fbportrait_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
+void
+fbportrait_down_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
 {
     dstpsd->orgsubdriver->Blit(dstpsd, dstpsd->xvirtres-destx-w, dstpsd->yvirtres-desty-h,   
@@ -62,8 +62,8 @@ fbportrait_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 
 }
 
-static void
-fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+void
+fbportrait_down_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
 	MWCOORD width, int height, int x_denominator, int y_denominator,
 	int src_x_fraction, int src_y_fraction,
 	int x_step_fraction, int y_step_fraction, int op)
@@ -80,7 +80,7 @@ fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_
 
 #if MW_FEATURE_PSDOP_ALPHACOL
 static void
-fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
+fbportrait_down_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 {
 	ADDR8 alpha_in, alpha_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -132,7 +132,7 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
+fbportrait_down_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -187,7 +187,7 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+fbportrait_down_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -240,8 +240,8 @@ fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 
-static void
-fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
+void
+fbportrait_down_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
 	if (!dstpsd->orgsubdriver->DrawArea)
 		return;
@@ -249,19 +249,19 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 	switch(gc->op) {
 #if MW_FEATURE_PSDOP_ALPHACOL
 	case PSDOP_ALPHACOL:
-		fbportrait_drawarea_alphacol(dstpsd, gc);
+		fbportrait_down_drawarea_alphacol(dstpsd, gc);
 		break;
 #endif
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 	case PSDOP_BITMAP_BYTES_MSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
+		fbportrait_down_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 	case PSDOP_BITMAP_BYTES_LSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		fbportrait_down_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
@@ -269,12 +269,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 
 SUBDRIVER fbportrait_down = {
 	NULL,
-	fbportrait_drawpixel,
-	fbportrait_readpixel,
-	fbportrait_drawhorzline,
-	fbportrait_drawvertline,
-	fbportrait_fillrect,
-	fbportrait_blit,
-	fbportrait_drawarea,
-	fbportrait_stretchblitex
+	fbportrait_down_drawpixel,
+	fbportrait_down_readpixel,
+	fbportrait_down_drawhorzline,
+	fbportrait_down_drawvertline,
+	fbportrait_down_fillrect,
+	fbportrait_down_blit,
+	fbportrait_down_drawarea,
+	fbportrait_down_stretchblitex
 };
diff --git a/src/drivers/fbportrait_left.c b/src/drivers/fbportrait_left.c
index 64f3560..5406b4c 100644
--- a/src/drivers/fbportrait_left.c
+++ b/src/drivers/fbportrait_left.c
@@ -14,39 +14,39 @@
 #include "device.h"
 #include "fb.h"
 
-static void
-fbportrait_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_left_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
 	psd->orgsubdriver->DrawPixel(psd, y, psd->xvirtres-x-1, c);
 }
 
-static MWPIXELVAL
-fbportrait_readpixel(PSD psd,MWCOORD x, MWCOORD y)
+MWPIXELVAL
+fbportrait_left_readpixel(PSD psd,MWCOORD x, MWCOORD y)
 {
 	return psd->orgsubdriver->ReadPixel(psd, y, psd->xvirtres-x-1);
 }
 
-static void
-fbportrait_drawhorzline(PSD psd,MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_left_drawhorzline(PSD psd,MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	/*x2 = psd->xvirtres-x2-1;
 	while (x2 <= (psd->xvirtres-x1-1))
-		fbportrait_drawpixel(psd, y, x2++, c);*/
+		fbportrait_left_drawpixel(psd, y, x2++, c);*/
 
 	psd->orgsubdriver->DrawVertLine(psd, y, psd->xvirtres-x2-1, psd->xvirtres-x1-1, c);
 }
 
-static void
-fbportrait_drawvertline(PSD psd,MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
+void
+fbportrait_left_drawvertline(PSD psd,MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	/*while (y1 <= y2)
-		fbportrait_drawpixel(psd, y1++, psd->xvirtres-x-1, c);*/
+		fbportrait_left_drawpixel(psd, y1++, psd->xvirtres-x-1, c);*/
 
 	psd->orgsubdriver->DrawHorzLine(psd, y1, y2, psd->xvirtres-x-1, c);
 }
 
-static void
-fbportrait_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+void
+fbportrait_left_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
 {
 #if 0
 	register ADDR16 addr;
@@ -99,8 +99,8 @@ fbportrait_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPI
 #endif
 }
 
-static void
-fbportrait_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
+void
+fbportrait_left_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 	PSD srcpsd, MWCOORD srcx,MWCOORD srcy,int op)
 {
 	dstpsd->orgsubdriver->Blit(dstpsd, desty, dstpsd->xvirtres-destx-w,
@@ -108,8 +108,8 @@ fbportrait_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 }
 
 #if 0
-static void
-fbportrait_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
+void
+fbportrait_left_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
 	MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw,
 	MWCOORD srch, int op)
 {
@@ -118,8 +118,8 @@ fbportrait_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
 }
 #endif
 
-static void
-fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+void
+fbportrait_left_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
 	MWCOORD width, int height, int x_denominator, int y_denominator,
 	int src_x_fraction, int src_y_fraction,
 	int x_step_fraction, int y_step_fraction, int op)
@@ -136,7 +136,7 @@ fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_
 
 #if MW_FEATURE_PSDOP_ALPHACOL
 static void
-fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
+fbportrait_left_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 {
 	ADDR8 alpha_in, alpha_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -189,7 +189,7 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t * gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
+fbportrait_left_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -244,7 +244,7 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+fbportrait_left_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -297,8 +297,8 @@ fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 
-static void
-fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
+void
+fbportrait_left_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
 	if (!dstpsd->orgsubdriver->DrawArea)
 		return;
@@ -306,19 +306,19 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 	switch(gc->op) {
 #if MW_FEATURE_PSDOP_ALPHACOL
 	case PSDOP_ALPHACOL:
-		fbportrait_drawarea_alphacol(dstpsd, gc);
+		fbportrait_left_drawarea_alphacol(dstpsd, gc);
 		break;
 #endif
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 	case PSDOP_BITMAP_BYTES_MSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
+		fbportrait_left_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 	case PSDOP_BITMAP_BYTES_LSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		fbportrait_left_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
@@ -326,12 +326,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 
 SUBDRIVER fbportrait_left = {
 	NULL,
-	fbportrait_drawpixel,
-	fbportrait_readpixel,
-	fbportrait_drawhorzline,
-	fbportrait_drawvertline,
-	fbportrait_fillrect,
-	fbportrait_blit,
-	fbportrait_drawarea,
-	fbportrait_stretchblitex
+	fbportrait_left_drawpixel,
+	fbportrait_left_readpixel,
+	fbportrait_left_drawhorzline,
+	fbportrait_left_drawvertline,
+	fbportrait_left_fillrect,
+	fbportrait_left_blit,
+	fbportrait_left_drawarea,
+	fbportrait_left_stretchblitex
 };
diff --git a/src/drivers/fbportrait_right.c b/src/drivers/fbportrait_right.c
index 8395af2..87b9089 100644
--- a/src/drivers/fbportrait_right.c
+++ b/src/drivers/fbportrait_right.c
@@ -2,7 +2,7 @@
  * Copyright (c) 2000, 2010 Greg Haerr <greg@censoft.com>
  *
  * Right portrait mode subdriver for Microwindows
-
+ *
  * Right rotation:
  * X -> maxy - y - h
  * Y -> X
@@ -13,47 +13,47 @@
 #include "device.h"
 #include "fb.h"
 
-static void
-fbportrait_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_right_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
 	psd->orgsubdriver->DrawPixel(psd, psd->yvirtres-y-1, x, c);
 }
 
-static MWPIXELVAL
-fbportrait_readpixel(PSD psd,MWCOORD x, MWCOORD y)
+MWPIXELVAL
+fbportrait_right_readpixel(PSD psd,MWCOORD x, MWCOORD y)
 {
 	return psd->orgsubdriver->ReadPixel(psd, psd->yvirtres-y-1, x);
 }
 
-static void
-fbportrait_drawhorzline(PSD psd,MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
+void
+fbportrait_right_drawhorzline(PSD psd,MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	/*x2 = x2;
 	while (x2 <= x1)
-		fbportrait_drawpixel(psd, psd->yvirtres-y-1, x2++, c);*/
+		fbportrait_right_drawpixel(psd, psd->yvirtres-y-1, x2++, c);*/
 
 	psd->orgsubdriver->DrawVertLine(psd, psd->yvirtres-y-1, x1, x2, c);
 }
 
-static void
-fbportrait_drawvertline(PSD psd,MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
+void
+fbportrait_right_drawvertline(PSD psd,MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	/*while (y1 <= y2)
-		fbportrait_drawpixel(psd, psd->yvirtres-1-y1++, x, c);*/
+		fbportrait_right_drawpixel(psd, psd->yvirtres-1-y1++, x, c);*/
 
 	psd->orgsubdriver->DrawHorzLine(psd, psd->yvirtres-y2-1, psd->yvirtres-y1-1, x, c);
 }
 
-static void
-fbportrait_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
+void
+fbportrait_right_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
 	MWPIXELVAL c)
 {
 	while(x1 <= x2)
 		psd->orgsubdriver->DrawHorzLine(psd, psd->yvirtres-y2-1, psd->yvirtres-y1-1, x1++, c);
 }
 
-static void
-fbportrait_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
+void
+fbportrait_right_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 	PSD srcpsd, MWCOORD srcx,MWCOORD srcy,int op)
 {
 	dstpsd->orgsubdriver->Blit(dstpsd, dstpsd->yvirtres-desty-h, destx,
@@ -62,7 +62,7 @@ fbportrait_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 
 #if 0
 static void
-fbportrait_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
+fbportrait_right_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
 	MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw,
 	MWCOORD srch, int op)
 {
@@ -71,8 +71,8 @@ fbportrait_stretchblit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD dstw,
 }
 #endif
 
-static void
-fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
+void
+fbportrait_right_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
 	MWCOORD width, int height, int x_denominator, int y_denominator,
 	int src_x_fraction, int src_y_fraction,
 	int x_step_fraction, int y_step_fraction, int op)
@@ -89,7 +89,7 @@ fbportrait_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_
 
 #if MW_FEATURE_PSDOP_ALPHACOL
 static void
-fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t *gc)
+fbportrait_right_drawarea_alphacol(PSD dstpsd, driver_gc_t *gc)
 {
 	ADDR8 alpha_in, alpha_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -141,7 +141,7 @@ fbportrait_drawarea_alphacol(PSD dstpsd, driver_gc_t *gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
+fbportrait_right_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -196,7 +196,7 @@ fbportrait_drawarea_bitmap_bytes_msb_first(PSD psd, driver_gc_t * gc)
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 static void
-fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
+fbportrait_right_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 {
 	ADDR8 pixel_in, pixel_out;
 	MWCOORD	in_x, in_y, in_w, in_h;
@@ -249,8 +249,8 @@ fbportrait_drawarea_bitmap_bytes_lsb_first(PSD psd, driver_gc_t * gc)
 }
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 
-static void
-fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
+void
+fbportrait_right_drawarea(PSD dstpsd, driver_gc_t * gc)
 {
 	if (!dstpsd->orgsubdriver->DrawArea)
 		return;
@@ -258,19 +258,19 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 	switch(gc->op) {
 #if MW_FEATURE_PSDOP_ALPHACOL
 	case PSDOP_ALPHACOL:
-		fbportrait_drawarea_alphacol(dstpsd, gc);
+		fbportrait_right_drawarea_alphacol(dstpsd, gc);
 		break;
 #endif
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST
 	case PSDOP_BITMAP_BYTES_MSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
+		fbportrait_right_drawarea_bitmap_bytes_msb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_MSB_FIRST */
 
 #if MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST
 	case PSDOP_BITMAP_BYTES_LSB_FIRST:
-		fbportrait_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
+		fbportrait_right_drawarea_bitmap_bytes_lsb_first(dstpsd, gc);
 		break;
 #endif /* MW_FEATURE_PSDOP_BITMAP_BYTES_LSB_FIRST */
 	}
@@ -278,12 +278,12 @@ fbportrait_drawarea(PSD dstpsd, driver_gc_t * gc)
 
 SUBDRIVER fbportrait_right = {
 	NULL,
-	fbportrait_drawpixel,
-	fbportrait_readpixel,
-	fbportrait_drawhorzline,
-	fbportrait_drawvertline,
-	fbportrait_fillrect,
-	fbportrait_blit,
-	fbportrait_drawarea,
-	fbportrait_stretchblitex
+	fbportrait_right_drawpixel,
+	fbportrait_right_readpixel,
+	fbportrait_right_drawhorzline,
+	fbportrait_right_drawvertline,
+	fbportrait_right_fillrect,
+	fbportrait_right_blit,
+	fbportrait_right_drawarea,
+	fbportrait_right_stretchblitex
 };
diff --git a/src/drivers/genfont.c b/src/drivers/genfont.c
index dded6a0..272dd13 100644
--- a/src/drivers/genfont.c
+++ b/src/drivers/genfont.c
@@ -24,7 +24,8 @@ extern MWCFONT font_X6x13;			/* MWFONT_SYSTEM_FIXED (should be ansi)*/
 /*extern MWCFONT font_rom8x8, font_X5x7;*/	/* unused*/
 
 /* handling routines for MWCOREFONT*/
-static MWFONTPROCS fontprocs = {
+MWFONTPROCS mwfontprocs = {
+	0,				/* capabilities*/
 	MWTF_ASCII,		/* routines expect ascii*/
 	NULL,			/* init*/
 	NULL,			/* createfont*/
@@ -32,7 +33,7 @@ static MWFONTPROCS fontprocs = {
 	gen_gettextsize,
 	gen_gettextbits,
 	gen_unloadfont,
-	corefont_drawtext,
+	gen_drawtext,
 	NULL,			/* setfontsize*/
 	NULL,			/* setfontrotation*/
 	NULL,			/* setfontattr*/
@@ -59,21 +60,21 @@ static MWFONTPROCS fontprocs = {
 
 /* first font is default font*/
 MWCOREFONT gen_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
-	{&fontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
 	/* deprecated redirections for the time being*/
-	{&fontprocs, 0, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
-	{&fontprocs, 0, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
+	{&mwfontprocs, 0, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
+	{&mwfontprocs, 0, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
 };
 
-/*GB: pointer to an user builtin font table. */
+/* Pointer to an user builtin font table. */
 MWCOREFONT *user_builtin_fonts = NULL;
 
 /*  Sets the fontproc to fontprocs.  */
 void
 gen_setfontproc(MWCOREFONT *pf)
 {
-	pf->fontprocs = &fontprocs;
+	pf->fontprocs = &mwfontprocs;
 }
 
 /*
@@ -106,7 +107,7 @@ gen_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo)
 
 /*
  * Generalized low level routine to calc bounding box for text output.
- * Handles both fixed and proportional fonts.  Passed ascii string.
+ * Handles both fixed and proportional fonts.  Passed ASCII or UC16 string.
  */
 void
 gen_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
@@ -114,7 +115,7 @@ gen_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
 {
 	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
 	const unsigned char *str = text;
-	unsigned int	c;
+	const unsigned short *istr = text;
 	int				width;
 
 	if(pf->width == NULL)
@@ -122,47 +123,17 @@ gen_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
 	else {
 		width = 0;
 		while(--cc >= 0) {
-			c = *str++;
+			unsigned int	c;
 
-			/* if char not in font, map to first character by default*/
-			if(c < pf->firstchar || c >= pf->firstchar+pf->size)
-				c = pf->firstchar;
-
-			/*if(c >= pf->firstchar && c < pf->firstchar+pf->size)*/
-				width += pf->width[c - pf->firstchar];
-		}
-	}
-	*pwidth = width;
-	*pheight = pf->height;
-	*pbase = pf->ascent;
-}
-
-#if HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT
-/*
- * Routine to calc bounding box for text output.
- * Handles both fixed and proportional fonts.  Passed MWTF_UC16 string.
- */
-void
-gen16_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
-	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
-{
-	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
-	const unsigned short *str = text;
-	unsigned int	c;
-	int				width;
-
-	if (pf->width == NULL)
-		width = cc * pf->maxwidth;
-	else {
-		width = 0;
-		while (--cc >= 0) {
-			c = *str++;
+			if (pfont->fontprocs->encoding == MWTF_UC16)
+				c = *istr++;
+			else c = *str++;
 
 			/* if char not in font, map to first character by default*/
 			if(c < pf->firstchar || c >= pf->firstchar+pf->size)
 				c = pf->firstchar;
 
-			/*if (c >= pf->firstchar && c < pf->firstchar+pf->size)*/
+			/*if(c >= pf->firstchar && c < pf->firstchar+pf->size)*/
 				width += pf->width[c - pf->firstchar];
 		}
 	}
@@ -170,7 +141,6 @@ gen16_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
 	*pheight = pf->height;
 	*pbase = pf->ascent;
 }
-#endif /* HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT*/
 
 /*
  * Generalized low level routine to get the bitmap associated
@@ -216,63 +186,3 @@ gen_unloadfont(PMWFONT pfont)
 {
 	/* builtins can't be unloaded*/
 }
-
-#if NOTUSED
-/* 
- * Generalized low level text draw routine, called only
- * if no clipping is required
- */
-void
-gen_drawtext(PMWFONT pfont,PSD psd,MWCOORD x,MWCOORD y,const void *text,
-	int n,MWPIXELVAL fg)
-{
-	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
-	const unsigned char *	str = text;
-	MWCOORD 		width;		/* width of character */
-	MWCOORD 		height;		/* height of character */
-	const MWIMAGEBITS *	bitmap;
-
-	/* x, y is bottom left corner*/
-	y -= pf->height - 1;
-	while (n-- > 0) {
-		pfont->GetTextBits(pfont, *s++, &bitmap, &width, &height);
-		gen_drawbitmap(psd, x, y, width, height, bitmap, fg);
-		x += width;
-	}
-}
-
-/*
- * Generalized low level bitmap output routine, called
- * only if no clipping is required.  Only the set bits
- * in the bitmap are drawn, in the foreground color.
- */
-void
-gen_drawbitmap(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
-	MWIMAGEBITS *table, PIXELVAL fgcolor)
-{
-  MWCOORD minx;
-  MWCOORD maxx;
-  MWIMAGEBITS bitvalue;	/* bitmap word value */
-  int bitcount;		/* number of bits left in bitmap word */
-
-  minx = x;
-  maxx = x + width - 1;
-  bitcount = 0;
-  while (height > 0) {
-	if (bitcount <= 0) {
-		bitcount = MWIMAGE_BITSPERIMAGE;
-		bitvalue = *table++;
-	}
-	if (MWIMAGE_TESTBIT(bitvalue))
-		psd->DrawPixel(psd, x, y, fgcolor);
-	bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
-	--bitcount;
-	if (x++ == maxx) {
-		x = minx;
-		++y;
-		--height;
-		bitcount = 0;
-	}
-  }
-}
-#endif /* NOTUSED*/
diff --git a/src/drivers/genfont.hbf.c b/src/drivers/genfont.hbf.c
index 945e67a..f9ce8ae 100644
--- a/src/drivers/genfont.hbf.c
+++ b/src/drivers/genfont.hbf.c
@@ -40,13 +40,14 @@ extern MWCFONT font_helvB10, font_helvB12, font_helvR10;
 extern MWCFONT font_X5x7, font_X6x13;
 
 /* handling routines for MWCOREFONT*/
-static MWFONTPROCS fontprocs = {
+MWFONTPROCS mwfontprocs = {
+	0,				/* capabilities*/
 	MWTF_ASCII,		/* routines expect ascii*/
 	gen_getfontinfo,
 	gen_gettextsize,
 	gen_gettextbits,
 	gen_unloadfont,
-	corefont_drawtext,
+	gen_drawtext,
 	NULL,			/* setfontsize*/
 	NULL,			/* setfontrotation*/
 	NULL,			/* setfontattr*/
@@ -194,36 +195,6 @@ int Font_Init()
 }
 #endif
 
-#if HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT
-/*
- * Routine to calc bounding box for text output.
- * Handles both fixed and proportional fonts.  Passed MWTF_UC16 string.
- */
-void
-gen16_gettextsize(PMWFONT pfont, const void *text, int cc, MWTEXTFLAGS flags,
-	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
-{
-	PMWCFONT		pf = ((PMWCOREFONT) pfont)->cfont;
-	const unsigned short *	str = text;
-	unsigned		int c;
-	int			width;
-
-	if (pf->width == NULL)
-		width = cc * pf->maxwidth;
-	else {
-		width = 0;
-		while (--cc >= 0) {
-			c = *str++;
-			if (c >= pf->firstchar && c < pf->firstchar + pf->size)
-				width += pf->width[c - pf->firstchar];
-		}
-	}
-	*pwidth = width;
-	*pheight = pf->height;
-	*pbase = pf->ascent;
-}
-#endif /* HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT*/
-
 /*
  * Generalized low level routine to get the bitmap associated
  * with a character.  Handles fixed and proportional fonts.
@@ -336,63 +307,3 @@ gen_unloadfont(PMWFONT pfont)
 {
 	/* builtins can't be unloaded*/
 }
-
-#if NOTUSED
-/* 
- * Generalized low level text draw routine, called only
- * if no clipping is required
- */
-void
-gen_drawtext(PMWFONT pfont,PSD psd,MWCOORD x,MWCOORD y,const void *text,
-	int n,MWPIXELVAL fg)
-{
-	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
-	const unsigned char *	str = text;
-	MWCOORD 		width;		/* width of character */
-	MWCOORD 		height;		/* height of character */
-	const MWIMAGEBITS *	bitmap;
-
-	/* x, y is bottom left corner*/
-	y -= pf->height - 1;
-	while (n-- > 0) {
-		pfont->GetTextBits(pfont, *s++, &bitmap, &width, &height);
-		gen_drawbitmap(psd, x, y, width, height, bitmap, fg);
-		x += width;
-	}
-}
-
-/*
- * Generalized low level bitmap output routine, called
- * only if no clipping is required.  Only the set bits
- * in the bitmap are drawn, in the foreground color.
- */
-void
-gen_drawbitmap(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
-	MWIMAGEBITS *table, PIXELVAL fgcolor)
-{
-  MWCOORD minx;
-  MWCOORD maxx;
-  MWIMAGEBITS bitvalue;	/* bitmap word value */
-  int bitcount;		/* number of bits left in bitmap word */
-
-  minx = x;
-  maxx = x + width - 1;
-  bitcount = 0;
-  while (height > 0) {
-	if (bitcount <= 0) {
-		bitcount = MWIMAGE_BITSPERIMAGE;
-		bitvalue = *table++;
-	}
-	if (MWIMAGE_TESTBIT(bitvalue))
-		psd->DrawPixel(psd, x, y, fgcolor);
-	bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
-	--bitcount;
-	if (x++ == maxx) {
-		x = minx;
-		++y;
-		--height;
-		bitcount = 0;
-	}
-  }
-}
-#endif /* NOTUSED*/
diff --git a/src/drivers/genmem.c b/src/drivers/genmem.c
index 78caa2c..7125e28 100644
--- a/src/drivers/genmem.c
+++ b/src/drivers/genmem.c
@@ -41,7 +41,7 @@ gen_allocatememgc(PSD psd)
 /* initialize memory device with passed parms*/
 void
 gen_initmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format,int pitch,int size,void *addr)
 {
 	assert(mempsd->flags & PSF_MEMORY);
 
@@ -57,7 +57,9 @@ gen_initmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
 	mempsd->yvirtres = h;
 	mempsd->planes = planes;
 	mempsd->bpp = bpp;
+	mempsd->data_format = data_format;
 	mempsd->linelen = linelen;
+	mempsd->pitch = pitch;
 	mempsd->size = size;
 	mempsd->addr = addr;
 }
@@ -74,12 +76,12 @@ gen_initmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
  */
 MWBOOL
 gen_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format,int pitch,int size,void *addr)
 {
 	PSUBDRIVER subdriver;
 
 	/* initialize mem screen driver*/
-	gen_initmemgc(mempsd, w, h, planes, bpp, linelen, size, addr);
+	gen_initmemgc(mempsd, w, h, planes, bpp, data_format, linelen, pitch, size, addr);
 
 	/* select and init hw compatible framebuffer subdriver for pixmap drawing*/
 	subdriver = select_fb_subdriver(mempsd);
@@ -155,6 +157,12 @@ set_subdriver(PSD psd, PSUBDRIVER subdriver, MWBOOL init)
 	psd->Blit 			= subdriver->Blit;
 	psd->DrawArea 		= subdriver->DrawArea;
 	psd->StretchBlitEx	= subdriver->StretchBlitEx;
+	psd->BlitCopyMaskMonoByteMSB = subdriver->BlitCopyMaskMonoByteMSB;
+	psd->BlitCopyMaskMonoByteLSB = subdriver->BlitCopyMaskMonoByteLSB;
+	psd->BlitCopyMaskMonoWordMSB = subdriver->BlitCopyMaskMonoWordMSB;
+	psd->BlitBlendMaskAlphaByte  = subdriver->BlitBlendMaskAlphaByte;
+	psd->BlitSrcOverRGBA8888     = subdriver->BlitSrcOverRGBA8888;
+	psd->BlitCopyRGB888          = subdriver->BlitCopyRGB888;
 
 	/* call driver init procedure to calc map size and linelen*/
 	if (init && !subdriver->Init(psd))
@@ -175,4 +183,10 @@ get_subdriver(PSD psd, PSUBDRIVER subdriver)
 	subdriver->Blit 			= psd->Blit;
 	subdriver->DrawArea 		= psd->DrawArea;
 	subdriver->StretchBlitEx	= psd->StretchBlitEx;
+	subdriver->BlitCopyMaskMonoByteMSB = psd->BlitCopyMaskMonoByteMSB;
+	subdriver->BlitCopyMaskMonoByteLSB = psd->BlitCopyMaskMonoByteLSB;
+	subdriver->BlitCopyMaskMonoWordMSB = psd->BlitCopyMaskMonoWordMSB;
+	subdriver->BlitBlendMaskAlphaByte  = psd->BlitBlendMaskAlphaByte;
+	subdriver->BlitSrcOverRGBA8888     = psd->BlitSrcOverRGBA8888;
+	subdriver->BlitCopyRGB888          = psd->BlitCopyRGB888;
 }
diff --git a/src/drivers/genmem.h b/src/drivers/genmem.h
index b635369..b183578 100644
--- a/src/drivers/genmem.h
+++ b/src/drivers/genmem.h
@@ -11,8 +11,8 @@
 /* genmem.c*/
 PSD 	gen_allocatememgc(PSD psd);
 void	gen_initmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-			int linelen,int size,void *addr);
+			int data_format,int pitch, int linelen,int size,void *addr);
 MWBOOL	gen_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-			int size,void *addr);
+			int data_format,int pitch, int size,void *addr);
 void	gen_freememgc(PSD mempsd);
 void	gen_setportrait(PSD psd, int portraitmode);
diff --git a/src/drivers/nofont.c b/src/drivers/nofont.c
index fa1f6d9..c266ecb 100644
--- a/src/drivers/nofont.c
+++ b/src/drivers/nofont.c
@@ -16,7 +16,8 @@ static MWCFONT nullfont = {
 };
 
 /* handling routines for MWCOREFONT*/
-static MWFONTPROCS fontprocs = {
+MWFONTPROCS mwfontprocs = {
+	0,				/* capabilities*/
 	MWTF_ASCII,		/* routines expect ascii*/
 	NULL,			/* getfontinfo*/
 	NULL,			/* gettextsize*/
@@ -30,8 +31,8 @@ static MWFONTPROCS fontprocs = {
 
 /* first font is default font if no match*/
 MWCOREFONT gen_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_SYSTEM_VAR, &nullfont},
 };
diff --git a/src/drivers/romfont.c b/src/drivers/romfont.c
index 4af386d..5d54e28 100644
--- a/src/drivers/romfont.c
+++ b/src/drivers/romfont.c
@@ -22,7 +22,8 @@ int	ROM_CHAR_HEIGHT = 14;	/* number of scan lines in fonts in ROM */
 FARADDR rom_char_addr;
 
 /* handling routines for core rom fonts*/
-static MWFONTPROCS fontprocs = {
+MWFONTPROCS mwfontprocs = {
+	0,				/* capabilities*/
 	MWTF_ASCII,		/* routines expect ascii*/
 	pcrom_getfontinfo,
 	pcrom_gettextsize,
@@ -36,7 +37,7 @@ static MWFONTPROCS fontprocs = {
 
 /* first font is default font*/
 MWCOREFONT pcrom_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, MWFONT_OEM_FIXED, NULL}
+	{&mwfontprocs, 0, 0, 0, 0, MWFONT_OEM_FIXED, NULL}
 };
 
 /* init PC ROM routines, must be called in graphics mode*/
diff --git a/src/drivers/scr_bios.c b/src/drivers/scr_bios.c
index 3251f12..9b98f0b 100644
--- a/src/drivers/scr_bios.c
+++ b/src/drivers/scr_bios.c
@@ -80,16 +80,16 @@ static void VGA_getscreeninfo(PSD psd,PMWSCREENINFO psi);;
 #endif
 static void VGA_setpalette(PSD psd,int first,int count,MWPALENTRY *pal);
 static MWBOOL VGA_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-		int linelen,int size,void *addr);
+		int data_format,int linelen,int pitch,int size,void *addr);
 static void NULL_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w,
 		MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op) {}
 static PSD  NULL_allocatememgc(PSD psd) { return NULL; }
 static MWBOOL NULL_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-			int linelen,int size,void *addr) { return 0; }
+			int data_format,int linelen,int pitch, int size,void *addr) { return 0; }
 static void NULL_freememgc(PSD mempsd) {}
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	VGA_open,
 	VGA_close,
 	VGA_getscreeninfo,
@@ -239,6 +239,7 @@ VGA_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
@@ -270,12 +271,12 @@ VGA_setpalette(PSD psd,int first,int count,MWPALENTRY *pal)
 /* initialize memory device with passed parms, and select suitable fb driver*/
 static MWBOOL
 VGA_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format, int pitch, int size,void *addr)
 {
 	extern SUBDRIVER memplan4;
 
 	/* initialize mem screen driver*/
-	gen_initmemgc(mempsd, w, h, planes, bpp, linelen, size, addr);
+	gen_initmemgc(mempsd, w, h, planes, bpp, data_format, linelen, pitch, size, addr);
 
 	/* set and initialize subdriver into mem screen driver*/
 	if (!set_subdriver(mempsd, &memplan4, TRUE))
diff --git a/src/drivers/scr_debug.c b/src/drivers/scr_debug.c
index 66a300d..6586cf2 100644
--- a/src/drivers/scr_debug.c
+++ b/src/drivers/scr_debug.c
@@ -30,7 +30,7 @@ void DBG_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 		PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	DBG_open,
 	DBG_close,
 	DBG_getscreeninfo,
@@ -80,6 +80,7 @@ DBG_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = 1;
diff --git a/src/drivers/scr_djgr.c b/src/drivers/scr_djgr.c
index 8ef6166..85da7b3 100644
--- a/src/drivers/scr_djgr.c
+++ b/src/drivers/scr_djgr.c
@@ -35,7 +35,7 @@ static void DJGR_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,
 static PSD  DJGR_allocatememgc(PSD psd);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	DJGR_open,
 	DJGR_close,
 	DJGR_getscreeninfo,
@@ -111,6 +111,7 @@ DJGR_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_ecos.c b/src/drivers/scr_ecos.c
index bc45b56..7c60639 100644
--- a/src/drivers/scr_ecos.c
+++ b/src/drivers/scr_ecos.c
@@ -36,7 +36,7 @@ static void fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette);
 static void gen_getscreeninfo(PSD psd,PMWSCREENINFO psi);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	fb_open,
 	fb_close,
 	gen_getscreeninfo,
@@ -118,6 +118,7 @@ fb_open(PSD psd)
     }
 #endif
 
+	psd->data_format = 0;			// FIXME
     /* set pixel format*/
     switch (li.type) {
     case FB_TRUE_RGB565:
@@ -361,6 +362,7 @@ gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
     psi->cols = psd->xvirtres;
     psi->planes = psd->planes;
     psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
     psi->ncolors = psd->ncolors;
     psi->pixtype = psd->pixtype;
     psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_em84xx.c b/src/drivers/scr_em84xx.c
index 235382d..88ceafa 100644
--- a/src/drivers/scr_em84xx.c
+++ b/src/drivers/scr_em84xx.c
@@ -85,10 +85,10 @@ static void EM8400_fillrect(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2,
 static void EM8400_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 		PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op);
 static MWBOOL EM8400_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-                int linelen,int size,void *addr);
+                int data_format,int linelen, int pitch, ,int size,void *addr);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	EM8400_open,
 	EM8400_close,
 	EM8400_getscreeninfo,
@@ -251,6 +251,7 @@ EM8400_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = 1;
@@ -417,11 +418,11 @@ EM8400_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 
 static MWBOOL
 EM8400_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-	int linelen,int size,void *addr)
+	int data_format, int linelen,int pitch, int size,void *addr)
 {
 	extern SUBDRIVER fblinear24;
 
-        gen_initmemgc(mempsd, w, h, planes, bpp, linelen, size, addr);
+        gen_initmemgc(mempsd, w, h, planes, bpp, data_format, linelen, pitch, size, addr);
 
         /* set and initialize subdriver into mem screen driver*/
         if (!set_subdriver(mempsd, &fblinear24, TRUE))
@@ -429,4 +430,3 @@ EM8400_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
 
         return 1;
 }
-
diff --git a/src/drivers/scr_em86xx.c b/src/drivers/scr_em86xx.c
index 7b40012..1714fb0 100755
--- a/src/drivers/scr_em86xx.c
+++ b/src/drivers/scr_em86xx.c
@@ -52,7 +52,7 @@ static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOO
 #ifdef DRAWAREA_TEST
 static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op);
 #endif
-static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen, int size,void *addr);
+static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int data_format,int linelen, int pitch,int size,void *addr);
 static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op);
 
 #ifdef NO_SWITCH_BUFFER_TEST
@@ -60,7 +60,7 @@ static int switch_first = 0;
 #endif
 
 SCREENDEVICE scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	em86xx_open,
 	em86xx_close,
 	em86xx_getscreeninfo,
@@ -346,6 +346,7 @@ static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
@@ -615,9 +616,9 @@ static void em86xx_drawarea(PSD psd, driver_gc_t * gc)
  */
 MWBOOL
 em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format, int pitch,int size,void *addr)
 {
-	if (!gen_mapmemgc(mempsd, w, h, planes, bpp, linelen, size, addr)) {
+	if (!gen_mapmemgc(mempsd, w, h, planes, bpp, data_format, linelen, pitch, size, addr)) {
 		printf("%s, %d, gen_mapmemgc fail\n", __FUNCTION__, __LINE__);
 		return 0;
 	}
diff --git a/src/drivers/scr_fb.c b/src/drivers/scr_fb.c
index f2e0d97..8067a61 100644
--- a/src/drivers/scr_fb.c
+++ b/src/drivers/scr_fb.c
@@ -50,7 +50,7 @@ static void fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette);
 static void gen_getscreeninfo(PSD psd,PMWSCREENINFO psi);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	fb_open,
 	fb_close,
 	gen_getscreeninfo,
@@ -188,10 +188,12 @@ fb_open(PSD psd)
 
 	/* set linelen to byte length, possibly converted later*/
 	psd->linelen = fb_fix.line_length;
+	psd->pitch = psd->linelen;
 	psd->size = 0;		/* force subdriver init of size*/
 
 	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
 
+	psd->data_format = 0;			// FIXME coming soon
 	/* set pixel format*/
 	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
 		switch(psd->bpp) {
@@ -477,6 +479,7 @@ gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->fonts = NUMBER_FONTS;
 	psi->portrait = psd->portrait;
diff --git a/src/drivers/scr_fbsd.c b/src/drivers/scr_fbsd.c
index dd29e17..95a7061 100644
--- a/src/drivers/scr_fbsd.c
+++ b/src/drivers/scr_fbsd.c
@@ -76,7 +76,7 @@ static void FBSD_blit2(PSD dstpsd,MWCOORD destx,MWCOORD desty,
 
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	FBSD_open,
 	FBSD_close,
 	FBSD_getscreeninfo,
@@ -109,7 +109,7 @@ static void FBSD_close(PSD psd)
 static PSD FBSD_open(PSD psd)
 {
     PSUBDRIVER subdriver;
-    int size, linelen;
+    int size, linelen, pitch;
 
     if (geteuid() != 0) 
     {
@@ -144,6 +144,7 @@ static PSD FBSD_open(PSD psd)
     psd -> linelen = VGLDisplay->Xsize;
     psd -> planes  = 1;
     psd -> pixtype = MWPIXEL_FORMAT;
+	psd -> data_format = 0;			// FIXME
     psd -> bpp = 8;
 
 /*     switch(psd->pixtype) { */
@@ -183,9 +184,10 @@ static PSD FBSD_open(PSD psd)
     }
     /* calc size and linelen of savebits alloc*/
     GdCalcMemGCAlloc(&savebits, savebits.xvirtres, savebits.yvirtres, 
-		     0, 0, &size, &linelen);
+		     0, 0, &size, &linelen, &pitch);
 
     savebits.linelen = linelen;
+    savebits.pitch = pitch;
     savebits.size = size;
     if ((savebits.addr = malloc(size)) == NULL)
     {
@@ -203,6 +205,7 @@ static void FBSD_getscreeninfo(PSD psd, PMWSCREENINFO psi)
     psi->cols = psd->xvirtres;
     psi->planes = psd->planes;
     psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
     psi->ncolors = psd->ncolors;
     psi->pixtype = psd->pixtype;
     psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_herc.c b/src/drivers/scr_herc.c
index 5e0cce2..b9b5bdc 100644
--- a/src/drivers/scr_herc.c
+++ b/src/drivers/scr_herc.c
@@ -44,7 +44,7 @@ static void HERC_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h
 static PSD  HERC_allocatememgc(PSD psd);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	HERC_open,
 	HERC_close,
 	HERC_getscreeninfo,
@@ -148,6 +148,7 @@ HERC_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_prsm.c b/src/drivers/scr_prsm.c
index bf8cb1b..3f2aac5 100644
--- a/src/drivers/scr_prsm.c
+++ b/src/drivers/scr_prsm.c
@@ -61,11 +61,11 @@ void wr_rect2(int x1, int x2, int y1, int y2, unsigned char *buf);
 
 /* dummy routines for now */
 static MWBOOL VB_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-	int linelen,int size,void *addr);
+	int data_format,int linelen,int pitch,int size,void *addr);
 
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	VB_open,
 	VB_close,
 	VB_getscreeninfo,
@@ -130,6 +130,7 @@ VB_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = 1;
@@ -289,8 +290,7 @@ VB_blit(PSD destpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 
 static MWBOOL
 VB_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format, int pitch,int size,void *addr)
 {
 	return 0;
 }
-
diff --git a/src/drivers/scr_psp.c b/src/drivers/scr_psp.c
index 0a4f559..c440be1 100644
--- a/src/drivers/scr_psp.c
+++ b/src/drivers/scr_psp.c
@@ -33,7 +33,7 @@ stub_setpalette(PSD psd,int first,int count,MWPALENTRY *pal)
 }
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	fb_open,
 	fb_close,
 	gen_getscreeninfo,
@@ -103,6 +103,7 @@ gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
     psi->cols = psd->xvirtres;
     psi->planes = psd->planes;
     psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
     psi->ncolors = psd->ncolors;
     psi->pixtype = psd->pixtype;
     psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_rtems.c b/src/drivers/scr_rtems.c
index 1086d27..757614d 100644
--- a/src/drivers/scr_rtems.c
+++ b/src/drivers/scr_rtems.c
@@ -34,7 +34,7 @@ static void fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette);
 static void gen_getscreeninfo(PSD psd,PMWSCREENINFO psi);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, NULL,
 	fb_open,
 	fb_close,
 	gen_getscreeninfo,
@@ -124,6 +124,7 @@ fb_open(PSD psd)
 	psd->flags = PSF_SCREEN;
 #endif
 
+	psd->data_format = 0;			// FIXME
 	/* set pixel format*/
 	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
 		switch(psd->bpp) {
@@ -324,6 +325,7 @@ gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_smp863x.c b/src/drivers/scr_smp863x.c
index 12a9221..8da70c3 100755
--- a/src/drivers/scr_smp863x.c
+++ b/src/drivers/scr_smp863x.c
@@ -52,7 +52,7 @@ static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOO
 #ifdef DRAWAREA_TEST
 static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op);
 #endif
-static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen, int size,void *addr);
+static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int data_format,int linelen, int size,void *addr);
 static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op);
 
 #ifdef NO_SWITCH_BUFFER_TEST
@@ -66,7 +66,7 @@ static int switch_first = 0;
 #define RUAMAP_ALIGN(x) (((RMuint32)x + 16)&~0xF)
 
 SCREENDEVICE scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	em86xx_open,
 	em86xx_close,
 	em86xx_getscreeninfo,
@@ -352,6 +352,7 @@ static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
@@ -592,9 +593,9 @@ static void em86xx_drawarea(PSD psd, driver_gc_t * gc)
  */
 MWBOOL
 em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
-	int size,void *addr)
+	int data_format, int size,void *addr)
 {
-	if (!gen_mapmemgc(mempsd, w, h, planes, bpp, linelen, size, addr)) {
+	if (!gen_mapmemgc(mempsd, w, h, planes, bpp, data_format, linelen, size, addr)) {
 		printf("%s, %d, gen_mapmemgc fail\n", __FUNCTION__, __LINE__);
 		return 0;
 	}
diff --git a/src/drivers/scr_svga.c b/src/drivers/scr_svga.c
index 7b7233f..cfc9b4f 100644
--- a/src/drivers/scr_svga.c
+++ b/src/drivers/scr_svga.c
@@ -36,7 +36,7 @@ static void SVGA_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w,
 		MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op);
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	SVGA_open,
 	SVGA_close,
 	SVGA_getscreeninfo,
@@ -112,6 +112,7 @@ SVGA_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->fonts = NUMBER_FONTS;
 	psi->portrait = MWPORTRAIT_NONE;
diff --git a/src/drivers/scr_tc.c b/src/drivers/scr_tc.c
index be38d6c..54de56a 100644
--- a/src/drivers/scr_tc.c
+++ b/src/drivers/scr_tc.c
@@ -101,6 +101,7 @@ BGI_getscreeninfo(PSD psd,PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->pixtype = psd->pixtype;
 	psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_win32.c b/src/drivers/scr_win32.c
index 3a7d6e6..cc33f70 100644
--- a/src/drivers/scr_win32.c
+++ b/src/drivers/scr_win32.c
@@ -63,7 +63,7 @@ static void win32_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start,
 		int x_step_fraction, int y_step_fraction, long op);
 
 SCREENDEVICE scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	win32_open,
 	win32_close,
 	win32_getscreeninfo,
@@ -168,6 +168,7 @@ win32_open(PSD psd)
 	psd->linelen = psd->xres = psd->xvirtres;
 	psd->yres = psd->yvirtres;
 	psd->planes = 1;
+	psd->data_format = 0;
 	psd->pixtype = MWPIXEL_FORMAT;
 #if (MWPIXEL_FORMAT == MWPF_TRUECOLOR8888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR0888) || (MWPIXEL_FORMAT == MWPF_TRUECOLORABGR)
 	psd->bpp = 32;
@@ -180,7 +181,7 @@ win32_open(PSD psd)
 #endif 
 	/* Calculate the correct linelen here */
 	GdCalcMemGCAlloc(psd, psd->xres, psd->yres, psd->planes,
-			 psd->bpp, &size, &psd->linelen);
+			 psd->bpp, &size, &psd->linelen, &psd->pitch);
 
 	psd->ncolors = psd->bpp >= 24 ? (1 << 24) : (1 << psd->bpp);
 	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
@@ -235,6 +236,7 @@ win32_getscreeninfo(PSD psd, PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->portrait = psd->portrait;
 	psi->fonts = NUMBER_FONTS;
diff --git a/src/drivers/scr_x11.c b/src/drivers/scr_x11.c
index 59afde1..b59f59e 100644
--- a/src/drivers/scr_x11.c
+++ b/src/drivers/scr_x11.c
@@ -64,9 +64,10 @@ static void X11_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start,
 		MWCOORD dest_y_start, MWCOORD width, MWCOORD height, int x_denominator,
 		int y_denominator, int src_x_fraction, int src_y_fraction,
 		int x_step_fraction, int y_step_fraction, int op);
+static void X11_update(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
 
 SCREENDEVICE scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
 	X11_open,
 	X11_close,
 	X11_getscreeninfo,
@@ -87,7 +88,8 @@ SCREENDEVICE scrdev = {
 	gen_setportrait,
 	0,				/* int portrait */
 	NULL,			/* orgsubdriver */
-	X11_stretchblitex /* StretchBlitEx subdriver*/
+	X11_stretchblitex, /* StretchBlitEx subdriver*/
+	X11_update
 };
 
 /* called from keyboard/mouse/screen */
@@ -684,7 +686,7 @@ X11_open(PSD psd)
 	Cursor cursor;
 	/*XEvent ev; */
 	PSUBDRIVER subdriver;
-	int size, linelen;
+	int size, linelen, pitch;
 	XSizeHints *sizehints;
 
 	if (x11_setup_display() < 0)
@@ -790,6 +792,7 @@ X11_open(PSD psd)
 	psd->yres = psd->yvirtres = x11_height;
 	psd->linelen = x11_width;
 	psd->planes = 1;
+	psd->data_format = 0;			// FIXME
 	psd->pixtype = MWPIXEL_FORMAT;
 	switch (psd->pixtype) {
 #if MWPIXEL_FORMAT == MWPF_PALETTE
@@ -817,14 +820,14 @@ X11_open(PSD psd)
 
 	/* Calculate the correct linelen here */
 	GdCalcMemGCAlloc(psd, psd->xres, psd->yres, psd->planes,
-			 psd->bpp, &size, &psd->linelen);
+			 psd->bpp, &size, &psd->linelen, &psd->pitch);
 
 	psd->ncolors = psd->bpp >= 24 ? (1 << 24) : (1 << psd->bpp);
 	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
 	psd->size = 0;
 	psd->addr = NULL;
 	psd->portrait = MWPORTRAIT_NONE;
-
+printf("x11 emulated bpp %d\n", psd->bpp);
 	/* remember original subdriver for portrait subdriver callbacks*/
 	psd->orgsubdriver = &x11dev;
 
@@ -837,16 +840,57 @@ X11_open(PSD psd)
 	if (!subdriver)
 		return NULL;
 
+//FIXME
+fbportrait_left.BlitCopyMaskMonoByteMSB = savebits.left_subdriver->BlitCopyMaskMonoByteMSB;
+fbportrait_left.BlitCopyMaskMonoByteLSB = savebits.left_subdriver->BlitCopyMaskMonoByteLSB;
+fbportrait_left.BlitCopyMaskMonoWordMSB = savebits.left_subdriver->BlitCopyMaskMonoWordMSB;
+fbportrait_left.BlitBlendMaskAlphaByte  = savebits.left_subdriver->BlitBlendMaskAlphaByte;
+fbportrait_left.BlitSrcOverRGBA8888     = savebits.left_subdriver->BlitSrcOverRGBA8888;
+fbportrait_left.BlitCopyRGB888          = savebits.left_subdriver->BlitCopyRGB888;
+
+fbportrait_right.BlitCopyMaskMonoByteMSB = savebits.right_subdriver->BlitCopyMaskMonoByteMSB;
+fbportrait_right.BlitCopyMaskMonoByteLSB = savebits.right_subdriver->BlitCopyMaskMonoByteLSB;
+fbportrait_right.BlitCopyMaskMonoWordMSB = savebits.right_subdriver->BlitCopyMaskMonoWordMSB;
+fbportrait_right.BlitBlendMaskAlphaByte  = savebits.right_subdriver->BlitBlendMaskAlphaByte;
+fbportrait_right.BlitSrcOverRGBA8888     = savebits.right_subdriver->BlitSrcOverRGBA8888;
+fbportrait_right.BlitCopyRGB888          = savebits.right_subdriver->BlitCopyRGB888;
+
+fbportrait_down.BlitCopyMaskMonoByteMSB = savebits.down_subdriver->BlitCopyMaskMonoByteMSB;
+fbportrait_down.BlitCopyMaskMonoByteLSB = savebits.down_subdriver->BlitCopyMaskMonoByteLSB;
+fbportrait_down.BlitCopyMaskMonoWordMSB = savebits.down_subdriver->BlitCopyMaskMonoWordMSB;
+fbportrait_down.BlitBlendMaskAlphaByte  = savebits.down_subdriver->BlitBlendMaskAlphaByte;
+fbportrait_down.BlitSrcOverRGBA8888     = savebits.down_subdriver->BlitSrcOverRGBA8888;
+fbportrait_down.BlitCopyRGB888          = savebits.down_subdriver->BlitCopyRGB888;
+
+psd->left_subdriver = &fbportrait_left;
+psd->right_subdriver = &fbportrait_right;
+psd->down_subdriver = &fbportrait_down;
+
 	/* calc size and linelen of savebits alloc */
 	GdCalcMemGCAlloc(&savebits, savebits.xvirtres, savebits.yvirtres, 0,
-			 0, &size, &linelen);
+			 0, &size, &linelen, &pitch);
 	savebits.linelen = linelen;
+	savebits.pitch = pitch;
 	savebits.size = size;
 	if ((savebits.addr = malloc(size)) == NULL)
 		return NULL;
 
 	set_subdriver(&savebits, subdriver, TRUE);
 
+x11dev.BlitCopyMaskMonoByteMSB = savebits.BlitCopyMaskMonoByteMSB;
+x11dev.BlitCopyMaskMonoByteLSB = savebits.BlitCopyMaskMonoByteLSB;
+x11dev.BlitCopyMaskMonoWordMSB = savebits.BlitCopyMaskMonoWordMSB;
+x11dev.BlitBlendMaskAlphaByte  = savebits.BlitBlendMaskAlphaByte;
+x11dev.BlitSrcOverRGBA8888     = savebits.BlitSrcOverRGBA8888;
+x11dev.BlitCopyRGB888          = savebits.BlitCopyRGB888;
+
+psd->BlitCopyMaskMonoByteMSB = savebits.BlitCopyMaskMonoByteMSB;
+psd->BlitCopyMaskMonoByteLSB = savebits.BlitCopyMaskMonoByteLSB;
+psd->BlitCopyMaskMonoWordMSB = savebits.BlitCopyMaskMonoWordMSB;
+psd->BlitBlendMaskAlphaByte  = savebits.BlitBlendMaskAlphaByte;
+psd->BlitSrcOverRGBA8888     = savebits.BlitSrcOverRGBA8888;
+psd->BlitCopyRGB888          = savebits.BlitCopyRGB888;
+
 	/* set X11 psd to savebits memaddr for screen->offscreen blits... */
 	psd->addr = savebits.addr;
 
@@ -869,6 +913,7 @@ X11_getscreeninfo(PSD psd, PMWSCREENINFO psi)
 	psi->cols = psd->xvirtres;
 	psi->planes = psd->planes;
 	psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
 	psi->ncolors = psd->ncolors;
 	psi->portrait = psd->portrait;
 	psi->fonts = NUMBER_FONTS;
@@ -1132,6 +1177,15 @@ X11_drawarea(PSD psd, driver_gc_t * gc)
 	update_from_savebits(gc->dstx, gc->dsty, gc->width, gc->height);
 }
 
+static void
+X11_update(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height)
+{
+	if (!width)
+		width = psd->xres;
+	if (!height)
+		height = psd->yres;
+	update_from_savebits(x, y, width, height);
+}
 
 /* perform pre-select() duties*/
 static void
diff --git a/src/drivers/vtswitch.c b/src/drivers/vtswitch.c
index 213fcc9..b4b7536 100644
--- a/src/drivers/vtswitch.c
+++ b/src/drivers/vtswitch.c
@@ -56,6 +56,7 @@ static void	null_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start,
 			int x_denominator, int y_denominator,
 			int src_x_fraction, int src_y_fraction,
 			int x_step_fraction, int y_step_fraction, long op) {}
+static void null_convblit(PSD psd, PMWBLITPARMS parms) {}
 
 static SUBDRIVER nulldriver = {
 	NULL,
@@ -66,7 +67,13 @@ static SUBDRIVER nulldriver = {
 	null_fillrect,
 	null_blit,
 	null_drawarea,
-	null_stretchblitex
+	null_stretchblitex,
+	null_convblit,
+	null_convblit,
+	null_convblit,
+	null_convblit,
+	null_convblit,
+	null_convblit
 };
 
 static void
diff --git a/src/engine/Objects.rules b/src/engine/Objects.rules
index b6a2449..ad74017 100644
--- a/src/engine/Objects.rules
+++ b/src/engine/Objects.rules
@@ -18,6 +18,8 @@ MW_CORE_OBJS += \
 	$(MW_DIR_OBJ)/engine/devopen.o \
 	$(MW_DIR_OBJ)/engine/devdraw.o \
 	$(MW_DIR_OBJ)/engine/devblit.o \
+	$(MW_DIR_OBJ)/engine/convblit_8888.o \
+	$(MW_DIR_OBJ)/engine/convblit_mask.o \
 	$(MW_DIR_OBJ)/engine/devfont.o \
 	$(MW_DIR_OBJ)/engine/devmouse.o \
 	$(MW_DIR_OBJ)/engine/devkbd.o \
diff --git a/src/engine/convblit_888.c b/src/engine/convblit_888.c
index 85c538e..e69de29 100644
--- a/src/engine/convblit_888.c
+++ b/src/engine/convblit_888.c
@@ -1,593 +0,0 @@
-/*
- * Device-independent low level blit routines - 24bpp 888 output
- *
- * Copyright (c) 2010 Greg Haerr <greg@censoft.com>
- *
- * These routines do no range checking, clipping, or cursor
- * overwriting checks, but instead draw directly to the
- * data_out memory buffer specified in the passed BLITPARMS struct.
- */
-#include "device.h"
-#include "convblit.h"
-
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define SSZ	4
-#define DSZ	3
-/*
- * Conversion blit composite src_over 32bpp RGBA image to 24bpp BGR image
- */
-void convblit_srcover_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;
-	int height = gc->height;
-
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			d += DSZ;
-			s += SSZ;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
-}
-
-#if 0000
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * Conversion blit copy 32bpp RGBA image to 32bpp BGRA image
- */
-void convblit_copy_rgba8888_bgra(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-	int height = gc->height;
-
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = s[SA];
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			d += 4;
-			s += 4;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
-}
-#endif
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define SSZ	3
-#define DSZ	3
-/*
- * Conversion blit copy 24bpp RGB image to 24bpp BGR image
- */
-void convblit_copy_rgb888_bgr(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 3;
-	int height = gc->height;
-
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			d += 3;
-			s += 3;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
-}
-
-#if 0000
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate left 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_left(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to lower left for left portrait*/
-	/* rotate left: X -> Y, Y -> maxx - X - w*/
-	int newx = gc->dsty;
-	gc->dsty = psd->xvirtres - gc->dstx - 1;
-	gc->dstx = newx;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			s += 3;					/* src: next pixel over*/
-			d -= dst_pitch;			/* dst: next row up*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst += 4;					/* dst: next pixel right*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
-}
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * Conversion blit composite src_over and rotate left 32bpp RGBA image to 32bpp BGRA image
- */
-void convblit_srcover_rgba8888_bgra_left(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to lower left for left portrait*/
-	/* rotate left: X -> Y, Y -> maxx - X*/
-	int newx = gc->dsty;
-	gc->dsty = psd->xvirtres - gc->dstx - 1;
-	gc->dstx = newx;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
-
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d -= dst_pitch;			/* dst: next row up*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst += 4;					/* dst: next pixel right*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
-}
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate right 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_right(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to upper right for right portrait*/
- 	/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
-	int newy = gc->dstx;
-	gc->dstx = psd->yvirtres - gc->dsty - 1;
-	gc->dsty = newy;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			s += 3;					/* src: next pixel over*/
-			d += dst_pitch;			/* dst: next pixel down*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= 4;					/* dst: next pixel left*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
-}
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * conversion blit composite srcover and rotate right 32bpp RGBA to 32bpp BGRA
- */
-void convblit_srcover_rgba8888_bgra_right(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to upper right for right portrait*/
- 	/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
-	int newy = gc->dstx;
-	gc->dstx = psd->yvirtres - gc->dsty - 1;
-	gc->dsty = newy;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
-
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d += dst_pitch;			/* dst: next pixel down*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= 4;					/* dst: next pixel left*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
-}
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * conversion blit composite srcover and rotate down 32bpp RGBA to 32bpp BGRA
- */
-void convblit_srcover_rgba8888_bgra_down(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
-
-	/* change dst top left to lower right for down portrait*/
- 	/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
-	gc->dstx = psd->xvirtres - gc->dstx - 1;
-	gc->dsty = psd->yvirtres - gc->dsty - 1;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
-
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d -= 4;					/* dst: next pixel left*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= gc->dst_pitch;		/* dst: next pixel up*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
-}
-
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate down 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_down(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
-
-	/* change dst top left to lower right for down portrait*/
- 	/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
-	gc->dstx = psd->xvirtres - gc->dstx - 1;
-	gc->dsty = psd->yvirtres - gc->dsty - 1;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			s += 3;					/* src: next pixel over*/
-			d -= 4;					/* dst: next pixel left*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= gc->dst_pitch;		/* dst: next pixel up*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
-}
-#endif
diff --git a/src/engine/convblit_8888.c b/src/engine/convblit_8888.c
index 841c2d2..58cde14 100644
--- a/src/engine/convblit_8888.c
+++ b/src/engine/convblit_8888.c
@@ -1,43 +1,95 @@
 /*
+ * Device-independent low level convblit routines - 24/32bpp RGB/A in/out (any order) or 16bpp 565/555
+ *
  * Copyright (c) 2010 Greg Haerr <greg@censoft.com>
  *
- * Device-independent low level blit routines.
+ * This file will need to be modified when adding a new hardware framebuffer
+ * image format.  Currently, 32bpp BGRA, 24bpp BGR, and 16bpp RGB 565/555 are defined.
  *
  * These routines do no range checking, clipping, or cursor
  * overwriting checks, but instead draw directly to the
  * data_out memory buffer specified in the passed BLITPARMS struct.
  */
 #include "device.h"
+#include "convblit.h"
+
+/* for convenience in specifying inline parms*/
+#define R		0		/* RGBA parms*/
+#define G		1
+#define B		2
+#define A		3
+
+#define NONE	0		/* portrait parm*/
+#define LEFT	1
+#define RIGHT	2
+#define DOWN	3
+
+#define COPY	0		/* mode parm*/
+#define SRCOVER	1
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
 /*
- * Conversion blit composite src_over 32bpp RGBA image to 32bpp BGRA image
+ * Conversion blit for COPY or SRCOVER from RGBA or RGB input to
+ * 32 or 24bpp output, and rotate according to portrait specified.
+ *
+ * The gcc inline mechanism will compile this function with the
+ * result of no switch and few if statements, as most use constant comparisons,
+ * and will be optimized out.  Thus, the inner loops run very fast!
+ * This is also true for the copy vs srcover.  When COPY is specified,
+ * no blending code will be included.
  */
-void convblit_srcover_rgba8888_bgra(PSD psd, PMWBLITPARMS gc)
+static inline void convblit_8888(PSD psd, PMWBLITPARMS gc, int mode,
+	int SSZ, int SR, int SG, int SB, int SA,
+	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)
 {
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-	int height = gc->height;
+	unsigned char *src, *dst;
+	int dsz, dst_pitch;
+	int height, newx, newy;
+	int src_pitch = gc->src_pitch;
+
+	/* compiler will optimize out switch statement and most else to constants*/
+	switch (PORTRAIT) {
+	case NONE:
+		dsz = DSZ;					/* dst: next pixel over*/
+		dst_pitch = gc->dst_pitch;	/* dst: next line down*/
+		break;
+
+	case LEFT:
+		/* change dst top left to lower left for left portrait*/
+		/* rotate left: X -> Y, Y -> maxx - X*/
+		newx = gc->dsty;
+		gc->dsty = psd->xvirtres - gc->dstx - 1;
+		gc->dstx = newx;
+
+		dsz = -gc->dst_pitch;		/* dst: next row up*/
+		dst_pitch = DSZ;			/* dst: next pixel right*/
+		break;
+
+	case RIGHT:
+		/* change dst top left to upper right for right portrait*/
+ 		/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
+		newy = gc->dstx;
+		gc->dstx = psd->yvirtres - gc->dsty - 1;
+		gc->dsty = newy;
+
+		dsz = gc->dst_pitch;		/* dst: next pixel down*/
+		dst_pitch = -DSZ;			/* dst: next pixel left*/
+		break;
+
+	case DOWN:
+		/* change dst top left to lower right for down portrait*/
+ 		/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
+		gc->dstx = psd->xvirtres - gc->dstx - 1;
+		gc->dsty = psd->yvirtres - gc->dsty - 1;
+
+		dsz = -DSZ;					/* dst: next pixel left*/
+		dst_pitch = -gc->dst_pitch;	/* dst: next pixel up*/
+		break;
+	}
+
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
+	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;
 
+	height = gc->height;
 	while (--height >= 0)
 	{
 		register unsigned char *d = dst;
@@ -47,603 +99,221 @@ void convblit_srcover_rgba8888_bgra(PSD psd, PMWBLITPARMS gc)
 
 		while (--w >= 0)
 		{
-			if ((alpha = s[SA]) == 255)
+			/* inline implementation will optimize out all but two compares in inner loop*/
+			if (mode == COPY || (alpha = s[SA]) == 255)		/* copy source*/
 			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
+				if (DSZ == 2)
+					((unsigned short *)d)[0] = RGB2PIXEL565(s[SR], s[SG], s[SB]);
+				else
+				{
+					if (DA >= 0)			/* compiler will optimize out completely*/
+						d[DA] = (SA >= 0)? s[SA]: 255;
+
+					d[DR] = s[SR];
+					d[DG] = s[SG];
+					d[DB] = s[SB];
+				}
 			}
-			else
+			else if (alpha != 0)							/* blend source w/dest*/
 			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
-
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
+				if (DSZ == 2) {
+					unsigned short sr = RED2PIXEL(s[SR]);
+					unsigned short sg = GREEN2PIXEL(s[SG]);
+					unsigned short sb = BLUE2PIXEL(s[SB]);
+					alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
+
+					/* d = muldiv255(255-a, d - s) + s*/
+					((unsigned short *)d)[0] = muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
+				}
+				else
+				{
+ 					/* d += muldiv255(a, 255 - d)*/
+					if (DA >= 0)
+						d[DA] += muldiv255(alpha, 255 - d[DA]);
+
+ 					/* d += muldiv255(a, s - d)*/
+					d[DR] += muldiv255(alpha, s[SR] - d[DR]);
+					d[DG] += muldiv255(alpha, s[SG] - d[DG]);
+					d[DB] += muldiv255(alpha, s[SB] - d[DB]);
+				}
 			}
-			d += 4;
-			s += 4;
+			d += dsz;
+			s += SSZ;				/* src: next pixel right*/
 		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
+		src += src_pitch;			/* src: next line down*/
+		dst += dst_pitch;
 	}
-
+printf("convblit_8888\n");
 	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
-}
+	if (!psd->Update)
+		return;
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * Conversion blit copy 32bpp RGBA image to 32bpp BGRA image
- */
-void convblit_copy_rgba8888_bgra(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-	int height = gc->height;
+	switch (PORTRAIT) {		/* switch will be optimized out*/
+	case NONE:
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
+		break;
 
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
+	case LEFT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
+		break;
 
-		while (--w >= 0)
-		{
-			d[A] = s[SA];
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
+	case RIGHT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
+		break;
 
-			d += 4;
-			s += 4;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
+	case DOWN:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
+		break;
 	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
 }
 
-#if 0000
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SB	0
-#define SG	1
-#define SR	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * Conversion blit copy 32bpp BGR image to 32bpp BGRA image
- */
-void convblit_copy_bgr8888_bgra(PSD psd, PMWBLITPARMS gc)
-{
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-	int height = gc->height;
-
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
+/*---------- 32bpp BGRA output ----------*/
 
-			d += 4;
-			s += 4;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
+/* Conversion blit composite src_over 32bpp RGBA image to 32bpp BGRA image*/
+void convblit_srcover_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 4, B,G,R,A, NONE);
 }
-#endif
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * Conversion blit copy 24bpp RGB image to 32bpp BGRA image
- */
-void convblit_copy_rgb888_bgra(PSD psd, PMWBLITPARMS gc)
+void convblit_srcover_rgba8888_bgra8888_left(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-	int height = gc->height;
-
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			d += 4;
-			s += 3;
-		}
-		src += gc->src_pitch;
-		dst += gc->dst_pitch;
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 4, B,G,R,A, LEFT);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate left 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_left(PSD psd, PMWBLITPARMS gc)
+void convblit_srcover_rgba8888_bgra8888_right(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to lower left for left portrait*/
-	/* rotate left: X -> Y, Y -> maxx - X - w*/
-	int newx = gc->dsty;
-	gc->dsty = psd->xvirtres - gc->dstx - 1;
-	gc->dstx = newx;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
-
-			s += 3;					/* src: next pixel over*/
-			d -= dst_pitch;			/* dst: next row up*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst += 4;					/* dst: next pixel right*/
-	}
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 4, B,G,R,A, RIGHT);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * Conversion blit composite src_over and rotate left 32bpp RGBA image to 32bpp BGRA image
- */
-void convblit_srcover_rgba8888_bgra_left(PSD psd, PMWBLITPARMS gc)
+void convblit_srcover_rgba8888_bgra8888_down(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to lower left for left portrait*/
-	/* rotate left: X -> Y, Y -> maxx - X*/
-	int newx = gc->dsty;
-	gc->dsty = psd->xvirtres - gc->dstx - 1;
-	gc->dstx = newx;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
-
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 4, B,G,R,A, DOWN);
+}
 
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d -= dst_pitch;			/* dst: next row up*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst += 4;					/* dst: next pixel right*/
-	}
+/* Conversion blit copy 24bpp RGB image to 32bpp BGRA image*/
+void convblit_copy_rgb888_bgra8888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 4, B,G,R,A, NONE);
+}
 
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
+void convblit_copy_rgb888_bgra8888_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 4, B,G,R,A, LEFT);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SSZ
-#undef DSZ
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate right 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_right(PSD psd, PMWBLITPARMS gc)
+void convblit_copy_rgb888_bgra8888_right(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to upper right for right portrait*/
- 	/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
-	int newy = gc->dstx;
-	gc->dstx = psd->yvirtres - gc->dsty - 1;
-	gc->dsty = newy;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 4, B,G,R,A, RIGHT);
+}
 
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
+void convblit_copy_rgb888_bgra8888_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 4, B,G,R,A, DOWN);
+}
 
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
+#if LATER
+/* Conversion blit copy 32bpp RGBA image to 32bpp BGRA image*/
+void convblit_copy_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 4, B,G,R,A, NONE);
+}
+#endif
 
-			s += 3;					/* src: next pixel over*/
-			d += dst_pitch;			/* dst: next pixel down*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= 4;					/* dst: next pixel left*/
-	}
+/*---------- 24bpp BGR output ----------*/
 
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
+/* Conversion blit composite src_over 32bpp RGBA image to 24bpp BGR image*/
+void convblit_srcover_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 3, B,G,R,-1, NONE);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * conversion blit composite srcover and rotate right 32bpp RGBA to 32bpp BGRA
- */
-void convblit_srcover_rgba8888_bgra_right(PSD psd, PMWBLITPARMS gc)
+void convblit_srcover_rgba8888_bgr888_left(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
-	int dst_pitch = gc->dst_pitch;
-
-	/* change dst top left to upper right for right portrait*/
- 	/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
-	int newy = gc->dstx;
-	gc->dstx = psd->yvirtres - gc->dsty - 1;
-	gc->dsty = newy;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 3, B,G,R,-1, LEFT);
+}
 
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
+void convblit_srcover_rgba8888_bgr888_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 3, B,G,R,-1, RIGHT);
+}
 
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
+void convblit_srcover_rgba8888_bgr888_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 3, B,G,R,-1, DOWN);
+}
 
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d += dst_pitch;			/* dst: next pixel down*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= 4;					/* dst: next pixel left*/
-	}
+/* Conversion blit copy 24bpp RGB image to 24bpp BGR image*/
+void convblit_copy_rgb888_bgr888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, B,G,R,-1, NONE);
+}
 
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
+void convblit_copy_rgb888_bgr888_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, B,G,R,-1, LEFT);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define SA	3
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	4
-#define DSZ	4
-/*
- * conversion blit composite srcover and rotate down 32bpp RGBA to 32bpp BGRA
- */
-void convblit_srcover_rgba8888_bgra_down(PSD psd, PMWBLITPARMS gc)
+void convblit_copy_rgb888_bgr888_right(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 4;
-	unsigned char *dst;
-	int height;
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, B,G,R,-1, RIGHT);
+}
 
-	/* change dst top left to lower right for down portrait*/
- 	/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
-	gc->dstx = psd->xvirtres - gc->dstx - 1;
-	gc->dsty = psd->yvirtres - gc->dsty - 1;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
+void convblit_copy_rgb888_bgr888_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 3, B,G,R,-1, DOWN);
+}
 
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		unsigned int alpha;
-		int w = gc->width;
+#if LATER
+/* Conversion blit copy 32bpp RGBA image to 24bpp BGR image*/
+void convblit_copy_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 4, R,G,B,A, 3, B,G,R,-1, NONE);
+}
+#endif
 
-		while (--w >= 0)
-		{
-			if ((alpha = s[SA]) == 255)
-			{
-				d[A] = s[SA];
-				d[R] = s[SR];
-				d[G] = s[SG];
-				d[B] = s[SB];
-			}
-			else if (alpha != 0)
-			{
- 				/* d += muldiv255(a, 255 - d)*/
-				d[A] += muldiv255(alpha, 255 - d[A]);
+/*---------- 16bpp BGR output ----------*/
 
- 				/* d += muldiv255(a, s - d)*/
-				d[R] += muldiv255(alpha, s[SR] - d[R]);
-				d[G] += muldiv255(alpha, s[SG] - d[G]);
-				d[B] += muldiv255(alpha, s[SB] - d[B]);
-			}
-			s += 4;					/* src: next pixel over*/
-			d -= 4;					/* dst: next pixel left*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= gc->dst_pitch;		/* dst: next pixel up*/
-	}
+/* Conversion blit composite src_over 32bpp RGBA image to 16bpp image*/
+void convblit_srcover_rgba8888_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 2, 0,0,0,-1, NONE);
+}
 
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
+void convblit_srcover_rgba8888_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 2, 0,0,0,-1, LEFT);
 }
 
-#undef A
-#undef R
-#undef G
-#undef B
-#undef SR
-#undef SG
-#undef SB
-#undef SA
-#undef SSZ
-#undef DSZ
-#define SR	0
-#define SG	1
-#define SB	2
-#define B	0
-#define G	1
-#define R	2
-#define A	3
-#define SSZ	3
-#define DSZ	4
-/*
- * conversion blit copy and rotate down 24bpp RGB to 32bpp BGRA
- */
-void convblit_copy_rgb888_bgra_down(PSD psd, PMWBLITPARMS gc)
+void convblit_srcover_rgba8888_16bpp_right(PSD psd, PMWBLITPARMS gc)
 {
-	unsigned char *src = ((unsigned char *)gc->data)  + gc->srcy * gc->src_pitch + gc->srcx * 3;
-	unsigned char *dst;
-	int height;
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 2, 0,0,0,-1, RIGHT);
+}
 
-	/* change dst top left to lower right for down portrait*/
- 	/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
-	gc->dstx = psd->xvirtres - gc->dstx - 1;
-	gc->dsty = psd->yvirtres - gc->dsty - 1;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * 4;
+void convblit_srcover_rgba8888_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, SRCOVER, 4, R,G,B,A, 2, 0,0,0,-1, DOWN);
+}
 
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = gc->width;
+/* Conversion blit copy 24bpp RGB image to 16bpp image*/
+void convblit_copy_rgb888_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 2, 0,0,0,-1, NONE);
+}
 
-		while (--w >= 0)
-		{
-			d[A] = 255;
-			d[R] = s[SR];
-			d[G] = s[SG];
-			d[B] = s[SB];
+void convblit_copy_rgb888_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 2, 0,0,0,-1, LEFT);
+}
 
-			s += 3;					/* src: next pixel over*/
-			d -= 4;					/* dst: next pixel left*/
-		}
-		src += gc->src_pitch;		/* src: next new line*/
-		dst -= gc->dst_pitch;		/* dst: next pixel up*/
-	}
+void convblit_copy_rgb888_16bpp_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 2, 0,0,0,-1, RIGHT);
+}
 
-	/* update screen bits if driver requires it*/
-	if (psd->Update)				/* adjust x,y,w,h to physical top left and w/h*/
-		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
+void convblit_copy_rgb888_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_8888(psd, gc, COPY, 3, R,G,B,-1, 2, 0,0,0,-1, DOWN);
 }
diff --git a/src/engine/convblit_mask.c b/src/engine/convblit_mask.c
index 3138078..f6eea61 100644
--- a/src/engine/convblit_mask.c
+++ b/src/engine/convblit_mask.c
@@ -1,9 +1,13 @@
 #include <stdio.h>
 /*
- * Device-independent low level blit routines - 1bpp bitmaps and 8bpp alpha mask
+ * Device-independent low level blit routines - 1bpp bitmap and 8bpp alpha mask input,
+ *		24/32bpp 8888 or 16bpp 565/555 output
  *
  * Copyright (c) 2010 Greg Haerr <greg@censoft.com>
  *
+ * This file will need to be modified when adding a new hardware framebuffer
+ * image format.  Currently, 32bpp BGRA and 24bpp BGR are defined.
+ *
  * These routines do no range checking, clipping, or cursor
  * overwriting checks, but instead draw directly to the
  * data_out memory buffer specified in the passed BLITPARMS struct.
@@ -11,34 +15,96 @@
 #include "device.h"
 #include "convblit.h"
 
+/* for convenience in specifying inline parms*/
+#define R		0		/* RGBA parms*/
+#define G		1
+#define B		2
+#define A		3
+
+#define NONE	0		/* portrait parm*/
+#define LEFT	1
+#define RIGHT	2
+#define DOWN	3
+
 /*
  * Conversion blit to draw 1bpp mono msb/lsb first byte/word bitmap into 8888 image.
  * Data can be word/byte array, padded to word/byte boundary.
+ *
+ * This function is defined as a macro first, since other #defines are used
+ * to parameterize the src width, and then an inline function is generated,
+ * which is then used with additional parameters to build the fast final function.
  */
-#define CONVBLIT_COPY_MASK_MONO_8888(funcname,A,R,G,B)	\
-void funcname(PSD psd, PMWBLITPARMS gc)\
+#define CONVBLIT_COPY_MASK_MONO(funcname)	\
+static inline void funcname(PSD psd, PMWBLITPARMS gc,\
+	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)\
 {\
-	int height = gc->height;\
+	unsigned char *src, *dst;\
+	int minx, maxx;\
+	int dsz, dst_pitch;\
+	int height, newx, newy;\
+	int src_pitch = gc->src_pitch;\
 	int usebg = gc->usebg;\
-	int minx = gc->srcx;\
-	int maxx = minx + gc->width;\
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + (gc->srcx >> 3);\
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + (gc->dstx << 2);\
-	/* color values in MWCOLORVAL format*/\
-	uint32_t fg = gc->fg_color;\
+	uint32_t fg = gc->fg_colorval;				/* color values in MWCOLORVAL format*/\
 	unsigned char fg_r = REDVALUE(fg);\
 	unsigned char fg_g = GREENVALUE(fg);\
 	unsigned char fg_b = BLUEVALUE(fg);\
 	unsigned char fg_a = ALPHAVALUE(fg);\
-	uint32_t bg = gc->bg_color;\
+	uint32_t bg = gc->bg_colorval;\
 	unsigned char bg_r = REDVALUE(bg);\
 	unsigned char bg_g = GREENVALUE(bg);\
 	unsigned char bg_b = BLUEVALUE(bg);\
 	unsigned char bg_a = ALPHAVALUE(bg);\
 \
+	/* compiler will optimize out switch statement and most else to constants*/\
+	switch (PORTRAIT) {\
+	case NONE:\
+		dsz = DSZ;					/* dst: next pixel over*/\
+		dst_pitch = gc->dst_pitch;	/* dst: next line down*/\
+		break;\
+\
+	case LEFT:\
+		/* change dst top left to lower left for left portrait*/\
+		/* rotate left: X -> Y, Y -> maxx - X*/\
+		newx = gc->dsty;\
+		gc->dsty = psd->xvirtres - gc->dstx - 1;\
+		gc->dstx = newx;\
+\
+		dsz = -gc->dst_pitch;		/* dst: next row up*/\
+		dst_pitch = DSZ;			/* dst: next pixel right*/\
+		break;\
+\
+	case RIGHT:\
+		/* change dst top left to upper right for right portrait*/\
+ 		/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/\
+		newy = gc->dstx;\
+		gc->dstx = psd->yvirtres - gc->dsty - 1;\
+		gc->dsty = newy;\
+\
+		dsz = gc->dst_pitch;		/* dst: next pixel down*/\
+		dst_pitch = -DSZ;			/* dst: next pixel left*/\
+		break;\
+\
+	case DOWN:\
+		/* change dst top left to lower right for down portrait*/\
+ 		/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/\
+		gc->dstx = psd->xvirtres - gc->dstx - 1;\
+		gc->dsty = psd->yvirtres - gc->dsty - 1;\
+\
+		dsz = -DSZ;					/* dst: next pixel left*/\
+		dst_pitch = -gc->dst_pitch;	/* dst: next pixel up*/\
+		break;\
+	}\
+\
+	minx = gc->srcx;\
+	maxx = minx + gc->width;\
+\
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + (gc->srcx >> 3);\
+	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;\
+\
 	/*\
 	 * Create new 8888 image from mono bitmap using current fg (and bg if usebg) color\
 	 */\
+	height = gc->height;\
 	while (--height >= 0)\
 	{\
 		register unsigned char *d = dst;\
@@ -53,23 +119,61 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
 \
 			if (bitvalue & BITNUM(x & SRC_TYPE_MASK))\
 			{\
-				d[A] = fg_a;\
-				d[R] = fg_r;\
-				d[G] = fg_g;\
-				d[B] = fg_b;\
+				if (DA >= 0)\
+					d[DA] = fg_a;\
+\
+				if (DSZ == 2)\
+					((unsigned short *)d)[0] = RGB2PIXEL565(fg_r, fg_g, fg_b);\
+				else\
+				{\
+					d[DR] = fg_r;\
+					d[DG] = fg_g;\
+					d[DB] = fg_b;\
+				}\
 			}\
 			else if (usebg)\
 			{\
-				d[A] = bg_a;\
-				d[R] = bg_r;\
-				d[G] = bg_g;\
-				d[B] = bg_b;\
+				if (DA >= 0)\
+					d[DA] = bg_a;\
+\
+				if (DSZ == 2)\
+					((unsigned short *)d)[0] = RGB2PIXEL565(bg_r, bg_g, bg_b);\
+				else\
+				{\
+					d[DR] = bg_r;\
+					d[DG] = bg_g;\
+					d[DB] = bg_b;\
+				}\
 			}\
-			d += 4;\
+			d += dsz;\
 		}\
+		src += src_pitch;		/* src: next line down*/\
+		dst += dst_pitch;\
+	}\
+printf("convblit_mask_mono\n");\
+	/* update screen bits if driver requires it*/\
+	if (!psd->Update)\
+		return;\
 \
-		src += gc->src_pitch;\
-		dst += gc->dst_pitch;\
+	switch (PORTRAIT) {		/* switch will be optimized out*/\
+	case NONE:\
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);\
+		break;\
+\
+	case LEFT:\
+		/* adjust x,y,w,h to physical top left and w/h*/\
+		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);\
+		break;\
+\
+	case RIGHT:\
+		/* adjust x,y,w,h to physical top left and w/h*/\
+		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);\
+		break;\
+\
+	case DOWN:\
+		/* adjust x,y,w,h to physical top left and w/h*/\
+		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);\
+		break;\
 	}\
 }
 
@@ -82,11 +186,74 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
 #define SRC_TYPE		unsigned char					/* byte*/
 #define BITNUM(n) 		(0x01 << (n))					/* lsb*/
 #define SRC_TYPE_MASK	(8*sizeof(SRC_TYPE) - 1)		/* x address boundary mask*/
-CONVBLIT_COPY_MASK_MONO_8888(convblit_copy_mask_mono_byte_lsb_argb,0,1,2,3)
+CONVBLIT_COPY_MASK_MONO(convblit_copy_mask_mono_byte_lsb)
 #undef SRC_TYPE
 #undef SRC_TYPE_MASK
 #undef BITNUM
 
+/* 32bpp BGRA*/
+void convblit_copy_mask_mono_byte_lsb_bgra(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 4, B,G,R,A, NONE);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgra_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 4, B,G,R,A, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgra_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 4, B,G,R,A, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgra_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 4, B,G,R,A, DOWN);
+}
+
+/* 24bpp BGR*/
+void convblit_copy_mask_mono_byte_lsb_bgr(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 3, B,G,R,-1, NONE);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgr_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 3, B,G,R,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgr_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 3, B,G,R,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_bgr_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 3, B,G,R,-1, DOWN);
+}
+
+/* 16bpp 565/555*/
+void convblit_copy_mask_mono_byte_lsb_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 2, 0,0,0,-1, NONE);
+}
+
+void convblit_copy_mask_mono_byte_lsb_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 2, 0,0,0,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_16bpp_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 2, 0,0,0,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_lsb_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_lsb(psd, gc, 2, 0,0,0,-1, DOWN);
+}
+
 /*
  * Routine to draw mono 1bpp MSBFirst bitmap into 8888 image.
  * Bitmap is word array, padded to word boundary.
@@ -96,11 +263,74 @@ CONVBLIT_COPY_MASK_MONO_8888(convblit_copy_mask_mono_byte_lsb_argb,0,1,2,3)
 #define SRC_TYPE		unsigned short					/* word*/
 #define BITNUM(n) 		(0x8000 >> (n))					/* msb*/
 #define SRC_TYPE_MASK	(8*sizeof(SRC_TYPE) - 1)		/* x address boundary mask*/
-CONVBLIT_COPY_MASK_MONO_8888(convblit_copy_mask_mono_word_msb_argb,0,1,2,3)
+CONVBLIT_COPY_MASK_MONO(convblit_copy_mask_mono_word_msb)
 #undef SRC_TYPE
 #undef SRC_TYPE_MASK
 #undef BITNUM
 
+/* 32bpp BGRA*/
+void convblit_copy_mask_mono_word_msb_bgra(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 4, B,G,R,A, NONE);
+}
+
+void convblit_copy_mask_mono_word_msb_bgra_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 4, B,G,R,A, LEFT);
+}
+
+void convblit_copy_mask_mono_word_msb_bgra_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 4, B,G,R,A, RIGHT);
+}
+
+void convblit_copy_mask_mono_word_msb_bgra_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 4, B,G,R,A, DOWN);
+}
+
+/* 24bpp BGR*/
+void convblit_copy_mask_mono_word_msb_bgr(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 3, B,G,R,-1, NONE);
+}
+
+void convblit_copy_mask_mono_word_msb_bgr_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 3, B,G,R,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_word_msb_bgr_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 3, B,G,R,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_word_msb_bgr_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 3, B,G,R,-1, DOWN);
+}
+
+/* 16bpp 565/555*/
+void convblit_copy_mask_mono_word_msb_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 2, 0,0,0,-1, NONE);
+}
+
+void convblit_copy_mask_mono_word_msb_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 2, 0,0,0,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_word_msb_16bpp_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 2, 0,0,0,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_word_msb_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_word_msb(psd, gc, 2, 0,0,0,-1, DOWN);
+}
+
 /*
  * Routine to draw mono 1bpp MSBFirst bitmap into 8888 image.
  * Bitmap is byte array.
@@ -110,90 +340,261 @@ CONVBLIT_COPY_MASK_MONO_8888(convblit_copy_mask_mono_word_msb_argb,0,1,2,3)
 #define SRC_TYPE		unsigned char					/* byte*/
 #define BITNUM(n) 		(0x80 >> (n))					/* msb*/
 #define SRC_TYPE_MASK	(8*sizeof(SRC_TYPE) - 1)		/* x address boundary mask*/
-CONVBLIT_COPY_MASK_MONO_8888(convblit_copy_mask_mono_byte_msb_argb,0,1,2,3)
+CONVBLIT_COPY_MASK_MONO(convblit_copy_mask_mono_byte_msb)
 #undef SRC_TYPE
 #undef SRC_TYPE_MASK
 #undef BITNUM
 
+/* 32bpp BGRA*/
+void convblit_copy_mask_mono_byte_msb_bgra(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 4, B,G,R,A, NONE);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgra_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 4, B,G,R,A, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgra_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 4, B,G,R,A, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgra_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 4, B,G,R,A, DOWN);
+}
+
+/* 24bpp BGR*/
+void convblit_copy_mask_mono_byte_msb_bgr(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 3, B,G,R,-1, NONE);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgr_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 3, B,G,R,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgr_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 3, B,G,R,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_msb_bgr_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 3, B,G,R,-1, DOWN);
+}
+
+/* 16bpp 565/555*/
+void convblit_copy_mask_mono_byte_msb_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 2, 0,0,0,-1, NONE);
+}
+
+void convblit_copy_mask_mono_byte_msb_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 2, 0,0,0,-1, LEFT);
+}
+
+void convblit_copy_mask_mono_byte_msb_16bpp_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 2, 0,0,0,-1, RIGHT);
+}
+
+void convblit_copy_mask_mono_byte_msb_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_copy_mask_mono_byte_msb(psd, gc, 2, 0,0,0,-1, DOWN);
+}
+
 /*
- * Conversion blit to blend 8bpp alpha with fg/bg into 8888 image
+ * Conversion blit to blend 8bpp alpha with fg/bg onto 24bpp 888 or 32bpp 8888 image
  */
-#define CONVBLIT_BLEND_MASK_ALPHA_BYTE_8888(funcname,A,R,G,B)	\
-void funcname(PSD psd, PMWBLITPARMS gc)\
-{\
-	int height = gc->height;\
-	int usebg = gc->usebg;\
-	unsigned char *src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx;\
-	unsigned char *dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + (gc->dstx << 2);\
-	/* color values in MWCOLORVAL format*/\
-	uint32_t fg = gc->fg_color;\
-	unsigned char fg_r = REDVALUE(fg);\
-	unsigned char fg_g = GREENVALUE(fg);\
-	unsigned char fg_b = BLUEVALUE(fg);\
-	unsigned char fg_a = ALPHAVALUE(fg);\
-	uint32_t bg = gc->bg_color;\
-	unsigned char bg_r = REDVALUE(bg);\
-	unsigned char bg_g = GREENVALUE(bg);\
-	unsigned char bg_b = BLUEVALUE(bg);\
-	unsigned char bg_a = ALPHAVALUE(bg);\
-\
-	/*\
-	 * Create new 8888 image by blending fg/bg with 8bpp alpha byte array\
-	 */\
-	while (--height >= 0)\
-	{\
-		register unsigned char *d = dst;\
-		register unsigned char *s = src;\
-		unsigned int alpha;\
-		int w = gc->width;\
-\
-		while (--w >= 0)\
-		{\
-			if ((alpha = *s++) == 0)\
-			{\
-				if (usebg)\
-				{\
-					d[A] = bg_a;\
-					d[R] = bg_r;\
-					d[G] = bg_g;\
-					d[B] = bg_b;\
-				} \
-			}\
-			else if (alpha == 255)\
-			{\
-				d[A] = fg_a;\
-				d[R] = fg_r;\
-				d[G] = fg_g;\
-				d[B] = fg_b;\
-			}\
-			else\
-			{\
-				if (usebg)\
-				{\
- 					/*d = muldiv255(a, 255 - d) + d*/\
-					d[A] = muldiv255(alpha, 255 - bg_a) + bg_a;\
-\
- 					/* d = muldiv255(a, s - d) + d*/\
-					d[R] = muldiv255(alpha, fg_r - bg_r) + bg_r;\
-					d[G] = muldiv255(alpha, fg_g - bg_g) + bg_g;\
-					d[B] = muldiv255(alpha, fg_b - bg_b) + bg_b;\
-				}\
-				else\
-				{\
- 					/*d += muldiv255(a, 255 - d)*/\
-					d[A] += muldiv255(alpha, 255 - d[A]);\
-\
- 					/* d += muldiv255(a, s - d)*/\
-					d[R] += muldiv255(alpha, fg_r - d[R]);\
-					d[G] += muldiv255(alpha, fg_g - d[G]);\
-					d[B] += muldiv255(alpha, fg_b - d[B]);\
-				}\
-			}\
-			d += 4;\
-		}\
-		src += gc->src_pitch;\
-		dst += gc->dst_pitch;\
-	}\
+static inline void convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc,
+	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)
+{
+	unsigned char *src, *dst;
+	int dsz, dst_pitch;
+	int height, newx, newy;
+	int src_pitch = gc->src_pitch;
+	int usebg = gc->usebg;
+	uint32_t fg = gc->fg_colorval;				/* color values in MWCOLORVAL format*/
+	unsigned char fg_r = REDVALUE(fg);
+	unsigned char fg_g = GREENVALUE(fg);
+	unsigned char fg_b = BLUEVALUE(fg);
+	unsigned char fg_a = ALPHAVALUE(fg);
+	uint32_t bg = gc->bg_colorval;
+	unsigned char bg_r = REDVALUE(bg);
+	unsigned char bg_g = GREENVALUE(bg);
+	unsigned char bg_b = BLUEVALUE(bg);
+	unsigned char bg_a = ALPHAVALUE(bg);
+
+	/* compiler will optimize out switch statement and most else to constants*/
+	switch (PORTRAIT) {
+	case NONE:
+		dsz = DSZ;					/* dst: next pixel over*/
+		dst_pitch = gc->dst_pitch;	/* dst: next line down*/
+		break;
+
+	case LEFT:
+		/* change dst top left to lower left for left portrait*/
+		/* rotate left: X -> Y, Y -> maxx - X*/
+		newx = gc->dsty;
+		gc->dsty = psd->xvirtres - gc->dstx - 1;
+		gc->dstx = newx;
+
+		dsz = -gc->dst_pitch;		/* dst: next row up*/
+		dst_pitch = DSZ;			/* dst: next pixel right*/
+		break;
+
+	case RIGHT:
+		/* change dst top left to upper right for right portrait*/
+ 		/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
+		newy = gc->dstx;
+		gc->dstx = psd->yvirtres - gc->dsty - 1;
+		gc->dsty = newy;
+
+		dsz = gc->dst_pitch;		/* dst: next pixel down*/
+		dst_pitch = -DSZ;			/* dst: next pixel left*/
+		break;
+
+	case DOWN:
+		/* change dst top left to lower right for down portrait*/
+ 		/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
+		gc->dstx = psd->xvirtres - gc->dstx - 1;
+		gc->dsty = psd->yvirtres - gc->dsty - 1;
+
+		dsz = -DSZ;					/* dst: next pixel left*/
+		dst_pitch = -gc->dst_pitch;	/* dst: next pixel up*/
+		break;
+	}
+
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx;
+	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;
+
+	/*
+	 * Blend fg/bg with alpha byte array onto destination image
+	 */
+	height = gc->height;
+	while (--height >= 0)
+	{
+		register unsigned char *d = dst;
+		register unsigned char *s = src;
+		unsigned int alpha;
+		int w = gc->width;
+
+		while (--w >= 0)
+		{
+			/* inline implementation will optimize out all but usebg and alpha compares in inner loop*/
+			if ((alpha = *s++) == 0)					/* draw background only if specified*/
+			{
+				if (usebg)
+				{
+					if (DSZ == 2)
+						((unsigned short *)d)[0] = RGB2PIXEL565(bg_r, bg_g, bg_g);
+					else
+					{
+						if (DA >= 0)
+							d[DA] = bg_a;
+						d[DR] = bg_r;
+						d[DG] = bg_g;
+						d[DB] = bg_b;
+					}
+				} 
+			}
+			else if (alpha == 255)					/* copy source*/
+			{
+				if (DSZ == 2)
+					((unsigned short *)d)[0] = RGB2PIXEL565(fg_r, fg_g, fg_g);
+				else
+				{
+					if (DA >= 0)
+						d[DA] = fg_a;
+					d[DR] = fg_r;
+					d[DG] = fg_g;
+					d[DB] = fg_b;
+				}
+			}
+			else									/* blend source w/dest or passed bg*/
+			{
+				if (usebg)
+				{
+					if (DSZ == 2) {
+						unsigned short sr = RED2PIXEL(fg_r);
+						unsigned short sg = GREEN2PIXEL(fg_g);
+						unsigned short sb = BLUE2PIXEL(fg_b);
+						alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
+
+						/* d = muldiv255(255-a, d - s) + s*/
+						((unsigned short *)d)[0] = muldiv255_16bpp(gc->bg_pixelval, sr, sg, sb, alpha);
+					}
+					else
+					{
+ 						/*d = muldiv255(a, 255 - d) + d*/
+						if (DA >= 0)
+							d[DA] = muldiv255(alpha, 255 - bg_a) + bg_a;
+
+ 						/* d = muldiv255(a, s - d) + d*/
+						d[DR] = muldiv255(alpha, fg_r - bg_r) + bg_r;
+						d[DG] = muldiv255(alpha, fg_g - bg_g) + bg_g;
+						d[DB] = muldiv255(alpha, fg_b - bg_b) + bg_b;
+					}
+				}
+				else
+				{
+					if (DSZ == 2) {
+						unsigned short sr = RED2PIXEL(fg_r);
+						unsigned short sg = GREEN2PIXEL(fg_g);
+						unsigned short sb = BLUE2PIXEL(fg_b);
+						alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
+
+						/* d = muldiv255(255-a, d - s) + s*/
+						((unsigned short *)d)[0] = muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
+					}
+					else
+					{
+ 						/*d += muldiv255(a, 255 - d)*/
+						if (DA >= 0)
+							d[DA] += muldiv255(alpha, 255 - d[DA]);
+
+ 						/* d += muldiv255(a, s - d)*/
+						d[DR] += muldiv255(alpha, fg_r - d[DR]);
+						d[DG] += muldiv255(alpha, fg_g - d[DG]);
+						d[DB] += muldiv255(alpha, fg_b - d[DB]);
+					}
+				}
+			}
+			d += dsz;
+		}
+		src += src_pitch;				/* src: next line down*/
+		dst += dst_pitch;
+	}
+printf("convblit_mask_alpha\n");
+	/* update screen bits if driver requires it*/
+	if (!psd->Update)
+		return;
+
+	switch (PORTRAIT) {		/* switch will be optimized out*/
+	case NONE:
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
+		break;
+
+	case LEFT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
+		break;
+
+	case RIGHT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
+		break;
+
+	case DOWN:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		psd->Update(psd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
+		break;
+	}
 }
 
 /*
@@ -201,8 +602,70 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
  *
  * Used to draw FT2 and T1LIB antialiased glyphs.
  */
-CONVBLIT_BLEND_MASK_ALPHA_BYTE_8888(convblit_blend_mask_alpha_byte_argb,0,1,2,3)
+/* 32bpp BGRA*/
+void convblit_blend_mask_alpha_byte_bgra(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 4, B,G,R,A, NONE);
+}
 
+void convblit_blend_mask_alpha_byte_bgra_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 4, B,G,R,A, LEFT);
+}
+
+void convblit_blend_mask_alpha_byte_bgra_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 4, B,G,R,A, RIGHT);
+}
+
+void convblit_blend_mask_alpha_byte_bgra_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 4, B,G,R,A, DOWN);
+}
+
+/* 24bpp BGR*/
+void convblit_blend_mask_alpha_byte_bgr(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 3, B,G,R,-1, NONE);
+}
+
+void convblit_blend_mask_alpha_byte_bgr_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 3, B,G,R,-1, LEFT);
+}
+
+void convblit_blend_mask_alpha_byte_bgr_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 3, B,G,R,-1, RIGHT);
+}
+
+void convblit_blend_mask_alpha_byte_bgr_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 3, B,G,R,-1, DOWN);
+}
+
+/* 16bpp 565/555*/
+void convblit_blend_mask_alpha_byte_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 2, 0,0,0,-1, NONE);
+}
+
+void convblit_blend_mask_alpha_byte_16bpp_left(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 2, 0,0,0,-1, LEFT);
+}
+
+void convblit_blend_mask_alpha_byte_16bpp_right(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 2, 0,0,0,-1, RIGHT);
+}
+
+void convblit_blend_mask_alpha_byte_16bpp_down(PSD psd, PMWBLITPARMS gc)
+{
+	convblit_blend_mask_alpha_byte(psd, gc, 2, 0,0,0,-1, DOWN);
+}
+
+#if LATER
 /*
  * Conversion blit to draw 1bpp mono msb/lsb first byte bitmap into 8888 image.
  * Data is byte array, padded to byte boundary.
@@ -230,13 +693,12 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
 	int first_byte, last_byte, size_main, t, y;\
 	unsigned char *src, *dst;\
 	int usebg = gc->usebg;\
-	/* color values in MWCOLORVAL format*/\
-	uint32_t fg = gc->fg_color;\
+	uint32_t fg = gc->fg_colorval;				/* color values in MWCOLORVAL format*/\
 	unsigned char fg_r = REDVALUE(fg);\
 	unsigned char fg_g = GREENVALUE(fg);\
 	unsigned char fg_b = BLUEVALUE(fg);\
 	unsigned char fg_a = ALPHAVALUE(fg);\
-	uint32_t bg = gc->bg_color;\
+	uint32_t bg = gc->bg_colorval;\
 	unsigned char bg_r = REDVALUE(bg);\
 	unsigned char bg_g = GREENVALUE(bg);\
 	unsigned char bg_b = BLUEVALUE(bg);\
@@ -425,6 +887,10 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
 		src += gc->src_pitch;\
 		dst += gc->dst_pitch;\
 	}\
+\
+	/* update screen bits if driver requires it*/\
+	if (psd->Update)\
+		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);\
 }
 
 
@@ -432,7 +898,7 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
  * Fast, larger routine to draw mono 1bpp MSBFirst bitmap into ARGB image.
  * Bitmap is byte array.
  * This routine is best used for large bitmaps, as setup times are longer
- * than the simpler CONVBLIT_COPY_MASK_MONO_8888 routine.
+ * than the simpler CONVBLIT_COPY_MASK_MONO routine.
  *
  * Used to draw FT2 non-antialiased glyphs.
  */
@@ -441,7 +907,7 @@ void funcname(PSD psd, PMWBLITPARMS gc)\
 #define BITNUM(n) (0x80 >> (n))						/* byte msb*/
 #define FIRST_BIT BITNUM(0)
 #define LAST_BIT  BITNUM(7)
-CONVBLIT_COPY_MASK_MONO_8888_LARGE(convblit_copy_mask_mono_byte_msb_argb_large,0,1,2,3)
+CONVBLIT_COPY_MASK_MONO_8888_LARGE(convblit_copy_mask_mono_byte_msb_bgra_large,3,2,1,0)
 #undef BEFORE_OR_EQUAL
 #undef NEXT_BIT
 #undef BITNUM
@@ -461,9 +927,11 @@ CONVBLIT_COPY_MASK_MONO_8888_LARGE(convblit_copy_mask_mono_byte_msb_argb_large,0
 #define BITNUM(n) (0x01 << (n))						/* byte lsb*/
 #define FIRST_BIT BITNUM(0)
 #define LAST_BIT  BITNUM(7)
-CONVBLIT_COPY_MASK_MONO_8888_LARGE(convblit_copy_mask_mono_byte_lsb_argb_large,0,1,2,3)
+CONVBLIT_COPY_MASK_MONO_8888_LARGE(convblit_copy_mask_mono_byte_lsb_bgra_large,3,2,1,0)
 #undef BEFORE_OR_EQUAL
 #undef NEXT_BIT
 #undef BITNUM
 #undef FIRST_BIT
 #undef LAST_BIT
+
+#endif /* LATER*/
diff --git a/src/engine/devblit.c b/src/engine/devblit.c
index 43859b1..6dd8b47 100644
--- a/src/engine/devblit.c
+++ b/src/engine/devblit.c
@@ -18,11 +18,16 @@
 #include <assert.h>
 #include "swap.h"
 #include "device.h"
+#include "convblit.h"
+#include "../drivers/fb.h"		/* for DRAWON macro*/
 
 extern MWPIXELVAL gr_foreground;      /* current foreground color */
 extern MWPIXELVAL gr_background;      /* current background color */
 extern MWBOOL 	  gr_usebg;    	      /* TRUE if background drawn in pixmaps */
 
+typedef void (*BlitFunc)(PSD, PMWBLITPARMS);
+static void GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, BlitFunc convblit);
+
 /**
  * Draw a rectangular area using the current clipping region and the
  * specified bit map.  This differs from rectangle drawing in that the
@@ -139,40 +144,161 @@ GdBitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 	GdFixCursor(psd);
 }
 
+/* call conversion blit with clipping and cursor fix*/
+static void
+GdConvBlitInternal(PSD psd, PMWBLITPARMS gc, BlitFunc convblit)
+{
+	MWCOORD x = gc->dstx;
+	MWCOORD y = gc->dsty;
+	MWCOORD width = gc->width;
+	MWCOORD height = gc->height;
+	MWCOORD srcx, srcy;
+	MWCOORD rx1, rx2, ry1, ry2, rw, rh;
+	int count;
+#if DYNAMICREGIONS
+	MWRECT *prc;
+	extern MWCLIPREGION *clipregion;
+#else
+	MWCLIPRECT *prc;
+	extern MWCLIPRECT cliprects[];
+	extern int clipcount;
+#endif
+
+	/* check clipping region*/
+	switch(GdClipArea(psd, x, y, x + width - 1, y + height - 1)) {
+	case CLIP_VISIBLE:
+		DRAWON;
+		convblit(psd, gc);
+		DRAWOFF;
+		GdFixCursor(psd);
+		return;
+
+	case CLIP_INVISIBLE:
+		return;
+	}
+
+	/* partially clipped, we'll traverse visible region and draw*/
+	srcx = gc->srcx;
+	srcy = gc->srcy;
+
+#if DYNAMICREGIONS
+	prc = clipregion->rects;
+	count = clipregion->numRects;
+#else
+	prc = cliprects;
+	count = clipcount;
+#endif
+
+	while (count-- > 0) {
+#if DYNAMICREGIONS
+		rx1 = prc->left;
+		ry1 = prc->top;
+		rx2 = prc->right;
+		ry2 = prc->bottom;
+#else
+		/* old clip-code*/
+		rx1 = prc->x;
+		ry1 = prc->y;
+		rx2 = prc->x + prc->width;
+		ry2 = prc->y + prc->height;
+#endif
+
+		/* Check if this rect intersects with the one we draw */
+		if (rx1 < x)
+			rx1 = x;
+		if (ry1 < y)
+			ry1 = y;
+		if (rx2 > x + width)
+			rx2 = x + width;
+		if (ry2 > y + height)
+			ry2 = y + height;
+
+		rw = rx2 - rx1;
+		rh = ry2 - ry1;
+
+		if (rw > 0 && rh > 0) {
+			gc->dstx = rx1;
+			gc->dsty = ry1;
+			gc->width = rw;
+			gc->height = rh;
+			gc->srcx = srcx + rx1 - x;
+			gc->srcy = srcy + ry1 - y;
+			GdCheckCursor(psd, rx1, ry1, rx2 - 1, ry2 - 1);
+			DRAWON;
+			convblit(psd, gc);
+			DRAWOFF;
+		}
+		prc++;
+	}
+	GdFixCursor(psd);
+
+	/* Reset everything, in case the caller re-uses it. */
+	gc->dstx = x;
+	gc->dsty = y;
+	gc->width = width;
+	gc->height = height;
+	gc->srcx = srcx;
+	gc->srcy = srcy;
+}
+
 void
 GdConversionBlit(PSD psd, PMWBLITPARMS parms)
 {
+	BlitFunc convblit;
 	driver_gc_t	gc;
-	int op;
+	int op = 0;
+
+	/* setup destination for convblit*/
+	parms->dst_pitch = psd->pitch;
+	parms->data_out = psd->addr;
 
 	/* temp transfer parms to old driver struct*/
 	switch (parms->data_format) {
+	case MWIF_ALPHABYTE:			/* ft2 alias, t1lib alias*/
+		convblit = psd->BlitBlendMaskAlphaByte;		/* conv 8bpp alpha with fg/bg*/
+		op = PSDOP_ALPHACOL;
+		break;
+
 	case MWIF_MONOBYTEMSB:			/* ft2 non-alias*/
-		//convblit_copy_mono_byte_msb_argb(parms);	/* conv mono byte MSBFirst to ARGB*/
+		convblit = psd->BlitCopyMaskMonoByteMSB;	/* conv mono byte MSBFirst*/
 		op = PSDOP_BITMAP_BYTES_MSB_FIRST;
 		break;
 
-	//case MWIF_MONOWORDMSB:			/* core mwcfont, pcf*/
-		//convblit_copy_mono_word_msb_argb(parms);	/* conv mono word MSBFirst to ARGB*/
-		//break;
+	case MWIF_MONOWORDMSB:			/* core mwcfont, pcf*/
+		convblit = psd->BlitCopyMaskMonoWordMSB;	/* conv mono word MSBFirst*/
+		if (!convblit) {
+			DPRINTF("GdConversionBlit: no convblit, using GdBitmap fallback\n");
+			GdBitmap(psd, parms->dstx, parms->dsty, parms->width, parms->height, parms->data);
+			return;
+		}
+		break;
 
 	case MWIF_MONOBYTELSB:			/* t1lib non-alias*/
-		//convblit_copy_mono_byte_lsb_argb(parms);	/* conv mono byte LSBFirst to ARGB*/
+		convblit = psd->BlitCopyMaskMonoByteLSB;	/* conv mono byte LSBFirst*/
 		op = PSDOP_BITMAP_BYTES_LSB_FIRST;
 		break;
 
-	case MWIF_ALPHABYTE:			/* ft2 alias, t1lib alias*/
-		//convblit_blend_8_fgbg_argb(parms);		/* conv 8bpp alpha with fg/bg to ARGB*/
-		op = PSDOP_ALPHACOL;
+	case MWIF_RGBA8888:				/* png 32bpp w/alpha*/
+		convblit = psd->BlitSrcOverRGBA8888;		/* image, src 32bpp w/alpha - srcover*/
+		break;
+
+	case MWIF_RGB888:				/* png 24bpp no alpha*/
+		convblit = psd->BlitCopyRGB888;				/* image, src 24bpp - copy*/
 		break;
 
 	default:
-		printf("GdConversionBlit: No conversion blit available\n");
-		//FREEA(parms->data_out);
+		EPRINTF("GdConversionBlit: unsupported data format 0x%x\n", parms->data_format);
 		return;
+	}
 
+	/* call conversion blit routine*/
+	if (convblit) {
+		GdConvBlitInternal(psd, parms, convblit);
+		return;
 	}
 
+	DPRINTF("GdConversionBlit: no convblit, using DrawArea fallback\n");
+	/* FIXME temp copy into deprecated driver_t gc and call DrawArea driver entry point*/
 	gc.op = op;
 	gc.width = parms->width;
 	gc.height = parms->height;
@@ -180,18 +306,12 @@ GdConversionBlit(PSD psd, PMWBLITPARMS parms)
 	gc.dsty = parms->dsty;
 	gc.srcx = parms->srcx;
 	gc.srcy = parms->srcy;
-	gc.fg_color = parms->fg_color;
-	gc.bg_color = parms->bg_color;
+	gc.src_linelen = parms->src_pitch;
+	gc.fg_color = parms->fg_pixelval;		/* drawarea uses pixelval color*/
+	gc.bg_color = parms->bg_pixelval;
 	gc.usebg = parms->usebg;
 	gc.data = parms->data;
-
-	gc.src_linelen = parms->src_pitch;
 	//gc->dst_linelen = 
-
-	//parms->data_format;
-	//parms->dst_pitch;
-	//parms->data_out;
-
 	GdDrawAreaInternal(psd, &gc);
 }
 
@@ -206,6 +326,7 @@ GdConversionBlit(PSD psd, PMWBLITPARMS parms)
  * It is the caller's responsibility to GdFixCursor(psd).
  *
  * This is a low-level function.
+ * FIXME THIS FUNCTION WILL BE REMOVED WHEN GdConversionBlit/GdConvBlitInternal FINISHED.
  */
 void
 GdDrawAreaInternal(PSD psd, driver_gc_t * gc)
@@ -259,7 +380,7 @@ GdDrawAreaInternal(PSD psd, driver_gc_t * gc)
 		rx2 = prc->right;
 		ry2 = prc->bottom;
 #else
-		/* old clip-code by Morten */
+		/* old clip-code*/
 		rx1 = prc->x;
 		ry1 = prc->y;
 		rx2 = prc->x + prc->width;
diff --git a/src/engine/devdraw.c b/src/engine/devdraw.c
index 09efeb8..2702a2a 100644
--- a/src/engine/devdraw.c
+++ b/src/engine/devdraw.c
@@ -21,6 +21,8 @@
 
 extern MWPIXELVAL gr_foreground;      /* current foreground color */
 extern MWPIXELVAL gr_background;      /* current background color */
+extern MWCOLORVAL gr_foreground_rgb;  /* current fg color in 0xAARRGGBB format*/
+extern MWCOLORVAL gr_background_rgb;
 extern MWBOOL 	  gr_usebg;    	      /* TRUE if background drawn in pixmaps */
 extern int 	  gr_mode; 	      /* drawing mode */
 extern MWPALENTRY gr_palette[256];    /* current palette*/
@@ -127,6 +129,7 @@ GdSetForegroundColor(PSD psd, MWCOLORVAL fg)
 	MWPIXELVAL oldfg = gr_foreground;
 
 	gr_foreground = GdFindColor(psd, fg);
+	gr_foreground_rgb = fg;
 	return oldfg;
 }
 
@@ -144,6 +147,7 @@ GdSetBackgroundColor(PSD psd, MWCOLORVAL bg)
 	MWPIXELVAL oldbg = gr_background;
 
 	gr_background = GdFindColor(psd, bg);
+	gr_background_rgb = bg;
 	return oldbg;
 }
 
@@ -693,6 +697,7 @@ typedef union {
 	unsigned short v; 
 } RGB555;	
 
+static void GdDrawImageInternal(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage);
 /**
  * Draw a color bitmap image in 1, 4, 8, 24 or 32 bits per pixel.  The
  * Microwindows color image format is DWORD padded bytes, with
@@ -710,6 +715,45 @@ typedef union {
 void
 GdDrawImage(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
 {
+	MWBLITPARMS parms;
+
+	/* if not using new MWIF_ format and convblit drivers, must draw pixel by pixel*/
+	switch (pimage->data_format) {
+	case MWIF_RGBA8888:
+		if (psd->BlitSrcOverRGBA8888)
+			goto fastblit;
+		break;
+
+	case MWIF_RGB888:
+		if (psd->BlitCopyRGB888)
+			goto fastblit;
+		break;
+	}
+
+	if (pimage->data_format)
+		DPRINTF("GdDrawImage: no convblit, using DrawImageInternal fallback\n");
+	else DPRINTF("GdDrawImage: image not RGBA/RGB format, using slow GdDrawImageInternal\n");
+
+	GdDrawImageInternal(psd, x, y, pimage);			/* old pixel-by-pixel drawing*/
+	return;
+
+fastblit:
+	/* use fast conversion blit*/
+	parms.data_format = pimage->data_format;
+	parms.dstx = x;
+	parms.dsty = y;
+	parms.width = pimage->width;
+	parms.height = pimage->height;
+	parms.srcx = 0;
+	parms.srcy = 0;
+	parms.src_pitch = pimage->pitch;
+	parms.data = pimage->imagebits;
+	GdConversionBlit(psd, &parms);
+}
+
+static void
+GdDrawImageInternal(PSD psd, MWCOORD x, MWCOORD y, PMWIMAGEHDR pimage)
+{
 	MWCOORD minx;
 	MWCOORD maxx;
 	MWUCHAR bitvalue = 0;
@@ -1495,7 +1539,7 @@ GdCopyArea(PSD psd, MWCOORD srcx, MWCOORD srcy, MWCOORD width, MWCOORD height,
  */
 int
 GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height, int planes,
-	int bpp, int *psize, int *plinelen)
+	int bpp, int *psize, int *plinelen, int *ppitch)
 {
 	int	bytelen, linelen, tmp;
 
@@ -1561,8 +1605,9 @@ GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height, int planes,
 		return 0;
 	}
 
-	*plinelen = linelen;
 	*psize = bytelen * height;
+	*plinelen = linelen;
+	*ppitch = bytelen;
 	return 1;
 }
 
diff --git a/src/engine/devfont.c b/src/engine/devfont.c
index b8ddf63..b7ddba9 100644
--- a/src/engine/devfont.c
+++ b/src/engine/devfont.c
@@ -35,11 +35,11 @@ static PMWFONT	gr_pfont;
 /* temp extern decls*/
 extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
+extern MWCOLORVAL gr_foreground_rgb;
+extern MWCOLORVAL gr_background_rgb;
 extern MWBOOL gr_usebg;
 extern MWCOREFONT *user_builtin_fonts;
 
-void corefont_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
-		const void *text, int cc, MWTEXTFLAGS flags);
 static int utf8_to_utf16(const unsigned char *utf8, int cc,
 		unsigned short *unicode16);
 static int uc16_to_utf8(const unsigned short *us, int cc, unsigned char *s);
@@ -281,10 +281,10 @@ GdCreateFont(PSD psd, const char *name, MWCOORD height, MWCOORD width, const PMW
 		EPRINTF("createfont: %s,%d not found\n", fontname, height);
 		EPRINTF("  (tried "
 			"builtin_createfont"
-#ifdef HAVE_FNT_SUPPORT
+#if HAVE_FNT_SUPPORT
 			", fnt_createfont"
 #endif
-#ifdef HAVE_PCF_SUPPORT
+#if HAVE_PCF_SUPPORT
 			", pcf_createfont"
 #endif
 #if HAVE_FREETYPE_SUPPORT
@@ -450,15 +450,14 @@ GdText(PSD psd, MWCOORD x, MWCOORD y, const void *str, int cc,MWTEXTFLAGS flags)
 	 * rather than converting to the renderer specification.  This is
 	 * because we allow DBCS-encoded strings to draw using the
 	 * specially-compiled-in font if the character is not ASCII.
-	 * This is specially handled in corefont_drawtext below.
+	 * This is specially handled in gen_drawtext below.
 	 *
 	 * If the font is not builtin, then the drawtext routine must handle
 	 * all glyph output, including ASCII.
 	 */
 	if (flags & MWTF_DBCSMASK) {
 		/* force double-byte sequences to UC16 if builtin font only*/
-		if (gr_pfont->fontprocs->GetTextBits == gen_gettextbits &&
-		    gr_pfont->fontprocs->DrawText == corefont_drawtext) {
+		if (gr_pfont->fontprocs == &mwfontprocs) {
 			defencoding = MWTF_UC16;
 			force_uc16 = 1;
 		}
@@ -485,7 +484,7 @@ GdText(PSD psd, MWCOORD x, MWCOORD y, const void *str, int cc,MWTEXTFLAGS flags)
 	}
 
 	/* draw text string, DBCS flags may still be set*/
-#ifdef HAVE_KSC5601_SUPPORT
+#if HAVE_KSC5601_SUPPORT
 	if (flags & MWTF_DBCS_EUCKR)
 		;
 	else
@@ -499,10 +498,10 @@ GdText(PSD psd, MWCOORD x, MWCOORD y, const void *str, int cc,MWTEXTFLAGS flags)
 }
 
 /*
- * Draw ascii text using COREFONT type font.
+ * Draw ASCII or MWTF_UC16 text using COREFONT type font (buitin, PCF, FNT)
  */
 void
-corefont_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
+gen_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 	const void *text, int cc, MWTEXTFLAGS flags)
 {
 	const unsigned char *str = text;
@@ -512,8 +511,9 @@ corefont_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 	MWCOORD		base;			/* baseline of text*/
 	MWCOORD		startx, starty;
 	const MWIMAGEBITS *bitmap;		/* bitmap for characters */
-	MWBOOL		bgstate;
+	MWBOOL		bgstate = gr_usebg;
 	int		clip;
+	MWBLITPARMS parms;
 
 	if (flags & MWTF_DBCSMASK)
 		dbcs_gettextsize(pfont, istr, cc, flags, &width, &height, &base);
@@ -525,131 +525,67 @@ corefont_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		y -= (height - 1);
 	startx = x;
 	starty = y + base;
-	bgstate = gr_usebg;
 
 	switch (clip = GdClipArea(psd, x, y, x + width - 1, y + height - 1)) {
 	case CLIP_VISIBLE:
-		/* clear background once for all characters*/
-		if (gr_usebg)
-			psd->FillRect(psd, x, y, x + width - 1, y + height - 1,
-				gr_background);
-
-		/* FIXME if we had a low-level text drawer, plug in here:
-		psd->DrawText(psd, x, y, str, cc, gr_foreground, pfont);
-		GdFixCursor(psd);
-		return;
-		*/
-
-		/* save state for combined routine below*/
-		bgstate = gr_usebg;
-		gr_usebg = FALSE;
+		/* clear background once for all characters, save usebg state*/
+		if (gr_usebg && psd->bpp < 16) {	//FIXME kluge for non-convblit systems
+			psd->FillRect(psd, x, y, x + width - 1, y + height - 1, gr_background);
+			gr_usebg = FALSE;
+		}
 		break;
 
 	case CLIP_INVISIBLE:
 		return;
 	}
 
-	/* Get the bitmap for each character individually, and then display
-	 * them possibly using clipping for each one.
-	 */
+	/* fill in unchanging blit parms*/
+	parms.data_format = MWIF_MONOWORDMSB;	/* data is 1bpp words, msb first*/
+	parms.op = MWROP_COPY;					/* copy to dst, 1=fg (0=bg if usebg)*/
+	parms.fg_colorval = gr_foreground_rgb;		/* for convblit*/
+	parms.bg_colorval = gr_background_rgb;
+	//parms.fg_pixelval = gr_foreground;			/* for drawarea fallback*/
+	//parms.bg_pixelval = gr_background;
+	parms.usebg = gr_usebg;
+	parms.srcx = 0;
+	parms.srcy = 0;
 
 	/*
-	 * If the string was marked as DBCS, then we've forced the conversion
-	 * to UC16 in GdText.  Here we special-case the non-ASCII values and
-	 * get the bitmaps from the specially-compiled-in font.  Otherwise,
-	 * we draw them using the normal pfont->fontprocs->GetTextBits.
+	 * Get the bitmap for each character individually, and then display
+	 * them possibly using clipping for each one.
 	 */
 	while (--cc >= 0 && x < psd->xvirtres) {
+		/*
+	 	 * If the string was marked as DBCS, then we've forced the conversion
+	 	 * to UC16 in GdText.  Here we special-case the non-ASCII values and
+	 	 * get the bitmaps from the specially-compiled-in font.  Otherwise,
+	 	 * we draw them using the normal pfont->fontprocs->GetTextBits.
+	 	 */
 		if (flags & MWTF_DBCSMASK)
-			dbcs_gettextbits(pfont, *istr++, flags, &bitmap, &width,
-				&height, &base);
+			dbcs_gettextbits(pfont, *istr++, flags, &bitmap, &width, &height, &base);
 		else {
 			int ch;
 
 			if (pfont->fontprocs->encoding == MWTF_UC16)
 				ch = *istr++;
 			else ch = *str++;
-			pfont->fontprocs->GetTextBits(pfont, ch, &bitmap, &width,
-				&height, &base);
+			pfont->fontprocs->GetTextBits(pfont, ch, &bitmap, &width, &height, &base);
 		}
 
-		if (clip == CLIP_VISIBLE)
-			drawbitmap(psd, x, y, width, height, bitmap);
-		else
-			GdBitmap(psd, x, y, width, height, bitmap);
-		x += width;
-	}
-
-	if (pfont->fontattr & MWTF_UNDERLINE)
-		GdLine(psd, startx, starty, x, starty, FALSE);
-
-	/* restore background draw state*/
-	gr_usebg = bgstate;
-
-	GdFixCursor(psd);
-}
-
-#if HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT
-/*
- * Draw MWTF_UC16 text using COREFONT type font.
- */
-void
-gen16_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
-	const void *text, int cc, MWTEXTFLAGS flags)
-{
-	const unsigned short *str = text;
-	MWCOORD		width;			/* width of text area */
-	MWCOORD		height;			/* height of text area */
-	MWCOORD		base;			/* baseline of text */
-	MWCOORD		startx, starty;
-	const MWIMAGEBITS *bitmap;		/* bitmap for characters */
-	MWBOOL		bgstate;
-	int		clip;
-
-	pfont->fontprocs->GetTextSize(pfont, str, cc, flags, &width, &height, &base);
-
-	if (flags & MWTF_BASELINE)
-		y -= base;
-	else if (flags & MWTF_BOTTOM)
-		y -= (height - 1);
-	startx = x;
-	starty = y + base;
-	bgstate = gr_usebg;
-
-	switch (clip = GdClipArea(psd, x, y, x + width - 1, y + height - 1)) {
-	case CLIP_VISIBLE:
-		/* clear background once for all characters*/
-		if (gr_usebg)
-			psd->FillRect(psd, x, y, x + width - 1, y + height - 1,
-				gr_background);
-
-		/* FIXME if we had a low-level text drawer, plug in here:
-		psd->DrawText(psd, x, y, str, cc, gr_foreground, pfont);
-		GdFixCursor(psd);
-		return;
-		*/
-
-		/* save state for combined routine below*/
-		bgstate = gr_usebg;
-		gr_usebg = FALSE;
-		break;
-
-	case CLIP_INVISIBLE:
-		return;
-	}
-
-	/* Get the bitmap for each character individually, and then display
-	 * them using clipping for each one.
-	 */
-	while (--cc >= 0 && x < psd->xvirtres) {
-		unsigned int ch = *str++;
-		pfont->fontprocs->GetTextBits(pfont, ch, &bitmap, &width,
-			&height, &base);
-
-		if (clip == CLIP_VISIBLE)
-			drawbitmap(psd, x, y, width, height, bitmap);
-		else
-			GdBitmap(psd, x, y, width, height, bitmap);
+		if (psd->bpp >= 16) {
+			parms.dstx = x;
+			parms.dsty = y;
+			parms.height = height;
+			parms.width = width;
+			parms.src_pitch = ((width + 15) >> 4) << 1;	/* pad to WORD boundary*/
+			parms.data = (char *)bitmap;
+			GdConversionBlit(psd, &parms);
+		} else {
+			if (clip == CLIP_VISIBLE)
+				drawbitmap(psd, x, y, width, height, bitmap);
+			else
+				GdBitmap(psd, x, y, width, height, bitmap);
+		}
 		x += width;
 	}
 
@@ -661,7 +597,6 @@ gen16_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 
 	GdFixCursor(psd);
 }
-#endif /* HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT*/
 
 #if HAVE_FREETYPE_SUPPORT
 /*
@@ -980,8 +915,7 @@ GdGetTextSize(PMWFONT pfont, const void *str, int cc, MWCOORD *pwidth,
 	/* DBCS handled specially: see comment in GdText*/
 	if (flags & MWTF_DBCSMASK) {
 		/* force double-byte sequences to UC16 if builtin font only*/
-		if (pfont->fontprocs->GetTextBits == gen_gettextbits &&
-		    pfont->fontprocs->DrawText == corefont_drawtext) {
+		if (gr_pfont->fontprocs == &mwfontprocs) {
 			defencoding = MWTF_UC16;
 			force_uc16 = 1;
 		}
diff --git a/src/engine/devimage.c b/src/engine/devimage.c
index 0950670..003925d 100644
--- a/src/engine/devimage.c
+++ b/src/engine/devimage.c
@@ -390,6 +390,7 @@ GdDrawImageToFit(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 		image2.height = height;
 		image2.planes = pimage->planes;
 		image2.bpp = pimage->bpp;
+		image2.data_format = pimage->data_format;
 		GdComputeImagePitch(pimage->bpp, width, &image2.pitch,
 			&image2.bytesperpixel);
 		image2.compression = pimage->compression;
@@ -461,6 +462,7 @@ GdDrawImagePartToFit(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD heigh
 		image2.height = height;
 		image2.planes = pimage->planes;
 		image2.bpp = pimage->bpp;
+		image2.data_format = pimage->data_format;
 		GdComputeImagePitch(pimage->bpp, width, &image2.pitch,
 			&image2.bytesperpixel);
 		image2.compression = pimage->compression;
@@ -542,6 +544,7 @@ GdGetImageInfo(int id, PMWIMAGEINFO pii)
 	pii->height = pimage->height;
 	pii->planes = pimage->planes;
 	pii->bpp = pimage->bpp;
+	pii->data_format = pimage->data_format;
 	pii->pitch = pimage->pitch;
 	pii->bytesperpixel = pimage->bytesperpixel;
 	pii->compression = pimage->compression;
@@ -602,6 +605,7 @@ void print_image(PMWIMAGEHDR image)
 	DPRINTF("width: %d\n", image->width);
 	DPRINTF("planes: %d\n", image->planes);
 	DPRINTF("bpp: %d\n", image->bpp);
+	DPRINTF("data_format: %d\n", image->data_format);
 	DPRINTF("compression: %d\n", image->compression);
 	DPRINTF("palsize: %d\n", image->palsize);
 
diff --git a/src/engine/devopen.c b/src/engine/devopen.c
index 2eede7c..c523acd 100644
--- a/src/engine/devopen.c
+++ b/src/engine/devopen.c
@@ -37,6 +37,8 @@ int 	gr_mode = MWROP_COPY; 	    /* drawing mode */
 /*static*/ MWPALENTRY	gr_palette[256];    /* current palette*/
 /*static*/ int	gr_firstuserpalentry;/* first user-changable palette entry*/
 /*static*/ int 	gr_nextpalentry;    /* next available palette entry*/
+MWCOLORVAL gr_foreground_rgb;	/* current fg color in 0xAARRGGBB format for mono convblits*/
+MWCOLORVAL gr_background_rgb;	/* current background color */
 
 uint32_t gr_dashmask;     /* An actual bitmask of the dash values */
 uint32_t gr_dashcount;    /* The number of bits defined in the dashmask */
diff --git a/src/engine/font_eucjp.c b/src/engine/font_eucjp.c
index 8fa689f..22af58f 100644
--- a/src/engine/font_eucjp.c
+++ b/src/engine/font_eucjp.c
@@ -26,7 +26,6 @@
 #endif
 
 typedef struct MWEUCJPFONT {
-	0,						/* can't scale*/
 	PMWFONTPROCS fontprocs;	/* common hdr */
 	int fontsize;
 	int	fontwidth;
@@ -56,6 +55,7 @@ static void eucjp_destroyfont(PMWFONT pfont);
 
 /* handling routines for MWEUCJPFONT*/
 static MWFONTPROCS eucjp_procs = {
+	0,				/* can't scale*/
 	MWTF_UC16,		/* routines expect unicode index*/
 	NULL,			/* init*/
 	eucjp_createfont,
@@ -63,7 +63,7 @@ static MWFONTPROCS eucjp_procs = {
 	eucjp_gettextsize,
 	eucjp_gettextbits,
 	eucjp_destroyfont,
-	corefont_drawtext,
+	gen_drawtext,
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
diff --git a/src/engine/font_fnt.c b/src/engine/font_fnt.c
index bfa1d57..aeabdf8 100644
--- a/src/engine/font_fnt.c
+++ b/src/engine/font_fnt.c
@@ -75,11 +75,7 @@ MWFONTPROCS fnt_fontprocs = {
 	gen_gettextsize,
 	gen_gettextbits,
 	fnt_unloadfont,
-#if STANDALONE
-	gen16_drawtext, //FIXME
-#else
-	corefont_drawtext,
-#endif
+	gen_drawtext,
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
@@ -93,10 +89,10 @@ static MWFONTPROCS fnt_fontprocs16 = {
 	NULL,			/* init*/
 	fnt_createfont,
 	gen_getfontinfo,
-	gen16_gettextsize,
+	gen_gettextsize,
 	gen_gettextbits,
 	fnt_unloadfont,
-	gen16_drawtext,
+	gen_drawtext,
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
diff --git a/src/engine/font_freetype2.c b/src/engine/font_freetype2.c
index 3057875..b2306ac 100644
--- a/src/engine/font_freetype2.c
+++ b/src/engine/font_freetype2.c
@@ -47,6 +47,8 @@
 #endif
 
 /* temp extern decls*/
+extern MWCOLORVAL gr_foreground_rgb;
+extern MWCOLORVAL gr_background_rgb;
 extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
 extern MWBOOL gr_usebg;
@@ -1183,13 +1185,13 @@ freetype2_drawtext(PMWFONT pfont, PSD psd, MWCOORD ax, MWCOORD ay,
 	use_kerning = (pf->fontattr & MWTF_KERNING) && FT_HAS_KERNING(face);
 
 	/* Initialize blit parms we won't change*/
-	parms.fg_color = gr_foreground;
-	parms.bg_color = gr_background;
+	parms.fg_colorval = gr_foreground_rgb;		/* for convblit*/
+	parms.bg_colorval = gr_background_rgb;
+	parms.fg_pixelval = gr_foreground;			/* for drawarea fallback*/
+	parms.bg_pixelval = gr_background;
 	parms.usebg = gr_usebg;
 	parms.srcx = 0;
 	parms.srcy = 0;
-	parms.dst_pitch = 0;		/* set later in GdConversionBlit*/
-	parms.data_out = 0;			/* set later in GdConversionBlit*/
 
 	// FIXME: don't use antialias settings if no alphacol driver (psd->flags & PSF_HAVEOP_ALPHACOL)
 	if (pf->fontattr & MWTF_ANTIALIAS) {
diff --git a/src/engine/font_pcf.c b/src/engine/font_pcf.c
index 86b1d37..f500800 100644
--- a/src/engine/font_pcf.c
+++ b/src/engine/font_pcf.c
@@ -99,11 +99,7 @@ MWFONTPROCS pcf_fontprocs = {
 	gen_gettextsize,
 	gen_gettextbits,
 	pcf_unloadfont,
-#if STANDALONE
-	gen16_drawtext,
-#else
-	corefont_drawtext,
-#endif
+	gen_drawtext,
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
@@ -117,10 +113,10 @@ static MWFONTPROCS pcf_fontprocs16 = {
 	NULL,			/* init*/
 	pcf_createfont,
 	gen_getfontinfo,
-	gen16_gettextsize,
+	gen_gettextsize,
 	gen_gettextbits,
 	pcf_unloadfont,
-	gen16_drawtext,
+	gen_drawtext,
 	NULL,			/* setfontsize */
 	NULL,			/* setfontrotation */
 	NULL,			/* setfontattr */
diff --git a/src/engine/font_t1lib.c b/src/engine/font_t1lib.c
index 60b0afe..f807a49 100644
--- a/src/engine/font_t1lib.c
+++ b/src/engine/font_t1lib.c
@@ -73,6 +73,8 @@ MWFONTPROCS t1lib_fontprocs = {
 };
 
 /* temp extern decls*/
+extern MWCOLORVAL gr_foreground_rgb;
+extern MWCOLORVAL gr_background_rgb;
 extern MWPIXELVAL gr_foreground;
 extern MWPIXELVAL gr_background;
 extern MWBOOL gr_usebg;
@@ -233,13 +235,13 @@ t1lib_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		else if(flags & MWTF_BOTTOM)
 			y -= height - 1;
 
-		parms.fg_color = gr_foreground;
-		parms.bg_color = gr_background;
+		parms.fg_colorval = gr_foreground_rgb;		/* for convblit*/
+		parms.bg_colorval = gr_background_rgb;
+		parms.fg_pixelval = gr_foreground;			/* for drawarea fallback*/
+		parms.bg_pixelval = gr_background;
 		parms.usebg = gr_usebg;
 		parms.srcx = 0;
 		parms.srcy = 0;
-		parms.dst_pitch = 0;		/* set later in GdConversionBlit*/
-		parms.data_out = 0;			/* set later in GdConversionBlit*/
 		parms.dstx = x;
 		parms.dsty = y;
 		parms.height = height;
diff --git a/src/engine/image_bmp.c b/src/engine/image_bmp.c
index f6fc241..f50cb6a 100644
--- a/src/engine/image_bmp.c
+++ b/src/engine/image_bmp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2001, 2003, 2005 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 2000, 2001, 2003, 2005, 2010 Greg Haerr <greg@censoft.com>
  * Portions Copyright (c) 2000 Martin Jolicoeur <martinj@visuaide.com>
  *
  * Image decode routine for BMP files
@@ -73,10 +73,63 @@ static int	DecodeRLE8(MWUCHAR *buf, buffer_t *src);
 static int	DecodeRLE4(MWUCHAR *buf, buffer_t *src);
 static void	put4(int b);
 
+void convblit_bgr888_rgb888(unsigned char *data, int width, int height, int pitch);
+void convblit_bgr8888_rgba8888(unsigned char *data, int width, int height, int pitch);
+
 /*
- * BMP decoding routine
+ * Conversion blit 24bpp BGR to 24bpp RGB
+ */
+void convblit_bgr888_rgb888(unsigned char *data, int width, int height, int pitch)
+{
+	unsigned char *src = data;
+
+	while (--height >= 0)
+	{
+		register unsigned char *s = src;
+		int w = width;
+
+		while (--w >= 0)
+		{
+			/* swap R and B*/
+			unsigned char b = s[0];
+			s[0] = s[2];
+			s[2] = b;
+
+			s += 3;
+		}
+		src += pitch;
+	}
+}
+
+/*
+ * Conversion blit 32bpp BGRX to 32bpp RGBA 255 alpha
  */
+void convblit_bgr8888_rgba8888(unsigned char *data, int width, int height, int pitch)
+{
+	unsigned char *src = data;
+
+	while (--height >= 0)
+	{
+		register unsigned char *s = src;
+		int w = width;
+
+		while (--w >= 0)
+		{
+			/* swap R and B*/
+			unsigned char b = s[0];
+			s[0] = s[2];
+			s[2] = b;
+			s[3] = 255;		/* alpha*/
+
+			s += 4;
+		}
+		src += pitch;
+	}
+}
 
+/*
+ * BMP decoding routine
+ */
 int
 GdDecodeBMP(buffer_t *src, PMWIMAGEHDR pimage)
 {
@@ -161,7 +214,9 @@ GdDecodeBMP(buffer_t *src, PMWIMAGEHDR pimage)
 			pimage->palsize = 1 << pimage->bpp;
 		compression = bmpi.BiCompression;
 	}
-	pimage->compression = MWIMAGE_BGR;	/* right side up, BGR order*/
+printf("bmp bpp %d\n", pimage->bpp);
+	pimage->compression = MWIMAGE_RGB;	/* right side up, BGR order will be converted to RGB*/
+	pimage->data_format = 0;		/* force GdDrawImage for now*/
 	pimage->planes = 1;
 
 	/* only 1, 4, 8, 16, 24 and 32 bpp bitmaps*/
@@ -179,8 +234,7 @@ GdDecodeBMP(buffer_t *src, PMWIMAGEHDR pimage)
 	}
 
 	/* compute byte line size and bytes per pixel*/
-	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch,
-		&pimage->bytesperpixel);
+	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch, &pimage->bytesperpixel);
 
 	/* Allocate image */
 	if( (pimage->imagebits = malloc(pimage->pitch*pimage->height)) == NULL)
@@ -236,11 +290,16 @@ GdDecodeBMP(buffer_t *src, PMWIMAGEHDR pimage)
 			if(!DecodeRLE4(imagebits, src))
 				break;
 		} else {
-			if(GdImageBufferRead(src, imagebits, pimage->pitch) !=
-				pimage->pitch)
+			if(GdImageBufferRead(src, imagebits, pimage->pitch) != pimage->pitch)
 					goto err;
 		}
 	}
+
+	/* conv BGR -> RGB*/
+	if (pimage->bpp == 24)
+		convblit_bgr888_rgb888(imagebits, pimage->width, pimage->height, pimage->pitch);
+	else if (pimage->bpp == 32)
+		convblit_bgr8888_rgba8888(imagebits, pimage->width, pimage->height, pimage->pitch);
 	return 1;		/* bmp image ok*/
 	
 err:
diff --git a/src/engine/image_gif.c b/src/engine/image_gif.c
index b22cc46..254f85f 100644
--- a/src/engine/image_gif.c
+++ b/src/engine/image_gif.c
@@ -467,7 +467,8 @@ ReadImage(buffer_t* src, PMWIMAGEHDR pimage, int len, int height, int cmapSize,
     pimage->planes = 1;
     pimage->bpp = 8;
     GdComputeImagePitch(8, len, &pimage->pitch, &pimage->bytesperpixel);
-    pimage->compression = MWIMAGE_BGR;	/* right side up, BGR order*/
+    pimage->compression = 0;
+    pimage->data_format = 0;		/* force GdDrawImage for now*/
     pimage->palsize = cmapSize;
     pimage->palette = malloc(256*sizeof(MWPALENTRY));
     pimage->imagebits = malloc(height*pimage->pitch);
@@ -475,8 +476,7 @@ ReadImage(buffer_t* src, PMWIMAGEHDR pimage, int len, int height, int cmapSize,
 	    return 0;
 
     for (i = 0; i < cmapSize; i++) {
-	/*ImageSetCmap(image, i, cmap[CM_RED][i],
-		     cmap[CM_GREEN][i], cmap[CM_BLUE][i]);*/
+	/*ImageSetCmap(image, i, cmap[CM_RED][i], cmap[CM_GREEN][i], cmap[CM_BLUE][i]);*/
 	pimage->palette[i].r = cmap[CM_RED][i];
 	pimage->palette[i].g = cmap[CM_GREEN][i];
 	pimage->palette[i].b = cmap[CM_BLUE][i];
diff --git a/src/engine/image_jpeg.c b/src/engine/image_jpeg.c
index 9a4e628..73be407 100644
--- a/src/engine/image_jpeg.c
+++ b/src/engine/image_jpeg.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2001, 2003 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 2000, 2001, 2003, 2010 Greg Haerr <greg@censoft.com>
  * Portions Copyright (c) 2000 Martin Jolicoeur <martinj@visuaide.com>
  * Portions Copyright (c) Independant JPEG group (ijg)
  *
@@ -188,9 +188,12 @@ fastjpeg:
 	pimage->bpp = (fast_grayscale || psd->pixtype == MWPF_PALETTE)?
 		8: cinfo.output_components*8;
 #endif
-	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch,
-		&pimage->bytesperpixel);
+	if (pimage->bpp == 24)
+		pimage->data_format = MWIF_RGB888;
+	else pimage->data_format = 0;		/* force GdDrawImage for now*/
 	pimage->compression = MWIMAGE_RGB;	/* RGB not BGR order*/
+printf("jpeg bpp %d\n", pimage->bpp);
+	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch, &pimage->bytesperpixel);
 	pimage->palsize = (pimage->bpp == 8)? 256: 0;
 	pimage->imagebits = malloc(pimage->pitch * pimage->height);
 	if(!pimage->imagebits)
diff --git a/src/engine/image_png.c b/src/engine/image_png.c
index 73d657d..355e98b 100644
--- a/src/engine/image_png.c
+++ b/src/engine/image_png.c
@@ -141,6 +141,14 @@ GdDecodePNG(buffer_t * src, PMWIMAGEHDR pimage)
 	pimage->bpp = channels * 8;
 	pimage->bytesperpixel = channels;
 
+	/* set format for blit output*/
+	if (channels == 4)
+		pimage->data_format = MWIF_RGBA8888;
+	else if (channels == 3)
+		pimage->data_format = MWIF_RGB888;
+	else pimage->data_format = 0;		/* will use slow GdDrawImage*/
+printf("png %dbpp\n", channels*8);
+
 	if (alpha_present)
 		pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
 	else
diff --git a/src/engine/image_pnm.c b/src/engine/image_pnm.c
index 0b8b171..4823d23 100644
--- a/src/engine/image_pnm.c
+++ b/src/engine/image_pnm.c
@@ -109,6 +109,9 @@ GdDecodePNM(buffer_t *src, PMWIMAGEHDR pimage)
 	pimage->planes = 1;
 	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch, &pimage->bytesperpixel);
 	pimage->compression = MWIMAGE_RGB;
+	if (pimage->bpp == 24)
+		pimage->data_format = MWIF_RGB888;
+	else pimage->data_format = 0;		/* force GdDrawImage for now*/
 	if(!(pimage->imagebits = malloc(pimage->pitch * pimage->height))) {
 		EPRINTF("GdDecodePNM: couldn't allocate memory for image\n");
 		if(pimage->palette)
diff --git a/src/engine/image_tiff.c b/src/engine/image_tiff.c
index a1f87ad..cfc977d 100644
--- a/src/engine/image_tiff.c
+++ b/src/engine/image_tiff.c
@@ -17,12 +17,48 @@
 #if MW_FEATURE_IMAGES && defined(HAVE_TIFF_SUPPORT)
 #include <tiffio.h>
 
+void convblit_flipy_8888(PMWBLITPARMS gc);
+
+/*
+ * Conversion blit flip y direction 32bpp (upside-down)
+ */
+void convblit_flipy_8888(PMWBLITPARMS gc)
+{
+	unsigned char *dst;
+	unsigned char *src = ((unsigned char *)gc->data) + gc->srcy * gc->src_pitch + gc->srcx * 4;
+	int height = gc->height;
+
+	/* flip y coordinate*/
+	gc->dsty = height - gc->dsty - 1;
+	dst = ((unsigned char *)gc->data_out)            + gc->dsty * gc->dst_pitch + gc->dstx * 4;
+
+	while (--height >= 0)
+	{
+		register unsigned char *d = dst;
+		register unsigned char *s = src;
+		int w = gc->width;
+
+		while (--w >= 0)
+		{
+			d[0] = s[0];
+			d[1] = s[1];
+			d[2] = s[2];
+			d[3] = s[3];
+
+			d += 4;
+			s += 4;
+		}
+		src += gc->src_pitch;
+		dst -= gc->dst_pitch;
+	}
+}
+
 int
 GdDecodeTIFF(char *path, PMWIMAGEHDR pimage)
 {
 	TIFF 	*tif;
 	int		w, h;
-	long	size;
+	MWBLITPARMS parms;
 	static TIFFErrorHandler prev_handler = NULL;
 
 	if (!prev_handler)
@@ -34,26 +70,34 @@ GdDecodeTIFF(char *path, PMWIMAGEHDR pimage)
 
 	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);
 	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);
-	size = w * h;
 	pimage->width = w;
 	pimage->height = h;
 	pimage->bpp = 32;
-	pimage->pitch = w * sizeof(uint32);
+	pimage->pitch = w * 4;
 	pimage->bytesperpixel = 4;
 	pimage->planes = 1;
 	pimage->palsize = 0;
 	pimage->palette = NULL;
+	pimage->data_format = MWIF_RGBA8888;		/* upside down 32bpp RGBA image*/
 
-	/* upside down, RGB order (with alpha)*/
-	pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL |
-		MWIMAGE_UPSIDEDOWN;
+	/* compression used only by GdDrawImage fallback*/
+	pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL | MWIMAGE_UPSIDEDOWN;
 
 	/* Allocate image */
-	if ((pimage->imagebits = malloc(size * sizeof(uint32))) == NULL)
-		goto err;
+	if ((parms.data = malloc(h * pimage->pitch)) == NULL ||
+	    (pimage->imagebits = malloc(h * pimage->pitch)) == NULL)
+			goto err;
+
+	TIFFReadRGBAImage(tif, pimage->width, pimage->height, (uint32 *)parms.data, 0);
 
-	TIFFReadRGBAImage(tif, pimage->width, pimage->height,
-		(uint32 *)pimage->imagebits, 0);
+	/* use conversion blit to flip upside down image*/
+	parms.dstx = parms.dsty = parms.srcx = parms.srcy = 0;
+	parms.width = pimage->width;
+	parms.height = pimage->height;
+	parms.src_pitch = parms.dst_pitch = pimage->pitch;
+	parms.data_out = pimage->imagebits;
+	convblit_flipy_8888(&parms);
+	free(parms.data);
 
 	TIFFClose(tif);
 	return 1;
@@ -62,6 +106,8 @@ err:
 	EPRINTF("GdDecodeTIFF: image loading error\n");
 	if (tif)
 		TIFFClose(tif);
+	if(parms.data)
+		free(parms.data);
 	if(pimage->imagebits)
 		free(pimage->imagebits);
 	if(pimage->palette)
diff --git a/src/engine/image_xpm.c b/src/engine/image_xpm.c
index 3c41780..456d2e9 100644
--- a/src/engine/image_xpm.c
+++ b/src/engine/image_xpm.c
@@ -70,8 +70,7 @@ XPM_parse_color(char *color)
 			g = strtol(gstr, NULL, 16) >> 8;
 			b = strtol(bstr, NULL, 16) >> 8;
 
-			return (long)(255L << 24 |
-				(r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF));
+			return (long)(255L << 24 | (r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF));
 		}
 	}
 
@@ -155,21 +154,22 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 			if (sinfo.bpp <= 8) {
 				pimage->bpp = sinfo.bpp;
 				pimage->compression = 0;
+				pimage->data_format = 0;		/* force GdDrawImage for now*/
 			} else {
 				pimage->bpp = 32;
-				pimage->compression = MWIMAGE_BGR;
+				pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
+				pimage->data_format = MWIF_RGBA8888;
+printf("xpm 32bpp ARGB8888\n");
 			}
 
 			pimage->palsize = colors;
-			GdComputeImagePitch(pimage->bpp, col, &pimage->pitch,
-					    &pimage->bytesperpixel);
+			GdComputeImagePitch(pimage->bpp, col, &pimage->pitch, &pimage->bytesperpixel);
 
 			pimage->imagebits = malloc(pimage->pitch * pimage->height);
 			imageptr = (unsigned char *) pimage->imagebits;
 
 			/* Allocate enough room for all the colors */
-			colorheap = (struct xpm_cmap *) malloc(colors *
-							   sizeof(struct xpm_cmap));
+			colorheap = (struct xpm_cmap *) malloc(colors * sizeof(struct xpm_cmap));
 
 			/* Allocate the palette space (if required) */
 			if (sinfo.bpp <= 8)
@@ -248,10 +248,8 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 					pimage->transcolor = in_color;
 				}
 
-				pimage->palette[in_color].r =
-					(n->color >> 16) & 0xFF;
-				pimage->palette[in_color].g =
-					(n->color >> 8) & 0xFF;
+				pimage->palette[in_color].r = (n->color >> 16) & 0xFF;
+				pimage->palette[in_color].g = (n->color >> 8) & 0xFF;
 				pimage->palette[in_color].b = n->color & 0xFF;
 			}
 
@@ -297,8 +295,7 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 					z = pxlstr[0];
 
 					if (!colormap[z]) {
-						EPRINTF("GdDecodeXPM: No color entry for (%s)\n",
-							pxlstr);
+						EPRINTF("GdDecodeXPM: No color entry for (%s)\n", pxlstr);
 						return -1;
 					}
 
@@ -357,6 +354,7 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 
 					break;
 
+#ifdef NOTUSED
 				case 8:
 				case 16:
 				case 24:
@@ -368,8 +366,7 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 					imageptr += pimage->bytesperpixel;
 					bytecount += pimage->bytesperpixel;
 					break;
-
-#ifdef NOTUSED
+#endif
 				case 8:
 					imageptr[0] = (unsigned char) (dwordcolor & 0xFF);
 					imageptr += pimage->bytesperpixel;
@@ -379,21 +376,20 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 				case 16:
 				case 24:
 				case 32:
-					imageptr[0] = (unsigned char) (dwordcolor >> 24) & 0xFF;
-					imageptr[1] = (unsigned char) (dwordcolor >> 16) & 0xFF;
-					imageptr[2] = (unsigned char) (dwordcolor >> 8) & 0xFF;
-					imageptr[3] = (unsigned char) (dwordcolor & 0xFF);
+					/* create RGBA image*/
+					imageptr[3] = (unsigned char) (dwordcolor >> 24) & 0xFF;	// A
+					imageptr[0] = (unsigned char) (dwordcolor >> 16) & 0xFF;	// R
+					imageptr[1] = (unsigned char) (dwordcolor >> 8) & 0xFF;		// G
+					imageptr[2] = (unsigned char) (dwordcolor & 0xFF);			// B
 					imageptr += pimage->bytesperpixel;
 					bytecount += pimage->bytesperpixel;
 					break;
-#endif
 				}
 			}
 
 			/* Pad to the end of the line */
 			if (bytecount < pimage->pitch)
-				for (i = 0; i < (pimage->pitch - bytecount);
-				     i++)
+				for (i = 0; i < (pimage->pitch - bytecount); i++)
 					*imageptr++ = 0x00;
 
 			read_xline++;
diff --git a/src/fontdemo3.sh b/src/fontdemo3.sh
index 0a648e6..5acbcb1 100755
--- a/src/fontdemo3.sh
+++ b/src/fontdemo3.sh
@@ -9,4 +9,4 @@
 #bin/nano-X & bin/nanowm & bin/pcfdemo /usr/lib/X11/fonts/misc/6x13.pcf.gz
 #bin/nano-X & bin/nanowm & bin/pcfdemo /usr/lib/X11/fonts/misc/9x15.pcf.gz
 #bin/nano-X -N & bin/nanowm & bin/pcfdemo fonts/pcf/jiskan24.pcf.gz
-bin/nano-X -N & bin/nanowm & bin/pcfdemo /usr/share/fonts/X11/misc/cursor.pcf.gz & bin/pcfdemo fonts/pcf/vga.pcf.gz & bin/pcfdemo fonts/pcf/helvB12_lin.pcf.gz & bin/pcfdemo fonts/pcf/jiskan24.pcf.gz
+bin/nano-X -L & bin/nanowm & bin/pcfdemo /usr/share/fonts/X11/misc/cursor.pcf.gz & bin/pcfdemo fonts/pcf/vga.pcf.gz & bin/pcfdemo fonts/pcf/helvB12_lin.pcf.gz & bin/pcfdemo fonts/pcf/jiskan24.pcf.gz
diff --git a/src/fonts/korean/jo16x16.c b/src/fonts/korean/jo16x16.c
index 060d4a1..2ef9734 100644
--- a/src/fonts/korean/jo16x16.c
+++ b/src/fonts/korean/jo16x16.c
@@ -8,12 +8,15 @@
  *	No warranties is provided, as to this code.
  */
 #include <stdio.h>
+#include <string.h>
 
 #define   FONT_SIZE 32
 #define   NTYPES1   8
 #define   NTYPES2   4
 #define   NTYPES3   4
 
+int	get_han_image( int johab_code, char *bitmap);
+
 static char HanFont1[NTYPES1][19][FONT_SIZE] = {
    {  {	  0,  0,  0,  0,  0,  0,  0,  0, 63,128, 17,128,  3,  0,  6,  0,
          12,  0, 24,  0, 48,  0, 64,  0,  0,  0,  0,  0,  0,  0,  0,  0 },	/* 0,0 */
diff --git a/src/ft2test.sh b/src/ft2test.sh
index b6c43b1..a1b0431 100755
--- a/src/ft2test.sh
+++ b/src/ft2test.sh
@@ -2,4 +2,4 @@
 # Nano-X applications, press <BREAK> key to exit
 #bin/nano-X -N & bin/nanowm & bin/ft2test & sleep 10000
 #pkill nano
-bin/nano-X -L & bin/nanowm & bin/ft2test & sleep 10000
+bin/nano-X -N & bin/nanowm & bin/ft2test & sleep 10000
diff --git a/src/include/convblit.h b/src/include/convblit.h
index 0f0a836..d2b2ca2 100644
--- a/src/include/convblit.h
+++ b/src/include/convblit.h
@@ -4,23 +4,112 @@
 
 
 /* convblit_8888.c*/
-void convblit_srcover_rgba8888_bgra(PSD psd, PMWBLITPARMS gc);	// png/tiff 32bpp RGBA srcover
-void convblit_srcover_rgba8888_bgra_left(PSD psd, PMWBLITPARMS gc);
-void convblit_srcover_rgba8888_bgra_right(PSD psd, PMWBLITPARMS gc);
-void convblit_srcover_rgba8888_bgra_down(PSD psd, PMWBLITPARMS gc);
-
-void convblit_copy_rgb888_bgra(PSD psd, PMWBLITPARMS gc);		// png/jpg 24bpp RGB copy
-void convblit_copy_rgb888_bgra_left(PSD psd, PMWBLITPARMS gc);
-void convblit_copy_rgb888_bgra_right(PSD psd, PMWBLITPARMS gc);
-void convblit_copy_rgb888_bgra_down(PSD psd, PMWBLITPARMS gc);
-
-void convblit_copy_rgba8888_bgra(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA copy
-
-//void	(*BlitMaskMonoByteMSB)(PMWBLITPARMS parms);				/* ft non-alias*/
-//void	(*BlitMaskMonoByteLSB)(PMWBLITPARMS parms);				/* t1 non-alias*/
-//void	(*BlitMaskMonoWordMSB)(PMWBLITPARMS parms);				/* core/pcf non-alias*/
-//void	(*BlitMaskAlphaByte)(PMWBLITPARMS parms);				/* ft2/t1 antialias*/
-//void	(*BlitRGBA)(PMWBLITPARMS parms);				/* png RGBA image w/alpha*/
-//void	(*BlitRGB)(PMWBLITPARMS parms);					/* png RGB image no alpha*/
-//void	(*BlitBGRA)(PMWBLITPARMS parms);				/* 32bpp hw framebuffer*/
-//void	(*BlitBGR)(PMWBLITPARMS parms);					/* 24bpp hw framebuffer*/
+
+/* ----- 32bpp output -----*/
+void convblit_srcover_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc);	// png/tiff 32bpp RGBA srcover
+void convblit_srcover_rgba8888_bgra8888_left(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_bgra8888_right(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_bgra8888_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_rgb888_bgra8888(PSD psd, PMWBLITPARMS gc);		// png/jpg 24bpp RGB copy
+void convblit_copy_rgb888_bgra8888_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_bgra8888_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_bgra8888_down(PSD psd, PMWBLITPARMS gc);
+
+/* ----- 24bpp output -----*/
+void convblit_srcover_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_bgr888_left(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_bgr888_right(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_bgr888_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_rgb888_bgr888(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_bgr888_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_bgr888_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_bgr888_down(PSD psd, PMWBLITPARMS gc);
+
+/* ----- 16bpp output -----*/
+void convblit_srcover_rgba8888_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_srcover_rgba8888_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_rgb888_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_rgb888_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+#if LATER
+void convblit_copy_rgba8888_bgra8888(PSD psd, PMWBLITPARMS gc);		// 32bpp RGBA copy
+void convblit_copy_rgba8888_bgr888(PSD psd, PMWBLITPARMS gc);
+#endif
+
+/* convblit_mask.c*/
+/* 1bpp and 8bpp (alphablend) mask conversion blits - for font display*/
+
+/* ----- 32bpp output -----*/
+void convblit_copy_mask_mono_byte_msb_bgra(PSD psd, PMWBLITPARMS gc);		/* ft2 non-alias*/
+void convblit_copy_mask_mono_byte_msb_bgra_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_bgra_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_bgra_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_byte_lsb_bgra(PSD psd, PMWBLITPARMS gc);		/* t1lib non-alias*/
+void convblit_copy_mask_mono_byte_lsb_bgra_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_bgra_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_bgra_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_word_msb_bgra(PSD psd, PMWBLITPARMS gc);		/* pcf non-alias*/
+void convblit_copy_mask_mono_word_msb_bgra_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_bgra_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_bgra_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_blend_mask_alpha_byte_bgra(PSD psd, PMWBLITPARMS gc);			/* ft2/t1lib alias*/
+void convblit_blend_mask_alpha_byte_bgra_left(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_bgra_right(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_bgra_down(PSD psd, PMWBLITPARMS gc);
+
+/* ----- 24bpp output -----*/
+void convblit_copy_mask_mono_byte_msb_bgr(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_bgr_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_bgr_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_bgr_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_byte_lsb_bgr(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_bgr_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_bgr_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_bgr_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_word_msb_bgr(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_bgr_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_bgr_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_bgr_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_blend_mask_alpha_byte_bgr(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_bgr_left(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_bgr_right(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_bgr_down(PSD psd, PMWBLITPARMS gc);
+
+/* ----- 16bpp output -----*/
+void convblit_copy_mask_mono_byte_msb_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_msb_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_byte_lsb_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_byte_lsb_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_copy_mask_mono_word_msb_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_copy_mask_mono_word_msb_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+void convblit_blend_mask_alpha_byte_16bpp(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_16bpp_left(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_16bpp_right(PSD psd, PMWBLITPARMS gc);
+void convblit_blend_mask_alpha_byte_16bpp_down(PSD psd, PMWBLITPARMS gc);
+
+#if LATER
+void convblit_copy_mask_mono_byte_msb_bgra_large(PSD psd, PMWBLITPARMS gc);	/* ft2 non-alias*/
+void convblit_copy_mask_mono_byte_lsb_bgra_large(PSD psd, PMWBLITPARMS gc);	/* t1lib non-alias*/
+#endif
diff --git a/src/include/device.h b/src/include/device.h
index 969b493..e2d4c0c 100644
--- a/src/include/device.h
+++ b/src/include/device.h
@@ -19,7 +19,7 @@
 
 /* the fontmapper is obsolete, according to Greg */
 #define FONTMAPPER	0			/* =1 for Morten's font mapper*/
-#define FASTJPEG	1			/* =1 for temp quick jpeg 8bpp*/
+#define FASTJPEG	0			/* =1 for temp quick jpeg 8bpp*/
 #if RTEMS || __ECOS || PSP
 #define HAVE_MMAP       0
 #else
@@ -238,6 +238,13 @@ typedef struct {
 			int x_denominator, int y_denominator,
 			int src_x_fraction, int src_y_fraction,
 			int x_step_fraction, int y_step_fraction, int op);
+	/* new fast blit functions*/
+	void	(*BlitCopyMaskMonoByteMSB)(PSD psd, PMWBLITPARMS parms);	/* ft non-alias*/
+	void	(*BlitCopyMaskMonoByteLSB)(PSD psd, PMWBLITPARMS parms);	/* t1 non-alias*/
+	void	(*BlitCopyMaskMonoWordMSB)(PSD psd, PMWBLITPARMS parms);	/* core/pcf non-alias*/
+	void	(*BlitBlendMaskAlphaByte)(PSD psd, PMWBLITPARMS parms);		/* ft2/t1 antialias*/
+	void	(*BlitSrcOverRGBA8888)(PSD psd, PMWBLITPARMS parms);		/* png RGBA image w/alpha*/
+	void	(*BlitCopyRGB888)(PSD psd, PMWBLITPARMS parms);				/* png RGB image no alpha*/
 } SUBDRIVER, *PSUBDRIVER;
 
 /*
@@ -253,9 +260,11 @@ typedef struct _mwscreendevice {
 	int	bpp;			/* # bpp*/
 	int	linelen;		/* line length in bytes for bpp 1,2,4,8*/
 						/* line length in pixels for bpp 16, 18, 24, 32*/
+	int	pitch;			/* row length in bytes*/
 	int	size;			/* size of memory allocated*/
 	int32_t	ncolors;	/* # screen colors*/
 	int	pixtype;		/* format of pixel value*/
+	int data_format;	/* MWIF_ image data format*/
 	int	flags;			/* device flags*/
 	void *	addr;		/* address of memory allocated (memdc or fb)*/
 
@@ -283,7 +292,7 @@ typedef struct _mwscreendevice {
 	int	(*SetIOPermissions)(PSD psd);
 	PSD	(*AllocateMemGC)(PSD psd);
 	MWBOOL	(*MapMemGC)(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,
-			int linelen,int size,void *addr);
+			int data_format,int linelen,int pitch,int size,void *addr);
 	void	(*FreeMemGC)(PSD mempsd);
 	/* Note: StretchBlit() is deprecated, use StretchBlitEx()
 	void	(*StretchBlit)(PSD destpsd,MWCOORD destx,MWCOORD desty,
@@ -300,6 +309,17 @@ typedef struct _mwscreendevice {
 			int src_x_fraction, int src_y_fraction,
 			int x_step_fraction, int y_step_fraction,
 			int op);
+	void	(*Update)(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
+	PSUBDRIVER left_subdriver;
+	PSUBDRIVER right_subdriver;
+	PSUBDRIVER down_subdriver;
+	/* new fast blit functions for text and images*/
+	void	(*BlitCopyMaskMonoByteMSB)(PSD psd, PMWBLITPARMS parms);	/* ft non-alias*/
+	void	(*BlitCopyMaskMonoByteLSB)(PSD psd, PMWBLITPARMS parms);	/* t1 non-alias*/
+	void	(*BlitCopyMaskMonoWordMSB)(PSD psd, PMWBLITPARMS parms);	/* core/pcf non-alias*/
+	void	(*BlitBlendMaskAlphaByte)(PSD psd, PMWBLITPARMS parms);		/* ft2/t1 antialias*/
+	void	(*BlitSrcOverRGBA8888)(PSD psd, PMWBLITPARMS parms);		/* png RGBA image w/alpha*/
+	void	(*BlitCopyRGB888)(PSD psd, PMWBLITPARMS parms);				/* png RGB image no alpha*/
 } SCREENDEVICE;
 
 /* PSD flags*/
@@ -385,7 +405,7 @@ void	GdReadArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
 void	GdArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
 		void *pixels, int pixtype);
 void	GdConversionBlit(PSD psd, PMWBLITPARMS parms);
-void	GdDrawAreaInternal(PSD psd, driver_gc_t *gc);
+void	GdDrawAreaInternal(PSD psd, driver_gc_t *gc);	/* to be deprecated*/
 void	GdTranslateArea(MWCOORD width, MWCOORD height, void *in, int inpixtype,
 		MWCOORD inpitch, void *out, int outpixtype, int outpitch);
 void	GdCopyArea(PSD psd,MWCOORD srcx,MWCOORD srcy,MWCOORD width,
@@ -399,7 +419,7 @@ void	GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 		MWCOORD d2_y, PSD srcpsd, MWCOORD s1_x, MWCOORD s1_y,
 		MWCOORD s2_x, MWCOORD s2_y, int rop);
 int	GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height,
-		int planes, int bpp, int *size, int *linelen);
+		int planes, int bpp, int *size, int *linelen, int *pitch);
 void	drawbitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
 		const MWIMAGEBITS *imagebits);
 void	drawpoint(PSD psd, MWCOORD x, MWCOORD y);
diff --git a/src/include/genfont.h b/src/include/genfont.h
index 64b61ed..8319601 100644
--- a/src/include/genfont.h
+++ b/src/include/genfont.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2005 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 1999, 2005, 2010 Greg Haerr <greg@censoft.com>
  *
  * Screen Driver Utilities
  * 
@@ -20,20 +20,12 @@ void	gen_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 		MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase);
 void	gen_unloadfont(PMWFONT pfont);
 
-void	gen16_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
+void 	gen_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
 		const void *text, int cc, MWTEXTFLAGS flags);
 void	gen16_gettextsize(PMWFONT pfont, const void *text, int cc,
 		MWTEXTFLAGS flags, MWCOORD *pwidth, MWCOORD *pheight,
 		MWCOORD *pbase);
 
-void	corefont_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
-		const void *text, int cc, MWTEXTFLAGS flags);
-
 /* local data*/
 extern MWCOREFONT gen_fonts[NUMBER_FONTS];
-
-/* the following aren't used yet*/
-void	gen_drawtext(PMWFONT pfont, PSD psd, MWCOORD x, MWCOORD y,
-		const void *text, int n, MWPIXELVAL fg);
-void 	gen_drawbitmap(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
-		MWIMAGEBITS *table, MWPIXELVAL fgcolor);
+extern MWFONTPROCS mwfontprocs;	/* builtin fontprocs - for special DBCS handling*/
diff --git a/src/include/mwtypes.h b/src/include/mwtypes.h
index 5494bef..55fc122 100644
--- a/src/include/mwtypes.h
+++ b/src/include/mwtypes.h
@@ -110,17 +110,18 @@
 #define MWIF_ARGB8888		0x00020000L		/* 32bpp ARGB image byte order (new)*/
 #define MWIF_RGBA8888		0x00030000L		/* 32bpp RGBA image byte order (old TRUECOLORABGR)*/
 //#define MWIF_ABGR8888		0x00040000L		/* 32bpp ABGR image byte order (new)*/
-#define MWIF_BGR888			0x00050000L		/* 24bpp BGR image byte order  (old TRUECOLOR888)*/
-//#define MWIF_RGB888		0x00060000L		/* 24bpp RGB image byte order  (new)*/
-#define MWIF_RGB565			0x00070000L		/* 16bpp 5/6/5 RGB packed l.endian (old TRUECOLOR565)*/
-//#define MWIF_RGB565_BR	0x00080000L		/* 16bpp 5/6/5 RGB packed b.endian (new)*/
-#define MWIF_RGB555			0x00090000L		/* 16bpp 5/5/5 RGB packed l.endian (old TRUECOLOR555)*/
-//#define MWIF_RGB555_BR	0x000A0000L		/* 16bpp 5/5/5 RGB packed b.endian (new)*/
-#define MWIF_BGR555			0x000B0000L		/* 16bpp 5/5/5 BGR packed l.endian (old TRUECOLOR1555)*/
-//#define MWIF_BGR555_BR	0x000C0000L		/* 16bpp 5/5/5 BGR packed b.endian (new)*/
-#define MWIF_BGR332			0x000D0000L		/*  8bpp 3/3/2 RGB packed (old TRUECOLOR332)*/
-#define MWIF_BGR233			0x000E0000L		/*  8bpp 2/3/3 BGR packed (old TRUECOLOR233)*/
-#define MWIF_PAL8			0x000F0000L		/*  8bpp palette (old MWPF_PALETTE)*/
+//#define MWIF_BGR8888		0x00050000L		/* 32bpp BGR image order no alpha*/
+#define MWIF_BGR888			0x00060000L		/* 24bpp BGR image byte order  (old TRUECOLOR888)*/
+#define MWIF_RGB888			0x00070000L		/* 24bpp RGB image byte order  (png no alpha)*/
+#define MWIF_RGB565			0x00080000L		/* 16bpp 5/6/5 RGB packed l.endian (old TRUECOLOR565)*/
+//#define MWIF_RGB565_BR	0x00090000L		/* 16bpp 5/6/5 RGB packed b.endian (new)*/
+#define MWIF_RGB555			0x000A0000L		/* 16bpp 5/5/5 RGB packed l.endian (old TRUECOLOR555)*/
+//#define MWIF_RGB555_BR	0x000B0000L		/* 16bpp 5/5/5 RGB packed b.endian (new)*/
+#define MWIF_BGR555			0x000C0000L		/* 16bpp 5/5/5 BGR packed l.endian (old TRUECOLOR1555)*/
+//#define MWIF_BGR555_BR	0x000D0000L		/* 16bpp 5/5/5 BGR packed b.endian (new)*/
+#define MWIF_BGR332			0x000E0000L		/*  8bpp 3/3/2 RGB packed (old TRUECOLOR332)*/
+#define MWIF_BGR233			0x000F0000L		/*  8bpp 2/3/3 BGR packed (old TRUECOLOR233)*/
+#define MWIF_PAL8			0x00100000L		/*  8bpp palette (old MWPF_PALETTE)*/
 
 /* Line modes */
 #define MWLINE_SOLID      0
@@ -320,6 +321,7 @@ typedef struct {
 	int 	ydpcm;		/* dots/centimeter in y direction */
 	int	 	planes;		/* hw # planes*/
 	int	 	bpp;		/* hw bpp*/
+	int		data_format;/* MWIF_ image data format*/
 	int32_t	ncolors;	/* hw number of colors supported*/
 	int 	fonts;		/* number of built-in fonts */
 	int 	buttons;	/* buttons which are implemented */
@@ -428,8 +430,10 @@ typedef struct {
 	MWCOORD		dstx, dsty;		/* dest x, y*/
 	MWCOORD		srcx, srcy;		/* source x, y*/
 	int			src_pitch;		/* source row length in bytes*/
-	uint32_t	fg_color;		/* foreground color, hw pixel format*/
-	uint32_t	bg_color;
+	MWCOLORVAL	fg_colorval;	/* fg color, MWCOLORVAL 0xAARRGGBB format*/
+	MWCOLORVAL	bg_colorval;
+	uint32_t	fg_pixelval;	/* fg color, hw pixel format*/
+	uint32_t	bg_pixelval;
 	MWBOOL		usebg;			/* set =1 to draw background*/
 	void *		data;			/* input image data GdConversionBlit*/
 
@@ -782,6 +786,7 @@ typedef struct {
 #define MWIMAGE_ALPHA_CHANNEL   04	/* compression flag: 32-bit w/alpha */
 #define MWIMAGE_555		0x08	/* compression flag: 5/5/5 format*/
 
+/* image structure - if changed, convbmp.c needs updating*/
 typedef struct {
 	int		width;		/* image width in pixels*/
 	int		height;		/* image height in pixels*/
@@ -794,6 +799,7 @@ typedef struct {
 	int32_t	transcolor;	/* transparent color or -1 if none*/
 	MWPALENTRY *palette;/* palette*/
 	MWUCHAR *imagebits;	/* image bits (dword right aligned)*/
+	int		data_format;/* MWIF_ image data format*/
 } MWIMAGEHDR, *PMWIMAGEHDR;
 
 /* image information structure - returned by GdGetImageInfo*/
@@ -803,6 +809,7 @@ typedef struct {
 	int		height;		/* image height in pixels*/
 	int		planes;		/* # image planes*/
 	int		bpp;		/* bits per pixel (1, 4 or 8)*/
+	int		data_format;/* MWIF image data format*/
 	int		pitch;		/* bytes per line*/
 	int		bytesperpixel;	/* bytes per pixel*/
 	int		compression;	/* compression algorithm*/
@@ -878,11 +885,25 @@ typedef struct {
  * macro = (to duplicate 0.91 code)		d = muldiv255(255 - a, d) + a
  * correct macro =						d = muldiv255(d, 255 - a) + a
  */
+/* single byte color macros for 24/32bpp*/
 //#define muldiv255(a,b)	(((a)*(b))/255)		/* slow divide, exact*/
 #define muldiv255(a,b)		((((a)+1)*(b))>>8)		/* very fast, 92% accurate*/
 //#define muldiv255(a,b)	((((a)+((a)>>7))*(b))>>8)	/* fast, 35% accurate*/
+
+/* pixel to pixel blend for 16bpp*/
 #define mulscale(a,b,n)		((((a)+1)*(b))>>(n))	/* very fast, always shift for 16bpp*/
 
+/* single byte color macros for 15/16bpp macros - FIXME endian specific*/
+/* d = muldiv255(255-a, d-s) + s*/
+#define muldiv255_rgb565(d, sr, sg, sb, as) \
+						  (((((((d) & 0xF800) - (sr)) * as) >> 8) + (sr)) & 0xF800)\
+						| (((((((d) & 0x07E0) - (sg)) * as) >> 8) + (sg)) & 0x07E0)\
+						| (((((((d) & 0x001F) - (sb)) * as) >> 8) + (sb)) & 0x001F)
+#define muldiv255_rgb555(d, sr, sg, sb, as) \
+						  (((((((d) & 0x7C00) - (sr)) * as) >> 8) + (sr)) & 0x7C00)\
+						| (((((((d) & 0x03E0) - (sg)) * as) >> 8) + (sg)) & 0x03E0)\
+						| (((((((d) & 0x001F) - (sb)) * as) >> 8) + (sb)) & 0x001F)
+
 /* palette color definition*/
 #define RGBDEF(r,g,b)	{r, g, b}
 
@@ -940,6 +961,28 @@ typedef struct {
 #define RGB2PIXEL233(r,g,b)	\
 	((((r) & 0xe0) >> 5) | (((g) & 0xe0) >> 2) | (((b) & 0xc0) >> 0))
 
+/* create single component of 5/6/5format pixel from color byte*/
+#define RED2PIXEL565(byte)		(((byte) & 0xf8) << 8)
+#define GREEN2PIXEL565(byte)	(((byte) & 0xfc) << 3)
+#define BLUE2PIXEL565(byte)		(((byte) & 0xf8) >> 3)
+
+/* create single component of 5/5/5format pixel from color byte*/
+#define RED2PIXEL555(byte)		(((byte) & 0xf8) << 7)
+#define GREEN2PIXEL555(byte)	(((byte) & 0xf8) << 2)
+#define BLUE2PIXEL555(byte)		(((byte) & 0xf8) >> 3)
+
+/* these defines used in convblits, must be available regardless of MWPIXEL_FORMAT, default 565*/
+#if MWPIXEL_FORMAT == MWPF_TRUECOLOR555
+#define muldiv255_16bpp		muldiv255_rgb555
+#define RED2PIXEL(byte)		RED2PIXEL555(byte)
+#define GREEN2PIXEL(byte)	GREEN2PIXEL555(byte)
+#define BLUE2PIXEL(byte)	BLUE2PIXEL555(byte)
+#else
+#define muldiv255_16bpp		muldiv255_rgb565
+#define RED2PIXEL(byte)		RED2PIXEL565(byte)
+#define GREEN2PIXEL(byte)	GREEN2PIXEL565(byte)
+#define BLUE2PIXEL(byte)	BLUE2PIXEL565(byte)
+#endif
 
 /*
  * Conversion from MWCOLORVAL to MWPIXELVAL
diff --git a/src/include/windows.h b/src/include/windows.h
index c747dac..2807915 100644
--- a/src/include/windows.h
+++ b/src/include/windows.h
@@ -70,7 +70,9 @@ typedef struct {
 	int		height;		/* height*/
 	int		planes;		/* # planes*/
 	int		bpp;		/* bits per pixel*/
-	int		linelen;	/* bytes per line*/
+	int		data_format;/* MWIF_ image data format*/
+	int		linelen;	/* bytes per line (to be deprecated)*/
+	int		pitch;		/* bytes per line*/
 	int		size;		/* allocated size in bytes*/
 	char 		bits[1];	/* beginning of bitmap*/
 } MWBITMAPOBJ;
diff --git a/src/mwin/bmp/convbmp.c b/src/mwin/bmp/convbmp.c
index dc4098b..a9ca572 100644
--- a/src/mwin/bmp/convbmp.c
+++ b/src/mwin/bmp/convbmp.c
@@ -1,8 +1,9 @@
 /*
- * Copyright (c) 1999, 2000, 2003 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 1999, 2000, 2003, 2010 Greg Haerr <greg@censoft.com>
  *
  * Windows BMP to Microwindows image converter
  *
+ * 6/21/2010 updated with data_format
  * 9/24/2003 endian-neutral conversion
  * 05/01/2000 Michael Temari <Michael@TemWare.Com>
  * Modified to output .s ACK format for Minix
@@ -403,6 +404,7 @@ UCHAR *p = (UCHAR *)&l;
 	else
 		printf("  0,\n");
 	printf("  imagebits,\n");
+	printf("  0x%lx,\t\t/* data_format*/\n", 0L);
 	printf("};\n");
    } else {
 	printf(".extern _image_%s\n", name);
@@ -421,6 +423,7 @@ UCHAR *p = (UCHAR *)&l;
 		printf(".data4\t__II1\n");
 	else
 		printf(".data4\t0\n");
+	printf(".data4\t%ld\n",0L);	/* data_format*/
 	printf(".sect .text\n");
    }
 
diff --git a/src/mwin/windefw.c b/src/mwin/windefw.c
index 35d9184..ab70d10 100644
--- a/src/mwin/windefw.c
+++ b/src/mwin/windefw.c
@@ -109,8 +109,7 @@ DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 					GetSysColor(COLOR_BTNFACE));
 				holdpen = SelectObject(hdc, hpen);
 				SelectObject(hdc, GetStockObject(NULL_BRUSH));
-				Rectangle(hdc, rc.left, rc.top, rc.right,
-					rc.bottom);
+				Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
 				InflateRect(&rc, -1, -1);
 
 				/* fill caption*/
@@ -128,8 +127,7 @@ DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 				DeleteObject(SelectObject(hdc, holdpen));
 
 				/* draw caption text*/
-				if(GetWindowText(hwnd, szTitle,
-				   sizeof(szTitle))) {
+				if(GetWindowText(hwnd, szTitle, sizeof(szTitle))) {
 					SetBkMode(hdc, TRANSPARENT);
 					/* set background color even though
 					 * transparent in case GdArea is used
@@ -142,11 +140,9 @@ DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 						GetActiveWindow()==hwnd?
 						GetSysColor(COLOR_CAPTIONTEXT):
 						GetSysColor(COLOR_INACTIVECAPTIONTEXT));
-					SelectObject(hdc,
-					    GetStockObject(DEFAULT_GUI_FONT));
+					SelectObject(hdc, GetStockObject(DEFAULT_GUI_FONT));
 					GetWindowRect(hwnd, &rc);
-					TextOut(hdc, rc.left+4, rc.top+2,
-						szTitle, strlen(szTitle));
+					TextOut(hdc, rc.left+4, rc.top+2, szTitle, strlen(szTitle));
 				}
 
 				/* draw close box*/
@@ -170,8 +166,7 @@ DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 				LineTo(hdc, rc.right-1, rc.top);
 			} else {
 				SelectObject(hdc, GetStockObject(NULL_BRUSH));
-				Rectangle(hdc, rc.left, rc.top, rc.right,
-					rc.bottom);
+				Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
 			}
 			ReleaseDC(hwnd, hdc);
 		}
diff --git a/src/mwin/wingdi.c b/src/mwin/wingdi.c
index 1be1adb..e858385 100644
--- a/src/mwin/wingdi.c
+++ b/src/mwin/wingdi.c
@@ -97,6 +97,7 @@ GetDCEx(HWND hwnd,HRGN hrgnClip,DWORD flags)
 	 */
 	default_bitmap.planes = scrdev.planes;
 	default_bitmap.bpp = scrdev.bpp;
+	default_bitmap.data_format = scrdev.data_format;
 	hdc->bitmap = &default_bitmap;
 
 	hdc->drawmode = R2_COPYPEN;
@@ -1559,7 +1560,7 @@ SelectObject(HDC hdc, HGDIOBJ hObject)
 
 		/* init memory context*/
 		if (!hdc->psd->MapMemGC(hdc->psd, pb->width, pb->height,
-			pb->planes, pb->bpp, pb->linelen, pb->size,
+			pb->planes, pb->bpp, pb->data_format, pb->linelen, pb->pitch, pb->size,
 			&pb->bits[0]))
 				return NULL;
 
@@ -1723,7 +1724,7 @@ CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight)
 {
 	MWBITMAPOBJ *	hbitmap;
 	int		size;
-	int		linelen;
+	int		linelen, pitch;
 
 	if(!hdc)
 		return NULL;
@@ -1732,7 +1733,7 @@ CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight)
 	nHeight = MWMAX(nHeight, 1);
 
 	/* calc memory allocation size and linelen from width and height*/
-	if(!GdCalcMemGCAlloc(hdc->psd, nWidth, nHeight, 0, 0, &size, &linelen))
+	if(!GdCalcMemGCAlloc(hdc->psd, nWidth, nHeight, 0, 0, &size, &linelen, &pitch))
 		return NULL;
 
 	/* allocate gdi object*/
@@ -1747,7 +1748,9 @@ CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight)
 	/* create compatible with hdc*/
 	hbitmap->planes = hdc->psd->planes;
 	hbitmap->bpp = hdc->psd->bpp;
+	hbitmap->data_format = hdc->psd->data_format;
 	hbitmap->linelen = linelen;
+	hbitmap->pitch = pitch;
 	hbitmap->size = size;
 
 	return (HBRUSH)hbitmap;
diff --git a/src/mwin/winresbmp.c b/src/mwin/winresbmp.c
index 52bf8a1..7e0b774 100644
--- a/src/mwin/winresbmp.c
+++ b/src/mwin/winresbmp.c
@@ -198,6 +198,7 @@ resLoadBitmap(HINSTANCE hInst, LPCTSTR resName)
 			pImageHdr->pitch = linesize;
 			pImageHdr->bytesperpixel = bytesperpixel;
 			pImageHdr->compression = 1;
+			pImageHdr->data_format = 0;		/* FIXME unknown?*/
 			pImageHdr->palsize = palsize;
 			pImageHdr->transcolor = -1L;
 			retV = pImageHdr;
diff --git a/src/nanox/client.c b/src/nanox/client.c
index 8151a30..aa106bb 100644
--- a/src/nanox/client.c
+++ b/src/nanox/client.c
@@ -3099,6 +3099,7 @@ GrDrawImageBits(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 		req->pitch = pimage->pitch;
 		req->bytesperpixel = pimage->bytesperpixel;
 		req->compression = pimage->compression;
+		req->data_format = pimage->data_format;
 		req->palsize = pimage->palsize;
 		req->transcolor = pimage->transcolor;
 		addr = GetReqData(req);
diff --git a/src/nanox/nxproto.h b/src/nanox/nxproto.h
index 30a7f74..06f171b 100644
--- a/src/nanox/nxproto.h
+++ b/src/nanox/nxproto.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2003 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 1999, 2003, 2010 Greg Haerr <greg@censoft.com>
  * Copyright (c) 2000 Alex Holden <alex@linuxhacker.org>
  * Portions Copyright (c) 2002, 2003 by Koninklijke Philips Electronics N.V.
  *
@@ -975,6 +975,7 @@ typedef struct {
 	INT16	compression;
 	INT16	palsize;
 	UINT32	transcolor;
+	UINT32	data_format;
 	/*MWIMAGEBITS imagebits[];*/
 	/*MWPALENTRY palette[palsize];*/
 } nxDrawImageBitsReq;
diff --git a/src/nanox/srvfunc.c b/src/nanox/srvfunc.c
index 2bfdcfe..0bb2379 100644
--- a/src/nanox/srvfunc.c
+++ b/src/nanox/srvfunc.c
@@ -2018,7 +2018,7 @@ GrNewPixmap(GR_SIZE width, GR_SIZE height, void * pixels)
 {
 	GR_PIXMAP	*pp;
 	PSD		psd;
-	int 		size, linelen, bpp, planes;
+	int 		size, linelen, pitch, bpp, planes, data_format;
 	GR_WINDOW_ID id;
    
 	if (width <= 0 || height <= 0) {
@@ -2036,6 +2036,7 @@ GrNewPixmap(GR_SIZE width, GR_SIZE height, void * pixels)
 	 */
 	planes = rootwp->psd->planes;
 	bpp = rootwp->psd->bpp;
+	data_format = rootwp->psd->data_format;
 	psd = rootwp->psd->AllocateMemGC(rootwp->psd);
 	if (!psd) {
 		SERVER_UNLOCK();
@@ -2050,7 +2051,7 @@ GrNewPixmap(GR_SIZE width, GR_SIZE height, void * pixels)
 		return 0;
 	}
 
-	GdCalcMemGCAlloc(psd, width, height, 0, 0, &size, &linelen);
+	GdCalcMemGCAlloc(psd, width, height, 0, 0, &size, &linelen, &pitch);
 
 	/* Allocate space for pixel values */
 	if (!pixels) {
@@ -2074,7 +2075,7 @@ GrNewPixmap(GR_SIZE width, GR_SIZE height, void * pixels)
 	pp->height = height;
 	pp->owner = curclient;
 
-	psd->MapMemGC(psd, width, height, planes, bpp, linelen, size, pixels);
+	psd->MapMemGC(psd, width, height, planes, bpp, data_format, linelen, pitch, size, pixels);
 
 	listpp = pp;
 	id = pp->id;
diff --git a/src/nanox/srvnet.c b/src/nanox/srvnet.c
index 86d0877..7c9434a 100644
--- a/src/nanox/srvnet.c
+++ b/src/nanox/srvnet.c
@@ -910,6 +910,7 @@ GrDrawImageBitsWrapper(void *r)
 	hdr.pitch = req->pitch;
 	hdr.bytesperpixel = req->bytesperpixel;
 	hdr.compression = req->compression;
+	hdr.data_format = req->data_format;
 	hdr.palsize = req->palsize;
 	hdr.transcolor = req->transcolor;
 	addr = GetReqData(req);
diff --git a/src/nxviewalpha.sh b/src/nxviewalpha.sh
index b3bd5ce..917ad92 100755
--- a/src/nxviewalpha.sh
+++ b/src/nxviewalpha.sh
@@ -1,4 +1,4 @@
 
 # image viewer demo showing alpha blending
 # alphademo.png is a center red dice, left blue, bottom yellow, right green
-bin/nano-X -x 1024 -y 768 -N & bin/nanowm & bin/nxview -p mwin/bmp/alphademo.png; sleep 10000
+bin/nano-X -x 1024 -y 768 -L & bin/nanowm & bin/nxview -p mwin/bmp/alphademo.png; sleep 10000
