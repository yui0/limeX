diff -urN /home/greg/net/microwindows-0.90/src/Arch.rules ./Arch.rules
--- /home/greg/net/microwindows-0.90/src/Arch.rules	2003-05-16 09:36:42.000000000 -0700
+++ ./Arch.rules	2008-09-18 01:39:55.000000000 -0700
@@ -1,11 +1,11 @@
 ##############################################################################
 # Microwindows Architecture rules Makefile
 # Copyright (c) 2000 Martin Jolicoeur, Greg Haerr
-# Portions Copyright 2002 by Koninklijke Philips Electronics N.V.
+# Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
 #
-# This makefile should be placed at the top of a project hierarchy
+# Architecture-specific settings.
 #
-# NOTE: The TOP environment variable should be set to that top directory
+# NOTE: The MW_DIR_SRC environment variable should be set to that top directory
 ##############################################################################
 
 # Standard set of warnings for all platforms that use GCC
@@ -21,7 +21,7 @@
 COMPILER = gcc
 endif
 CXX_COMPILER = g++
-TOOLSPREFIX =
+TOOLSPREFIX = $(NATIVETOOLSPREFIX)
 DEFINES += -DLINUX=1 -DUNIX=1
 CFLAGS += $(GCC_WARNINGS) $(OPTFLAGS)
 LDFLAGS +=
@@ -47,7 +47,7 @@
 TOOLSPREFIX = $(ARMTOOLSPREFIX)
 DEFINES += -DLINUX=1 -DUNIX=1
 CFLAGS += $(GCC_WARNINGS) $(OPTFLAGS) -mstructure-size-boundary=8
-LDFLAGS +=
+LDFLAGS += -Wl,-elf2flt="s3276"
 endif
 
 ifeq ($(ARCH), LINUX-MIPS)
@@ -55,11 +55,11 @@
 CXX_COMPILER = g++
 TOOLSPREFIX = $(MIPSTOOLSPREFIX)
 DEFINES += -DLINUX=1 -DUNIX=1
-CFLAGS += -msoft-float $(GCC_WARNINGS) $(OPTFLAGS)
+CFLAGS += $(GCC_WARNINGS) $(OPTFLAGS) -D__MIPSEL__ -Wa,-mips32r2 -Wa,-mfix7000
 ifneq ($(DEBUG), Y)
 CFLAGS += -s
 endif
-LDFLAGS +=
+LDFLAGS += -m elf32ltsmip
 endif
 
 ifeq ($(ARCH), LINUX-POWERPC)
diff -urN /home/greg/net/microwindows-0.90/src/config ./config
--- /home/greg/net/microwindows-0.90/src/config	2003-05-30 21:00:18.000000000 -0700
+++ ./config	2008-09-18 01:41:54.000000000 -0700
@@ -37,9 +37,10 @@
 # note: ELKS can't build client/server nano-X, nor widget lib
 #
 ####################################################################
-ARCH                     = LINUX-NATIVE
+ARCH                     = LINUX-MIPS
 BIGENDIAN                = N
-ARMTOOLSPREFIX           = arm-linux-
+NATIVETOOLSPREFIX        = 
+ARMTOOLSPREFIX           = arm-elf-
 MIPSTOOLSPREFIX          = mipsel-linux-
 POWERPCTOOLSPREFIX       = powerpc-linux-
 SHTOOLSPREFIX            = sh-linux-gnu
@@ -51,9 +52,9 @@
 #
 ####################################################################
 OPTIMIZE                 = Y
-DEBUG                    = Y
-VERBOSE                  = N
-THREADSAFE               = Y
+DEBUG                    = N
+VERBOSE                  = Y
+THREADSAFE               = N
 GPROF                    = N
 
 ####################################################################
@@ -61,9 +62,9 @@
 # Libraries to build: microwin, nano-X, nanowidget, object frameworks
 #
 ####################################################################
-MICROWIN                 = Y
+MICROWIN                 = N
 NANOX                    = Y
-SHAREDLIBS               = N
+SHAREDLIBS               = Y
 OBJFRAMEWORK             = N
 
 
@@ -72,15 +73,15 @@
 # Demos to build
 #
 ####################################################################
-MICROWINDEMO             = Y
-NANOXDEMO                = Y
+MICROWINDEMO             = N
+NANOXDEMO                = N
 
 ####################################################################
 #
 # Applications to build
 #
 ####################################################################
-NANOWM                   = Y
+NANOWM                   = N
 
 ####################################################################
 #
@@ -98,7 +99,7 @@
 # define MWPF_TRUECOLOR332  /* pixel is packed 8 bits 3/3/2 truecolor*/
 #
 ####################################################################
-SCREEN_PIXTYPE           = MWPF_TRUECOLOR0888
+SCREEN_PIXTYPE           = MWPF_TRUECOLOR8888 
 
 ####################################################################
 #
@@ -107,7 +108,7 @@
 # or for speed or debugging.  This affects the nano-X server only.
 #
 ####################################################################
-LINK_APP_INTO_SERVER     = N
+LINK_APP_INTO_SERVER     = Y
 
 ####################################################################
 # Shared memory support for Nano-X client/server protocol speedup
@@ -125,52 +126,52 @@
 ####################################################################
 # BMP, GIF reading support
 ####################################################################
-HAVE_BMP_SUPPORT         = Y
+HAVE_BMP_SUPPORT         = N
 HAVE_GIF_SUPPORT         = Y
-HAVE_PNM_SUPPORT         = Y
-HAVE_XPM_SUPPORT         = Y
+HAVE_PNM_SUPPORT         = N
+HAVE_XPM_SUPPORT         = N
 
 ####################################################################
 # JPEG support through libjpeg, see README.txt in contrib/jpeg
 ####################################################################
 HAVE_JPEG_SUPPORT        = Y
-INCJPEG                  = .
-LIBJPEG                  = /usr/lib/libjpeg.a
-
+INCJPEG                  = $(MRUASDK)/MRUA_src/rmlibjpeg/src/libjpeg
+#LIBJPEG                  = ../../externalib/lib/libjpeg.a
 ####################################################################
 # PNG support via libpng and libz
 ####################################################################
-HAVE_PNG_SUPPORT         = N
-INCPNG                   = /usr/include
-LIBPNG                   = /usr/lib/libpng.a
-LIBZ                     = /usr/lib/libz.a
+HAVE_PNG_SUPPORT         = Y
+INCPNG                   = $(MRUASDK)/MRUA_src/rmlibpng/src/libpng
+#LIBPNG                   = ../../externalib/lib/libpng.a
+#LIBZ                     = ../../externalib/lib/libz.a
 
 ####################################################################
 # TIFF support through libtiff
 ####################################################################
 HAVE_TIFF_SUPPORT        = N
-INCTIFF                  = /usr/include
-LIBTIFF                  = /usr/lib/libtiff.a
+INCTIFF                  = . 
+#LIBTIFF                  = /usr/lib/libtiff.a
 
 ####################################################################
 # native .fnt loadable font support
 ####################################################################
-HAVE_FNT_SUPPORT         = Y
+HAVE_FNT_SUPPORT         = N
 HAVE_FNTGZ_SUPPORT       = N
-FNT_FONT_DIR             = "fonts/bdf"
+FNT_FONT_DIR             = .
+#"fonts/bdf"
 
 ####################################################################
 # T1 adobe type1 font support thru t1lib
 ####################################################################
 HAVE_T1LIB_SUPPORT       = N
 INCT1LIB                 = /usr/include
-LIBT1LIB                 = /usr/lib/libt1.a
+LIBT1LIB                 = /usr/local/lib/libt1.a
 
 ####################################################################
 # TrueType font support thru FreeType 1.x
 ####################################################################
-HAVE_FREETYPE_SUPPORT    = Y
-INCFTLIB                 = /usr/include
+HAVE_FREETYPE_SUPPORT    = N
+INCFTLIB                 = /usr/include/freetype1
 LIBFTLIB                 = /usr/lib/libttf.so
 FREETYPE_FONT_DIR        = "fonts/truetype"
 
@@ -187,8 +188,8 @@
 # Selecting HAVE_PCFGZ_SUPPORT will allow you to directly read
 # .pcf.gz files, but it will add libz to the size of the server
 ####################################################################
-HAVE_PCF_SUPPORT         = Y
-HAVE_PCFGZ_SUPPORT       = Y
+HAVE_PCF_SUPPORT         = N
+HAVE_PCFGZ_SUPPORT       = N
 PCF_FONT_DIR             = "fonts/pcf"
 
 ####################################################################
@@ -247,6 +248,21 @@
 #
 ####################################################################
 GRAYPALETTE              = N
+DITHER=N
+
+####################################################################
+#
+# Use static buffer to store image
+#
+####################################################################
+STATIC_BUFFER_FOR_IMAGE	= Y
+
+####################################################################
+#
+# Support Alpha Blending for PNG
+#
+####################################################################
+ALPHA_BLENDING_FOR_PNG = N
 
 ####################################################################
 #
@@ -275,14 +291,14 @@
 # set FBREVERSE to reverse bit orders in 1,2,4 bpp
 # set FBVGA=N for all systems without VGA hardware (for MIPS must=N)
 FRAMEBUFFER              = Y
-FBVGA                    = Y
-VTSWITCH                 = Y
+FBVGA                    = N
+VTSWITCH                 = N
 FBREVERSE                = N
 
 # set HAVETEXTMODE=Y for systems that can switch between text & graphics.
 # On a graphics-only embedded system, such as Osprey and Embedded
 # Planet boards, set HAVETEXTMODE=N
-HAVETEXTMODE             = Y
+HAVETEXTMODE             = N
 
 # svgalib screen driver
 VGALIB                   = N
@@ -310,10 +326,10 @@
 # YOPYMOUSE	Yopy (/dev/yopy-ts)
 # HARRIERMOUSE	NEC Harrier (/dev/tpanel)
 ####################################################################
-GPMMOUSE                 = Y
+GPMMOUSE                 = N
 SERMOUSE                 = N
 SUNMOUSE                 = N
-NOMOUSE                  = N
+NOMOUSE                  = Y
 IPAQMOUSE                = N
 ZAURUSMOUSE              = N
 TUXMOUSE                 = N
@@ -325,17 +341,23 @@
 PSIONMOUSE               = N
 YOPYMOUSE                = N
 HARRIERMOUSE             = N
+LIRCMOUSE                = N
 
 # keyboard or null kbd driver
 TTYKBD                   = N
-SCANKBD                  = Y
+SCANKBD                  = N
 PIPEKBD                  = N
 IPAQKBD                  = N
 LIRCKBD                  = N
-NOKBD                    = N
+NOKBD                    = Y
 
 endif
 
+# Secondary keyboard drivers.
+# You may have a normal keyboard driver in addition to these
+# drivers, e.g. for both normal keyboard and IR input.
+LIRCKBD2                 = N
+
 ####################################################################
 # Screen driver specific configuration
 # SA1100_LCD_LTLEND 4bpp driver with arm SA1100 LCD controller
@@ -377,3 +399,30 @@
 SERMOUSE                 = Y
 
 endif
+
+#####################################################################
+# mmap shared flags and do mmap pags alignment flags
+#
+MMAP_SHARED_FLAGS       = Y
+MMAP_PAGE_ALIGNMENT     = Y
+
+#Put the minimum and maximum size of the memory that using rua memory if HAVE_DEVICE_MEM_SUPPORT enabled
+#For SMP8634, HAVE_DEVICE_MEM_SUPPORT is a must if GFX enabled.
+DEVICE_MEM_MALLOC_MIN=0
+DEVICE_MEM_MALLOC_MAX=134217728
+
+HAVE_FREETYPE_SUPPORT=N
+HAVE_DEVICE_MEM_SUPPORT=Y
+HAVE_FREETYPE_2_SUPPORT=Y
+INCFT2LIB=/home/andy/core_repos/src/libs/../../build/build_SMP8634RevC_TVDOCK/third_party_build//include
+LIBFT2LIB=/home/andy/core_repos/src/libs/../../build/build_SMP8634RevC_TVDOCK/third_party_build//lib/libfreetype.a
+ALPHA_BLENDING_FOR_PNG = Y
+HAVE_PNG_SUPPORT = Y
+EM86XX = Y
+EM86XX_SDK = /home/andy/core_repos/src/libs/../../src/libs/2.8.3.0/mrua_SMP8634_2.8.3.0_GCC4_dev.mips/MRUA_src
+SIGMA86_CHIP_NO = SMP8634
+SAMPLES_LIB = /home/andy/core_repos/src/libs/../../src/mediaplayer/libhal.a /home/andy/core_repos/src/libs/../../src/mediaplayer/mediaplayer.a
+SCREEN_PIXTYPE = MWPF_TRUECOLOR8888
+DESKTOP_WIDTH = 1280
+DESKTOP_HEIGHT = 720
+WAIT_FOR_COMMANDS = Y
diff -urN /home/greg/net/microwindows-0.90/src/demos/nxscribble/li_recognizer.c ./demos/nxscribble/li_recognizer.c
--- /home/greg/net/microwindows-0.90/src/demos/nxscribble/li_recognizer.c	2003-05-16 09:36:13.000000000 -0700
+++ ./demos/nxscribble/li_recognizer.c	2008-09-18 01:39:54.000000000 -0700
@@ -956,6 +956,7 @@
 extern float expf (float);	/* N.B.  exp() appears to be broken on ELX! */
 #endif
 
+#define rint(x) ((int) x)
 #define	WORST_SCORE	MAXINT
 
 /* Dynamic programming parameters */
diff -urN /home/greg/net/microwindows-0.90/src/drivers/dbgimplementation.c ./drivers/dbgimplementation.c
--- /home/greg/net/microwindows-0.90/src/drivers/dbgimplementation.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/dbgimplementation.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,145 @@
+/*****************************************
+ Copyright © 2001-2003	
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+/**
+	@file dbgimplementation.c
+	@brief User mode test application, debugging print implementation.
+*/
+
+#ifndef ALLOW_OS_CODE
+#define ALLOW_OS_CODE
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+
+int verbose_stdout = 1;
+int verbose_stderr = 1;
+
+int console_output(const char *format, ...);
+int file_output(FILE *fptr, const char *format, ...);
+int DebugLevel = 1;
+
+int console_output(const char *format, ...)
+{
+        va_list ap;
+        int res;
+                                                                                
+        if (verbose_stdout != 0) {
+                va_start(ap, format);
+                res = vprintf(format, ap);
+                va_end(ap);
+                return(res);
+        }
+        return(0);
+}
+                                                                                
+int file_output(FILE *fptr, const char *format, ...)
+{
+        va_list ap;
+        int res;
+                                                                                
+	if (((fptr != stderr) && (verbose_stdout != 0)) || 
+ 		((fptr == stderr) && (verbose_stderr != 0))) {
+                va_start(ap, format);
+                res = vfprintf(fptr, format, ap);
+                va_end(ap);
+                return(res);
+        }
+        return(0);
+}
+
+#include "../rmdef/rmdef.h"
+
+#define RM_MAX_STRING 1024
+
+static char str[RM_MAX_STRING];
+
+#if ((RMCOMPILERID==RMCOMPILERID_GCC) || (RMCOMPILERID==RMCOMPILERID_ARMELF_GCC) || (RMCOMPILERID==RMCOMPILERID_MIPSEL_GCC))
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+
+#ifndef RMDBGLOG_implementation
+void RMDBGLOG_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{  
+        if (active && (verbose_stderr != 0)) {
+		va_list ap;
+		
+                snprintf((char *)str,RM_MAX_STRING,"[%s:%ld] ",(char *)filename,line);
+		
+                va_start(ap, text);
+                vsnprintf((char *)(str+strlen(str)), RM_MAX_STRING-strlen(str), text, ap); 
+                va_end(ap);
+                
+		fputs(str, stderr);
+        }
+}
+#endif // RMDBGLOG_implementation
+
+#ifndef RMDBGPRINT_implementation
+void RMDBGPRINT_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{
+        if (active && (verbose_stderr != 0)) {
+		va_list ap;
+		
+                va_start(ap, text);
+                vsnprintf((char *)str,RM_MAX_STRING,text,ap); 
+                va_end(ap);
+                
+               	fputs(str, stderr);
+        }
+}
+#endif // RMDBGPRINT_implementation
+
+#elif (RMCOMPILERID==RMCOMPILERID_VISUALC)
+
+#include <windows.h>
+#include <stdio.h>
+
+#ifndef RMDBGLOG_implementation
+void RMDBGLOG_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{  
+        if (active && (verbose_stdout != 0)) {
+		va_list ap;
+		
+#ifdef UNICODE
+		sprintf((char *)str, (char *)"[%ls:%ld] ", filename, line);
+#else
+		sprintf((char *)str, (char *)"[%s:%ld] ", filename, line);
+#endif
+		
+		va_start(ap, text);
+		vsprintf((char *)(str+strlen(str)), (const char *)text, ap); 
+		va_end(ap);
+		
+		OutputDebugString(str);
+	}
+}
+#endif // RMDBGLOG_implementation
+
+#ifndef RMDBGPRINT_implementation
+void RMDBGPRINT_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{
+        if (active && (verbose_stdout != 0)) {
+		va_list ap;
+		
+		va_start(ap, text);
+		vsprintf((char *)str, (const char *)text, ap); 
+		va_end(ap);
+		
+		OutputDebugString(str);
+	}
+}
+#endif // RMDBGPRINT_implementation
+
+#else
+
+NOTCOMPILABLE
+
+#endif 
diff -urN /home/greg/net/microwindows-0.90/src/drivers/fblin16.c ./drivers/fblin16.c
--- /home/greg/net/microwindows-0.90/src/drivers/fblin16.c	2003-05-11 11:18:11.000000000 -0700
+++ ./drivers/fblin16.c	2008-09-18 01:39:55.000000000 -0700
@@ -210,8 +210,7 @@
 	return;
 stdblit:
 #endif
-
-	if (op == MWROP_COPY) {
+	if (op == MWROP_COPY) { 
 		/* copy from bottom up if dst in src rectangle*/
 		/* memmove is used to handle x case*/
 		if (srcy < dsty) {
@@ -222,11 +221,60 @@
 		}
 		while (--h >= 0) {
 			/* a _fast_ memcpy is a _must_ in this routine*/
-			memmove(dst, src, w<<1);
-			dst += dlinelen;
-			src += slinelen;
+            for(i=0; i<w; ++i) {
+                unsigned int s = *src++;
+                unsigned int d = *dst;
+                *dst++ = s;
+            }
+            dst += dlinelen - w;
+            src += slinelen - w;
 		}
-	} else {
+	} else if (op == MWROP_COPY_RK) {
+        /* replace keycolor with nearest color */
+		if (srcy < dsty) {
+			src += (h-1) * slinelen;
+			dst += (h-1) * dlinelen;
+			slinelen *= -1;
+			dlinelen *= -1;
+		}
+		while (--h >= 0) {
+			/* a _fast_ memcpy is a _must_ in this routine*/
+            for(i=0; i<w; ++i) {
+                unsigned int s = *src++;
+                unsigned int d = *dst;
+                if ((s&0xFFFF) != RGB2PIXEL565(0xea,0xe6,0xdd) ) {
+                    *dst++ = s;
+                } else {
+                    s = (unsigned int)RGB2PIXEL565(0xea,0xe6,0xd0) & 0xFFFF;
+                    *dst++ = s;
+                }
+            }
+            dst += dlinelen - w;
+            src += slinelen - w;
+		}
+    } else if (op == MWROP_COPY_IK){
+        /* ignore key color */
+		if (srcy < dsty) {
+			src += (h-1) * slinelen;
+			dst += (h-1) * dlinelen;
+			slinelen *= -1;
+			dlinelen *= -1;
+		}
+		while (--h >= 0) {
+			/* a _fast_ memcpy is a _must_ in this routine*/
+            for(i=0; i<w; ++i) {
+                unsigned int s = *src++;
+                unsigned int d = *dst;
+                if ((s&0xFFFF) != RGB2PIXEL565(0xea,0xe6,0xdd) ) {
+                    *dst++ = s;
+                } else {
+                    dst++;
+                }
+            }
+            dst += dlinelen - w;
+            src += slinelen - w;
+		}
+    } else{
 		while (--h >= 0) {
 			for (i=0; i<w; i++) {
 				applyOp(MWROP_TO_MODE(op), *src, dst, ADDR16);
diff -urN /home/greg/net/microwindows-0.90/src/drivers/fblin32alpha.c ./drivers/fblin32alpha.c
--- /home/greg/net/microwindows-0.90/src/drivers/fblin32alpha.c	2003-05-11 11:18:41.000000000 -0700
+++ ./drivers/fblin32alpha.c	2008-09-18 01:39:55.000000000 -0700
@@ -15,8 +15,14 @@
  * contributions.
  */
 /*#define NDEBUG*/
+#include <stdio.h>
+#include <stdlib.h>
 #include <assert.h>
+#include <stdio.h>
 #include <string.h>
+#include <sys/time.h>
+#include <time.h>
+
 #include "device.h"
 #include "fb.h"
 
@@ -67,6 +73,7 @@
 		/* convert linelen from byte to pixel len for bpp 16, 24, 32 */
 		psd->linelen /= 4;
 	}
+	
 	return 1;
 }
 
@@ -187,9 +194,16 @@
 
 	DRAWON;
 	if (gr_mode == MWMODE_COPY) {
+#if (MWPIXEL_FORMAT == MWPF_TRUECOLOR888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR0888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR8888)
+		MWPIXELVAL p;
+		if ((c & 0x00FFFFFF) == RGB2PIXEL888(0xea, 0xe6, 0xdd)) p = (c & 0x00FFFFFF);
+		else p = c;
+		while (x1++ <= x2) *addr++ = p;
+#else
 		/* FIXME: memsetl(dst, c, x2-x1+1) */
 		while (x1++ <= x2)
 			*addr++ = c;
+#endif
 	} else if (gr_mode <= MWMODE_SIMPLE_MAX) {
 		while (x1++ <= x2) {
 			applyOp(gr_mode, c, addr, ADDR32);
@@ -425,6 +439,222 @@
 	DRAWOFF;
 }
 
+#define YOFF_DOWN2UP (-1)	/* draw photo deflection to up */
+#define YOFF_UP2DOWN (1)	/* draw photo deflection to down */
+#define YOFF_HORIZ (0)		/* draw photo without deflection */
+#define XOFF_CENTER2LEFT (-1)	/* draw photo at left side */
+#define XOFF_CENTER2RIGHT (1)	/* draw photo at right side */
+
+typedef struct angle_map_s {
+	int angle;
+	int y_shrink_ratio;		/* shrink ratio at y direction */
+	int x_shrink_ratio_deno;	/* shrink ratio denominator at x direction */
+	int x_shrink_ratio_mole;	/* shrink ratio molecule at x direction */
+	int yoff_direction;
+	int xoff_direction;
+	int *draw_limit_y;
+	int *draw_limit_x;
+} angle_map_t;
+
+/*FIXME: we need add more items to fill this table */
+static angle_map_t angle_map[] = {
+	{0,  1,  1, 1, YOFF_HORIZ,   XOFF_CENTER2RIGHT, NULL,NULL},
+	{10, 10, 7, 6, YOFF_DOWN2UP, XOFF_CENTER2RIGHT, NULL,NULL},
+	{20, 9,  6, 5, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{30, 8,  5, 4, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{40, 7,  4, 3, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{50, 6,  3, 2, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{60, 5,  2, 1, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{70, 4,  5, 2, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{80, 3,  3, 1, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+	{88, 2,  5, 1, YOFF_DOWN2UP, XOFF_CENTER2RIGHT,NULL,NULL},
+
+	{92, 2,  5, 1, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{100,3,  3, 1, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{110,4,  5, 2, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{120,5,  2, 1, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{130,6,  3, 2, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{140,7,  4, 3, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{150,8,  5, 4, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{160,9,  6, 5, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{170,10, 7, 6, YOFF_DOWN2UP, XOFF_CENTER2LEFT,NULL,NULL},
+	{180,1,  1, 1, YOFF_HORIZ,   XOFF_CENTER2LEFT,NULL,NULL},
+
+	{300, 6, 3, 2, YOFF_UP2DOWN, XOFF_CENTER2RIGHT,NULL,NULL},
+	{330, 9, 6, 5, YOFF_UP2DOWN, XOFF_CENTER2RIGHT,NULL,NULL},
+	{360, 1,  1, 1, YOFF_HORIZ,   XOFF_CENTER2RIGHT,NULL,NULL},
+};
+
+static int distort_prepare_params(int angle, int w, int h,
+				int *y_shrink_ratio,
+				int *x_shrink_ratio_deno,
+				int *x_shrink_ratio_mole,
+				int *yoff_direction,
+				int *xoff_direction,
+				int **draw_limit_y,
+				int **draw_limit_x)
+{
+	int i = 0;
+	for (i = 0 ; i < sizeof(angle_map)/sizeof(angle_map_t); i++) {
+		if (angle <= angle_map[i].angle) {
+			*y_shrink_ratio = angle_map[i].y_shrink_ratio;
+			*x_shrink_ratio_deno = angle_map[i].x_shrink_ratio_deno;
+			*x_shrink_ratio_mole = angle_map[i].x_shrink_ratio_mole;
+			*yoff_direction = angle_map[i].yoff_direction;
+			*xoff_direction = angle_map[i].xoff_direction;
+
+			if (angle_map[i].draw_limit_y == NULL) {
+				angle_map[i].draw_limit_y = (int *)malloc(sizeof(int)*(2*w));
+				if (!angle_map[i].draw_limit_y) {
+					fprintf(stderr,"%s:%d,malloc failed\n",__FUNCTION__,__LINE__);
+					return -1;
+				}
+				bzero(angle_map[i].draw_limit_y, sizeof(int)*(2*w));
+			}
+			*draw_limit_y = angle_map[i].draw_limit_y;
+
+			/* need save draw_limit at x direction when in quadrant 4 */
+			if (angle > 270 && angle < 360) {
+				if (angle_map[i].draw_limit_x == NULL) {
+					angle_map[i].draw_limit_x = (int *)malloc(sizeof(int)*(2*h));
+					if (!angle_map[i].draw_limit_x) {
+						fprintf(stderr,"%s:%d,malloc failed\n",__FUNCTION__,__LINE__);
+						return -1;
+					}
+					bzero(angle_map[i].draw_limit_x, sizeof(int)*(2*h));
+				}
+				*draw_limit_x = angle_map[i].draw_limit_x;
+			}
+			return 0;
+		}
+	}
+	return -1;
+}
+
+
+static void distort_get_drawlimit(int angle, int **draw_limit_x_dep, int **draw_limit_y_dep)
+{
+	int i = 0;
+	if (angle > 0 && angle < 90) {
+		/* find a draw limit dependence array at y direction*/
+		for (i = sizeof(angle_map)/sizeof(angle_map_t) -1; i >= 0; i--) {
+			if (angle_map[i].angle >= 0 && angle_map[i].angle < 90) {
+				/* because the angle in array is ascend.*/
+				if ((angle_map[i].angle - angle) < 0) {
+					if (angle_map[i].draw_limit_y) {
+						*draw_limit_y_dep = angle_map[i].draw_limit_y;
+						break;
+					}
+				}
+			}
+		}	
+	} else if (angle > 90 && angle < 180) {
+		/* find a draw limit dependence array at y direction*/
+		for (i = 0 ; i < sizeof(angle_map)/sizeof(angle_map_t); i++) {
+			if (angle_map[i].angle > 90 && angle_map[i].angle <= 180) {
+				if ((angle_map[i].angle - angle) > 0) {
+					if (angle_map[i].draw_limit_y) {
+						*draw_limit_y_dep = angle_map[i].draw_limit_y;
+						break;
+					}
+				}
+			}
+		}	
+	} else if (angle > 270 && angle < 360) {
+		/* find a draw limit dependence array at x and y direction*/
+		for (i = sizeof(angle_map)/sizeof(angle_map_t) - 1; i >= 0; i--) {
+			if (angle_map[i].angle > 270 && angle_map[i].angle < 360) {
+				if ((angle_map[i].angle - angle) < 0) {
+					if (angle_map[i].draw_limit_y && angle_map[i].draw_limit_x) {
+						*draw_limit_y_dep = angle_map[i].draw_limit_y;
+						*draw_limit_x_dep = angle_map[i].draw_limit_x;
+						break;
+					}
+				}
+			}
+		}
+	} else if (angle == 0) {
+		/* find a draw limit dependence array at x and y direction*/
+		for (i = sizeof(angle_map)/sizeof(angle_map_t) - 1; i >= 0; i--) {
+			if (angle_map[i].angle > 270 && angle_map[i].angle < 360) {
+				if (angle_map[i].draw_limit_y && angle_map[i].draw_limit_x) {
+					*draw_limit_y_dep = angle_map[i].draw_limit_y;
+					*draw_limit_x_dep = angle_map[i].draw_limit_x;
+					break;
+				}
+			}
+		}	
+	}
+	return;
+}
+
+static void draw_distort(ADDR32 dst, ADDR32 src, int dlinelen, int slinelen, int w, int h, int angle)
+{
+	int x, y;
+	int yoff, yoff_direction;
+	int xoff_direction;
+	int nx, ny;
+	int y_shrink_ratio;
+	int x_shrink_ratio_deno, x_shrink_ratio_mole;
+	int i = 0;
+	int *draw_limit_y = NULL;
+	int *draw_limit_y_dep = NULL;
+	int *draw_limit_x = NULL;
+	int *draw_limit_x_dep = NULL;
+
+	if (distort_prepare_params(angle, w, h,
+				&y_shrink_ratio,
+				&x_shrink_ratio_deno,
+				&x_shrink_ratio_mole,
+				&yoff_direction,
+				&xoff_direction,
+				&draw_limit_y,
+				&draw_limit_x) < 0)
+		return;
+
+	distort_get_drawlimit(angle, &draw_limit_x_dep, &draw_limit_y_dep);
+
+	for (y = 0; y < h; y++) {
+		yoff = h/3;
+		for(x = 0; x < w; x++) {
+			if (yoff_direction != YOFF_HORIZ && x%y_shrink_ratio == 0)
+				yoff += yoff_direction;
+			if (xoff_direction == XOFF_CENTER2LEFT)
+				nx = (w - w*x_shrink_ratio_mole/x_shrink_ratio_deno) + (w - x)*x_shrink_ratio_mole/x_shrink_ratio_deno;
+			else // XOFF_CENTER2RIGHT 
+				nx = w + x*x_shrink_ratio_mole/x_shrink_ratio_deno;
+
+			if (draw_limit_x_dep) {
+				if ( !draw_limit_y_dep || 
+					(draw_limit_x_dep[y + yoff] ==0 && draw_limit_y_dep[nx] == 0)||
+					(draw_limit_y_dep[nx] && y + yoff < draw_limit_y_dep[nx]) || 
+					(draw_limit_x_dep[y + yoff] && nx > draw_limit_x_dep[y + yoff])) {
+					if (y < 5 || y > (h - 5) || x < 5 || x > (w-5))
+						dst[nx + dlinelen*yoff] = RGB2PIXEL8888(0xf9,0xfb,0xfa);
+					else {
+						dst[nx + dlinelen*yoff] = src[w-x];
+					}
+				}
+			} else if (!draw_limit_y_dep || (y + yoff < draw_limit_y_dep[nx])) {
+				if (y < 5 || y > (h - 5) || x < 5 || x > (w-5))
+					dst[nx + dlinelen*yoff] = RGB2PIXEL8888(0xf9,0xfb,0xfa);
+				else {
+					dst[nx + dlinelen*yoff] = src[w-x];
+				}
+			}
+			if (y == 0 && draw_limit_y) {
+				draw_limit_y[nx] = y + yoff;
+			}
+			if ((x == w - 1) && draw_limit_x) {
+				draw_limit_x[y + yoff] = nx;
+			}
+		}
+		dst += dlinelen;
+		src += slinelen;
+	}
+}
+
+#define ALPHABLEND 1
 /* srccopy bitblt*/
 static void
 linear32a_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
@@ -439,8 +669,10 @@
 	int dlinelen_minus_w4;
 	int slinelen_minus_w4;
 #if ALPHABLEND
-	unsigned int alpha;
+	unsigned int opacity=100; // 0~100
+	unsigned long color;
 #endif
+	unsigned int alpha;
 
 	assert(dst != 0);
 	assert(dstx >= 0 && dstx < dstpsd->xres);
@@ -458,48 +690,25 @@
 	DRAWON;
 	dst += dstx + dsty * dlinelen;
 	src += srcx + srcy * slinelen;
-
-#if ALPHABLEND
-	if ((op & MWROP_EXTENSION) != MWROP_BLENDCONSTANT)
-		goto stdblit;
-	alpha = op & 0xff;
-
-	src8 = (ADDR8) src;
-	dst8 = (ADDR8) dst;
-	dlinelen_minus_w4 = (dlinelen - w) * 4;
-	slinelen_minus_w4 = (slinelen - w) * 4;
-	while (--h >= 0) {
-		for (i = 0; i < w; ++i) {
-			register unsigned long s;
-			register unsigned long d;
-			s = src8[MWI_BYTE_OFFSET_R];
-			d = dst8[MWI_BYTE_OFFSET_R];
-			dst8[MWI_BYTE_OFFSET_R] =
-				(unsigned char) (((s - d) * alpha) >> 8) + d;
-			s = src8[MWI_BYTE_OFFSET_G];
-			d = dst8[MWI_BYTE_OFFSET_G];
-			dst8[MWI_BYTE_OFFSET_G] =
-				(unsigned char) (((s - d) * alpha) >> 8) + d;
-			s = src8[MWI_BYTE_OFFSET_B];
-			d = dst8[MWI_BYTE_OFFSET_B];
-			dst8[MWI_BYTE_OFFSET_B] =
-				(unsigned char) (((s - d) * alpha) >> 8) + d;
-			s = src8[MWI_BYTE_OFFSET_ALPHA];
-			d = dst8[MWI_BYTE_OFFSET_ALPHA];
-			dst8[MWI_BYTE_OFFSET_ALPHA] =
-				(unsigned char) (((s - d) * alpha) >> 8) + d;
-			dst8 += 4;
-			src8 += 4;
+	if ((op & MWROP_EXTENSION) == MWROP_DISTORT) {
+		int angle = 0;
+		if ((op & 0xF000) == 0xF000) { // clear distort dependence
+			int i = 0;
+			for (i = 0 ; i < sizeof(angle_map)/sizeof(angle_map_t); i++) {
+				if (angle_map[i].draw_limit_y) {
+					free(angle_map[i].draw_limit_y);
+					angle_map[i].draw_limit_y = NULL;
+				}
+				if (angle_map[i].draw_limit_x) {
+					free(angle_map[i].draw_limit_x);
+					angle_map[i].draw_limit_x = NULL;
+				}
+			}
 		}
-		dst8 += dlinelen_minus_w4;
-		src8 += slinelen_minus_w4;
-	}
-	DRAWOFF;
-	return;
-      stdblit:
-#endif
 
-	if (op == MWROP_COPY) {
+		angle = op & 0xFFF;
+		draw_distort(dst, src, dlinelen, slinelen, h, w, angle);
+	} else if (op == MWROP_COPY) {
 		/* copy from bottom up if dst in src rectangle */
 		/* memmove is used to handle x case */
 		if (srcy < dsty) {
@@ -514,14 +723,154 @@
 			dst += dlinelen;
 			src += slinelen;
 		}
-	} else if (MWROP_TO_MODE(op) <= MWMODE_SIMPLE_MAX) {
-		for (i = 0; i < w; ++i) {
-			applyOp(MWROP_TO_MODE(op), *src, dst, ADDR32);
-			++src;
-			++dst;
+	} else if (op == MWROP_COPY_RK) {
+        	/* replace keycolor with nearest color */
+		if (srcy < dsty) {
+			src += (h - 1) * slinelen;
+			dst += (h - 1) * dlinelen;
+			slinelen *= -1;
+			dlinelen *= -1;
+		}
+		while (--h >= 0) {
+			/* a _fast_ memcpy is a _must_ in this routine*/
+			for(i = 0; i < w; ++i) {
+				unsigned long s = *src++;
+				if ((s & 0x00FFFFFF) != RGB2PIXEL888(0xea, 0xe6, 0xdd) ) {
+					*dst++ = s;
+				} else {
+					s = (unsigned long)RGB2PIXEL8888(0xea,0xe6,0xd0);
+					*dst++ = s;
+				}
+			}
+			dst += dlinelen - w;
+			src += slinelen - w;
+		}
+	} else if (op == MWROP_COPY_IK) {
+		/* ignore key color */
+		if (srcy < dsty) {
+			src += (h - 1) * slinelen;
+			dst += (h - 1) * dlinelen;
+			slinelen *= -1;
+			dlinelen *= -1;
+		}
+		while (--h >= 0) {
+			/* a _fast_ memcpy is a _must_ in this routine*/
+			for(i = 0; i < w; ++i) {
+				unsigned long s = *src++;
+				if ((s&0x00FFFFFF) != RGB2PIXEL888(0xea, 0xe6, 0xdd) ) {
+					*dst++ = s;
+				} else {
+					dst++;
+				}
+			}
+			dst += dlinelen - w;
+			src += slinelen - w;
+		}
+	} else if ((op & MWROP_EXTENSION) == MWROP_COPY_ALPHA) { // In main trunc , MWROP_OVERALPHACHANNEL
+		alpha = op & 0xff;
+
+		src8 = (ADDR8) src;
+		dst8 = (ADDR8) dst;
+		dlinelen_minus_w4 = (dlinelen - w) * 4;
+		slinelen_minus_w4 = (slinelen - w) * 4;
+		while (--h >= 0) {
+			for (i = 0; i < w; ++i) {
+				register unsigned long s;
+
+				if((*(unsigned long *)src8 & 0x00FFFFFF) != RGB2PIXEL888(0xea, 0xe6, 0xdd)){
+					s = src8[MWI_BYTE_OFFSET_R];
+					dst8[MWI_BYTE_OFFSET_R] = s;
+				
+					s = src8[MWI_BYTE_OFFSET_G];
+					dst8[MWI_BYTE_OFFSET_G] = s;
+				
+					s = src8[MWI_BYTE_OFFSET_B];
+					dst8[MWI_BYTE_OFFSET_B] = s;
+				
+					dst8[MWI_BYTE_OFFSET_ALPHA] = alpha;
+				}
+				dst8 += 4;
+				src8 += 4;
+			}
+			dst8 += dlinelen_minus_w4;
+			src8 += slinelen_minus_w4;
+		}
+	} else if ((op & MWROP_EXTENSION) == MWROP_COPY_ALPHABLEND) {
+		alpha = op & 0xff;
+
+		src8 = (ADDR8) src;
+		dst8 = (ADDR8) dst;
+		dlinelen_minus_w4 = (dlinelen - w) * 4;
+		slinelen_minus_w4 = (slinelen - w) * 4;
+
+		while (--h >= 0) {
+			for (i = 0; i < w; ++i) {
+				register unsigned long s;
+				register unsigned long d;
+				
+				if((*(unsigned long *)src8 & 0x00FFFFFF) != RGB2PIXEL888(0xea, 0xe6, 0xdd)){
+					s = src8[MWI_BYTE_OFFSET_R];
+					d = dst8[MWI_BYTE_OFFSET_R];
+					dst8[MWI_BYTE_OFFSET_R] = (unsigned char) (((s - d) * alpha) >> 8) + d;
+					
+					s = src8[MWI_BYTE_OFFSET_G];
+					d = dst8[MWI_BYTE_OFFSET_G];
+					dst8[MWI_BYTE_OFFSET_G] = (unsigned char) (((s - d) * alpha) >> 8) + d;
+					
+					s = src8[MWI_BYTE_OFFSET_B];
+					d = dst8[MWI_BYTE_OFFSET_B];
+					dst8[MWI_BYTE_OFFSET_B] = (unsigned char) (((s - d) * alpha) >> 8) + d;
+					
+					s = src8[MWI_BYTE_OFFSET_ALPHA];
+					d = dst8[MWI_BYTE_OFFSET_ALPHA];
+					
+					dst8[MWI_BYTE_OFFSET_ALPHA] = alpha;
+				}
+				dst8 += 4;
+				src8 += 4;
+			}
+			dst8 += dlinelen_minus_w4;
+			src8 += slinelen_minus_w4;
+		}
+	} else if ((op & MWROP_EXTENSION) == MWROP_BLENDCONSTANT){
+		alpha = op & 0xff;
+	
+		src8 = (ADDR8) src;
+		dst8 = (ADDR8) dst;
+		dlinelen_minus_w4 = (dlinelen - w) * 4;
+		slinelen_minus_w4 = (slinelen - w) * 4;
+		while (--h >= 0) {
+			for (i = 0; i < w; ++i) {
+				register unsigned long s;
+				register unsigned long d;
+				unsigned char ap;
+
+				ap = src8[MWI_BYTE_OFFSET_ALPHA] * alpha/255;
+				
+				if ((*(unsigned long *) src8 & 0x00ffffffUL) != 0xeae6dd) {
+					s = src8[MWI_BYTE_OFFSET_R];
+					d = dst8[MWI_BYTE_OFFSET_R];
+					dst8[MWI_BYTE_OFFSET_R] = (unsigned char) (((s - d) * ap) >> 8) + d;
+					s = src8[MWI_BYTE_OFFSET_G];
+					d = dst8[MWI_BYTE_OFFSET_G];
+					dst8[MWI_BYTE_OFFSET_G] = (unsigned char) (((s - d) * ap) >> 8) + d;
+					s = src8[MWI_BYTE_OFFSET_B];
+					d = dst8[MWI_BYTE_OFFSET_B];
+					dst8[MWI_BYTE_OFFSET_B] = (unsigned char) (((s - d) * ap) >> 8) + d;
+					s = src8[MWI_BYTE_OFFSET_ALPHA];
+					d = dst8[MWI_BYTE_OFFSET_ALPHA];
+#if 0 // ERWIN
+					dst8[MWI_BYTE_OFFSET_ALPHA] = 255;
+#else
+					dst8[MWI_BYTE_OFFSET_ALPHA] = (unsigned char) (((s - d) * ap) >> 8) + d;
+#endif
+				}
+				dst8 += 4;
+				src8 += 4;
+			}
+			dst8 += dlinelen_minus_w4;
+			src8 += slinelen_minus_w4;
 		}
-		dst += dlinelen - w;
-		src += slinelen - w;
 	} else if (MWROP_TO_MODE(op) == MWMODE_SRC_OVER) {
 
 		src8 = (ADDR8) src;
@@ -539,6 +888,11 @@
 					dst8[2] = src8[2];
 					dst8[MWI_BYTE_OFFSET_ALPHA] = a;
 				} else if (a != 0) {
+#if 1 // Roy, if background is keycolor, we simply copy the source pixel
+					if ((*(unsigned long *) dst8 & 0x00ffffffUL) == 0xeae6dd) {
+						*(unsigned long *) dst8 = *(unsigned long *) src8;
+					} else {
+#endif
 					s = (int) (unsigned char)
 						src8[MWI_BYTE_OFFSET_R];
 					d = (int) (unsigned char)
@@ -570,6 +924,9 @@
 						dst8[MWI_BYTE_OFFSET_ALPHA];
 					dst8[MWI_BYTE_OFFSET_ALPHA] =
 						(a + ((d * (256 - a)) >> 8));
+#if 1 // Roy
+					}
+#endif
 				}
 				src8 += 4;
 				dst8 += 4;
@@ -577,8 +934,10 @@
 			dst8 += (dlinelen - w) * 4;
 			src8 += (slinelen - w) * 4;
 		}
-	} else {
-		/* FIXME: Implement other alpha blend modes */
+
+
+	}else{
+		printf("F:%s, why here op:%lx\n", __FUNCTION__, op);
 	}
 	DRAWOFF;
 }
@@ -875,34 +1234,34 @@
 
 			x_count = width;
 			while (x_count-- > 0) {
-				int c;
+				unsigned long c;
+				unsigned long orig;
 				int a;
-				int s;
-				register int d;
-				int orig;
-				int result;
 				c = *src_ptr;
 				a = (c >> 24) & 0xFF;
 				if (a == 255) {
 					*dest_ptr = c;
 				} else if (a != 0) {
+					int s;
+					int d;
+					unsigned long result;
+					
 					orig = *dest_ptr;
-					d = (orig >> 24) & 0xFF;
-					result = ((d + a -
-						   ((d * a) >> 8)) << 24);
-					s = ((c >> 16) & 0xFF);
-					d = (orig >> 16) & 0xFF;
-					result |=
-						(((((s - d) * a) >> 8) +
-						  d) << 16);
-					s = ((c >> 8) & 0xFF);
-					d = (orig >> 8) & 0xFF;
-					result |=
-						(((((s - d) * a) >> 8) +
-						  d) << 8);
-					s = (c & 0xFF);
-					d = orig & 0xFF;
-					result |= ((((s - d) * a) >> 8) + d);
+					
+					s = (int)(c    >> 16) & 0xFF;
+					d = (int)(orig >> 16) & 0xFF;
+					result = ((unsigned long)((((s - d) * a) >> 8) + d) << 16);
+
+					s = (int)(c    >> 8) & 0xFF;
+					d = (int)(orig >> 8) & 0xFF;
+					result |= ((unsigned long)((((s - d) * a) >> 8) + d) << 8);
+
+					s = (int)c    & 0xFF;
+					d = (int)orig & 0xFF;
+					result |= ((unsigned long)(((s - d) * a) >> 8) + d);
+
+					d = (int)(orig >> 24) & 0xFF;
+					result |= ((unsigned long)(a + ((d * (256 - a)) >> 8)) << 24);
 					*dest_ptr = result;
 				}
 
@@ -1475,7 +1834,7 @@
 {
 	ADDR32 dst;
 	ADDR8 alpha;
-	unsigned long ps, pd;
+	unsigned long ps, pd, tmp;
 	int as;
 	long psr, psg, psb, psa;
 	int x, y;
@@ -1498,6 +1857,8 @@
 			as = *alpha++;
 			if (as == 255) {
 				*dst++ = ps;
+//			} else if ((*dst & 0x00FFFFFF) == 0xEAE6DD) {
+//				*dst++ = ps;
 			} else if (as != 0) {
 				/*
 				 * Scale alpha value from 255ths to 256ths
@@ -1512,30 +1873,15 @@
 				 */
 				as = 256 - (as + (as >> 7));
 				pd = *dst;
-
-				*dst++ = ((unsigned long) (((((long)
-							      (pd &
-							       0x00FF0000UL) -
-							      psr) *
-							     as) >> 8) +
-							   psr) &
-					  0x00FF0000UL)
-					|
-					((unsigned
-					  long) (((((long) (pd & 0x0000FF00UL)
-						    - psg) * as) >> 8) +
-						 psg) & 0x0000FF00UL)
-					|
-					((unsigned
-					  long) (((((long) (pd & 0x000000FFUL)
-						    - psb) * as) >> 8) +
-						 psb) & 0x000000FFUL)
-					| ((unsigned long) ((((long)
-							      ((pd >> 8) &
-							       0x00FF0000UL)
-							      - psa) * as) +
-							    (psa << 8)) &
-					   0xFF000000UL);
+				tmp = ((unsigned long) (((((long) (pd & 0x00FF0000UL) - psr) * as) >> 8) + psr) & 0x00FF0000UL) |
+					((unsigned long) (((((long) (pd & 0x0000FF00UL) - psg) * as) >> 8) + psg) & 0x0000FF00UL) |
+					((unsigned long) (((((long) (pd & 0x000000FFUL) - psb) * as) >> 8) + psb) & 0x000000FFUL)
+					| ((unsigned long) ((((long) ((pd >> 8) & 0x00FF0000UL) - psa) * as) + (psa << 8)) & 0xFF000000UL);
+		                if ((tmp & 0x00FFFFFF) != RGB2PIXEL8888(0xea, 0xe6, 0xdd)) //0xffeae6dd)
+					*dst = tmp;
+		                else
+					*dst = (MW_U32)RGB2PIXEL8888(0xea,0xe6,0xd0);
+				dst++;
 			} else {
 				dst++;
 			}
diff -urN /home/greg/net/microwindows-0.90/src/drivers/fblin8.c ./drivers/fblin8.c
--- /home/greg/net/microwindows-0.90/src/drivers/fblin8.c	2003-02-25 11:52:25.000000000 -0800
+++ ./drivers/fblin8.c	2008-09-18 01:39:55.000000000 -0700
@@ -146,6 +146,8 @@
 	unsigned int srcalpha, dstalpha;
 #endif
 
+#define REPLACE_KEYCOLOR          18
+#define KEYCOLOR_INDEX            20
 	assert (dstpsd->addr != 0);
 	assert (dstx >= 0 && dstx < dstpsd->xres);
 	assert (dsty >= 0 && dsty < dstpsd->yres);
@@ -216,7 +218,36 @@
 			dst += dlinelen;
 			src += slinelen;
 		}
-	} else {
+	} else if((op & MWROP_EXTENSION) == MWROP_COPY_RK){
+        /* replace keycolor */
+        while (--h >= 0) {
+			int i;
+			for (i=0; i<w; i++) {
+                if(*src == KEYCOLOR_INDEX) {
+                    applyOp(MWROP_TO_MODE(MWROP_COPY), REPLACE_KEYCOLOR, dst, ADDR8);
+                }else{
+                    applyOp(MWROP_TO_MODE(MWROP_COPY), *src, dst, ADDR8);
+                }
+				++src;
+				++dst;
+			}
+			dst += dlinelen - w;
+			src += slinelen - w;
+        }
+    } else if((op & MWROP_EXTENSION) == MWROP_COPY_IK){ 
+        /* ignore keycolor */
+        while (--h >= 0) {
+			int i;
+			for (i=0; i<w; i++) {
+                if(*src != KEYCOLOR_INDEX) 
+                    applyOp(MWROP_TO_MODE(MWROP_COPY), *src, dst, ADDR8);
+				++src;
+				++dst;
+			}
+			dst += dlinelen - w;
+			src += slinelen - w;
+        } 
+    } else {
 		while (--h >= 0) {
 			int i;
 			for (i=0; i<w; i++) {
diff -urN /home/greg/net/microwindows-0.90/src/drivers/genfont.c ./drivers/genfont.c
--- /home/greg/net/microwindows-0.90/src/drivers/genfont.c	2003-05-10 08:29:54.000000000 -0700
+++ ./drivers/genfont.c	2008-09-18 01:39:55.000000000 -0700
@@ -16,12 +16,28 @@
 #include "device.h"
 #include "genfont.h"
 
+#ifdef USE_HBF_FONT
+#include "hbf.h"
+
+static char *locale;
+HBF *font_big5_24;
+HBF *font_big5_16;
+int hbf_init=0;
+#endif
+
 /* compiled in fonts*/
-extern MWCFONT font_winFreeSansSerif11x13;	/* new MWFONT_SYSTEM_VAR (was MWFONT_GUI_VAR)*/
-extern MWCFONT font_X6x13;			/* MWFONT_SYSTEM_FIXED (should be ansi)*/
-/*extern MWCFONT font_winFreeSystem14x16;*/	/* deprecated MWFONT_SYSTEM_VAR*/
-/*extern MWCFONT font_rom8x16;*/		/* deprecated MWFONT_OEM_FIXED*/
-/*extern MWCFONT font_rom8x8, font_X5x7;*/	/* unused*/
+extern MWCFONT font_arial20;
+extern MWCFONT font_arial24;
+extern MWCFONT font_arial28;
+extern MWCFONT font_arial16;
+extern MWCFONT font_rom8x16, font_rom8x8;
+extern MWCFONT font_winFreeSansSerif11x13;
+extern MWCFONT font_winFreeSystem14x16;
+extern MWCFONT font_winSystem14x16;
+extern MWCFONT font_winMSSansSerif11x13;
+extern MWCFONT font_winTerminal8x12;
+extern MWCFONT font_helvB10, font_helvB12, font_helvR10;
+extern MWCFONT font_X5x7, font_X6x13;
 
 /* handling routines for MWCOREFONT*/
 static MWFONTPROCS fontprocs = {
@@ -54,13 +70,22 @@
  * format for use by the .fnt loader using the fonts/convbdf.c program.
  */
 
-/* first font is default font*/
+/* first font is default font if no match*/
 MWCOREFONT gen_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
-	/* deprecated redirections for the time being*/
-	{&fontprocs, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
-	{&fontprocs, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
+#if HAVEMSFONTS
+#error
+	{&fontprocs, 0, 0, 0, "arial20", &font_arial20},
+	{&fontprocs, 0, 0, 0, "arial24", &font_arial24},
+	{&fontprocs, 0, 0, 0, "arial28", &font_arial28},
+	{&fontprocs, 0, 0, 0, MWFONT_GUI_VAR, &font_winMSSansSerif11x13},
+	{&fontprocs, 0, 0, 0, MWFONT_OEM_FIXED, &font_winTerminal8x12},
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13}
+#else
+	{&fontprocs, 0, 0, 0, "arial16", &font_arial16},
+	{&fontprocs, 0, 0, 0, "arial20", &font_arial20},
+	{&fontprocs, 0, 0, 0, "arial24", &font_arial24},
+	{&fontprocs, 0, 0, 0, "arial28", &font_arial28},
+#endif
 };
 
 /*
@@ -110,8 +135,36 @@
 		width = 0;
 		while(--cc >= 0) {
 			c = *str++;
-			if(c >= pf->firstchar && c < pf->firstchar+pf->size)
-				width += pf->width[c - pf->firstchar];
+#if HAVE_BIG5_SUPPORT
+            /* chinese big5 decoding*/
+            if ((c >= 0xA4 && c <= 0xC5 && cc >= 1 &&
+                ((*str >= 0x40 && *str <= 0x7E) ||
+                (*str >= 0xA1 && *str <= 0xFE)))||(c==0xC6&&(*str >= 0x40 && *str <= 0x7E) )) {
+                    --cc;
+                    ++str;
+                    width += (pf->maxwidth < 20) ? 16 : 24; /* FIXME */
+            } else
+#endif
+#if HAVE_GB2312_SUPPORT
+            /* chinese gb2312 decoding*/
+            if (c >= 0xA1 && c < 0xF8 && cc >= 1 &&
+                *str >= 0xA1 && *str < 0xFF) {
+                    --cc;
+                    ++str;
+                    width += (pf->maxwidth < 20) ? 16 : 28; /* FIXME */
+            } else
+#endif
+#if HAVE_KSC5601_SUPPORT
+            /* Korean KSC5601 decoding */
+            if (c >= 0xA1 && c <= 0xFE && cc >= 1 &&
+                (*str >= 0xA1 && *str <= 0xFE)) {
+                    --cc;
+                    ++str;
+                    width += 16;    /* FIXME*/
+            } else
+#endif
+                if(c >= pf->firstchar && c < pf->firstchar+pf->size)
+                    width += pf->width[c - pf->firstchar];
 		}
 	}
 	*pwidth = width;
@@ -119,6 +172,28 @@
 	*pbase = pf->ascent;
 }
 
+#ifdef USE_HBF_FONT
+int Font_Init()
+{
+    if(getenv("LOCALE")==NULL){
+        setenv("LOCALE","tc",1);
+    }
+    locale=getenv("LOCALE");
+    char font16[20];
+    char font24[20];
+    sprintf(font16,"/font/%s16.hbf",locale);
+    sprintf(font24,"/font/%s24.hbf",locale);
+    if((font_big5_16 = hbfOpen(font16))==NULL){
+        return 0;
+    }
+    if((font_big5_24 = hbfOpen(font24))==NULL){
+        return 0;
+    }
+    hbf_init = 1;
+    return 1;
+}
+#endif
+
 #if HAVE_FNT_SUPPORT | HAVE_PCF_SUPPORT
 /*
  * Routine to calc bounding box for text output.
@@ -157,10 +232,86 @@
 gen_gettextbits(PMWFONT pfont, int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
-	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
-	int 			count, width;
-	const MWIMAGEBITS *	bits;
-
+    PMWCFONT            pf = ((PMWCOREFONT)pfont)->cfont;
+    int                 count, width;
+	const MWIMAGEBITS  *bits;
+	static MWIMAGEBITS  map[MAX_CHAR_HEIGHT * MAX_CHAR_WIDTH / MWIMAGE_BITSPERIMAGE];
+
+    *retmap = map;
+#ifdef USE_HBF_FONT
+    int no_hbf_font = 0;
+
+    if (hbf_init==0) {
+        if(Font_Init()==0){
+            no_hbf_font = 1;
+        }
+    }
+#endif
+
+#if HAVE_BIG5_SUPPORT
+#ifdef USE_HBF_FONT
+    if(no_hbf_font == 0){
+        int CH = ((unsigned int)ch) >> 8, CL = ((unsigned int)ch) & 0xFF;
+        if ((CH >= 0xA4 && CH <= 0xC5 && ((CL >= 0x40 && CL <= 0x7E) || (CL >= 0xA1 && CL <= 0xFE)))||
+            (CH==0xC6&&(CL >= 0x40 && CL <= 0x7E)) )
+        {
+            int i;
+            int seq;
+            {
+                seq=0;
+                /* ladd=loby-(if(loby<127)?64:98) */
+                CL/*c2*/-=(CL/*c2*/<127?64:98);
+
+                if (CH <= 0xC6) seq = (CH - 0xA1) * 157 + CL;
+                else if (CH >= 0xC9)
+                    seq = (CH - 0xC9) * 157 + CL + (0xC6 - 0xA1) * 157 + 0x3E;
+            }
+
+            if (pf->maxwidth < 20) {
+                unsigned char *bitmap;
+                *pwidth = hbfBitmapBBox(font_big5_16)->hbf_width;
+                *pheight = hbfBitmapBBox(font_big5_16)->hbf_height;
+                *pbase = 0;
+                bitmap = hbfGetBitmap(font_big5_16,(HBF_CHAR)ch);
+
+                if(bitmap==NULL) {
+                    memset(map,0xff,32);
+                }
+                else
+                {
+                    for (i = 0; i < *pheight; i++) {
+                        unsigned char *DstBitmap  = ((unsigned char *)map) + i * 2;
+                        unsigned char *FontBitmap =bitmap+i*2;
+                        DstBitmap[0] = FontBitmap[1];
+                        DstBitmap[1] = FontBitmap[0];
+                    }
+                }
+            } else {
+                unsigned char *bitmap;
+                *pwidth = hbfBitmapBBox(font_big5_24)->hbf_width;
+                *pheight = hbfBitmapBBox(font_big5_24)->hbf_height;
+                *pbase = 0;
+                bitmap = hbfGetBitmap(font_big5_24,(HBF_CHAR)ch);
+                if(bitmap==NULL) {
+                    memset(map, 0xff, 112);
+                }
+                else
+                {
+                    for (i = 0; i < *pheight; i++) {
+                        unsigned char *DstBitmap  = ((unsigned char *)map) + i * 4;
+                        unsigned char *FontBitmap =bitmap+i*3;
+                        DstBitmap[0] = FontBitmap[1];
+                        DstBitmap[1] = FontBitmap[0];
+                        DstBitmap[2] = 0;
+                        DstBitmap[3] = FontBitmap[2];
+                    }
+                }
+            }
+            return;
+        }
+    }
+#endif
+#endif /* HAVE_BIG5_SUPPORT*/
 	/* if char not in font, map to first character by default*/
 	if(ch < pf->firstchar || ch >= pf->firstchar+pf->size)
 		ch = pf->firstchar;
diff -urN /home/greg/net/microwindows-0.90/src/drivers/get_key.c ./drivers/get_key.c
--- /home/greg/net/microwindows-0.90/src/drivers/get_key.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/get_key.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,212 @@
+/*
+ *
+ * Copyright (c) Sigma Designs, Inc. 2003. All rights reserved.
+ *
+ */
+
+/**
+	@file get_key.c
+	@brief non-blocking character read from terminal
+	
+	@author Christian Wolff
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <termios.h>
+#include <signal.h>
+
+#include "../rmdef/rmdef.h"
+
+#include "get_key.h"
+
+static struct termios tio_save;
+static RMuint32 init_count = 0;
+static RMuint32 exit_count = 0;
+static void (*terminate)(void *param) = NULL;
+void *g_param;
+
+static void sig_handler(int signo)
+{
+	if (exit_count++) {
+		RMDBGLOG((ENABLE, "Signal %d during cleanup, exiting unclean!\n", signo));
+		exit(1);
+	}
+	RMDBGLOG((ENABLE, "Signal %d, exiting...\n", signo));
+	RMTermExit();
+	if (terminate) (*terminate)(g_param);
+	exit(0);
+}
+
+void RMTermInit(RMbool block_int)
+{
+	struct termios tio;
+	
+	if (init_count++) return;
+	if (tcgetattr(STDIN_FILENO, &tio_save) < 0) {
+		init_count--;
+		return;
+	}
+	tio = tio_save;
+	if (block_int) {
+		tio.c_lflag &= ~(ECHO | ICANON | ISIG);
+		tio.c_iflag &= ~(BRKINT);
+	} else {
+		tio.c_lflag |= (ISIG);
+		tio.c_lflag &= ~(ECHO | ICANON);
+		tio.c_iflag |= (BRKINT);
+		tio.c_iflag &= ~(IGNBRK);
+	}
+	
+	/* 
+	   arrows or F1 characters generate a sequence of 3 characters in a row:
+	   like ESC [ A (up arrow).
+	   
+	   To avoid reading [ or A as an individual character, we set
+	   an inter character interval of 1/10 second. If characters
+	   are received in less of 1/10 second then it is treated as
+	   an individual character and is discard.
+	*/
+	
+	tio.c_cc[VMIN] = 3;   /* up to 3 chars at a time */
+	tio.c_cc[VTIME] = 1;  /* after receiving 1 char and after a delay of 1/10 second, 'read' returns */
+	tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio);
+}
+
+void RMTermExit(void)
+{
+	if (--init_count) return;
+	tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio_save);
+}
+
+void RMSignalInit(void (*cleanup)(void *param), void *param)
+{
+	terminate = cleanup;
+	g_param = param;
+	
+	if (signal(SIGBUS, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGBUS!\n"));
+#ifdef SIGEMT
+	if (signal(SIGEMT, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGEMT!\n"));
+#endif
+	if (signal(SIGFPE, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGFPE!\n"));
+	if (signal(SIGHUP, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGHUP!\n"));
+	if (signal(SIGILL, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGILL!\n"));
+	if (signal(SIGINT, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGINT!\n"));
+	if (signal(SIGIOT, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGIOT!\n"));
+	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGPIPE!\n"));
+	if (signal(SIGQUIT, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGQUIT!\n"));
+	if (signal(SIGSEGV, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGSEGV!\n"));
+	if (signal(SIGSYS, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGSYS!\n"));
+	if (signal(SIGTERM, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGTERM!\n"));
+	if (signal(SIGTRAP, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGTRAP!\n"));
+	if (signal(SIGUSR1, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGUSR1!\n"));
+	if (signal(SIGUSR2, sig_handler) == SIG_ERR) RMDBGLOG((ENABLE, "Can't catch SIGUSR2!\n"));
+}
+
+RMbool RMKeyAvailable(void)
+{
+	struct timeval tv;
+	fd_set readfds;
+	
+	tv.tv_sec = 0;
+	tv.tv_usec = 0;
+	FD_ZERO(&readfds);
+	FD_SET(STDIN_FILENO, &readfds);
+	return (select(STDIN_FILENO + 1, &readfds, NULL, NULL, &tv) > 0);
+}
+
+RMascii RMGetKey(void)
+{
+	RMascii Key[3];
+	if (read(STDIN_FILENO, Key, 3) == 1) return Key[0];
+	return '\0';
+}
+
+RMbool RMGetKeyNoWait(RMascii *pKey)
+{
+	RMascii Key[3];
+
+	if (! RMKeyAvailable()) return FALSE;
+	if (pKey == NULL) return FALSE;
+	if (read(STDIN_FILENO, Key, 3) == 1) {
+		*pKey = Key[0];
+		return TRUE;
+	}
+	
+	return FALSE;
+}
+
+void RMTermEnableEcho()
+{
+	static struct termios tio;
+	if (tcgetattr(STDIN_FILENO, &tio) < 0) {
+		return;
+	}
+	tio.c_lflag |= ECHO | ICANON;
+	tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio);
+}
+
+void RMTermDisableEcho()
+{
+	static struct termios tio;
+	if (tcgetattr(STDIN_FILENO, &tio) < 0) {
+		return;
+	}
+	tio.c_lflag &=  ~( ECHO | ICANON );
+	tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio);
+}
+
+void RMTermGetUint32(RMuint32 *data)
+{
+/* 	static struct termios tio; */
+ 	RMbool handle_echo = FALSE; 
+	
+	RMuint32 i = 0;
+	RMascii buffer[31];
+	RMascii key;
+
+	if (data == NULL)
+		return;
+
+/* 	if ( tcgetattr(STDIN_FILENO, &tio) == 0 && (tio.c_lflag & ( ECHO | ICANON )) == 0 ) */
+/* 		handle_echo = TRUE; */
+
+ 	if (handle_echo)	 
+ 		RMTermEnableEcho(); 
+
+ try_again:
+	buffer[0] = '\0';
+	while (i < 31) {
+		if (RMKeyAvailable()) {
+			key = RMGetKey();
+			printf("%c", key); fflush(stdout); //echo
+			if ((key >= '0') && (key <= '9')) {
+				buffer[i++] = key;
+				buffer[i] = '\0';
+			}
+			if (key == '\n') {
+				buffer[i] = '\0';
+				break;
+			}
+		}
+	}
+	RMDBGLOG((DISABLE, "read '%s'\n", buffer));
+	sscanf(buffer, "%lu", data);
+	RMDBGLOG((DISABLE, "scanned %lu\n", *data));
+	
+	if (i < 1) {
+		fprintf(stderr, "you must enter a number\n");
+		goto try_again;
+	}
+
+	if (handle_echo)
+		RMTermDisableEcho();
+	
+	
+	return;
+
+}
+
diff -urN /home/greg/net/microwindows-0.90/src/drivers/hbf.c ./drivers/hbf.c
--- /home/greg/net/microwindows-0.90/src/drivers/hbf.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/hbf.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,1486 @@
+/*
+ * Copyright 1993,1994,1995 by Ross Paterson
+ *
+ * - You can use this code for any purpose and without fee, except that
+ *   you may distribute only verbatim copies of it.  Please send me any
+ *   bug fixes, ports or improvements for inclusion in future versions.
+ *
+ * - The code is supplied with no warranty of any kind.
+ *
+ * Ross Paterson <rap@doc.ic.ac.uk>
+ * 17 October 1995
+ *
+ * The following people have supplied bug fixes:
+ *	Simon Chow	<khsc@synoptics.com>
+ *	Fung Fung Lee	<lee@simd.stanford.edu>
+ *	Man-Chi Pong	<mcpong@cs.ust.hk>
+ *	Steven Simpson	<simpson@math.psu.edu>
+ *	Charles Wang	<charles.wang@infores.com>
+ *	Werner Lemberg	<a7621gac@awiuni11.edvz.univie.ac.at>
+ */
+
+/*
+ * Two C interfaces to HBF files.
+ *
+ * The multiple interfaces make this code rather messy; I intend
+ * to clean it up as experience is gained on what is really needed.
+ *
+ * There are also two modes of operation:
+ * - the default is to read each bitmap from its file as demanded
+ * - if IN_MEMORY is defined, the whole bitmap file is held in memory.
+ *   In this case, if running under Unix, the bitmap files may be gzipped
+ *   (but the filename used in the HBF file should be the name of the
+ *   file before it was gzipped).
+ */
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include "hbf.h"
+
+#ifdef __MSDOS__
+#define msdos
+#endif
+
+/*
+ * if the linker complains about an unresolved identifier '_strdup',
+ * uncomment the following definition.
+ */
+/* #define NO_STRDUP */
+
+#ifdef	__STDC__
+#	define	_(x)	x
+#else
+#	define	_(x)	()
+#endif
+
+#define	reg	register
+
+typedef	int	bool;
+#define	TRUE	1
+#define	FALSE	0
+
+#define	Bit(n)	(1<<(7 - (n)))
+
+/*
+ * Messy file system issues
+ */
+
+#ifdef unix
+#define	PATH_DELIMITER ':'
+#define	RelativeFileName(fn)	((fn)[0] != '/')
+#define	LocalFileName(fn)	(strchr(fn, '/') == NULL)
+#endif /* unix */
+#ifdef msdos
+#define	PATH_DELIMITER ';'
+#define	HasDrive(fn)	(isalpha((fn)[0]) && (fn)[1] == ':')
+#define	RelativeFileName(fn)	(! HasDrive(fn) && (fn)[0] != '\\')
+#define	LocalFileName(fn)	(! HasDrive(fn) && strchr(fn, '\\') == NULL)
+#define	READ_BINARY	"rb"
+#endif /* msdos */
+#ifdef vms
+#define	PATH_DELIMITER ','
+#define	RelativeFileName(fn)	(strchr(fn, ':') == NULL && ((fn)[0] != '[' || (fn)[1] == '.' || (fn)[1] == '-'))
+#define	LocalFileName(fn)	(strchr(fn, ':') == NULL && strchr(fn, ']') == NULL)
+#endif
+
+#ifndef	RelativeFileName
+#define	RelativeFileName(fn)	FALSE
+#endif
+
+#ifndef	LocalFileName
+#define	LocalFileName(fn)	FALSE
+#endif
+
+#ifndef READ_BINARY
+#define	READ_BINARY	"r"
+#endif
+
+#define	MAX_FILENAME	1024
+
+/*
+ *	Internal structures
+ */
+
+typedef	unsigned char	byte;
+
+#define PROPERTY	struct _PROPERTY
+#define BM_FILE		struct _BM_FILE
+#define B2_RANGE	struct _B2_RANGE
+#define CODE_RANGE	struct _CODE_RANGE
+
+PROPERTY {
+	char		*prop_name;
+	char		*prop_value;
+	PROPERTY	*prop_next;
+};
+
+BM_FILE {
+	char	*bmf_name;
+#ifdef IN_MEMORY
+	byte	*bmf_contents;
+#else
+	FILE	*bmf_file;
+#endif
+	long	bmf_size;
+	BM_FILE	*bmf_next;
+};
+
+B2_RANGE {
+	byte		b2r_start;
+	byte		b2r_finish;
+	B2_RANGE	*b2r_next;
+};
+
+typedef	unsigned short	CHAR;
+typedef	unsigned int	CHAR_INDEX;	/* character index in file */
+#define	BAD_CHAR_INDEX	0xffff
+
+CODE_RANGE {
+	CHAR		code_start;
+	CHAR		code_finish;
+	BM_FILE		*code_bm_file;
+	long		code_offset;
+	CHAR_INDEX	code_pos;
+	bool		code_transposed;
+	bool		code_inverted;
+	CODE_RANGE	*code_next;
+};
+
+/*
+ *	Extended internal version of HBF
+ */
+
+typedef struct {
+	/* fields corresponding to the definition */
+	HBF		public;
+	/* plus internal stuff */
+	char		*filename;
+	byte		*bitmap_buffer;
+	unsigned int	b2_size;	/* number of legal byte-2's */
+	PROPERTY	*property;
+	B2_RANGE	*byte_2_range;
+	CODE_RANGE	*code_range;
+	BM_FILE		*bm_file;
+} HBF_STRUCT;
+
+#define	FirstByte(code)		((code)>>8)
+#define	SecondByte(code)	((code)&0xff)
+#define	MakeCode(byte1,byte2)	(((byte1)<<8)|(byte2))
+
+/* size of a bitmap in the file (may be affected by transposition) */
+#define	FileBitmapSize(hbfFile,cp) \
+		((cp)->code_transposed ? \
+			(hbfBitmapBBox(hbfFile)->hbf_height + 7)/8 * \
+				hbfBitmapBBox(hbfFile)->hbf_width : \
+			HBF_BitmapSize(hbfFile))
+
+#define	NEW(type)	((type *)malloc((unsigned)(sizeof(type))))
+
+#define	QUOTE '"'
+
+#define MAXLINE	1024
+
+extern	char	*strdup		_((const char *s));
+
+static	void	add_b2r _((B2_RANGE **last_b2r, int start, int finish));
+static	bool	add_code_range _((HBF_STRUCT *hbf, const char *line));
+static	void	add_property _((HBF_STRUCT *hbf, const char *lp));
+static	CHAR_INDEX	b2_pos _((HBF_STRUCT *hbf, HBF_CHAR code));
+static	int	b2_size _((B2_RANGE *b2r));
+static	void	clear_bbox _((HBF_BBOX *bbox));
+static	void	clear_record _((HBF_STRUCT *hbf));
+static	char	*concat _((const char *dir, int dirlen, const char *stem));
+static	char	*expand_filename _((const char *name, const char *filename));
+static	const	byte *get_bitmap
+		_((HBF_STRUCT *hbf, HBF_CHAR code, byte *buffer));
+static	byte	*local_buffer _((HBF_STRUCT *hbf));
+static	void	invert _((byte *buffer, unsigned length));
+#ifdef IN_MEMORY
+static	bool	read_bitmap_file _((BM_FILE *bmf, FILE *f));
+static	bool	copy_transposed
+		_((HBF *hbf, byte *bitmap, const byte *source));
+#else
+static	bool	get_transposed _((HBF *hbf, FILE *f, byte *bitmap));
+#endif
+static	bool	match _((const char *lp, const char *sp));
+static	bool	parse_file _((FILE *f, HBF_STRUCT *hbf));
+static	FILE	*path_open
+		_((const char *path, const char *filename, char **fullp));
+static	bool	real_open _((const char *filename, HBF_STRUCT *hbf));
+
+/* Error reporting */
+
+int	hbfDebug;	/* set this for error reporting */
+
+#ifdef	__STDC__
+#include <stdarg.h>
+
+static void
+eprintf(const char *fmt, ...)
+{
+	if (hbfDebug) {
+		va_list	args;
+
+		(void)fprintf(stderr, "HBF: ");
+		va_start(args, fmt);
+		(void)vfprintf(stderr, fmt, args);
+		va_end(args);
+		(void)fprintf(stderr, "\n");
+	}
+}
+#else /* ! __STDC__ */
+/* poor man's variable-length argument list */
+static void
+eprintf(fmt, x1, x2, x3, x4, x5, x6, x7, x8, x9)
+	const	char	*fmt;
+	int	x1, x2, x3, x4, x5, x6, x7, x8, x9;
+{
+	if (hbfDebug) {
+		(void)fprintf(stderr, "HBF: ");
+		(void)fprintf(stderr, fmt, x1, x2, x3, x4, x5, x6, x7, x8, x9);
+		(void)fprintf(stderr, "\n");
+	}
+}
+#endif /* __STDC__ */
+
+static void
+clear_bbox(bbox)
+	HBF_BBOX *bbox;
+{
+	bbox->hbf_width = bbox->hbf_height = 0;
+	bbox->hbf_xDisplacement = bbox->hbf_yDisplacement = 0;
+}
+
+static void
+clear_record(hbf)
+	HBF_STRUCT *hbf;
+{
+	clear_bbox(&(hbf->public.hbf_bitmap_bbox));
+	clear_bbox(&(hbf->public.hbf_font_bbox));
+	hbf->property = NULL;
+	hbf->filename = NULL;
+	hbf->bitmap_buffer = NULL;
+	hbf->byte_2_range = NULL;
+	hbf->code_range = NULL;
+	hbf->bm_file = NULL;
+}
+
+/*
+ *	Byte-2 ranges
+ */
+
+static void
+add_b2r(last_b2r, start, finish)
+reg	B2_RANGE **last_b2r;
+	int	start;
+	int	finish;
+{
+reg	B2_RANGE *b2r;
+
+	b2r = NEW(B2_RANGE);
+	while (*last_b2r != NULL && (*last_b2r)->b2r_start < start)
+		last_b2r = &((*last_b2r)->b2r_next);
+	b2r->b2r_next = *last_b2r;
+	b2r->b2r_start = start;
+	b2r->b2r_finish = finish;
+	*last_b2r = b2r;
+}
+
+static CHAR_INDEX
+b2_pos(hbf, code)
+	HBF_STRUCT	*hbf;
+	HBF_CHAR	code;
+{
+reg	B2_RANGE *b2r;
+reg	unsigned c;
+reg	CHAR_INDEX	pos;
+
+	c = SecondByte(code);
+	pos = 0;
+	for (b2r = hbf->byte_2_range; b2r != NULL; b2r = b2r->b2r_next)
+		if (b2r->b2r_start <= c && c <= b2r->b2r_finish)
+			return pos + c - b2r->b2r_start;
+		else
+			pos += b2r->b2r_finish - b2r->b2r_start + 1;
+	return BAD_CHAR_INDEX;
+}
+
+static int
+b2_size(b2r)
+reg	B2_RANGE *b2r;
+{
+reg	int	size;
+
+	size = 0;
+	for ( ; b2r != NULL; b2r = b2r->b2r_next)
+		size += b2r->b2r_finish - b2r->b2r_start + 1;
+	return size;
+}
+
+/* map a position to a character code */
+static long
+code_of(hbf, pos)
+	HBF_STRUCT	*hbf;
+	long		pos;
+{
+	long	code;
+	int	residue;
+reg	B2_RANGE *b2r;
+
+	code = pos / hbf->b2_size * 256;
+	residue = pos % hbf->b2_size;
+	for (b2r = hbf->byte_2_range; b2r != NULL; b2r = b2r->b2r_next)
+		if (b2r->b2r_start + residue <= b2r->b2r_finish)
+			return code + b2r->b2r_start + residue;
+		else
+			residue -= b2r->b2r_finish - b2r->b2r_start + 1;
+	/* should never get here */
+	return 0L;
+}
+
+/*
+ *	String stuff
+ */
+
+static bool
+match(lp, sp)
+reg	const	char	*lp;
+reg	const	char	*sp;
+{
+	while (*lp == *sp && *sp != '\0') {
+		lp++;
+		sp++;
+	}
+	return (*lp == '\0' || isspace(*lp)) && *sp == '\0';
+}
+
+#ifdef NO_STRDUP
+char *
+strdup(s)
+	const	char	*s;
+{
+	char	*new_s;
+
+	new_s = malloc((unsigned)strlen(s) + 1);
+	strcpy(new_s, s);
+	return new_s;
+}
+#endif
+
+/*
+ *	Properties
+ */
+
+static void
+add_property(hbf, lp)
+reg	HBF_STRUCT	*hbf;
+reg	const char	*lp;
+{
+reg	PROPERTY	*prop;
+	char	tmp[MAXLINE];
+reg	char	*tp;
+
+	prop = NEW(PROPERTY);
+
+	tp = tmp;
+	while (*lp != '\0' && ! isspace(*lp))
+		*tp++ = *lp++;
+	*tp = '\0';
+	prop->prop_name = strdup(tmp);
+
+	while (*lp != '\0' && isspace(*lp))
+		lp++;
+
+	tp = tmp;
+	if (*lp == QUOTE) {
+		lp++;
+		while (*lp != '\0' && ! (*lp == QUOTE && *++lp != QUOTE))
+			*tp++ = *lp++;
+	}
+	else
+		for (;;) {
+			while (*lp != '\0' && ! isspace(*lp))
+				*tp++ = *lp++;
+			while (*lp != '\0' && isspace(*lp))
+				lp++;
+			if (*lp == '\0')
+				break;
+			*tp++ = ' ';
+		}
+	*tp = '\0';
+	prop->prop_value = strdup(tmp);
+
+	prop->prop_next = hbf->property;
+	hbf->property = prop;
+}
+
+const char *
+hbfProperty(hbfFile, propName)
+	HBF		*hbfFile;
+	const	char	*propName;
+{
+reg	HBF_STRUCT	*hbf;
+reg	PROPERTY	*prop;
+
+	hbf = (HBF_STRUCT *)hbfFile;
+	for (prop = hbf->property; prop != NULL; prop = prop->prop_next)
+		if (strcmp(prop->prop_name, propName) == 0)
+			return prop->prop_value;
+	return NULL;
+}
+
+/*
+ *	Compatability routines
+ */
+
+const char *
+HBF_GetProperty(handle, propertyName)
+	HBF		*handle;
+	const	char	*propertyName;
+{
+	return hbfProperty(handle, propertyName);
+}
+
+int
+HBF_GetFontBoundingBox(handle, width, height, xDisplacement, yDisplacement)
+	HBF_Handle	handle;
+	unsigned int	*width;
+	unsigned int	*height;
+	int		*xDisplacement;
+	int		*yDisplacement;
+{
+	if (width != NULL)
+		*width = hbfFontBBox(handle)->hbf_width;
+	if (height != NULL)
+		*height = hbfFontBBox(handle)->hbf_height;
+	if (xDisplacement != NULL)
+		*xDisplacement = hbfFontBBox(handle)->hbf_xDisplacement;
+	if (yDisplacement != NULL)
+		*yDisplacement = hbfFontBBox(handle)->hbf_yDisplacement;
+	return 0;
+}
+
+int
+HBF_GetBitmapBoundingBox(handle, width, height, xDisplacement, yDisplacement)
+	HBF_Handle	handle;
+	unsigned int	*width;
+	unsigned int	*height;
+	int		*xDisplacement;
+	int		*yDisplacement;
+{
+	if (width != NULL)
+		*width = hbfBitmapBBox(handle)->hbf_width;
+	if (height != NULL)
+		*height = hbfBitmapBBox(handle)->hbf_height;
+	if (xDisplacement != NULL)
+		*xDisplacement = hbfBitmapBBox(handle)->hbf_xDisplacement;
+	if (yDisplacement != NULL)
+		*yDisplacement = hbfBitmapBBox(handle)->hbf_yDisplacement;
+	return 0;
+}
+
+/*
+ * Prepend a directory to a relative filename.
+ */
+static char *
+concat(dir, dirlen, stem)
+	const	char	*dir;	/* not necessarily null-terminated */
+	int	dirlen;		/* number of significant chars in dir */
+	const	char	*stem;	/* relative filename */
+{
+	char	*fullname;
+
+	if (dirlen == 0)	/* null: current directory */
+		return strdup(stem);
+#ifdef unix
+	fullname = malloc(dirlen + strlen(stem) + 2);
+	(void)sprintf(fullname, "%.*s/%s", dirlen, dir, stem);
+#else
+#ifdef msdos
+	fullname = malloc(dirlen + strlen(stem) + 2);
+	(void)sprintf(fullname, "%.*s\\%s", dirlen, dir, stem);
+#else
+#ifdef vms
+	if (dir[dirlen-1] == ']' && stem[0] == '[' && stem[1] == '-') {
+		dirlen--;
+		stem++;
+		fullname = malloc(dirlen + strlen(stem) + 2);
+		(void)sprintf(fullname, "%.*s.%s", dirlen, dir, stem);
+	}
+	else {
+		if (dir[dirlen-1] == ']' && stem[0] == '[' && stem[1] == '.') {
+			dirlen--;
+			stem++;
+		}
+		fullname = malloc(dirlen + strlen(stem) + 1);
+		(void)sprintf(fullname, "%.*s%s", dirlen, dir, stem);
+	}
+#else
+	fullname = strdup(stem);
+#endif /* vms */
+#endif /* msdos */
+#endif /* unix */
+	return fullname;
+}
+
+/*
+ *	Bitmap files
+ *
+ *	If the host operating system has a heirarchical file system and
+ *	the bitmap file name is relative, it is relative to the directory
+ *	containing the HBF file.
+ */
+static char *
+expand_filename(name, hbf_name)
+	const	char	*name;
+	const	char	*hbf_name;
+{
+#ifdef unix
+reg	char	*s;
+reg	int	size;
+
+	size = name[0] != '/' && (s = strrchr(hbf_name, '/')) != NULL ?
+		s - hbf_name + 1 : 0;
+	s = malloc((unsigned)size + strlen(name) + 1);
+	(void)sprintf(s, "%.*s%s", size, hbf_name, name);
+	return s;
+#else
+#ifdef msdos
+reg	char	*s;
+reg	int	size;
+
+	size = HasDrive(name) ? 0 :
+		name[0] == '\\' ? (HasDrive(hbf_name) ? 2 : 0) :
+		(s = strrchr(hbf_name, '\\')) != NULL ?
+			s - hbf_name + 1 : 0;
+	s = malloc((unsigned)size + strlen(name) + 1);
+	(void)sprintf(s, "%.*s%s", size, hbf_name, name);
+	return s;
+#else
+#ifdef vms
+reg	char	*s;
+reg	const	char	*copyto;
+reg	int	size;
+
+	if ((s = strchr(hbf_name, ']')) != NULL && RelativeFileName(name))
+		return concat(hbf_name, (s - hbf_name) + 1, name);
+
+	copyto = hbf_name;
+	if ((s = strstr(copyto, "::")) != NULL && strstr(name, "::") == NULL)
+		copyto = s+2;
+	if ((s = strchr(copyto, ':')) != NULL && strchr(name, ':') == NULL)
+		copyto = s+1;
+	size = copyto - hbf_name;
+	s = malloc((unsigned)size + strlen(name) + 1);
+	(void)sprintf(s, "%.*s%s", size, hbf_name, name);
+	return s;
+#else
+	return strdup(name);
+#endif /* vms */
+#endif /* msdos */
+#endif /* unix */
+}
+
+static BM_FILE *
+find_file(hbf, filename)
+	HBF_STRUCT *hbf;
+	const char *filename;
+{
+	BM_FILE	**fp;
+reg	BM_FILE	*file;
+	FILE	*f;
+#ifdef IN_MEMORY
+#ifdef unix
+	bool	from_pipe;
+#endif
+#endif
+
+	for (fp = &(hbf->bm_file); *fp != NULL; fp = &((*fp)->bmf_next))
+		if (strcmp((*fp)->bmf_name, filename) == 0)
+			return *fp;
+
+	file = NEW(BM_FILE);
+	if (file == NULL) {
+		eprintf("out of memory");
+		return NULL;
+	}
+	file->bmf_name = expand_filename(filename, hbf->filename);
+	if (file->bmf_name == NULL) {
+		free((char *)file);
+		return NULL;
+	}
+	f = fopen(file->bmf_name, READ_BINARY);
+#ifdef IN_MEMORY
+#ifdef unix
+	from_pipe = FALSE;
+	if (f == NULL) {
+		char	tmp[400];
+
+		sprintf(tmp, "%s.gz", file->bmf_name);
+		if ((f = fopen(tmp, "r")) != NULL) {
+			fclose(f);
+			sprintf(tmp, "gzcat %s.gz", file->bmf_name);
+			if ((f = popen(tmp, "r")) != NULL)
+				from_pipe = TRUE;
+		}
+	}
+#endif /* unix */
+#endif /* IN_MEMORY */
+	if (f == NULL) {
+		eprintf("can't open bitmap file '%s'", file->bmf_name);
+		free(file->bmf_name);
+		free((char *)file);
+		return NULL;
+	}
+#ifdef IN_MEMORY
+	if (! read_bitmap_file(file, f)) {
+		free(file->bmf_name);
+		free((char *)file);
+		return NULL;
+	}
+#ifdef unix
+	if (from_pipe)
+		pclose(f);
+	else
+		fclose(f);
+#else /* ! unix */
+	fclose(f);
+#endif /* ! unix */
+#else /* ! IN_MEMORY */
+	file->bmf_file = f;
+	fseek(f, 0L, 2);
+	file->bmf_size = ftell(f);
+#endif /* ! IN_MEMORY */
+	file->bmf_next = NULL;
+	*fp = file;
+	return file;
+}
+
+#ifdef IN_MEMORY
+#define	GRAIN_SIZE	512
+
+static bool
+read_bitmap_file(bmf, f)
+	BM_FILE	*bmf;
+	FILE	*f;
+{
+	byte	*contents, *cp;
+	long	size;
+	int	c;
+
+	size = 0;
+	cp = contents = (byte *)malloc((unsigned)GRAIN_SIZE);
+	if (contents == NULL) {
+		eprintf("not enough space for bitmap file");
+		return NULL;
+	}
+	while ((c = getc(f)) != EOF) {
+		if (size%GRAIN_SIZE == 0) {
+			contents = (byte *)realloc((char *)contents,
+					(unsigned)(size + GRAIN_SIZE));
+			if (contents == NULL) {
+				eprintf("not enough space for bitmap file");
+				return NULL;
+			}
+			cp = contents + size;
+		}
+		*cp++ = c;
+		size++;
+	}
+	bmf->bmf_size = size;
+	bmf->bmf_contents = (byte *)realloc((char *)contents, (unsigned)size);
+	return TRUE;
+}
+#endif /* IN_MEMORY */
+
+/*
+ *	Code ranges
+ */
+
+/* check that a code range fits within its bitmap file */
+static bool
+too_short(hbf, cp)
+	HBF_STRUCT	*hbf;
+	CODE_RANGE	*cp;
+{
+	int	bm_size;
+	long	offset, end_offset;
+	BM_FILE	*bmf;
+	long	start, finish;
+
+	bm_size = FileBitmapSize(&(hbf->public), cp);
+	offset = cp->code_offset;
+	start = cp->code_start;
+	finish = cp->code_finish;
+	end_offset = offset + bm_size *
+			(hbf->b2_size*(long)FirstByte(finish) +
+				b2_pos(hbf, finish) - cp->code_pos + 1);
+	bmf = cp->code_bm_file;
+	if (end_offset <= bmf->bmf_size)
+		return FALSE;
+	/* bitmap file is too short: produce a specific error message */
+	if (offset > bmf->bmf_size)
+		eprintf("bitmap file '%s' is shorter than offset 0x%04lx",
+			bmf->bmf_name, offset);
+	else if (offset + bm_size > bmf->bmf_size)
+		eprintf("bitmap file '%s' too short: no room for any bitmaps at offset 0x%04lx",
+			bmf->bmf_name, offset);
+	else
+		eprintf("bitmap file '%s' is too short - code range appears to be 0x%04lx-0x%04lx",
+			bmf->bmf_name,
+			start,
+			code_of(hbf, cp->code_pos +
+					(bmf->bmf_size - offset)/bm_size) - 1);
+	return TRUE;
+}
+
+static const char *
+skip_word(n, s)
+	int	n;
+	const	char	*s;
+{
+	for ( ; n > 0; n--) {
+		while (*s != '\0' && ! isspace(*s))
+			s++;
+		while (*s != '\0' && isspace(*s))
+			s++;
+	}
+	return s;
+}
+
+/* optional keywords at the end of a CODE_RANGE line */
+static void
+parse_keywords(cp, s)
+	CODE_RANGE *cp;
+	const	char	*s;
+{
+	for (s = skip_word(4, s) ; *s != '\0'; s = skip_word(1, s)) {
+		switch (*s) {
+		case 's': case 'S': case 't': case 'T':
+			/* keyword "sideways" or "transposed" */
+			cp->code_transposed = TRUE;
+			break;
+		case 'i': case 'I':
+			/* keyword "inverted" */
+			cp->code_inverted = TRUE;
+		}
+	}
+}
+
+static bool
+add_code_range(hbf, line)
+	HBF_STRUCT	*hbf;
+	const char	*line;
+{
+	CODE_RANGE *cp;
+	CODE_RANGE **cpp;
+	long	start, finish;
+	long	offset;
+	char	filename[MAXLINE];
+	BM_FILE	*bmf;
+	CHAR_INDEX b2pos;
+
+	if (sscanf(line, "HBF_CODE_RANGE %li-%li %s %li",
+			   &start, &finish, filename, &offset) != 4) {
+		eprintf("syntax error in HBF_CODE_RANGE");
+		return FALSE;
+	}
+	/* code ranges are checked in real_open() */
+	if ((bmf = find_file(hbf, filename)) == NULL)
+		return FALSE;
+	if ((cp = NEW(CODE_RANGE)) == NULL) {
+		eprintf("out of memory");
+		return FALSE;
+	}
+
+	cp->code_start = (CHAR)start;
+	cp->code_finish = (CHAR)finish;
+	cp->code_bm_file = bmf;
+	cp->code_offset = offset;
+	cp->code_transposed = cp->code_inverted = FALSE;
+	parse_keywords(cp, line);
+	/* insert it in order */
+	for (cpp = &hbf->code_range;
+	     *cpp != NULL && (*cpp)->code_finish < start;
+	     cpp = &((*cpp)->code_next))
+		;
+	if (*cpp != NULL && (*cpp)->code_start <= finish) {
+		eprintf("code ranges overlap");
+		return FALSE;
+	}
+	cp->code_next = *cpp;
+	*cpp = cp;
+
+	/* set code_pos, and check range */
+	if (start > finish) {
+		eprintf("illegal code range 0x%04lx-0x%04lx", start, finish);
+		return FALSE;
+	}
+	if ((b2pos = b2_pos(hbf, start)) == BAD_CHAR_INDEX) {
+		eprintf("illegal start code 0x%04lx", start);
+		return FALSE;
+	}
+	cp->code_pos = hbf->b2_size*(long)FirstByte(start) + b2pos;
+	if ((b2pos = b2_pos(hbf, finish)) == BAD_CHAR_INDEX) {
+		eprintf("illegal finish code 0x%04lx", finish);
+		return FALSE;
+	}
+	/* check that the bitmap file has enough bitmaps */
+	return ! too_short(hbf, cp);
+}
+
+/*
+ *	Reading and parsing of an HBF file
+ */
+
+/* get line, truncating to len, and trimming trailing spaces */
+static bool
+get_line(buf, len, f)
+	char	*buf;
+	int	len;
+	FILE	*f;
+{
+	int	c;
+	char	*bp;
+
+	bp = buf;
+	for (;;) {
+		if ((c = getc(f)) == EOF) {
+			eprintf("unexpected end of file");
+			return FALSE;
+		}
+		if (c == '\n' || c == '\r') {
+			/* trim trailing space */
+			while (bp > buf && isspace(*(bp-1)))
+				bp--;
+			*bp = '\0';
+			return TRUE;
+		}
+		if (len > 0) {
+			*bp++ = c;
+			len--;
+		}
+	}
+}
+
+/* get next non-COMMENT line */
+static bool
+get_text_line(buf, len, f)
+	char	*buf;
+	int	len;
+	FILE	*f;
+{
+	while (get_line(buf, len, f))
+		if (*buf != '\0' && ! match(buf, "COMMENT"))
+			return TRUE;
+	return FALSE;
+}
+
+static bool
+get_property(line, keyword, hbf)
+	const	char	*line;
+	const	char	*keyword;
+	HBF_STRUCT	*hbf;
+{
+	if (! match(line, keyword)) {
+		eprintf("%s expected", keyword);
+		return FALSE;
+	}
+	add_property(hbf, line);
+	return TRUE;
+}
+
+static bool
+get_bbox(line, keyword, bbox)
+	const	char	*line;
+	const	char	*keyword;
+	HBF_BBOX	*bbox;
+{
+	int	w, h, xd, yd;
+
+	if (! match(line, keyword) ||
+	    sscanf(line + strlen(keyword), "%i %i %i %i",
+			&w, &h, &xd, &yd) != 4) {
+		eprintf("%s expected", keyword);
+		return FALSE;
+	}
+	if (w <= 0 || h <= 0) {
+		eprintf("illegal %s dimensions %dx%d", keyword, w, h);
+		return FALSE;
+	}
+	bbox->hbf_width = w;
+	bbox->hbf_height = h;
+	bbox->hbf_xDisplacement = xd;
+	bbox->hbf_yDisplacement = yd;
+	return TRUE;
+}
+
+/*
+ *  HBFHeaderFile ::=
+ * 	'HBF_START_FONT'		version			EOLN
+ * 	'HBF_CODE_SCHEME'		word ...		EOLN
+ * 	'FONT'				fontName		EOLN
+ * 	'SIZE'				ptsize xres yres	EOLN
+ * 	'HBF_BITMAP_BOUNDING_BOX'	w h xd yd		EOLN
+ * 	'FONTBOUNDINGBOX'		w h xd yd		EOLN
+ * 	X11R5FontPropertySection
+ * 	'CHARS'				n			EOLN
+ * 	HBFByte2RangeSection
+ * 	HBFCodeRangeSection
+ * 	'HBF_END_FONT'			EOLN .
+ *
+ * This implementation allows extra lines before HBF_END_FONT.
+ * Anything after HBF_END_FONT is ignored.
+ */
+
+static bool
+parse_file(f, hbf)
+	FILE	*f;
+reg	HBF_STRUCT *hbf;
+{
+	char	line[MAXLINE];
+	int	start, finish;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_property(line, "HBF_START_FONT", hbf))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_property(line, "HBF_CODE_SCHEME", hbf))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_property(line, "FONT", hbf))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_property(line, "SIZE", hbf))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_bbox(line, "HBF_BITMAP_BOUNDING_BOX",
+			&(hbf->public.hbf_bitmap_bbox)))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f) ||
+	    ! get_bbox(line, "FONTBOUNDINGBOX", &(hbf->public.hbf_font_bbox)))
+		return FALSE;
+
+	if (! get_text_line(line, MAXLINE, f))
+		return FALSE;
+	if (match(line, "STARTPROPERTIES")) {
+		for (;;) {
+			if (! get_text_line(line, MAXLINE, f))
+				return FALSE;
+			if (match(line, "ENDPROPERTIES"))
+				break;
+			add_property(hbf, line);
+		}
+		if (! get_text_line(line, MAXLINE, f))
+			return FALSE;
+	}
+
+	if (match(line, "CHARS"))
+		if (! get_text_line(line, MAXLINE, f))
+			return FALSE;
+
+	if (match(line, "HBF_START_BYTE_2_RANGES")) {
+		for (;;) {
+			if (! get_text_line(line, MAXLINE, f))
+				return FALSE;
+			if (match(line, "HBF_END_BYTE_2_RANGES"))
+				break;
+			if (sscanf(line, "HBF_BYTE_2_RANGE %i-%i",
+					&start, &finish) != 2) {
+				eprintf("HBF_BYTE_2_RANGE expected");
+				return FALSE;
+			}
+			add_b2r(&(hbf->byte_2_range), start, finish);
+		}
+		if (! get_text_line(line, MAXLINE, f))
+			return FALSE;
+	}
+	else
+		add_b2r(&(hbf->byte_2_range), 0, 0xff);
+	hbf->b2_size = b2_size(hbf->byte_2_range);
+
+	if (! match(line, "HBF_START_CODE_RANGES")) {
+		eprintf("HBF_START_CODE_RANGES expected");
+		return FALSE;
+	}
+	for (;;) {
+		if (! get_text_line(line, MAXLINE, f))
+			return FALSE;
+		if (match(line, "HBF_END_CODE_RANGES"))
+			break;
+		if (! add_code_range(hbf, line))
+			return FALSE;
+	}
+
+	for (;;) {
+		if (! get_text_line(line, MAXLINE, f))
+			return FALSE;
+		if (match(line, "HBF_END_FONT"))
+			break;
+		/* treat extra lines as properties (for private extensions) */
+		add_property(hbf, line);
+	}
+
+	return TRUE;
+}
+
+static FILE *
+path_open(path, filename, fullp)
+	const	char	*path;
+	const	char	*filename;
+	char	**fullp;
+{
+	if (LocalFileName(filename) && path != NULL) {
+#ifdef PATH_DELIMITER
+		int	len;
+		char	*fullname;
+		FILE	*f;
+		const	char	*p_next;
+
+		len = strlen(filename);
+		for (;;) {
+			p_next = strchr(path, PATH_DELIMITER);
+			if (p_next == NULL)
+				p_next = path + strlen(path);
+			fullname = concat(path, p_next - path, filename);
+			if ((f = fopen(fullname, "r")) != NULL) {
+				*fullp = fullname;
+				return f;
+			}
+			free(fullname);
+			if (*p_next == '\0')
+				break;
+			path = p_next + 1;
+		}
+#endif
+		return NULL;
+	}
+	else {
+		*fullp = strdup(filename);
+		return fopen(*fullp, "r");
+	}
+}
+
+static bool
+real_open(filename, hbf)
+	const	char	*filename;
+reg	HBF_STRUCT *hbf;
+{
+	FILE	*f;
+
+	f = path_open(getenv("HBFPATH"), filename, &(hbf->filename));
+	if (f == NULL) {
+		eprintf("can't read file '%s'", filename);
+		return FALSE;
+	}
+	if (! parse_file(f, hbf)) {
+		fclose(f);
+		return FALSE;
+	}
+	fclose(f);
+	return TRUE;
+}
+
+HBF *
+hbfOpen(filename)
+	const	char	*filename;
+{
+reg	HBF_STRUCT *hbf;
+
+	if ((hbf = NEW(HBF_STRUCT)) == NULL) {
+		eprintf("can't allocate HBF structure");
+		return NULL;
+	}
+	clear_record(hbf);
+	if (real_open(filename, hbf))
+		return &(hbf->public);
+	hbfClose(&(hbf->public));
+	return NULL;
+}
+
+int
+HBF_OpenFont(filename, ptrHandleStorage)
+	const	char	*filename;
+	HBF	**ptrHandleStorage;
+{
+	return (*ptrHandleStorage = hbfOpen(filename)) == NULL ? -1 : 0;
+}
+
+/*
+ *	Close files, free everything associated with the HBF.
+ */
+
+int
+HBF_CloseFont(hbfFile)
+	HBF	*hbfFile;
+{
+reg	HBF_STRUCT	*hbf;
+	PROPERTY	*prop_ptr, *prop_next;
+	B2_RANGE	*b2r_ptr, *b2r_next;
+	CODE_RANGE	*code_ptr, *code_next;
+	BM_FILE		*bmf_ptr, *bmf_next;
+	int		status;
+
+	status = 0;
+	hbf = (HBF_STRUCT *)hbfFile;
+
+	if (hbf->filename != NULL)
+		free(hbf->filename);
+	if (hbf->bitmap_buffer != NULL)
+		free(hbf->bitmap_buffer);
+
+	for (prop_ptr = hbf->property;
+	     prop_ptr != NULL;
+	     prop_ptr = prop_next) {
+		prop_next = prop_ptr->prop_next;
+		free(prop_ptr->prop_name);
+		free(prop_ptr->prop_value);
+		free((char *)prop_ptr);
+	}
+
+	for (b2r_ptr = hbf->byte_2_range;
+	     b2r_ptr != NULL;
+	     b2r_ptr = b2r_next) {
+		b2r_next = b2r_ptr->b2r_next;
+		free((char *)b2r_ptr);
+	}
+
+	for (code_ptr = hbf->code_range;
+	     code_ptr != NULL;
+	     code_ptr = code_next) {
+		code_next = code_ptr->code_next;
+		free((char *)code_ptr);
+	}
+
+	for (bmf_ptr = hbf->bm_file;
+	     bmf_ptr != NULL;
+	     bmf_ptr = bmf_next) {
+		bmf_next = bmf_ptr->bmf_next;
+#ifdef IN_MEMORY
+		free((char *)(bmf_ptr->bmf_contents));
+#else
+		if (bmf_ptr->bmf_file != NULL &&
+		    fclose(bmf_ptr->bmf_file) < 0)
+			status = -1;
+#endif
+		free(bmf_ptr->bmf_name);
+		free((char *)bmf_ptr);
+	}
+
+	free((char *)hbf);
+
+	return status;
+}
+
+void
+hbfClose(hbfFile)
+	HBF	*hbfFile;
+{
+	(void)HBF_CloseFont(hbfFile);
+}
+
+/*
+ *	Fetch a bitmap
+ */
+
+const byte *
+hbfGetBitmap(hbf, code)
+	HBF		*hbf;
+	HBF_CHAR	code;
+{
+	return get_bitmap((HBF_STRUCT *)hbf, code, (byte *)NULL);
+}
+
+int
+HBF_GetBitmap(hbf, code, buffer)
+	HBF		*hbf;
+	HBF_CHAR	code;
+	byte		*buffer;
+{
+	return get_bitmap((HBF_STRUCT *)hbf, code, buffer) == NULL ? -1 : 0;
+}
+
+/*
+ * Internal function to fetch a bitmap.
+ * If buffer is non-null, it must be used.
+ */
+static const byte *
+get_bitmap(hbf, code, buffer)
+reg	HBF_STRUCT	*hbf;
+	HBF_CHAR	code;
+	byte		*buffer;
+{
+	CHAR_INDEX	pos, b2pos;
+reg	CODE_RANGE	*cp;
+	BM_FILE		*bmf;
+	int		bm_size;
+	long		offset;
+
+	if ((b2pos = b2_pos(hbf, code)) == BAD_CHAR_INDEX)
+		return NULL;
+	pos = hbf->b2_size*FirstByte(code) + b2pos;
+	for (cp = hbf->code_range; cp != NULL; cp = cp->code_next)
+		if (cp->code_start <= code && code <= cp->code_finish) {
+			bmf = cp->code_bm_file;
+			bm_size = FileBitmapSize(&(hbf->public), cp);
+			offset = cp->code_offset +
+				   (long)(pos - cp->code_pos) * bm_size;
+#ifdef IN_MEMORY
+			if (buffer == NULL &&
+			    ! cp->code_transposed && ! cp->code_inverted)
+				return bmf->bmf_contents + offset;
+#endif /* IN_MEMORY */
+			if (buffer == NULL &&
+			    ((buffer = local_buffer(hbf)) == NULL))
+				return NULL;
+#ifdef IN_MEMORY
+			if (cp->code_transposed)
+				copy_transposed(&(hbf->public),
+						buffer,
+						bmf->bmf_contents + offset);
+			else
+				memcpy((char *)buffer,
+				       (char *)(bmf->bmf_contents + offset),
+				       bm_size);
+#else /* ! IN_MEMORY */
+			if (fseek(bmf->bmf_file, offset, 0) != 0) {
+				eprintf("seek error on code 0x%04x", code);
+				return NULL;
+			}
+			if (cp->code_transposed ?
+			    ! get_transposed(&(hbf->public), bmf->bmf_file,
+						buffer) :
+			    fread((char *)buffer,
+					bm_size, 1, bmf->bmf_file) != 1) {
+				eprintf("read error on code 0x%04x", code);
+				return NULL;
+			}
+#endif /* IN_MEMORY */
+			if (cp->code_inverted)
+				invert(buffer, HBF_BitmapSize(&(hbf->public)));
+			return buffer;
+		}
+	eprintf("code 0x%04x out of range", code);
+	return NULL;
+}
+
+static byte *
+local_buffer(hbf)
+	HBF_STRUCT	*hbf;
+{
+	if (hbf->bitmap_buffer == NULL &&
+	    (hbf->bitmap_buffer = (byte *)malloc(HBF_BitmapSize(&(hbf->public)))) == NULL) {
+		eprintf("out of memory");
+		return NULL;
+	}
+	return hbf->bitmap_buffer;
+}
+
+static void
+invert(buffer, length)
+	byte	*buffer;
+	unsigned int	length;
+{
+	for ( ; length > 0; length--)
+		*buffer++ ^= 0xff;
+}
+
+#ifdef IN_MEMORY
+static bool
+copy_transposed(hbf, bitmap, source)
+	HBF	*hbf;
+reg	byte	*bitmap;
+reg	const	byte	*source;
+{
+reg	byte	*pos;
+reg	byte	*bm_end;
+	int	x;
+	int	width;
+reg	int	row_size;
+reg	int	c;
+reg	int	imask, omask;
+
+	width = hbfBitmapBBox(hbf)->hbf_width;
+	row_size = HBF_RowSize(hbf);
+	bm_end = bitmap + HBF_BitmapSize(hbf);
+	(void)memset((char *)bitmap, '\0', HBF_BitmapSize(hbf));
+	for (x = 0; x < width; x++) {
+		pos = bitmap + x/8;
+		omask = Bit(x%8);
+		/* y = 0 */
+		for (;;) {
+			c = *source++;
+			for (imask = Bit(0); imask != 0; imask >>= 1) {
+				/*
+				 * At this point,
+				 *
+				 *	imask == Bit(y%8)
+				 *	pos == bitmap + y*row_size + x/8
+				 *
+				 * We examine bit y of row x of the input,
+				 * setting bit x of row y of the output if
+				 * required, by applying omask to *pos.
+				 */
+				if ((c & imask) != 0)
+					*pos |= omask;
+				/* if (++y > height) goto end_column */
+				pos += row_size;
+				if (pos >= bm_end)
+					goto end_column;
+			}
+		}
+end_column:
+		;
+	}
+	return TRUE;
+}
+#else /* ! IN_MEMORY */
+static bool
+get_transposed(hbf, f, bitmap)
+	HBF	*hbf;
+	FILE	*f;
+reg	byte	*bitmap;
+{
+reg	byte	*pos;
+reg	byte	*bm_end;
+	int	x;
+	int	width;
+reg	int	row_size;
+reg	int	c;
+reg	int	imask, omask;
+
+	width = hbfBitmapBBox(hbf)->hbf_width;
+	row_size = HBF_RowSize(hbf);
+	bm_end = bitmap + HBF_BitmapSize(hbf);
+	(void)memset((char *)bitmap, '\0', HBF_BitmapSize(hbf));
+	for (x = 0; x < width; x++) {
+		pos = bitmap + x/8;
+		omask = Bit(x%8);
+		/* y = 0 */
+		for (;;) {
+			if ((c = getc(f)) == EOF)
+				return FALSE;
+			for (imask = Bit(0); imask != 0; imask >>= 1) {
+				/*
+				 * At this point,
+				 *
+				 *	imask == Bit(y%8)
+				 *	pos == bitmap + y*row_size + x/8
+				 *
+				 * We examine bit y of row x of the input,
+				 * setting bit x of row y of the output if
+				 * required, by applying omask to *pos.
+				 */
+				if ((c & imask) != 0)
+					*pos |= omask;
+				/* if (++y > height) goto end_column */
+				pos += row_size;
+				if (pos >= bm_end)
+					goto end_column;
+			}
+		}
+end_column:
+		;
+	}
+	return TRUE;
+}
+#endif /* ! IN_MEMORY */
+
+/*
+ * Call function on each valid code in ascending order.
+ */
+void
+hbfForEach(hbfFile, func)
+reg	HBF	*hbfFile;
+reg	void	(*func)_((HBF *sameHbfFile, HBF_CHAR code));
+{
+	HBF_STRUCT	*hbf;
+	CODE_RANGE	*cp;
+reg	B2_RANGE	*b2r;
+reg	unsigned	byte1, byte2;
+reg	unsigned	finish;
+
+	hbf = (HBF_STRUCT *)hbfFile;
+	for (cp = hbf->code_range; cp != NULL; cp = cp->code_next) {
+		byte1 = FirstByte(cp->code_start);
+		byte2 = SecondByte(cp->code_start);
+		while (MakeCode(byte1, byte2) <= cp->code_finish) {
+			for (b2r = hbf->byte_2_range;
+			     b2r != NULL;
+			     b2r = b2r->b2r_next) {
+				if (byte2 < b2r->b2r_start)
+					byte2 = b2r->b2r_start;
+				finish = b2r->b2r_finish;
+				if (byte1 == FirstByte(cp->code_finish) &&
+				    finish > SecondByte(cp->code_finish))
+					finish = SecondByte(cp->code_finish);
+				while (byte2 <= finish) {
+					(*func)(hbfFile,
+						MakeCode(byte1, byte2));
+					byte2++;
+				}
+			}
+			byte1++;
+			byte2 = 0;
+		}
+	}
+}
+
+const char *
+hbfFileName(hbf)
+	HBF	*hbf;
+{
+	return ((HBF_STRUCT *)hbf)->filename;
+}
+
+long
+hbfChars(hbfFile)
+	HBF	*hbfFile;
+{
+	HBF_STRUCT	*hbf;
+	CODE_RANGE	*cp;
+	long		num_chars;
+
+	hbf = (HBF_STRUCT *)hbfFile;
+	num_chars = 0;
+	for (cp = hbf->code_range; cp != NULL; cp = cp->code_next)
+		num_chars +=
+			hbf->b2_size*FirstByte(cp->code_finish) +
+			b2_pos(hbf, cp->code_finish) -
+			(hbf->b2_size*FirstByte(cp->code_start) +
+			b2_pos(hbf, cp->code_start)) + 1;
+	return num_chars;
+}
+
+/*
+ *	Functions also implemented as macros
+ */
+
+#ifdef hbfBitmapBBox
+#undef hbfBitmapBBox
+#endif
+
+HBF_BBOX *
+hbfBitmapBBox(hbf)
+	HBF	*hbf;
+{
+	return &(hbf->hbf_bitmap_bbox);
+}
+
+#ifdef hbfFontBBox
+#undef hbfFontBBox
+#endif
+
+HBF_BBOX *
+hbfFontBBox(hbf)
+	HBF	*hbf;
+{
+	return &(hbf->hbf_font_bbox);
+}
diff -urN /home/greg/net/microwindows-0.90/src/drivers/hbf.h ./drivers/hbf.h
--- /home/greg/net/microwindows-0.90/src/drivers/hbf.h	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/hbf.h	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ *	Two interfaces to HBF files -- take your pick.
+ *
+ *	Ross Paterson <rap@doc.ic.ac.uk>
+ */
+#ifndef _HBF_
+#define _HBF_
+
+#ifndef __STDC__
+#	ifndef const
+#		define const
+#	endif
+#endif
+
+/*
+ *	#1: a lightweight C interface.
+ */
+
+typedef	unsigned int	HBF_CHAR;
+
+typedef struct {
+	unsigned short	hbf_width;
+	unsigned short	hbf_height;
+	short		hbf_xDisplacement;
+	short		hbf_yDisplacement;
+} HBF_BBOX;
+
+typedef struct {
+	/* fields corresponding to the definition */
+	HBF_BBOX	hbf_bitmap_bbox;	/* HBF_BITMAP_BOUNDING_BOX */
+	HBF_BBOX	hbf_font_bbox;		/* FONTBOUNDINGBOX */
+} HBF;
+
+extern	HBF *hbfOpen(
+#ifdef __STDC__
+			const	char	*filename
+#endif
+		);
+
+extern	void	hbfClose(
+#ifdef __STDC__
+			HBF		*hbf
+#endif
+		);
+
+extern	const	char	*hbfProperty(
+#ifdef __STDC__
+			HBF		*hbf,
+			const	char	*propName
+#endif
+		);
+
+extern	const	unsigned char	*hbfGetBitmap(
+#ifdef __STDC__
+			HBF		*hbf,
+			HBF_CHAR	code
+#endif
+		);
+
+extern	void	hbfForEach(
+#ifdef __STDC__
+			HBF	*hbf,
+			void	(*func)(HBF *sameHbf, HBF_CHAR code)
+#endif
+		);
+
+extern	const	char	*hbfFileName(
+#ifdef __STDC__
+			HBF	*hbf
+#endif
+		);
+
+extern	long	hbfChars(
+#ifdef __STDC__
+			HBF	*hbf
+#endif
+		);
+
+extern	HBF_BBOX *hbfBitmapBBox(
+#ifdef __STDC__
+			HBF	*hbf
+#endif
+		);
+/* but defined here as a macro */
+#define	hbfBitmapBBox(hbf)	(&((hbf)->hbf_bitmap_bbox))
+
+extern	HBF_BBOX *hbfFontBBox(
+#ifdef __STDC__
+			HBF	*hbf
+#endif
+		);
+/* but defined here as a macro */
+#define	hbfFontBBox(hbf)	(&((hbf)->hbf_font_bbox))
+
+#define	HBF_RowSize(hbf)\
+	((hbfBitmapBBox(hbf)->hbf_width + 7)/8)
+
+#define	HBF_BitmapSize(hbf)\
+	(HBF_RowSize(hbf) * hbfBitmapBBox(hbf)->hbf_height)
+
+#define	HBF_GetBit(hbf,bitmap,x,y)\
+	(((bitmap)[(y)*HBF_RowSize(hbf) + (x)/8]>>(7 - (x)%8))&01)
+
+extern	int	hbfDebug;	/* set non-zero for error reporting */
+
+/*
+ *	#2: taken from Appendix 2 of the HBF draft.
+ */
+
+typedef	unsigned int	HBF_HzCode;
+typedef unsigned char	HBF_Byte ;
+typedef HBF_Byte *	HBF_BytePtr ;
+typedef HBF *	        HBF_Handle ;
+typedef HBF_Handle *    HBF_HandlePtr ;
+typedef char *	        String ;
+
+extern	int	HBF_OpenFont(
+#ifdef __STDC__
+		const	char *        filename,
+		HBF_HandlePtr ptrHandleStorage
+#endif
+);
+
+extern	int	HBF_CloseFont(
+#ifdef __STDC__
+		HBF_Handle handle
+#endif
+);
+
+extern	const char * HBF_GetProperty(
+#ifdef __STDC__
+		HBF_Handle	handle,
+		const	char *	propertyName
+#endif
+);
+
+extern	int	HBF_GetFontBoundingBox(
+#ifdef __STDC__
+		HBF_Handle   handle,
+		unsigned int *width,
+		unsigned int *height,
+		int *xDisplacement,
+		int *yDisplacement
+#endif
+);
+
+extern	int	HBF_GetBitmapBoundingBox(
+#ifdef __STDC__
+		HBF_Handle   handle,
+		unsigned int *width,
+		unsigned int *height,
+		int *xDisplacement,
+		int *yDisplacement
+#endif
+);
+
+extern	int	HBF_GetBitmap(
+#ifdef __STDC__
+		HBF_Handle  handle,
+		HBF_HzCode  hanziCode,
+		HBF_BytePtr ptrBitmapBuffer
+#endif
+);
+
+#endif /* ! _HBF_ */
diff -urN /home/greg/net/microwindows-0.90/src/drivers/kbd_tty.c ./drivers/kbd_tty.c
--- /home/greg/net/microwindows-0.90/src/drivers/kbd_tty.c	2002-08-21 09:36:18.000000000 -0700
+++ ./drivers/kbd_tty.c	2008-09-18 01:39:55.000000000 -0700
@@ -1,10 +1,13 @@
 /*
- * Copyright (c) 1999 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 1999, 2003 Greg Haerr <greg@censoft.com>
  * Copyright (c) 1991 David I. Bell
  * Permission is granted to use, distribute, or modify this source,
  * provided that this copyright notice remains intact.
  *
  * /dev/tty TTY Keyboard Driver
+ * 
+ * if TRANSLATE_ESCAPE_SEQUENCES is set in device.h, then we
+ * hard-decode function keys for Linux console and KDE konsole.
  */
 #include <stdlib.h>
 #include <sys/types.h>
@@ -14,12 +17,16 @@
 #include <termios.h>
 #include "device.h"
 
+/*#define DEBUG_ESCAPE_SEQUENCES*/
+
 #if ELKS
 #define	KEYBOARD	"/dev/tty1"	/* keyboard associated with screen*/
 #else
 #define	KEYBOARD	"/dev/tty"	/* keyboard associated with screen*/
 #endif
 
+#define CTRL(x)	  ((x) & 0x1f)
+
 extern int escape_quits;
 
 static int  TTY_Open(KBDDEVICE *pkd);
@@ -52,8 +59,6 @@
 static int
 TTY_Open(KBDDEVICE *pkd)
 {
-	int		i;
-	int		ledstate = 0;
 	char *		kbd;
 	struct termios	new;
 
@@ -119,27 +124,223 @@
 static int
 TTY_Read(MWKEY *kbuf, MWKEYMOD *modifiers, MWSCANCODE *scancode)
 {
-	int	cc;			/* characters read */
-	MWKEY	mwkey;
+#if TRANSLATE_ESCAPE_SEQUENCES
+	static unsigned char buf[5];
+	static int buflen = 0;
+#else
 	unsigned char buf[1];
+	const int buflen = 0;
+#endif
+	int	cc;			/* characters read */
+	MWKEY mwkey;
 
-	cc = read(fd, buf, 1);
-	if (cc > 0) {
-		mwkey = buf[0];
-		if (mwkey == 27 && escape_quits)	/* ESC -> quit*/
-			mwkey = MWKEY_QUIT;
-		else if (mwkey == ('P'&0x1f))		/* ^P -> print*/
-			mwkey = MWKEY_PRINT;
-
-		*kbuf = mwkey;		/* no translation*/
-		*modifiers = 0;		/* no modifiers*/
-		*scancode = 0;		/* no scancode*/
-		return 1;		/* keypress*/
-	}
+	cc = read(fd, buf + buflen, 1);
 	if ((cc < 0) && (errno != EINTR) && (errno != EAGAIN)) {
 		return -1;
 	}
-	return 0;
+	if (cc <= 0) {
+		return 0;
+	}
+	
+	mwkey = buf[0];
+#if TRANSLATE_ESCAPE_SEQUENCES
+	if (mwkey == 27) {
+		mwkey = 0;
+		buflen += cc;
+		if (buflen < 3) {
+			/* Need more characters - escape sequences are 3+ chars */
+			do {
+				cc = read(fd, buf + buflen, 3 - buflen);
+			} while ((cc < 0) && ((errno == EINTR) || (errno == EAGAIN)));
+			if (cc < 0) {
+				return -1;
+			}
+			buflen += cc;
+			if (buflen < 3) {
+				/* Partial escape sequence - will be completed on next read() */
+				return 0;
+			}
+		}
+
+		switch (buf[1]) {
+		case 'O': /* Letter O */
+			switch (buf[2]) {
+			case 'P': mwkey = MWKEY_F1; break;
+			case 'Q': mwkey = MWKEY_F2; break;
+			case 'R': mwkey = MWKEY_F3; break;
+			case 'S': mwkey = MWKEY_F4; break;
+			}
+			break;
+		case '1':
+			switch (buf[2]) {
+			case '5': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F5;
+				  break;
+			case '7': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F6;
+				  break;
+			case '8': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F7;
+				  break;
+			case '9': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F8;
+				  break;
+			}
+			break;
+		case '2':
+			switch (buf[2]) {
+			case '0': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F9;  
+				  break;
+			case '1': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F10; 
+				  break;
+			case '3': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F11; 
+				  break;
+			case '4': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_F12; 
+				  break;
+			}
+			break;
+		case '[':
+			switch (buf[2]) {
+			case '1':
+				if (buflen < 4)
+					return 0;
+				switch (buf[3]) {
+				case '~': mwkey = MWKEY_HOME; 
+					  break;
+				case '5': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F5; 
+					  break;
+				case '7': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F6; 
+					  break;
+				case '8': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F7; 
+					  break;
+				case '9': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F8; 
+					  break;
+				}
+				break;
+			case '2':
+				if (buflen < 4)
+					return 0;
+				switch (buf[3]) {
+				case '~': mwkey = MWKEY_INSERT; break;
+				case '0': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F9;  
+					  break;
+				case '1': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F10; 
+					  break;
+				case '3': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F11; 
+					  break;
+				case '4': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F12; 
+					  break;
+				}
+				break;
+			case '3': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_DELETE;   
+				  break;
+			case '4': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_END;      
+				  break;
+			case '5': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_PAGEUP;   
+				  break;
+			case '6': if (buflen < 4) return 0;
+				  if (buf[3] == '~') mwkey = MWKEY_PAGEDOWN; 
+				  break;
+			case 'A': mwkey = MWKEY_UP;    break;
+			case 'B': mwkey = MWKEY_DOWN;  break;
+			case 'C': mwkey = MWKEY_RIGHT; break;
+			case 'D': mwkey = MWKEY_LEFT;  break;
+			case 'F': mwkey = MWKEY_END;   break;
+			case 'H': mwkey = MWKEY_HOME;  break;
+			case '[':
+				if (buflen < 4)
+					return 0;
+				switch (buf[3]) {
+				case '7': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F6; 
+					  break;
+				case '8': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F7; 
+					  break;
+				case '9': if (buflen < 5) return 0;
+					  if (buf[4] == '~') mwkey = MWKEY_F8; 
+					  break;
+				case 'A': mwkey = MWKEY_F1; break;
+				case 'B': mwkey = MWKEY_F2; break;
+				case 'C': mwkey = MWKEY_F3; break;
+				case 'D': mwkey = MWKEY_F4; break;
+				case 'E': mwkey = MWKEY_F5; break;
+				}
+				break;
+			}
+			break;
+		case 27:
+			if (buf[2] == 27) mwkey = MWKEY_ESCAPE;
+			break;
+		}
+		if (mwkey == 0) {
+			if (buflen >= 5) {
+				EPRINTF("WARNING: Unknown escape sequence ESC '%c' '%c' '%c' '%c'.\n"
+					"(If you're trying to type a real escape, you have to press it 3 times.)\n",
+					buf[1], buf[2], buf[3], buf[4]);
+			} else if (buflen == 4) {
+				EPRINTF("WARNING: Unknown escape sequence ESC '%c' '%c' '%c'.\n"
+					"(If you're trying to type a real escape, you have to press it 3 times.)\n",
+					buf[1], buf[2], buf[3]);
+			} else {
+				EPRINTF("WARNING: Unknown escape sequence ESC '%c' '%c'.\n"
+					"(If you're trying to type a real escape, you have to press it 3 times.)\n",
+					buf[1], buf[2]);
+			}
+			buflen = 0;
+			return 0;
+		}
+#ifdef DEBUG_ESCAPE_SEQUENCES
+		if (buflen >= 5) {
+			EPRINTF("Got chars: ESC '%c' '%c' '%c' '%c'.\n",
+				buf[1], buf[2], buf[3], buf[4]);
+		} else if (buflen == 4) {
+			EPRINTF("Got chars: ESC '%c' '%c' '%c'.\n",
+				buf[1], buf[2], buf[3]);
+		} else {
+			EPRINTF("Got chars: ESC '%c' '%c'.\n",
+				buf[1], buf[2]);
+		}
+#endif
+		/* Parsed key - don't need the buffer any more. */
+		buflen = 0;
+	} else 
+#endif /* TRANSLATE_ESCAPE_SEQUENCES */
+
+	if (mwkey == CTRL('P'))			/* ^P -> print*/
+		mwkey = MWKEY_PRINT;
+	/*else if (mwkey == CTRL('S') || mwkey == CTRL('Q'))
+		mwkey = MWKEY_SCROLLOCK;*/
+
+	if ((mwkey == MWKEY_ESCAPE) && escape_quits)
+		mwkey = MWKEY_QUIT;
+
+#ifdef DEBUG_ESCAPE_SEQUENCES
+	if (buf[0] != 27) {
+		EPRINTF("Got char: '%c'.\n", buf[0]);
+	}
+	EPRINTF("Got key: %d\n", mwkey);
+#endif
+
+	*kbuf = mwkey;		/* no translation*/
+	*modifiers = 0;		/* no modifiers*/
+	*scancode = 0;		/* no scancode*/
+	return 1;		/* keypress*/
 }
 
 static int
diff -urN /home/greg/net/microwindows-0.90/src/drivers/rmmmimplementation.c ./drivers/rmmmimplementation.c
--- /home/greg/net/microwindows-0.90/src/drivers/rmmmimplementation.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/rmmmimplementation.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,97 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   rmmm.c
+  @brief  
+
+  @author Christian Wolff
+  @date   2003-04-03
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define ALLOW_OS_CODE 1
+#include "../rmdef/rmdef.h"
+
+inline void *RMMalloc(RMuint32 size)
+{
+	return malloc(size);
+}
+
+inline void RMFree(void *ptr)
+{
+	free(ptr);
+}
+
+inline void *RMMemset(void *s, RMuint8 c, RMuint32 n)
+{
+	return memset(s, c, n);
+}
+
+inline void *RMMemcpy(void *dest, const void *src, RMuint32 n)
+{
+	return memcpy(dest, src, n);
+}
+
+inline RMint32 RMMemcmp(const void *s1, const void *s2, RMuint32 n)
+{
+	return memcmp(s1, s2, n);
+}
+
+inline void *RMCalloc(RMuint32 nmemb, RMuint32 size)
+{
+	void *ptr = RMMalloc(nmemb * size);
+	if (ptr != NULL) RMMemset(ptr, 0, nmemb * size);
+	return ptr;
+}
+void RMEOSCallback()
+{
+	        RMDBGLOG((ENABLE,"%s: **** EOS ****\n",__FUNCTION__));
+}
+
+RMstatus RMInitSPU(RMuint32 width, RMuint32 height)
+{
+	        return RM_OK;
+}
+
+RMstatus RMClearSPU()
+{
+	        return RM_OK;
+}
+
+RMstatus RMCloseSPU()
+{
+	        return RM_OK;
+}
+
+
+RMstatus RMBlendSPU(RMuint8 *buffer)
+{
+	        return RM_OK;
+}
+/* returns TRUE to play the file and FALSE to skip it */
+RMbool RMPlayNonInterleavedAVI(void)
+{
+	        RMDBGLOG((ENABLE,"%s:**** AVI file not interleaved. Should we play it?\n",__FUNCTION__));
+		        return TRUE;
+}
+
+/* callback to pass stream information to the application, DRM protected, number of chapters, etc */
+void RMFileStreamInfoCallback(struct RMFileStreamInfo *streamInfo)
+{
+		RMDBGLOG((ENABLE,"%s:**** Got AVI/MP4 stream info ***\n",__FUNCTION__));
+}
+
+/* callback for the application to receive dcc context */
+void RMDCCInfo(struct dcc_context *dcc_info)
+{
+		        RMDBGLOG((ENABLE,"%s:**** Got DCC context ****\n",__FUNCTION__));
+}
+
+
diff -urN /home/greg/net/microwindows-0.90/src/drivers/scr_em86xx.c ./drivers/scr_em86xx.c
--- /home/greg/net/microwindows-0.90/src/drivers/scr_em86xx.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/scr_em86xx.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,1474 @@
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Microwindows Screen Driver for Linux kernel framebuffers
+ *
+ * Portions used from Ben Pfaff's BOGL <pfaffben@debian.org>
+ *
+ * Modified for eCos by
+ *   Gary Thomas <gthomas@redhat.com>
+ *   Richard Panton <richard.panton@3glab.org>
+ * 
+ * Note: modify select_fb_driver() to add new framebuffer subdrivers
+ */
+
+#define _GNU_SOURCE 1
+
+#include <assert.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "device.h"
+#include "genfont.h"
+#include "genmem.h"
+#include "fb.h"
+
+#include "mwtypes.h"
+
+// #define DRIVER_DEBUG
+
+/* #define GFX_KEYCOLOR_TEST  */
+
+/* #define NO_SWITCH_BUFFER_TEST */          // Switch buffer only one time
+
+#define SWITCH_BUFFER_TEST           // Test for changing WaitForPicture and Display sequence
+
+/* #define DRAWAREA_TEST */
+
+extern SUBDRIVER fblinear32alpha;
+static PSD  em86xx_open(PSD psd);
+static void em86xx_close(PSD psd);
+static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi);
+static void em86xx_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+static void em86xx_drawvertline(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+static void em86xx_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op);
+#ifdef DRAWAREA_TEST
+static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op);
+#endif
+static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen, int size,void *addr);
+static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op);
+
+#ifdef NO_SWITCH_BUFFER_TEST
+static int switch_first = 0;
+#endif
+
+SCREENDEVICE scrdev = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,NULL,
+	em86xx_open,
+	em86xx_close,
+	em86xx_getscreeninfo,
+	NULL,
+	NULL,						/* DrawPixel subdriver*/
+	NULL,						/* ReadPixel subdriver*/
+	em86xx_drawhorzline,		/* DrawHorzLine subdriver*/
+	em86xx_drawvertline,		/* DrawVertLine subdriver*/
+	em86xx_fillrect, 			/* FillRect subdriver*/
+	gen_fonts,
+	em86xx_blit,				/* Blit subdriver*/
+	NULL,						/* PreSelect*/
+#ifdef DRAWAREA_TEST
+	em86xx_drawarea, 						/* DrawArea subdriver*/
+#else
+	NULL,						/* DrawArea subdriver */
+#endif
+	NULL,						/* SetIOPermissions*/
+	gen_allocatememgc,
+	em86xx_mapmemgc,
+	gen_freememgc,
+	em86xx_stretchblit,			/* StretchBlit subdriver */
+	NULL,						/* SetPortrait */
+	0,							/* screen portrait mode */
+	NULL,						/* orgsubdriver */
+	NULL,						/* StretchBlitEx subdriver */
+};
+
+#define ALLOW_OS_CODE 1
+
+#include "common.h"
+
+#include "rmrtk/include/rmrtk.h"
+
+#define TIMEOUT_US 1000000
+
+enum {
+	MR_ERROR = -1,
+	MR_OK = 0,
+};
+
+/* 
+ *  use the SEND_GFX_COMMAND if you don't want a continuos polling
+ *  otherwise you can just write
+ *  while( RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0) == RM_PENDING);
+ *
+ *  uncomment the following line if you want the application to wait for the completion of commands
+ *  before going on (otherwise the command is queued, and the application only waits if the command
+ *  queue is full)
+ * 
+ */
+
+/* #define WAIT_FOR_COMMANDS */
+
+#ifdef WAIT_FOR_COMMANDS
+#define SEND_GFX_COMMAND(pRUA, moduleID, propertyID, pValue, ValueSize)	\
+{	\
+	RMstatus err;	\
+	RMuint32 n = 5;		\
+	\
+	struct RUAEvent evt;	\
+	evt.ModuleID = moduleID;	\
+	evt.Mask = RUAEVENT_COMMANDCOMPLETION;	\
+	do{		\
+		err = RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0);		\
+		if(err == RM_PENDING){		\
+			while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+				printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+		}	\
+		n--;	\
+	}while((n>0) && (err == RM_PENDING));	\
+	if (err != RM_OK) {		\
+		printf("%s, %d, Can't send command to command fifo\n", __FUNCTION__, __LINE__);	\
+		return err;		\
+	}	\
+	while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+		printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+}
+#else													
+#define SEND_GFX_COMMAND(pRUA, moduleID, propertyID, pValue, ValueSize)		\
+{	\
+	RMstatus err;	\
+	RMuint32 n;		\
+	n = 5;	\
+	do{		\
+		err = RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0);		\
+		if ((err == RM_PENDING)) {		\
+ 			struct RUAEvent evt;	\
+			evt.ModuleID = moduleID;	\
+			evt.Mask = RUAEVENT_COMMANDCOMPLETION;	\
+			while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+				printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+		}	\
+		n--;	\
+	}while((n>0) && (err == RM_PENDING));	\
+	if (err != RM_OK) {		\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("return err;");	\
+	}	\
+}
+#endif /* WAIT_FOR_COMMANDS */
+
+static struct playback_cmdline play_opt;
+static struct video_cmdline video_opt;
+static struct DCC *pDCC = NULL;
+static struct RUA *pRUA = NULL;
+static struct DCCVideoSource *pVideoSource;
+static RMuint32 pic_luma_addr[2], pic_addr[2], pic_index = 0, surface_addr;
+static RMuint32 gfx;
+static struct GFXEngine_Open_type gfx_profile;
+static struct dh_context dh_info = {0,};
+static struct dcc_context dcc_info = {0,};
+static struct GFXEngine_DisplayPicture_type display_pic;
+static struct GFXEngine_Surface_type YZ_surface;
+static struct GFXEngine_Surface_type NX_surface;
+static struct GFXEngine_Surface_type X_surface;
+
+#include <math.h>
+
+#define GFX_SUBOP_SCALE				(0x00000001)  // Scale image to destination size
+
+typedef struct {
+	struct RUA *pRUA;
+	struct DCC *pDCC;
+	unsigned long int gfx;
+	unsigned long int pic_addr[2];
+	unsigned long int pic_index;
+	struct dcc_context *dcc_info;
+#ifdef __EM8622__
+	struct dh_context *dh_info;
+#endif
+} GFXContext;
+
+typedef struct {
+		struct DCCOSDProfile bitmap_profile;
+		RMuint32 buf_addr;
+		RMuint32 buf_size;
+} PICContext ;
+
+static PICContext osd;
+static GFXContext GFX;
+
+void GFX_Fill_Rect(GFXContext *pGFX, PSD psd, MWCOORD x1,MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void GFX_SingleColor_Blend(GFXContext *pGFX, PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void GFX_Copy_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+#ifdef GFX_KEYCOLOR_TEST
+void GFX_Copy_IK_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+#endif
+void GFX_Blend_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+void GFX_Blend_BitmapFading(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width, int alpha);
+
+int Sigma86_Init (void);
+int GFX_Init (void);
+void GFX_Done (void);
+void Sigma86_Done (void);
+
+/* init framebuffer*/
+static PSD em86xx_open(PSD psd)
+{
+	PSUBDRIVER subdriver;
+
+	// Initialize EM86xx
+	if (Sigma86_Init() != MR_OK) {
+		Sigma86_Done();
+		return 0;
+	}
+
+	// Initialize GFX Engine
+	if (GFX_Init() != MR_OK) { 
+		Sigma86_Done();
+		return 0;
+	}
+
+	psd->xres = psd->xvirtres = osd.bitmap_profile.Width;
+	psd->yres = psd->yvirtres = osd.bitmap_profile.Height;
+
+	psd->planes = 1;
+	
+	switch (osd.bitmap_profile.ColorMode) {
+		case EMhwlibColorMode_TrueColor:
+		case EMhwlibColorMode_TrueColorWithKey:
+			switch (osd.bitmap_profile.ColorFormat) {
+				case EMhwlibColorFormat_24BPP_565:
+				case EMhwlibColorFormat_24BPP:
+					psd->bpp = 24;
+					break;
+				case EMhwlibColorFormat_32BPP_4444:
+				case EMhwlibColorFormat_32BPP:
+					psd->bpp = 32;
+					break;
+				case EMhwlibColorFormat_16BPP_565:
+				case EMhwlibColorFormat_16BPP_1555:
+				case EMhwlibColorFormat_16BPP_4444:
+					psd->bpp = 16;
+					break;
+			}
+			break;
+		case EMhwlibColorMode_LUT_1BPP:
+			psd->bpp = 1;
+			break;
+		case EMhwlibColorMode_LUT_2BPP:	
+			psd->bpp = 2;
+			break;
+		case EMhwlibColorMode_LUT_4BPP:
+			psd->bpp = 4;
+			break;
+		case EMhwlibColorMode_LUT_8BPP:
+			psd->bpp = 8;
+			break;
+		default:
+			break;
+	}
+
+	psd->ncolors = (psd->bpp >= 24) ? (1 << 24) : (1 << psd->bpp);
+
+	/* set linelen to byte length, possibly converted later*/
+	psd->linelen = osd.bitmap_profile.Width * ((psd->bpp + 7) / 8);
+
+	/* force subdriver init of size */
+	psd->size = 0;
+
+	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
+
+	/* set pixel format*/
+	psd->pixtype = MWPF_TRUECOLOR8888;
+
+	/* select a framebuffer subdriver based on planes and bpp*/
+	subdriver = select_fb_subdriver(psd);
+	if (!subdriver) {
+		fprintf(stderr, "No driver for screen %d\n", psd->bpp);
+		goto fail;
+	}
+
+	/*
+	 * set and initialize subdriver into screen driver
+	 * psd->size is calculated by subdriver init
+	 */
+	if(!set_subdriver(psd, subdriver, TRUE)) {
+		fprintf(stderr, "Driver initialize failed %d\n", psd->bpp);
+		goto fail;
+	}
+	// Replace with functions have been implemented in screen device driver
+	psd->DrawHorzLine = em86xx_drawhorzline;
+	psd->DrawVertLine = em86xx_drawvertline;
+	psd->FillRect = em86xx_fillrect;
+	psd->Blit = em86xx_blit;
+	psd->StretchBlit = em86xx_stretchblit;
+
+	/* mmap framebuffer into this address space*/
+	if (osd.buf_addr == 0) {
+		printf("Can't map framebuffer.\n");
+		goto fail;
+	}
+	psd->portrait = MWPORTRAIT_NONE;
+	psd->addr = (void *) osd.buf_addr;
+
+#ifdef DRIVER_DEBUG
+	printf("\nInfo about OSD driver.\n");
+	printf("ColorMode = %d\n", osd.bitmap_profile.ColorMode);
+	printf("ColorFormat = %d\n", osd.bitmap_profile.ColorFormat);
+	printf("Bits Per Pixel = %d\n", psd->bpp);
+	printf("The length of each line = %d, X resolution = %d, Y resolution = %d\n", psd->linelen, psd->xres, psd->yres);
+	printf("PSD address = 0x%lx\n", osd.buf_addr);
+#endif
+
+	return psd;	/* success*/
+
+fail:
+	return NULL;
+}
+
+/* close framebuffer*/
+static void em86xx_close(PSD psd)
+{
+	GFX_Done();
+	Sigma86_Done();
+}
+
+static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi)
+{
+	psi->rows = psd->yvirtres;
+	psi->cols = psd->xvirtres;
+	psi->planes = psd->planes;
+	psi->bpp = psd->bpp;
+	psi->ncolors = psd->ncolors;
+	psi->pixtype = psd->pixtype;
+	psi->fonts = NUMBER_FONTS;
+
+	psi->ydpcm = 42; // 320 / (3 * 2.54)
+	psi->xdpcm = 38; //240 / (2.5 * 2.54)
+
+
+	GFX.pRUA = pRUA;
+	GFX.pDCC = pDCC;
+	GFX.gfx = gfx;
+	GFX.pic_addr[0] = pic_luma_addr[0];
+	GFX.pic_addr[1] = pic_luma_addr[1];
+	GFX.pic_index = pic_index;
+	GFX.dcc_info = &dcc_info;
+#ifdef __EM8622__
+	GFX.dh_info = &dh_info;
+#endif
+	
+	psi->gfxcontext = (void *) &GFX;
+}
+
+inline void flush_instr_cache (void) 
+{
+	__asm("MCR     p15, 0, r0, c7, c5, 0");
+}
+
+inline void clean_data_cache (void)
+{        
+	__asm("MCR     p15, 0, r0, c7, c10, 0");
+
+	// drains write buffer
+	__asm("LDR     r3, =0");          // reset vector 
+	__asm("SWP     r2, r0, [r3]");    // r2 = [r3], [r3] = r0
+	__asm("SWP     r0, r2, [r3]");    // r0 = [r3], [r3] = r2
+}
+
+static void em86xx_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y, x2, y, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y, x2, y, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.DrawHorzLine(psd, x1, x2, y, c);
+			break;
+	}
+}
+
+static void em86xx_drawvertline(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y1, x1, y2, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y1, x1, y2, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.DrawVertLine(psd, x1, y1, y2, c);
+			break;
+	}
+}
+
+static void em86xx_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y1, x2, y2, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y1, x2, y2, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.FillRect(psd, x1, y1, x2, y2, c);
+			break;
+	}
+}
+
+static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op)
+{
+#ifdef SWITCH_BUFFER_TEST
+	int tmp_index = 0;
+#endif
+	int switch_flag = 0;
+	void * tmp_addr;
+
+#ifdef DRIVER_DEBUG
+	printf("\033[44m In %s:%d: Map (%p) [%d, %d] to (%p) [%d, %d, %d, %d]\033[0m\n", __FUNCTION__, __LINE__, srcpsd->addr, srcx, srcy, dstpsd->addr, dstx, dsty, w, h);
+	printf("\033[44m In %s:%d: Info about dstpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+	printf("\033[44m In %s:%d: Info about srcpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+
+	if (dstpsd->addr == (void *)osd.buf_addr) {
+		if ((op & MWROP_EXTENSION) == MWROP_SWITCH_BUFFER || op == MWROP_SWITCH_BUFFER) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+#ifdef SWITCH_BUFFER_TEST
+			tmp_index = pic_index;
+#endif
+			pic_index++;
+			pic_index &= 0x1;
+		}
+#ifdef NO_SWITCH_BUFFER_TEST
+		if (switch_first == 0) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+			pic_index++;
+			pic_index &= 0x1;
+			switch_first = 1;
+		}
+#endif
+	}
+
+	if (switch_flag == 1) {
+#ifdef SWITCH_BUFFER_TEST
+		display_pic.Surface = surface_addr;
+		display_pic.Picture = pic_addr[pic_index];
+		display_pic.Pts += 1800;
+		osd.buf_addr = pic_luma_addr[pic_index];
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_DisplayPicture, &display_pic, sizeof(display_pic));
+
+		SEND_GFX_COMMAND(pRUA, GFX.gfx, RMGFXEnginePropertyID_WaitForPicture, &(pic_addr[tmp_index]), sizeof(pic_addr[tmp_index]));
+//		NX_surface.StartAddress = pic_luma_addr[tmp_index];
+//		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+#else
+		SEND_GFX_COMMAND(pRUA, GFX.gfx, RMGFXEnginePropertyID_WaitForPicture, &(pic_addr[pic_index]), sizeof(pic_addr[pic_index]));
+		osd.buf_addr = NX_surface.StartAddress = pic_luma_addr[pic_index];
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+		display_pic.Picture = pic_addr[pic_index];
+		display_pic.Pts += 1800;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_DisplayPicture, &display_pic, sizeof(display_pic));
+
+#endif
+
+	}
+
+	switch ((op & MWROP_EXTENSION)) {
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_COPY_RK:
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_BLENDCONSTANT:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_BitmapFading(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres, op & 0xff);
+			break;
+#ifdef GFX_KEYCOLOR_TEST
+		case MWROP_COPY_IK:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				flush_instr_cache();
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_IK_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+#endif
+		default:
+#ifdef DRIVER_DEBUG
+			printf("op is %lx.\n", op);
+#endif
+			fblinear32alpha.Blit (dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, op);
+			break;
+	}
+
+	if (switch_flag == 1) {
+		tmp_addr = srcpsd->addr;
+		srcpsd->addr = dstpsd->addr;
+		dstpsd->addr = tmp_addr;
+#ifdef DRIVER_DEBUG
+		switch_flag = 0;
+		printf("\033[44m Finish switch buffer..\033[0m\n");
+		printf("\033[44m In %s:%d: Info about dstpsd (%p): xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->addr, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+		printf("\033[44m In %s:%d: Info about srcpsd (%p): xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n\n", __FUNCTION__, __LINE__, srcpsd->addr, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+	}
+}
+
+#ifdef DRAWAREA_TEST
+static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op)
+{
+	clean_data_cache();
+	fblinear32alpha.DrawArea(psd, gc, op);
+	clean_data_cache();
+}
+#endif
+
+/* 
+ * Initialize memory device with passed parms,
+ * select suitable framebuffer subdriver,
+ * and set subdriver in memory device.
+ */
+MWBOOL
+em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
+	int size,void *addr)
+{
+	if (!fb_mapmemgc(mempsd, w, h, planes, bpp, linelen, size, addr)) {
+		printf("%s, %d, fb_mapmemgc fail\n", __FUNCTION__, __LINE__);
+		return 0;
+	}
+	// Replace with functions have been implemented in screen device driver
+	mempsd->DrawHorzLine = em86xx_drawhorzline;
+	mempsd->DrawVertLine = em86xx_drawvertline;
+	mempsd->FillRect = em86xx_fillrect;
+	mempsd->Blit = em86xx_blit;
+	mempsd->StretchBlit = em86xx_stretchblit;
+	return 1;
+}
+
+static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op)
+{
+#ifdef SWITCH_BUFFER_TEST
+	int tmp_index = 0;
+#endif
+	int switch_flag = 0;
+	void * tmp_addr;
+
+#ifdef DRIVER_DEBUG
+	printf("\033[44m In %s:%d: dstpsd->addr=%p, dstx=%d dsty=%d, dstw=%d, dsth=%d, srcpsd->addr=%p, srcx=%d, srcy=%d, srcw=%d, srch=%d, op=%lx\033[0m\n", __FUNCTION__, __LINE__, dstpsd->addr, dstx, dsty, dstw, dsth, srcpsd->addr, srcx, srcy, srcw, srch, op);
+	printf("\033[44m In %s:%d: Info about dstpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+	printf("\033[44m In %s:%d: Info about srcpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+
+	if (dstpsd->addr == (void *)osd.buf_addr) {
+		if ((op & MWROP_EXTENSION) == MWROP_SWITCH_BUFFER || op == MWROP_SWITCH_BUFFER) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+#ifdef SWITCH_BUFFER_TEST
+			tmp_index = pic_index;
+#endif
+			pic_index++;
+			pic_index &= 0x1;
+		}
+#ifdef NO_SWITCH_BUFFER_TEST
+		if (switch_first == 0) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+			pic_index++;
+			pic_index &= 0x1;
+			switch_first = 1;
+		}
+#endif
+	}
+
+	if (switch_flag == 1) {
+#ifdef SWITCH_BUFFER_TEST
+		display_pic.Surface = surface_addr;
+		display_pic.Picture = pic_addr[pic_index];
+		display_pic.Pts += 1800;
+		osd.buf_addr = pic_luma_addr[pic_index];
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_DisplayPicture, &display_pic, sizeof(display_pic));
+
+		SEND_GFX_COMMAND(pRUA, GFX.gfx, RMGFXEnginePropertyID_WaitForPicture, &(pic_addr[tmp_index]), sizeof(pic_addr[tmp_index]));
+//		NX_surface.StartAddress = pic_luma_addr[tmp_index];
+//		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+#else
+		SEND_GFX_COMMAND(pRUA, GFX.gfx, RMGFXEnginePropertyID_WaitForPicture, &(pic_addr[pic_index]), sizeof(pic_addr[pic_index]));
+		osd.buf_addr = NX_surface.StartAddress = pic_luma_addr[pic_index];
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+		display_pic.Picture = pic_addr[pic_index];
+		display_pic.Pts += 1800;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_DisplayPicture, &display_pic, sizeof(display_pic));
+#endif
+	}
+
+	switch ((op & MWROP_EXTENSION)) {
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op | GFX_SUBOP_SCALE, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_COPY_RK:
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op | GFX_SUBOP_SCALE, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_BLENDCONSTANT:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_BitmapFading(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op, dstpsd->xvirtres, srcpsd->xvirtres, op & 0xff);
+			break;
+#ifdef GFX_KEYCOLOR_TEST
+		case MWROP_COPY_IK:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				flush_instr_cache();
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_IK_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+#endif
+		default:
+#ifdef DRIVER_DEBUG
+			printf("op is 0x%lx.\n", op);
+#endif
+			fblinear32alpha.Blit (dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, op);
+			break;
+	}
+
+	if (switch_flag == 1) {
+		tmp_addr = srcpsd->addr;
+		srcpsd->addr = dstpsd->addr;
+		dstpsd->addr = tmp_addr;
+#ifdef DRIVER_DEBUG
+		switch_flag = 0;
+		printf("\033[44m Finish switch buffer..\033[0m\n");
+		printf("\033[44m In %s:%d: Info about dstpsd (%p): xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->addr, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+		printf("\033[44m In %s:%d: Info about srcpsd (%p): xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n\n", __FUNCTION__, __LINE__, srcpsd->addr, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+	}
+}
+
+void GFX_Fill_Rect(GFXContext *pGFX, PSD psd, MWCOORD x1,MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_FillRectangle_type fill;
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.TotalWidth = psd->xvirtres;
+	NX_surface.StartAddress = (RMuint32)psd->addr;
+	NX_surface.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+
+	fill.X = x1;
+	fill.Y = y1;
+	fill.Width = x2 - x1 + 1;
+	fill.Height = y2 - y1 + 1;
+	fill.Color = c;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: X=%d, Y=%d, Width=%d, Height=%d, Color=%x\n", __FUNCTION__, __LINE__, fill.X, fill.Y, fill.Width, fill.Height, fill.Color);
+#endif
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_FillRectangle, &fill, sizeof(fill));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+void GFX_SingleColor_Blend(GFXContext *pGFX, PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_SingleColorBlendRectangles_type sc_blend;
+
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.TotalWidth = psd->xvirtres;
+	NX_surface.StartAddress = (RMuint32)psd->addr;
+	NX_surface.Tiled = FALSE;
+	X_surface.StartAddress = (RMuint32)psd->addr;
+
+	sc_blend.SaturateAlpha = 0;
+	sc_blend.SrcX = x1;
+	sc_blend.SrcY = y1;
+	sc_blend.DstX = x1;
+	sc_blend.DstY = y1;
+	sc_blend.Width = x2 - x1 + 1;
+	sc_blend.Height = y2 -x1 + 1;
+	sc_blend.Color = c;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: psd->addr = %p, srcX=%d, srcY=%d, dstX=%d, dsty=%d, Width=%d, Height=%d, Color=%x\n", __FUNCTION__, __LINE__, psd->addr, sc_blend.SrcX, sc_blend.SrcY, sc_blend.DstX, sc_blend.DstY, sc_blend.Width, sc_blend.Height, sc_blend.Color);
+#endif
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_SingleColorBlendRectangles, &sc_blend, sizeof(sc_blend));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+void GFX_Copy_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_MoveReplaceRectangle_type move;
+	struct GFXEngine_MoveReplaceScaleRectangle_type move_scale;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, srcpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, dw, dh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer.
+	surface_from.SurfaceID = (flag & GFX_SUBOP_SCALE) ? GFX_SURFACE_ID_Z : GFX_SURFACE_ID_Y;
+	surface_from.StartAddress = (RMuint32) srcpsd->addr;
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = (flag & GFX_SUBOP_SCALE) ? GFX_SURFACE_ID_Z : GFX_SURFACE_ID_Y;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer.
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+	surface_to.StartAddress = (RMuint32) dstpsd->addr;
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	if (flag & GFX_SUBOP_SCALE) {
+		move_scale.SrcX = sx;
+		move_scale.SrcY = sy;
+		move_scale.SrcWidth = sw;
+		move_scale.SrcHeight = sh;
+		move_scale.DstX = dx;
+		move_scale.DstY = dy;
+		move_scale.DstWidth = dw;
+		move_scale.DstHeight = dh;
+		move_scale.AlphaX = 0;
+		move_scale.AlphaY = 0;
+		move_scale.Merge = FALSE;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_MoveAndScaleRectangle, &move_scale, sizeof(move_scale));
+	} else {
+		move.Width = dw;
+		move.Height = dh;
+		move.SrcX = sx;
+		move.SrcY = sy;
+		move.DstX = dx;
+		move.DstY = dy;
+		move.AlphaX = 0;
+		move.AlphaY = 0;
+		move.Merge = FALSE;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_MoveRectangle, &move, sizeof(move));
+	}
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+#ifdef GFX_KEYCOLOR_TEST
+void GFX_Copy_IK_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_to;
+
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_MoveReplaceScaleRectangle_type move;
+	
+	struct GFXEngine_KeyColor_type keycolor;
+
+	struct GFXEngine_AlphaPalette_type alpha_palette;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, srcpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, dw, dh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer.
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+	surface_from.StartAddress = (RMuint32) srcpsd->addr;
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = EMhwlibColorMode_TrueColor;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to remove keycolor. 
+	keycolor.SurfaceID = GFX_SURFACE_ID_X;
+	keycolor.Color = 0xeae6dd;
+	keycolor.Range = 4;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_KeyColor, &keycolor, sizeof(keycolor));
+	
+	surface_to.SurfaceID = GFX_SURFACE_ID_X;
+	surface_to.StartAddress = (RMuint32) srcpsd->addr;
+	surface_to.TotalWidth = src_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = EMhwlibColorMode_TrueColorWithKey;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer.
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+	surface_to.StartAddress = (RMuint32) dstpsd->addr;
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	move.SrcWidth = sw;
+	move.SrcHeight = sh;
+	move.DstWidth = dw;
+	move.DstHeight = dh;
+	move.SrcX = sx;
+	move.SrcY = sy;
+	move.DstX = dx;
+	move.DstY = dy;
+	move.AlphaX = 0;
+	move.AlphaY = 0;
+	move.Merge = TRUE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ReplaceAndScaleRectangle, &move, sizeof(move));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+#endif
+
+void GFX_Blend_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	// Set Global variable
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_on;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_BlendAndScaleRectangles_type blend_param;
+
+//	struct GFXEngine_KeyColor_type keycolor;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, scrpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, sw, sh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer to blend
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+	surface_from.StartAddress = (RMuint32) srcpsd->addr;
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to be blend on
+	surface_on.SurfaceID = GFX_SURFACE_ID_X;
+	surface_on.StartAddress = (RMuint32) dstpsd->addr;
+	surface_on.TotalWidth = dst_width;
+	surface_on.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_on, sizeof(surface_on));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+	surface_to.StartAddress = (RMuint32) dstpsd->addr;
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Do command
+	blend_param.Src1X = sx;
+	blend_param.Src1Y = sy;
+	blend_param.SrcWidth = sw;
+	blend_param.SrcHeight = sh;
+	blend_param.Src2X = dx;  // Second rectangles to blend
+	blend_param.Src2Y = dy;
+	blend_param.DstX = dx;
+	blend_param.DstY = dy;
+	blend_param.DstWidth = dw;
+	blend_param.DstHeight = dh;
+	blend_param.SaturateAlpha = 0;
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_BlendAndScaleRectangles, &blend_param, sizeof(blend_param));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+
+void GFX_Blend_BitmapFading(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width, int alpha)
+{
+	// Set Global variable
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_on;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+	struct GFXEngine_AlphaPalette_type alpha_palette;
+	RMbool bEnableAlphaFading = TRUE;
+
+	struct GFXEngine_BlendAndScaleRectangles_type blend_param;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, scrpsd->width = %d, alpha=%d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, sw, sh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width, alpha);
+#endif
+
+	alpha_palette.Alpha0 = 0;
+	alpha_palette.Alpha1 = alpha;
+	alpha_palette.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_AlphaPalette, &alpha_palette, sizeof(alpha_palette));
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_EnableAlphaFading, &bEnableAlphaFading, sizeof(bEnableAlphaFading));
+
+	// Set input buffer to blend
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+	surface_from.StartAddress = (RMuint32) srcpsd->addr;
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to be blend on
+	surface_on.SurfaceID = GFX_SURFACE_ID_X;
+	surface_on.StartAddress = (RMuint32) dstpsd->addr;
+	surface_on.TotalWidth = dst_width;
+	surface_on.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_on, sizeof(surface_on));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+	surface_to.StartAddress = (RMuint32) dstpsd->addr;
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Do command
+	blend_param.Src1X = sx;
+	blend_param.Src1Y = sy;
+	blend_param.SrcWidth = sw;
+	blend_param.SrcHeight = sh;
+	blend_param.Src2X = dx;  // Second rectangles to blend
+	blend_param.Src2Y = dy;
+	blend_param.DstX = dx;
+	blend_param.DstY = dy;
+	blend_param.DstWidth = dw;
+	blend_param.DstHeight = dh;
+	blend_param.SaturateAlpha = 0;
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_BlendAndScaleRectangles, &blend_param, sizeof(blend_param));
+
+	bEnableAlphaFading = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_EnableAlphaFading, &bEnableAlphaFading, sizeof(bEnableAlphaFading));
+
+	alpha_palette.Alpha0 = 0;
+	alpha_palette.Alpha1 = 255;
+	alpha_palette.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_AlphaPalette, &alpha_palette, sizeof(alpha_palette));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+int Sigma86_Init (void)
+{
+	RMuint32 osd_scaler = EMHWLIB_MODULE(DispOSDScaler,0);
+
+	RMstatus err = RM_OK;
+
+	init_video_options(&video_opt);
+	init_playback_options(&play_opt);
+
+	err = RUACreateInstance(&pRUA, play_opt.chip_num);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error creating RUA instance! %d\n", err);
+		return MR_ERROR;
+	}
+	
+	err = DCCOpen(pRUA, &pDCC);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error Opening DCC! %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCInitChainEx(pDCC, DCCInitMode_LeaveDisplay);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot initialize microcode %d\n", err);
+		return MR_ERROR;
+	}
+	
+	dcc_info.pRUA = pRUA;
+ 	dcc_info.pDCC = pDCC;
+	dcc_info.route = DCCRoute_Main;
+	
+	/* with bootirq sdk, we must reset osd_scaler here, otherwise
+	 * dmaosd can't bootup.
+	 */
+	err = DCCSetSurfaceSource(dcc_info.pDCC, osd_scaler, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot unset osd scaler's surface\n");
+		return MR_ERROR;
+	}
+
+	/* the mixer should not modify the GFX scaler's config */
+	{
+		enum EMhwlibMixerSourceState state;
+		RMuint32 mixer, scaler, src_index, mixer_src;
+
+		mixer = EMHWLIB_MODULE(DispMainMixer, 0);
+		scaler= EMHWLIB_MODULE(DispGFXMultiScaler,0);
+
+		/* set a NULL surface, this will force a full register update when next surface is set */
+		err = DCCSetSurfaceSource(dcc_info.pDCC, scaler, NULL);
+		if (RMFAILED(err)) {
+			fprintf(stderr, "Cannot unset gfx scaler's surface\n");
+			return MR_ERROR;
+		}
+
+		err = RUAExchangeProperty(dcc_info.pRUA, mixer, RMGenericPropertyID_MixerSourceIndex, &scaler, sizeof(scaler), &src_index, sizeof(src_index));
+		if (RMFAILED(err)) {
+			RMDBGLOG((ENABLE, "Cannot get scaler index\n"));
+			return MR_ERROR;
+		}
+
+		mixer_src = EMHWLIB_TARGET_MODULE(mixer, 0 , src_index );
+		state = EMhwlibMixerSourceState_Slave;
+
+		while((err =  RUASetProperty(dcc_info.pRUA, mixer_src, RMGenericPropertyID_MixerSourceState, &state, sizeof(state), 0))==RM_PENDING);
+		if (RMFAILED(err)) {
+			RMDBGLOG((ENABLE, "Cannot set scaler's state on mixer\n"));
+			return MR_ERROR;
+		}
+
+		while ((err = RUASetProperty(dcc_info.pRUA, mixer, RMGenericPropertyID_Validate, NULL, 0, 0)) == RM_PENDING);
+		if (RMFAILED(err)) {
+			fprintf(stderr, "Cannot validate mixer\n");
+			return MR_ERROR;
+		}
+	}
+
+	/* open a video source with two pictures */
+	// Set OSD pixmap
+	memset(&osd, 0, sizeof(osd));
+	osd.bitmap_profile.SamplingMode = EMhwlibSamplingMode_444;
+	osd.bitmap_profile.ColorMode = EMhwlibColorMode_TrueColor;
+	osd.bitmap_profile.ColorFormat = EMhwlibColorFormat_32BPP;
+	osd.bitmap_profile.Width = DESKTOP_WIDTH;
+	osd.bitmap_profile.Height = DESKTOP_HEIGHT;
+	osd.bitmap_profile.ColorSpace = EMhwlibColorSpace_RGB_0_255;
+	osd.bitmap_profile.PixelAspectRatio.X = 1;
+	osd.bitmap_profile.PixelAspectRatio.Y = 1;
+
+#ifdef __EM8622__
+	err = DCCOpenMultiplePictureOSDVideoSource(dcc_info.pDCC, &osd.bitmap_profile, 2, &(pVideoSource), 0);
+#else
+	err = DCCOpenMultiplePictureOSDVideoSource(dcc_info.pDCC, &osd.bitmap_profile, 2, &(pVideoSource));
+#endif
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot open OSD decoder %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCGetOSDSurfaceInfo(dcc_info.pDCC, pVideoSource, NULL, &surface_addr, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot get surface address %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCGetOSDPictureInfo(pVideoSource, 0, &(pic_addr[0]),  &(pic_luma_addr[0]), NULL, NULL, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot get osd buffer info %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCGetOSDPictureInfo(pVideoSource, 1, &(pic_addr[1]), &(pic_luma_addr[1]), NULL, NULL, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot get osd buffer info %d\n", err);
+		return MR_ERROR;
+	}
+
+#ifdef DRIVER_DEBUG
+	printf("%s, %d, pic_addr=0x%lx, 0x%lx, pic_luma_addr=0x%lx, 0x%lx\n", __FUNCTION__, __LINE__, pic_addr[0], pic_addr[1], pic_luma_addr[0], pic_luma_addr[1]);
+#endif
+
+	/*possibly clean it before this with a fill */
+#ifdef __EM8622__
+	err = DCCInsertPictureInMultiplePictureOSDVideoSource(pVideoSource, 0, 0);
+#else
+	err = DCCInsertPictureInMultiplePictureOSDVideoSource(pVideoSource, 0);
+#endif
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot insert picture inside surface %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCSetSurfaceSource(dcc_info.pDCC, osd_scaler, pVideoSource);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot set the surface source %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCEnableVideoSource(pVideoSource, TRUE);
+	if (RMFAILED(err)){
+		fprintf(stderr,"Error enabling OSD buffer : %d\n",err);
+		return MR_ERROR;
+	}
+
+	while ((err = RUASetProperty(dcc_info.pRUA, osd_scaler, RMGenericPropertyID_Validate, NULL, 0, 0)) == RM_PENDING);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot validate scaler input window %d\n", err);
+		return MR_ERROR;
+	}
+
+	osd.buf_addr = pic_luma_addr[0];
+
+	return MR_OK;
+}
+
+int GFX_Init (void)
+{
+	RMuint32 chip_num;
+	RMuint32 gfx_count; 
+
+	struct GFXEngine_DRAMSize_in_type  dramSizeIn;
+	struct GFXEngine_DRAMSize_out_type dramSizeOut;
+	RMint32 i;
+	
+	RMstatus err = RM_OK;
+
+	struct GFXEngine_ColorFormat_type format;
+	
+	chip_num = 0;
+		
+	dramSizeIn.CommandFIFOCount = 10;
+	err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(GFXEngine,0), RMGFXEnginePropertyID_DRAMSize, &dramSizeIn, sizeof(dramSizeIn), &dramSizeOut, sizeof(dramSizeOut));
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error getting dram size for gfx engine\n");
+		return MR_ERROR;
+	}
+		
+	gfx_profile.CommandFIFOCount = dramSizeIn.CommandFIFOCount;
+	gfx_profile.Priority = 1;
+	gfx_profile.CachedSize = dramSizeOut.CachedSize;
+	gfx_profile.UncachedSize = dramSizeOut.UncachedSize;
+	
+	if (gfx_profile.CachedSize > 0) {
+		gfx_profile.CachedAddress = RUAMalloc(pRUA, 0, RUA_DRAM_CACHED, gfx_profile.CachedSize);
+	} else {
+		gfx_profile.CachedAddress = 0;
+	}
+		
+	gfx_profile.UncachedSize = dramSizeOut.UncachedSize;
+	if (gfx_profile.UncachedSize > 0) {
+		gfx_profile.UncachedAddress = RUAMalloc(pRUA, 0, RUA_DRAM_UNCACHED, gfx_profile.UncachedSize);
+	} else {
+		gfx_profile.UncachedAddress = 0;
+	}
+
+	gfx = GFXEngine;
+
+	i = 1;
+	{
+		enum RMcategoryID category;
+		while(TRUE){
+			err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(Enumerator,0),  RMEnumeratorPropertyID_IndexToCategoryID, &i, sizeof(i), &category, sizeof(category) );
+			if(err != RM_OK) break;
+			i++;
+					
+			gfx_count = 33;
+			
+			err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(Enumerator,0),  RMEnumeratorPropertyID_CategoryIDToNumberOfInstances, &category, sizeof(category), &gfx_count, sizeof(gfx_count));
+			if (RMFAILED(err)) {
+				fprintf(stderr, "Error getting gfx engine count\n");
+				return MR_ERROR;
+			}
+		}
+	}
+
+	gfx_count = 4;
+			
+	for (i = 0 ; i < (RMint32) gfx_count ; i++) {
+		gfx = EMHWLIB_MODULE(GFXEngine, i);
+		err = RUASetProperty(pRUA, gfx, RMGFXEnginePropertyID_Open, &gfx_profile, sizeof(gfx_profile), 0);
+		if (err == RM_OK) break;
+	}
+	if (i==(RMint32)gfx_count) {
+		fprintf(stderr, "Cannot open a gfx engine [0..%lu[\n", gfx_count);
+		return MR_ERROR;
+	}
+
+
+	/* 
+	 * wait for the picture to be on display. This is the correct way to make the
+	 * next double buffering implementation work 100%
+	 */
+	{
+		struct RUAEvent e;
+		RMuint32 index;
+
+		e.ModuleID = EMHWLIB_MODULE(DisplayBlock, 0);
+		e.Mask = EMHWLIB_DISPLAY_NEW_PICTURE_EVENT_ID(DispOSDScaler);
+		err = RUAWaitForMultipleEvents(pRUA, &e, 1, 1000000, &index);
+		if (err == RM_ERROR) {
+			fprintf(stderr, "cannot wait for the picture to be on display\n");
+		}
+	}
+
+	display_pic.Pts = 0;
+	display_pic.Surface = surface_addr;
+
+	X_surface.SurfaceID = GFX_SURFACE_ID_X;
+	X_surface.Tiled = FALSE;
+
+	GFX.pRUA = pRUA;
+	GFX.gfx = gfx;
+	GFX.pic_addr[0] = (unsigned long int) pic_luma_addr[0];
+	GFX.pic_addr[1] = (unsigned long int) pic_luma_addr[1];
+	GFX.pic_index = (unsigned long int) pic_index;
+
+	YZ_surface.StartAddress = osd.buf_addr;
+	YZ_surface.TotalWidth = osd.bitmap_profile.Width;
+	YZ_surface.Tiled = FALSE;
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	NX_surface.Tiled = FALSE;
+
+	format.MainMode = osd.bitmap_profile.ColorMode; 
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	YZ_surface.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &YZ_surface, sizeof(YZ_surface));
+
+	format.SurfaceID = GFX_SURFACE_ID_Y;
+	YZ_surface.SurfaceID = GFX_SURFACE_ID_Y;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &YZ_surface, sizeof(YZ_surface));
+
+	return MR_OK;
+}
+
+void GFX_Done (void)
+{
+	RMstatus err = RM_OK;
+	RMuint32 close_profile;
+
+	err = RUASetProperty(pRUA, gfx, RMGFXEnginePropertyID_Close, &close_profile, sizeof(close_profile), 0);
+	if (RMFAILED(err)) fprintf(stderr, "Cannot close the gfx accelerator\n");
+	
+	if(gfx_profile.CachedAddress)		
+		RUAFree(pRUA, gfx_profile.CachedAddress);
+	
+	if(gfx_profile.UncachedAddress)		
+		RUAFree(pRUA, gfx_profile.UncachedAddress);
+}
+
+void Sigma86_Done (void)
+{
+	RMstatus err = RM_OK;
+
+	err = DCCCloseVideoSource(pVideoSource);
+	if (RMFAILED(err)) {
+		RMDBGLOG((ENABLE, "Cannot close osd source %s\n", RMstatusToString(err)));
+	}
+	
+	err = DCCClose(pDCC);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot close DCC %d\n", err);
+	}
+
+	err = RUADestroyInstance(pRUA);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot destroy RUA instance %d\n", err);
+	}
+}
+
diff -urN /home/greg/net/microwindows-0.90/src/drivers/scr_fb.c ./drivers/scr_fb.c
--- /home/greg/net/microwindows-0.90/src/drivers/scr_fb.c	2003-02-25 00:59:52.000000000 -0800
+++ ./drivers/scr_fb.c	2008-09-18 01:39:55.000000000 -0700
@@ -46,7 +46,7 @@
 
 
 SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,NULL,
 	fb_open,
 	fb_close,
 	gen_getscreeninfo,
@@ -124,7 +124,11 @@
 
 	/* locate and open framebuffer, get info*/
 	if(!(env = getenv("FRAMEBUFFER")))
+#ifdef REDSONIC_EM8475
 		env = "/dev/fb0";
+#else
+		env = "/dev/fb/0";
+#endif
 	fb = open(env, O_RDWR);
 	if(fb < 0) {
 		EPRINTF("Error opening %s: %m. Check kernel config\n", env);
@@ -169,16 +173,18 @@
 
 	/* set pixel format*/
 #ifndef TPHELIO /* temp kluge: VTech Helio kernel needs changing*/
-	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
+	if(visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR || visual == FB_VISUAL_PSEUDOCOLOR) {
 		switch(psd->bpp) {
 		case 8:
 			psd->pixtype = MWPF_TRUECOLOR332;
 			break;
-		case 16:
+		case 16:		
 			if (fb_var.green.length == 5)
 				psd->pixtype = MWPF_TRUECOLOR555;
-			else
+			else{
 				psd->pixtype = MWPF_TRUECOLOR565;
+				//fprintf(stderr, "FB driver OPEN...pixtype:MWPF_TRUECOLOR565\n");	//William 0822				
+			}
 			break;
 		case 24:
 			psd->pixtype = MWPF_TRUECOLOR888;
@@ -201,10 +207,10 @@
 #endif
 		psd->pixtype = MWPF_PALETTE;
 
-	/*DPRINTF("%dx%dx%d linelen %d type %d visual %d bpp %d\n", psd->xres,
+	/*printf("%dx%dx%d linelen %d type %d visual %d bpp %d\n", psd->xres,
 	 	psd->yres, psd->ncolors, psd->linelen, type, visual,
-		psd->bpp);*/
-
+		psd->bpp);
+	*/
 	/* select a framebuffer subdriver based on planes and bpp*/
 	subdriver = select_fb_subdriver(psd);
 	if (!subdriver) {
@@ -243,6 +249,7 @@
 	/* mmap framebuffer into this address space*/
 	psd->size = (psd->size + getpagesize () - 1)
 			/ getpagesize () * getpagesize ();
+	printf("%s:%d psd->size = %d\n", __FUNCTION__,__LINE__,psd->size);
 #ifdef ARCH_LINUX_SPARC
 #define CG3_MMAP_OFFSET 	0x4000000
 #define CG6_RAM    		0x70016000
@@ -263,13 +270,28 @@
 		goto fail;
         }
 #else
+#ifdef MMAP_SHARED_FLAGS
 	psd->addr = mmap(NULL, psd->size, PROT_READ|PROT_WRITE,MAP_SHARED,fb,0);
+#else
+	psd->addr = mmap(NULL, psd->size, PROT_READ|PROT_WRITE,0,fb,0);
+#endif
 #endif
+
 	if(psd->addr == NULL || psd->addr == (unsigned char *)-1) {
 		EPRINTF("Error mmaping %s: %m\n", env);
 		goto fail;
 	}
 
+#ifdef MMAP_PAGE_ALIGNMENT
+#define PAGE_SIZE (4096)
+/* temporary fix for 5159, mapping is paged aligned , this patch from fb_test of sigma designs SDK*/
+        if (fb_fix.smem_start & (PAGE_SIZE-1)) {
+                psd->addr += (fb_fix.smem_start & (PAGE_SIZE-1));
+                fprintf(stderr, "Fix alignment 0x%08lx -> %p.\n",
+                        fb_fix.smem_start, psd->addr);
+        }
+#endif
+
 	/* save original palette*/
 	ioctl_getpalette(0, 16, saved_red, saved_green, saved_blue);
 
diff -urN /home/greg/net/microwindows-0.90/src/drivers/scr_smp863x.c ./drivers/scr_smp863x.c
--- /home/greg/net/microwindows-0.90/src/drivers/scr_smp863x.c	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/scr_smp863x.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,1496 @@
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Microwindows Screen Driver for Linux kernel framebuffers
+ *
+ * Portions used from Ben Pfaff's BOGL <pfaffben@debian.org>
+ *
+ * Modified for eCos by
+ *   Gary Thomas <gthomas@redhat.com>
+ *   Richard Panton <richard.panton@3glab.org>
+ * 
+ * Note: modify select_fb_driver() to add new framebuffer subdrivers
+ */
+
+#define _GNU_SOURCE 1
+
+#include <assert.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "device.h"
+#include "genfont.h"
+#include "genmem.h"
+#include "fb.h"
+
+#include "mwtypes.h"
+
+//#define DRIVER_DEBUG
+
+/* #define GFX_KEYCOLOR_TEST  */
+
+/* #define NO_SWITCH_BUFFER_TEST */          // Switch buffer only one time
+
+#define SWITCH_BUFFER_TEST           // Test for changing WaitForPicture and Display sequence
+
+/* #define DRAWAREA_TEST */
+
+extern SUBDRIVER fblinear32alpha;
+static PSD  em86xx_open(PSD psd);
+static void em86xx_close(PSD psd);
+static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi);
+static void em86xx_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
+static void em86xx_drawvertline(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
+static void em86xx_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op);
+#ifdef DRAWAREA_TEST
+static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op);
+#endif
+static MWBOOL em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen, int size,void *addr);
+static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op);
+
+#ifdef NO_SWITCH_BUFFER_TEST
+static int switch_first = 0;
+#endif
+
+// This for 8634 with MMU only
+// For MMU system, the mapped address has to mapped to 16bit aligned address, thus, the physical address should be aligned first
+// Without this, GFX reads from true physical address, however, the true data may start from mapped address
+// Thus, due to the aligned offset inconsistency, the picture may flick
+#define RUAMAP_ALIGN(x) (((RMuint32)x + 16)&~0xF)
+
+SCREENDEVICE scrdev = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL,
+	em86xx_open,
+	em86xx_close,
+	em86xx_getscreeninfo,
+	NULL,
+	NULL,						/* DrawPixel subdriver*/
+	NULL,						/* ReadPixel subdriver*/
+	em86xx_drawhorzline,		/* DrawHorzLine subdriver*/
+	em86xx_drawvertline,		/* DrawVertLine subdriver*/
+	em86xx_fillrect, 			/* FillRect subdriver*/
+	gen_fonts,
+	em86xx_blit,				/* Blit subdriver*/
+	NULL,						/* PreSelect*/
+#ifdef DRAWAREA_TEST
+	em86xx_drawarea, 						/* DrawArea subdriver*/
+#else
+	NULL,						/* DrawArea subdriver */
+#endif
+	NULL,						/* SetIOPermissions*/
+	gen_allocatememgc,
+	em86xx_mapmemgc,
+	gen_freememgc,
+	em86xx_stretchblit,			/* StretchBlit subdriver */
+	NULL,						/* SetPortrait */
+	0,							/* screen portrait mode */
+	NULL,						/* orgsubdriver */
+	NULL,						/* StretchBlitEx subdriver */
+};
+
+#define ALLOW_OS_CODE 1
+
+#include "common.h"
+
+#include "rmrtk/include/rmrtk.h"
+
+#define TIMEOUT_US 1000000
+
+enum {
+	MR_ERROR = -1,
+	MR_OK = 0,
+};
+
+/* 
+ *  use the SEND_GFX_COMMAND if you don't want a continuos polling
+ *  otherwise you can just write
+ *  while( RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0) == RM_PENDING);
+ *
+ *  uncomment the following line if you want the application to wait for the completion of commands
+ *  before going on (otherwise the command is queued, and the application only waits if the command
+ *  queue is full)
+ * 
+ */
+
+#ifdef WAIT_FOR_COMMANDS
+#define SEND_GFX_COMMAND(pRUA, moduleID, propertyID, pValue, ValueSize)	\
+{	\
+	RMstatus err;	\
+	RMuint32 n = 5;		\
+	\
+	struct RUAEvent evt;	\
+	evt.ModuleID = moduleID;	\
+	evt.Mask = RUAEVENT_COMMANDCOMPLETION;	\
+	do{		\
+		err = RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0);		\
+		if(err == RM_PENDING){		\
+			while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+				printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+		}	\
+		n--;	\
+	}while((n>0) && (err == RM_PENDING));	\
+	if (err != RM_OK) {		\
+		printf("%s, %d, Can't send command to command fifo\n", __FUNCTION__, __LINE__);	\
+		return err;		\
+	}	\
+	while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+		printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+}
+#else													
+#define SEND_GFX_COMMAND(pRUA, moduleID, propertyID, pValue, ValueSize)		\
+{	\
+	RMstatus err;	\
+	RMuint32 n;		\
+	n = 5;	\
+	do{		\
+		err = RUASetProperty(pRUA, moduleID, propertyID, pValue, ValueSize, 0);		\
+		if ((err == RM_PENDING)) {		\
+ 			struct RUAEvent evt;	\
+			evt.ModuleID = moduleID;	\
+			evt.Mask = RUAEVENT_COMMANDCOMPLETION;	\
+			while (RUAWaitForMultipleEvents(pRUA, &evt, 1, TIMEOUT_US, NULL) != RM_OK)	\
+				printf("%s, %d, Waiting for a command to finish\n", __FUNCTION__, __LINE__);	\
+		}	\
+		n--;	\
+	}while((n>0) && (err == RM_PENDING));	\
+	if (err != RM_OK) {		\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("\033[41m %s, %d, Can't send command to command fifo \033[0m\n", __FUNCTION__, __LINE__ );	\
+		printf("return err;");	\
+	}	\
+}
+#endif /* WAIT_FOR_COMMANDS */
+
+static struct playback_cmdline play_opt;
+static struct video_cmdline video_opt;
+static struct DCC *pDCC = NULL;
+struct RUA *pRUA = NULL;
+static struct DCCVideoSource *pVideoSource;
+static RMuint32 pic_luma_addr[2], pic_index = 0, surface_addr;
+static RMuint32 gfx;
+static struct GFXEngine_Open_type gfx_profile;
+static struct dh_context dh_info = {0,};
+static struct dcc_context dcc_info = {0,};
+static struct GFXEngine_DisplayPicture_type display_pic;
+static struct GFXEngine_Surface_type YZ_surface;
+static struct GFXEngine_Surface_type NX_surface;
+static struct GFXEngine_Surface_type X_surface;
+
+#include <math.h>
+
+#define GFX_SUBOP_SCALE				(0x00000001)  // Scale image to destination size
+
+typedef struct {
+	struct RUA *pRUA;
+	struct DCC *pDCC;
+	unsigned long int gfx;
+	unsigned long int pic_addr[2];
+	unsigned long int pic_index;
+	struct dcc_context *dcc_info;
+#ifdef __EM8622__
+	struct dh_context *dh_info;
+#endif
+} GFXContext;
+
+typedef struct {
+		struct DCCOSDProfile bitmap_profile;
+		RMuint32 buf_addr;
+		RMuint32 buf_size;
+} PICContext ;
+
+static PICContext osd;
+static GFXContext GFX;
+
+void GFX_Fill_Rect(GFXContext *pGFX, PSD psd, MWCOORD x1,MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void GFX_SingleColor_Blend(GFXContext *pGFX, PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
+void GFX_Copy_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+#ifdef GFX_KEYCOLOR_TEST
+void GFX_Copy_IK_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+#endif
+void GFX_Blend_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width);
+void GFX_Blend_BitmapFading(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width, int alpha);
+
+int Sigma86_Init (void);
+int GFX_Init (void);
+void GFX_Done (void);
+void Sigma86_Done (void);
+
+/* init framebuffer*/
+static PSD em86xx_open(PSD psd)
+{
+	PSUBDRIVER subdriver;
+
+	// Initialize EM86xx
+	if (Sigma86_Init() != MR_OK) {
+		Sigma86_Done();
+		return 0;
+	}
+
+	// Initialize GFX Engine
+	if (GFX_Init() != MR_OK) { 
+		Sigma86_Done();
+		return 0;
+	}
+
+	psd->xres = psd->xvirtres = osd.bitmap_profile.Width;
+	psd->yres = psd->yvirtres = osd.bitmap_profile.Height;
+
+	psd->planes = 1;
+	
+	switch (osd.bitmap_profile.ColorMode) {
+		case EMhwlibColorMode_TrueColor:
+		case EMhwlibColorMode_TrueColorWithKey:
+			switch (osd.bitmap_profile.ColorFormat) {
+				case EMhwlibColorFormat_24BPP_565:
+				case EMhwlibColorFormat_24BPP:
+					psd->bpp = 24;
+					break;
+				case EMhwlibColorFormat_32BPP_4444:
+				case EMhwlibColorFormat_32BPP:
+					psd->bpp = 32;
+					break;
+				case EMhwlibColorFormat_16BPP_565:
+				case EMhwlibColorFormat_16BPP_1555:
+				case EMhwlibColorFormat_16BPP_4444:
+					psd->bpp = 16;
+					break;
+			}
+			break;
+		case EMhwlibColorMode_LUT_1BPP:
+			psd->bpp = 1;
+			break;
+		case EMhwlibColorMode_LUT_2BPP:	
+			psd->bpp = 2;
+			break;
+		case EMhwlibColorMode_LUT_4BPP:
+			psd->bpp = 4;
+			break;
+		case EMhwlibColorMode_LUT_8BPP:
+			psd->bpp = 8;
+			break;
+		default:
+			break;
+	}
+
+	psd->ncolors = (psd->bpp >= 24) ? (1 << 24) : (1 << psd->bpp);
+
+	/* set linelen to byte length, possibly converted later*/
+	psd->linelen = osd.bitmap_profile.Width * ((psd->bpp + 7) / 8);
+
+	/* force subdriver init of size */
+	psd->size = 0;
+
+	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
+
+	/* set pixel format*/
+	psd->pixtype = MWPF_TRUECOLOR8888;
+
+	/* select a framebuffer subdriver based on planes and bpp*/
+	subdriver = select_fb_subdriver(psd);
+	if (!subdriver) {
+		fprintf(stderr, "No driver for screen %d\n", psd->bpp);
+		goto fail;
+	}
+
+	/*
+	 * set and initialize subdriver into screen driver
+	 * psd->size is calculated by subdriver init
+	 */
+	if(!set_subdriver(psd, subdriver, TRUE)) {
+		fprintf(stderr, "Driver initialize failed %d\n", psd->bpp);
+		goto fail;
+	}
+	// Replace with functions have been implemented in screen device driver
+	psd->DrawHorzLine = em86xx_drawhorzline;
+	psd->DrawVertLine = em86xx_drawvertline;
+	psd->FillRect = em86xx_fillrect;
+	psd->Blit = em86xx_blit; 
+	psd->StretchBlit = em86xx_stretchblit;
+	psd->StretchBlitEx = NULL;
+
+	/* mmap framebuffer into this address space*/
+	if (osd.buf_addr == 0) {
+		printf("Can't map framebuffer.\n");
+		goto fail;
+	}
+	psd->portrait = MWPORTRAIT_NONE;
+
+	psd->physical = psd->addr = (void *) osd.buf_addr;
+
+#ifdef DRIVER_DEBUG
+	printf("\nInfo about OSD driver.\n");
+	printf("ColorMode = %d\n", osd.bitmap_profile.ColorMode);
+	printf("ColorFormat = %d\n", osd.bitmap_profile.ColorFormat);
+	printf("Bits Per Pixel = %d\n", psd->bpp);
+	printf("The length of each line = %d, X resolution = %d, Y resolution = %d\n", psd->linelen, psd->xres, psd->yres);
+	printf("PSD address = 0x%lx\n", osd.buf_addr);
+#endif
+
+	return psd;	/* success*/
+
+fail:
+	return NULL;
+}
+
+/* close framebuffer*/
+static void em86xx_close(PSD psd)
+{
+	GFX_Done();
+	Sigma86_Done();
+}
+
+static void em86xx_getscreeninfo(PSD psd,PMWSCREENINFO psi)
+{
+	psi->rows = psd->yvirtres;
+	psi->cols = psd->xvirtres;
+	psi->planes = psd->planes;
+	psi->bpp = psd->bpp;
+	psi->ncolors = psd->ncolors;
+	psi->pixtype = psd->pixtype;
+	psi->fonts = NUMBER_FONTS;
+
+	psi->ydpcm = 42; // 320 / (3 * 2.54)
+	psi->xdpcm = 38; //240 / (2.5 * 2.54)
+
+
+	GFX.pRUA = pRUA;
+	GFX.pDCC = pDCC;
+	GFX.gfx = gfx;
+	GFX.pic_addr[0] = pic_luma_addr[0];
+	GFX.pic_addr[1] = pic_luma_addr[1];
+	GFX.pic_index = pic_index;
+	GFX.dcc_info = &dcc_info;
+#ifdef __EM8622__
+	GFX.dh_info = &dh_info;
+#endif
+	
+	psi->gfxcontext = (void *) &GFX;
+}
+
+inline void flush_instr_cache (void) 
+{
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO2) && defined WITH_IRQHANDLER_BOOTLOADER
+	__asm("MCR     p15, 0, r0, c7, c5, 0");
+#endif
+}
+
+inline void clean_data_cache (void)
+{        
+#if (EM86XX_CHIP<EM86XX_CHIPID_TANGO2) && defined WITH_IRQHANDLER_BOOTLOADER
+	__asm("MCR     p15, 0, r0, c7, c10, 0");
+
+	// drains write buffer
+	__asm("LDR     r3, =0");          // reset vector 
+	__asm("SWP     r2, r0, [r3]");    // r2 = [r3], [r3] = r0
+	__asm("SWP     r0, r2, [r3]");    // r0 = [r3], [r3] = r2
+#endif
+}
+
+static void em86xx_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y, x2, y, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y, x2, y, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.DrawHorzLine(psd, x1, x2, y, c);
+			break;
+	}
+}
+
+static void em86xx_drawvertline(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y1, x1, y2, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y1, x1, y2, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.DrawVertLine(psd, x1, y1, y2, c);
+			break;
+	}
+}
+
+static void em86xx_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	switch (gr_mode) {
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Fill_Rect(&GFX, psd, x1, y1, x2, y2, c);
+			break;
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (psd->addr != (void *)GFX.pic_addr[0] && psd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_SingleColor_Blend(&GFX, psd, x1, y1, x2, y2, c);
+			break;
+		default:
+#ifdef DRIVER_DEBUG
+			printf("In %s:%d: grMode = %d\n", __FUNCTION__, __LINE__, gr_mode);
+#endif
+			fblinear32alpha.FillRect(psd, x1, y1, x2, y2, c);
+			break;
+	}
+}
+
+static void em86xx_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op)
+{
+#ifdef SWITCH_BUFFER_TEST
+	int tmp_index = 0;
+#endif
+	int switch_flag = 0;
+
+#ifdef DRIVER_DEBUG
+	printf("\033[44m In %s:%d: Map (%p) [%d, %d] to (%p) [%d, %d, %d, %d]\033[0m\n", __FUNCTION__, __LINE__, srcpsd->addr, srcx, srcy, dstpsd->addr, dstx, dsty, w, h);
+	printf("\033[44m In %s:%d: Info about dstpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+	printf("\033[44m In %s:%d: Info about srcpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+
+	//if (dstpsd->addr == (void *)osd.buf_addr) {
+	if (dstpsd->physical == (void *)osd.buf_addr) {
+		if ((op & MWROP_EXTENSION) == MWROP_SWITCH_BUFFER || op == MWROP_SWITCH_BUFFER) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+#ifdef SWITCH_BUFFER_TEST
+			tmp_index = pic_index;
+#endif
+			pic_index++;
+			pic_index &= 0x1;
+		}
+#ifdef NO_SWITCH_BUFFER_TEST
+		if (switch_first == 0) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+			pic_index++;
+			pic_index &= 0x1;
+			switch_first = 1;
+		}
+#endif
+	}
+
+
+	switch ((op & MWROP_EXTENSION)) {
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_COPY_RK:
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_BLENDCONSTANT:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_BitmapFading(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres, op & 0xff);
+			break;
+#ifdef GFX_KEYCOLOR_TEST
+		case MWROP_COPY_IK:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				flush_instr_cache();
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_IK_Bitmap(&GFX, dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, w, h, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+#endif
+		default:
+#ifdef DRIVER_DEBUG
+			printf("op is %lx.\n", op);
+#endif
+			fblinear32alpha.Blit (dstpsd, dstx, dsty, w, h, srcpsd, srcx, srcy, op);
+			break;
+	}
+
+}
+
+#ifdef DRAWAREA_TEST
+static void em86xx_drawarea(PSD psd, driver_gc_t * gc, int op)
+{
+	clean_data_cache();
+	fblinear32alpha.DrawArea(psd, gc, op);
+	clean_data_cache();
+}
+#endif
+
+/* 
+ * Initialize memory device with passed parms,
+ * select suitable framebuffer subdriver,
+ * and set subdriver in memory device.
+ */
+MWBOOL
+em86xx_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
+	int size,void *addr)
+{
+	if (!fb_mapmemgc(mempsd, w, h, planes, bpp, linelen, size, addr)) {
+		printf("%s, %d, fb_mapmemgc fail\n", __FUNCTION__, __LINE__);
+		return 0;
+	}
+	// Replace with functions have been implemented in screen device driver
+	mempsd->DrawHorzLine = em86xx_drawhorzline;
+	mempsd->DrawVertLine = em86xx_drawvertline;
+	mempsd->FillRect = em86xx_fillrect;
+	mempsd->Blit = em86xx_blit;
+	mempsd->StretchBlit = em86xx_stretchblit;
+	mempsd->StretchBlitEx = NULL;
+	return 1;
+}
+
+static void em86xx_stretchblit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw, MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw, MWCOORD srch, long op)
+{
+#ifdef SWITCH_BUFFER_TEST
+	int tmp_index = 0;
+#endif
+	int switch_flag = 0;
+
+#ifdef DRIVER_DEBUG
+	printf("\033[44m In %s:%d: dstpsd->addr=%p, dstx=%d dsty=%d, dstw=%d, dsth=%d, srcpsd->addr=%p, srcx=%d, srcy=%d, srcw=%d, srch=%d, op=%lx\033[0m\n", __FUNCTION__, __LINE__, dstpsd->addr, dstx, dsty, dstw, dsth, srcpsd->addr, srcx, srcy, srcw, srch, op);
+	printf("\033[44m In %s:%d: Info about dstpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, dstpsd->xres, dstpsd->yres, dstpsd->xvirtres, dstpsd->yvirtres);
+	printf("\033[44m In %s:%d: Info about srcpsd: xres=%d, yres=%d, xvirtres=%d, yvirtres=%d\033[0m\n", __FUNCTION__, __LINE__, srcpsd->xres, srcpsd->yres, srcpsd->xvirtres, srcpsd->yvirtres);
+#endif
+
+	//if (dstpsd->addr == (void *)osd.buf_addr) {
+	if (dstpsd->physical == (void *)osd.buf_addr) {
+		if ((op & MWROP_EXTENSION) == MWROP_SWITCH_BUFFER || op == MWROP_SWITCH_BUFFER) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+#ifdef SWITCH_BUFFER_TEST
+			tmp_index = pic_index;
+#endif
+			pic_index++;
+			pic_index &= 0x1;
+		}
+#ifdef NO_SWITCH_BUFFER_TEST
+		if (switch_first == 0) {
+#ifdef DRIVER_DEBUG
+			printf("\033[44m Start to switch buffer.\033[0m\n");
+#endif
+			switch_flag = 1;
+			pic_index++;
+			pic_index &= 0x1;
+			switch_first = 1;
+		}
+#endif
+	}
+
+
+	switch ((op & MWROP_EXTENSION)) {
+		case MWROP_SRC_OVER:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op | GFX_SUBOP_SCALE, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_COPY_RK:
+		case MWROP_COPY:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op | GFX_SUBOP_SCALE, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+		case MWROP_BLENDCONSTANT:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Blend_BitmapFading(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op, dstpsd->xvirtres, srcpsd->xvirtres, op & 0xff);
+			break;
+#ifdef GFX_KEYCOLOR_TEST
+		case MWROP_COPY_IK:
+			// Please note: We need to clean data cache before call GFX command only when dstpsd->addr != osd.buf_addr.
+			// If we clean data cache at wrong timeing, it may delay the speed.
+			if (srcpsd->addr != (void *)GFX.pic_addr[0] && srcpsd->addr != (void *)GFX.pic_addr[1]) {
+				flush_instr_cache();
+				clean_data_cache();
+			}
+			if (dstpsd->addr != (void *)GFX.pic_addr[0] && dstpsd->addr != (void *)GFX.pic_addr[1]) {
+				clean_data_cache();
+			}
+			GFX_Copy_IK_Bitmap(&GFX, dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, srcw, srch, op, dstpsd->xvirtres, srcpsd->xvirtres);
+			break;
+#endif
+		default:
+#ifdef DRIVER_DEBUG
+			printf("op is 0x%lx.\n", op);
+#endif
+			fblinear32alpha.Blit (dstpsd, dstx, dsty, dstw, dsth, srcpsd, srcx, srcy, op);
+			break;
+	}
+
+}
+
+void GFX_Fill_Rect(GFXContext *pGFX, PSD psd, MWCOORD x1,MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_FillRectangle_type fill;
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.TotalWidth = psd->xvirtres;
+
+	if (psd->flags & PSF_ADDRDEVMALLOC) 
+		NX_surface.StartAddress = (RMuint32)RUAMAP_ALIGN(psd->physical);
+	else
+		NX_surface.StartAddress = (RMuint32)psd->addr;
+
+	NX_surface.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+
+	fill.X = x1;
+	fill.Y = y1;
+	fill.Width = x2 - x1 + 1;
+	fill.Height = y2 - y1 + 1;
+	fill.Color = c;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: X=%d, Y=%d, Width=%d, Height=%d, Color=%x\n", __FUNCTION__, __LINE__, fill.X, fill.Y, fill.Width, fill.Height, fill.Color);
+#endif
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_FillRectangle, &fill, sizeof(fill));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+void GFX_SingleColor_Blend(GFXContext *pGFX, PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_SingleColorBlendRectangles_type sc_blend;
+
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.TotalWidth = psd->xvirtres;
+
+	if (psd->flags & PSF_ADDRDEVMALLOC) 
+		NX_surface.StartAddress = (RMuint32)RUAMAP_ALIGN(psd->physical);
+	else
+		NX_surface.StartAddress = (RMuint32)psd->addr;
+
+	NX_surface.Tiled = FALSE;
+
+	if (psd->flags & PSF_ADDRDEVMALLOC) 
+		X_surface.StartAddress = (RMuint32)RUAMAP_ALIGN(psd->physical);
+	else
+		X_surface.StartAddress = (RMuint32)psd->addr;
+
+	sc_blend.SaturateAlpha = 0;
+	sc_blend.SrcX = x1;
+	sc_blend.SrcY = y1;
+	sc_blend.DstX = x1;
+	sc_blend.DstY = y1;
+	sc_blend.Width = x2 - x1 + 1;
+	sc_blend.Height = y2 -x1 + 1;
+	sc_blend.Color = c;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: psd->addr = %p, srcX=%d, srcY=%d, dstX=%d, dsty=%d, Width=%d, Height=%d, Color=%x\n", __FUNCTION__, __LINE__, psd->addr, sc_blend.SrcX, sc_blend.SrcY, sc_blend.DstX, sc_blend.DstY, sc_blend.Width, sc_blend.Height, sc_blend.Color);
+#endif
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_SingleColorBlendRectangles, &sc_blend, sizeof(sc_blend));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+void GFX_Copy_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_MoveReplaceRectangle_type move;
+	struct GFXEngine_MoveReplaceScaleRectangle_type move_scale;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, srcpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, dw, dh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer.
+	surface_from.SurfaceID = (flag & GFX_SUBOP_SCALE) ? GFX_SURFACE_ID_Z : GFX_SURFACE_ID_Y;
+
+	if (srcpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_from.StartAddress = (RMuint32) RUAMAP_ALIGN(srcpsd->physical);
+	else 
+		surface_from.StartAddress = (RMuint32) srcpsd->addr;
+
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = (flag & GFX_SUBOP_SCALE) ? GFX_SURFACE_ID_Z : GFX_SURFACE_ID_Y;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer.
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_to.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else
+		surface_to.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	if (flag & GFX_SUBOP_SCALE) {
+		move_scale.SrcX = sx;
+		move_scale.SrcY = sy;
+		move_scale.SrcWidth = sw;
+		move_scale.SrcHeight = sh;
+		move_scale.DstX = dx;
+		move_scale.DstY = dy;
+		move_scale.DstWidth = dw;
+		move_scale.DstHeight = dh;
+		move_scale.AlphaX = 0;
+		move_scale.AlphaY = 0;
+		move_scale.Merge = FALSE;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_MoveAndScaleRectangle, &move_scale, sizeof(move_scale));
+	} else {
+		move.Width = dw;
+		move.Height = dh;
+		move.SrcX = sx;
+		move.SrcY = sy;
+		move.DstX = dx;
+		move.DstY = dy;
+		move.AlphaX = 0;
+		move.AlphaY = 0;
+		move.Merge = FALSE;
+		SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_MoveRectangle, &move, sizeof(move));
+	}
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+#ifdef GFX_KEYCOLOR_TEST
+void GFX_Copy_IK_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_to;
+
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_MoveReplaceScaleRectangle_type move;
+	
+	struct GFXEngine_KeyColor_type keycolor;
+
+	struct GFXEngine_AlphaPalette_type alpha_palette;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, srcpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, dw, dh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer.
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+
+	if (srcpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_from.StartAddress = (RMuint32) RUAMAP_ALIGN(srcpsd->physical);
+	else
+		surface_from.StartAddress = (RMuint32) srcpsd->addr;
+
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = EMhwlibColorMode_TrueColor;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to remove keycolor. 
+	keycolor.SurfaceID = GFX_SURFACE_ID_X;
+	keycolor.Color = 0xeae6dd;
+	keycolor.Range = 4;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_KeyColor, &keycolor, sizeof(keycolor));
+	
+	surface_to.SurfaceID = GFX_SURFACE_ID_X;
+
+	if (srcpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_to.StartAddress = (RMuint32) RUAMAP_ALIGN(srcpsd->physical);
+	else
+		surface_to.StartAddress = (RMuint32) srcpsd->addr;
+
+	surface_to.TotalWidth = src_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = EMhwlibColorMode_TrueColorWithKey;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer.
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_to.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else
+		surface_to.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	move.SrcWidth = sw;
+	move.SrcHeight = sh;
+	move.DstWidth = dw;
+	move.DstHeight = dh;
+	move.SrcX = sx;
+	move.SrcY = sy;
+	move.DstX = dx;
+	move.DstY = dy;
+	move.AlphaX = 0;
+	move.AlphaY = 0;
+	move.Merge = TRUE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ReplaceAndScaleRectangle, &move, sizeof(move));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+#endif
+
+void GFX_Blend_Bitmap(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width)
+{
+	// Set Global variable
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_on;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+
+	struct GFXEngine_BlendAndScaleRectangles_type blend_param;
+
+//	struct GFXEngine_KeyColor_type keycolor;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, scrpsd->width = %d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, sw, sh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width);
+#endif
+
+	// Set input buffer to blend
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+
+	if (srcpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_from.StartAddress = (RMuint32) RUAMAP_ALIGN(srcpsd->physical);
+	else
+		surface_from.StartAddress = (RMuint32) srcpsd->addr;
+
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to be blend on
+	surface_on.SurfaceID = GFX_SURFACE_ID_X;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_on.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else 
+		surface_on.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_on.TotalWidth = dst_width;
+	surface_on.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_on, sizeof(surface_on));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_to.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else
+		surface_to.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Do command
+	blend_param.Src1X = sx;
+	blend_param.Src1Y = sy;
+	blend_param.SrcWidth = sw;
+	blend_param.SrcHeight = sh;
+	blend_param.Src2X = dx;  // Second rectangles to blend
+	blend_param.Src2Y = dy;
+	blend_param.DstX = dx;
+	blend_param.DstY = dy;
+	blend_param.DstWidth = dw;
+	blend_param.DstHeight = dh;
+	blend_param.SaturateAlpha = 0;
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_BlendAndScaleRectangles, &blend_param, sizeof(blend_param));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+
+void GFX_Blend_BitmapFading(GFXContext *pGFX, PSD dstpsd, int dx, int dy, int dw, int dh, PSD srcpsd, int sx, int sy, int sw, int sh, int flag, int dst_width, int src_width, int alpha)
+{
+	// Set Global variable
+	struct RUA *pRUA = pGFX->pRUA;
+	RMuint32 gfx = pGFX->gfx;
+
+	struct GFXEngine_Surface_type surface_from;
+	struct GFXEngine_Surface_type surface_on;
+	struct GFXEngine_Surface_type surface_to;
+	struct GFXEngine_ColorFormat_type format;
+	struct GFXEngine_AlphaPalette_type alpha_palette;
+	RMbool bEnableAlphaFading = TRUE;
+
+	struct GFXEngine_BlendAndScaleRectangles_type blend_param;
+
+#ifdef DRIVER_DEBUG
+	printf("In %s:%d: map (src = %p) [%d, %d, %d, %d] to (dst = %p)[%d, %d, %d, %d], dstpsd->width = %d, scrpsd->width = %d, alpha=%d\n", __FUNCTION__, __LINE__, srcpsd->addr, sx, sy, sw, sh, dstpsd->addr, dx, dy, dw, dh, dst_width, src_width, alpha);
+#endif
+
+	alpha_palette.Alpha0 = 0;
+	alpha_palette.Alpha1 = alpha;
+	alpha_palette.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_AlphaPalette, &alpha_palette, sizeof(alpha_palette));
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_EnableAlphaFading, &bEnableAlphaFading, sizeof(bEnableAlphaFading));
+
+	// Set input buffer to blend
+	surface_from.SurfaceID = GFX_SURFACE_ID_Z;
+
+	if (srcpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_from.StartAddress = (RMuint32) RUAMAP_ALIGN(srcpsd->physical);
+	else
+		surface_from.StartAddress = (RMuint32) srcpsd->addr;
+
+	surface_from.TotalWidth = src_width;
+	surface_from.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_from, sizeof(surface_from));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set input buffer to be blend on
+	surface_on.SurfaceID = GFX_SURFACE_ID_X;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_on.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else
+		surface_on.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_on.TotalWidth = dst_width;
+	surface_on.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_on, sizeof(surface_on));
+
+	format.SurfaceID = GFX_SURFACE_ID_X;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Set output buffer
+	surface_to.SurfaceID = GFX_SURFACE_ID_NX;
+
+	if (dstpsd->flags & PSF_ADDRDEVMALLOC) 
+		surface_to.StartAddress = (RMuint32) RUAMAP_ALIGN(dstpsd->physical);
+	else
+		surface_to.StartAddress = (RMuint32) dstpsd->addr;
+
+	surface_to.TotalWidth = dst_width;
+	surface_to.Tiled = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &surface_to, sizeof(surface_to));
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	format.MainMode = osd.bitmap_profile.ColorMode;
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	// Do command
+	blend_param.Src1X = sx;
+	blend_param.Src1Y = sy;
+	blend_param.SrcWidth = sw;
+	blend_param.SrcHeight = sh;
+	blend_param.Src2X = dx;  // Second rectangles to blend
+	blend_param.Src2Y = dy;
+	blend_param.DstX = dx;
+	blend_param.DstY = dy;
+	blend_param.DstWidth = dw;
+	blend_param.DstHeight = dh;
+	blend_param.SaturateAlpha = 0;
+
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_BlendAndScaleRectangles, &blend_param, sizeof(blend_param));
+
+	bEnableAlphaFading = FALSE;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_EnableAlphaFading, &bEnableAlphaFading, sizeof(bEnableAlphaFading));
+
+	alpha_palette.Alpha0 = 0;
+	alpha_palette.Alpha1 = 255;
+	alpha_palette.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_AlphaPalette, &alpha_palette, sizeof(alpha_palette));
+
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &NX_surface, sizeof(NX_surface));
+}
+
+
+int Sigma86_Init (void)
+{
+	RMuint32 local_surfaceID = 0, osd_scaler_id;
+	RMuint32 osd_scaler = EMHWLIB_MODULE(DispOSDScaler,0);
+	RMstatus err = RM_OK;
+
+	init_video_options(&video_opt);
+	init_playback_options(&play_opt);
+
+	err = RUACreateInstance(&pRUA, play_opt.chip_num);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error creating RUA instance! %d\n", err);
+		return MR_ERROR;
+	}
+	
+	err = DCCOpen(pRUA, &pDCC);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error Opening DCC! %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCInitChainEx(pDCC, DCCInitMode_LeaveDisplay);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot initialize microcode %d\n", err);
+		return MR_ERROR;
+	}
+	
+	dcc_info.pRUA = pRUA;
+ 	dcc_info.pDCC = pDCC;
+	dcc_info.route = DCCRoute_Main;
+
+	/* with bootirq sdk, we must reset osd_scaler here, otherwise
+	 * dmaosd can't bootup.
+	 */
+	err = DCCSetSurfaceSource(dcc_info.pDCC, osd_scaler, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot unset osd scaler's surface\n");
+		return MR_ERROR;
+	}
+
+	/* the mixer should not modify the GFX scaler's config */
+	{
+		enum EMhwlibMixerSourceState state;
+		RMuint32 mixer, src_index, mixer_src;
+
+		mixer = EMHWLIB_MODULE(DispMainMixer, 0);
+
+
+		err = DCCGetScalerModuleID(dcc_info.pDCC, dcc_info.route, DCCSurface_OSD, 0, &(osd_scaler_id));
+		if (RMFAILED(err)) {
+			RMDBGLOG((ENABLE, "Cannot get surface to display OSD source %d\n", err));
+			return MR_ERROR;
+		}
+		/* let the mixer know that this scaler will be used */
+
+	fprintf(stderr, "########################%s:%d, osd_scaler_id=0x%08lx##########\n", 
+			__FUNCTION__, __LINE__, osd_scaler_id);
+		err = RUAExchangeProperty(dcc_info.pRUA, mixer, RMGenericPropertyID_MixerSourceIndex, &osd_scaler_id, sizeof(osd_scaler_id), &src_index, sizeof(src_index));
+		if (RMFAILED(err)) {
+			RMDBGLOG((ENABLE, "Cannot get scaler index\n"));
+			return MR_ERROR;
+		}
+		mixer_src = EMHWLIB_TARGET_MODULE(mixer, 0, src_index);
+
+		state = EMhwlibMixerSourceState_Slave;
+
+		while((err =  RUASetProperty(dcc_info.pRUA, mixer_src, RMGenericPropertyID_MixerSourceState, &state, sizeof(state), 0))==RM_PENDING);
+		if (RMFAILED(err)) {
+			RMDBGLOG((ENABLE, "Cannot set scaler's state on mixer\n"));
+			return MR_ERROR;
+		}
+
+		while ((err = RUASetProperty(dcc_info.pRUA, mixer, RMGenericPropertyID_Validate, NULL, 0, 0)) == RM_PENDING);
+		if (RMFAILED(err)) {
+			fprintf(stderr, "Cannot validate mixer\n");
+			return MR_ERROR;
+		}
+	}
+
+	/* open a video source with two pictures */
+	// Set OSD pixmap
+	memset(&osd, 0, sizeof(osd));
+	osd.bitmap_profile.SamplingMode = EMhwlibSamplingMode_444;
+	osd.bitmap_profile.ColorMode = EMhwlibColorMode_TrueColor;
+	osd.bitmap_profile.ColorFormat = EMhwlibColorFormat_32BPP;
+	osd.bitmap_profile.Width = DESKTOP_WIDTH;
+	osd.bitmap_profile.Height = DESKTOP_HEIGHT;
+	osd.bitmap_profile.ColorSpace = EMhwlibColorSpace_RGB_0_255;
+	osd.bitmap_profile.PixelAspectRatio.X = 1;
+	osd.bitmap_profile.PixelAspectRatio.Y = 1;
+
+	err = DCCOpenOSDVideoSource(dcc_info.pDCC, 
+				    &(osd.bitmap_profile), 
+				    &pVideoSource);
+
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot open OSD decoder %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCGetOSDSurfaceInfo(dcc_info.pDCC, pVideoSource, NULL, &surface_addr, NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot get surface address %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCGetOSDVideoSourceInfo(pVideoSource, 
+				       &(pic_luma_addr[0]),
+				       NULL,
+				       NULL,
+				       NULL);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot DCCGetOSDVideoSourceInfo %d\n", err);
+		return MR_ERROR;
+	}
+
+	err = DCCClearOSDVideoSource(pVideoSource);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot DCCClearOSDVideoSource %d\n", err);
+		return MR_ERROR;
+	}
+
+#ifdef DRIVER_DEBUG
+	printf("%s, %d, pic_addr=0x%lx, 0x%lx, pic_luma_addr=0x%lx, 0x%lx\n", __FUNCTION__, __LINE__, pic_addr[0], pic_addr[1], pic_luma_addr[0], pic_luma_addr[1]);
+#endif
+
+	/*possibly clean it before this with a fill */
+
+	err = DCCSetSurfaceSource(dcc_info.pDCC, osd_scaler, pVideoSource);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot set the surface source %d\n", err);
+		return MR_ERROR;
+	}
+
+
+
+
+	err = DCCEnableVideoSource(pVideoSource, TRUE);
+	if (RMFAILED(err)){
+		fprintf(stderr,"Error enabling OSD buffer : %d\n",err);
+		return MR_ERROR;
+	}
+
+
+	while ((err = RUASetProperty(dcc_info.pRUA, osd_scaler, RMGenericPropertyID_Validate, NULL, 0, 0)) == RM_PENDING);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot validate scaler input window %d\n", err);
+		return MR_ERROR;
+	}
+
+	RUAGetProperty(dcc_info.pRUA, osd_scaler, RMGenericPropertyID_Surface, &local_surfaceID, sizeof(local_surfaceID));
+	fprintf(stderr,"%s:%d osd.buf_addr=%p, get osd surface = 0x%08lx, surf addr=%p\n",
+			__FUNCTION__, __LINE__, (void *)(osd.buf_addr),local_surfaceID, &local_surfaceID);
+
+
+	osd.buf_addr = pic_luma_addr[0];
+
+	return MR_OK;
+}
+
+int GFX_Init (void)
+{
+	RMuint32 chip_num;
+	RMuint32 gfx_count; 
+
+	struct GFXEngine_DRAMSize_in_type  dramSizeIn;
+	struct GFXEngine_DRAMSize_out_type dramSizeOut;
+	RMint32 i;
+	
+	RMstatus err = RM_OK;
+
+	struct GFXEngine_ColorFormat_type format;
+	
+	chip_num = 0;
+		
+	dramSizeIn.CommandFIFOCount = 10;
+	err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(GFXEngine,0), RMGFXEnginePropertyID_DRAMSize, &dramSizeIn, sizeof(dramSizeIn), &dramSizeOut, sizeof(dramSizeOut));
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Error getting dram size for gfx engine\n");
+		return MR_ERROR;
+	}
+		
+	gfx_profile.CommandFIFOCount = dramSizeIn.CommandFIFOCount;
+	gfx_profile.Priority = 1;
+	gfx_profile.CachedSize = dramSizeOut.CachedSize;
+	gfx_profile.UncachedSize = dramSizeOut.UncachedSize;
+	
+	if (gfx_profile.CachedSize > 0) {
+		gfx_profile.CachedAddress = RUAMalloc(pRUA, 0, RUA_DRAM_CACHED, gfx_profile.CachedSize);
+	} else {
+		gfx_profile.CachedAddress = 0;
+	}
+		
+	gfx_profile.UncachedSize = dramSizeOut.UncachedSize;
+	if (gfx_profile.UncachedSize > 0) {
+		gfx_profile.UncachedAddress = RUAMalloc(pRUA, 0, RUA_DRAM_UNCACHED, gfx_profile.UncachedSize);
+	} else {
+		gfx_profile.UncachedAddress = 0;
+	}
+
+	gfx = GFXEngine;
+
+	i = 1;
+	{
+		enum RMcategoryID category;
+		while(TRUE){
+			err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(Enumerator,0),  RMEnumeratorPropertyID_IndexToCategoryID, &i, sizeof(i), &category, sizeof(category) );
+			if(err != RM_OK) break;
+			i++;
+					
+			gfx_count = 33;
+			
+			err = RUAExchangeProperty(pRUA, EMHWLIB_MODULE(Enumerator,0),  RMEnumeratorPropertyID_CategoryIDToNumberOfInstances, &category, sizeof(category), &gfx_count, sizeof(gfx_count));
+			if (RMFAILED(err)) {
+				fprintf(stderr, "Error getting gfx engine count\n");
+				return MR_ERROR;
+			}
+		}
+	}
+
+	gfx_count = 4;
+			
+	for (i = 0 ; i < (RMint32) gfx_count ; i++) {
+		gfx = EMHWLIB_MODULE(GFXEngine, i);
+		err = RUASetProperty(pRUA, gfx, RMGFXEnginePropertyID_Open, &gfx_profile, sizeof(gfx_profile), 0);
+		if (err == RM_OK) break;
+	}
+	if (i==(RMint32)gfx_count) {
+		fprintf(stderr, "Cannot open a gfx engine [0..%lu[\n", gfx_count);
+		return MR_ERROR;
+	}
+
+
+	/* 
+	 * wait for the picture to be on display. This is the correct way to make the
+	 * next double buffering implementation work 100%
+	 */
+	{
+		struct RUAEvent e;
+		RMuint32 index;
+
+		e.ModuleID = EMHWLIB_MODULE(DisplayBlock, 0);
+		e.Mask = EMHWLIB_DISPLAY_NEW_PICTURE_EVENT_ID(DispOSDScaler);
+		err = RUAWaitForMultipleEvents(pRUA, &e, 1, 1000000, &index);
+		if (err == RM_ERROR) {
+			fprintf(stderr, "cannot wait for the picture to be on display\n");
+		}
+	}
+
+	display_pic.Pts = 0;
+	display_pic.Surface = surface_addr;
+
+	X_surface.SurfaceID = GFX_SURFACE_ID_X;
+	X_surface.Tiled = FALSE;
+
+	GFX.pRUA = pRUA;
+	GFX.gfx = gfx;
+	GFX.pic_addr[0] = (unsigned long int) pic_luma_addr[0];
+	GFX.pic_addr[1] = (unsigned long int) pic_luma_addr[1];
+	GFX.pic_index = (unsigned long int) pic_index;
+
+	YZ_surface.StartAddress = osd.buf_addr;
+	YZ_surface.TotalWidth = osd.bitmap_profile.Width;
+	YZ_surface.Tiled = FALSE;
+
+	NX_surface.SurfaceID = GFX_SURFACE_ID_NX;
+	NX_surface.StartAddress = osd.buf_addr;
+	NX_surface.TotalWidth = osd.bitmap_profile.Width;
+	NX_surface.Tiled = FALSE;
+
+	format.MainMode = osd.bitmap_profile.ColorMode; 
+	format.SubMode = osd.bitmap_profile.ColorFormat;
+	format.SamplingMode = osd.bitmap_profile.SamplingMode;
+
+	format.SurfaceID = GFX_SURFACE_ID_NX;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+
+	format.SurfaceID = GFX_SURFACE_ID_Z;
+	YZ_surface.SurfaceID = GFX_SURFACE_ID_Z;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &YZ_surface, sizeof(YZ_surface));
+
+	format.SurfaceID = GFX_SURFACE_ID_Y;
+	YZ_surface.SurfaceID = GFX_SURFACE_ID_Y;
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_ColorFormat, &format, sizeof(format));
+	SEND_GFX_COMMAND(pRUA, gfx, RMGFXEnginePropertyID_Surface, &YZ_surface, sizeof(YZ_surface));
+
+	return MR_OK;
+}
+
+void GFX_Done (void)
+{
+	RMstatus err = RM_OK;
+	RMuint32 close_profile;
+
+	err = RUASetProperty(pRUA, gfx, RMGFXEnginePropertyID_Close, &close_profile, sizeof(close_profile), 0);
+	if (RMFAILED(err)) fprintf(stderr, "Cannot close the gfx accelerator\n");
+	
+	if(gfx_profile.CachedAddress)		
+		RUAFree(pRUA, gfx_profile.CachedAddress);
+	
+	if(gfx_profile.UncachedAddress)		
+		RUAFree(pRUA, gfx_profile.UncachedAddress);
+}
+
+void Sigma86_Done (void)
+{
+	RMstatus err = RM_OK;
+
+	err = DCCCloseVideoSource(pVideoSource);
+	if (RMFAILED(err)) {
+		RMDBGLOG((ENABLE, "Cannot close osd source %s\n", RMstatusToString(err)));
+	}
+	
+	err = DCCClose(pDCC);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot close DCC %d\n", err);
+	}
+
+	err = RUADestroyInstance(pRUA);
+	if (RMFAILED(err)) {
+		fprintf(stderr, "Cannot destroy RUA instance %d\n", err);
+	}
+}
+
diff -urN /home/greg/net/microwindows-0.90/src/drivers/sigma86_2d.h ./drivers/sigma86_2d.h
--- /home/greg/net/microwindows-0.90/src/drivers/sigma86_2d.h	1969-12-31 16:00:00.000000000 -0800
+++ ./drivers/sigma86_2d.h	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,46 @@
+#ifndef __SIGMA86_2D_H
+#define __SIGMA86_2D_H
+
+
+/**
+ *   Init Sigma86 GFX engine
+ */
+int Sigma86_Init(void);
+
+/**
+ *  Init Sigma86 GFX engine
+ */
+
+int GFX_Init(void);
+
+/**
+ *   Release Sigma86 GFX engine
+ */
+int Sigma86_Done(void);
+
+
+
+/**
+ *   Fill an rectangle whose region is defined by (x,y,x+w-1,y+h-1) with color color.
+ *   The color is 32bit (ARGB). It will be dithering into the current OSD format.
+ */
+int sigma86_gui2d_fill(int x, int y, int w, int h, int color);
+
+
+/**
+ *   Copy data from (sx,sy) to (dx,dy)   
+ *
+ */
+
+int sigma86_gui2d_copyarea(int sx,int sy, int w, int h, int dx, int dy);
+
+
+
+/**
+ *   Draw an (RGB) 24 bit images into the OSD. It will scale the image is sw != dw or
+ *   sh != dh.
+ */
+int sigma86_gui2d_DrawImage24(int sx,int sy, int sw,int sh,int dx,int dy,int dw,int dh, char *bitmap);
+
+
+#endif
diff -urN /home/greg/net/microwindows-0.90/src/engine/devdraw.c ./engine/devdraw.c
--- /home/greg/net/microwindows-0.90/src/engine/devdraw.c	2003-05-29 18:18:00.000000000 -0700
+++ ./engine/devdraw.c	2008-09-18 01:39:55.000000000 -0700
@@ -492,7 +492,8 @@
 void
 GdFillRect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD width, MWCOORD height)
 {
-	unsigned long dm = 0, dc = 0;
+	unsigned long dm = 0;
+	int dc = 0;
 
 	MWCOORD x2 = x1 + width - 1;
 	MWCOORD y2 = y1 + height - 1;
@@ -524,14 +525,14 @@
 
 
 	/* Quickly save off the dash settings to avoid problems with drawrow */
-	GdSetDash(&dm, (int *) &dc);
+	GdSetDash(&dm, &dc);
 
 	/* The rectangle may be partially obstructed. So do it line by line. */
 	while (y1 <= y2)
 		drawrow(psd, x1, x2, y1++);
 
 	/* Restore the dash settings */
-	GdSetDash(&dm, (int *) &dc);
+	GdSetDash(&dm, &dc);
 
 	GdFixCursor(psd);
 }
@@ -703,38 +704,38 @@
 	if(psd->pixtype == MWPF_PALETTE) {
 	    switch(fLoadType) {
 	    case LOADPALETTE:
-		/* Load palette from beginning with image's palette.
-		 * First palette entries are Microwindows colors
-		 * and not changed.
-		 */
-		GdSetPalette(psd, gr_firstuserpalentry, palsize, palette);
-		break;
+            /* Load palette from beginning with image's palette.
+             * First palette entries are Microwindows colors
+             * and not changed.
+             */
+            GdSetPalette(psd, gr_firstuserpalentry, palsize, palette);
+            break;
 
 	    case MERGEPALETTE:
-		/* get system palette*/
-		for(i=0; i<(int)psd->ncolors; ++i)
-			newpal[i] = gr_palette[i];
-
-		/* merge passed palette into system palette*/
-		newsize = 0;
-		nextentry = gr_nextpalentry;
-
-		/* if color missing and there's room, add it*/
-		for(i=0; i<palsize && nextentry < (int)psd->ncolors; ++i) {
-			cr = GETPALENTRY(palette, i);
-			if(!GdColorInPalette(cr, newpal, nextentry)) {
-				newpal[nextentry++] = palette[i];
-				++newsize;
-			}
-		}
-
-		/* set the new palette if any color was added*/
-		if(newsize) {
-			GdSetPalette(psd, gr_nextpalentry, newsize,
-				&newpal[gr_nextpalentry]);
-			gr_nextpalentry += newsize;
-		}
-		break;
+            /* get system palette*/
+            for(i=0; i<(int)psd->ncolors; ++i)
+                newpal[i] = gr_palette[i];
+
+            /* merge passed palette into system palette*/
+            newsize = 0;
+            nextentry = gr_nextpalentry;
+
+            /* if color missing and there's room, add it*/
+            for(i=0; i<palsize && nextentry < (int)psd->ncolors; ++i) {
+                cr = GETPALENTRY(palette, i);
+                if(!GdColorInPalette(cr, newpal, nextentry)) {
+                    newpal[nextentry++] = palette[i];
+                    ++newsize;
+                }
+            }
+
+            /* set the new palette if any color was added*/
+            if(newsize) {
+                GdSetPalette(psd, gr_nextpalentry, newsize,
+                             &newpal[gr_nextpalentry]);
+                gr_nextpalentry += newsize;
+            }
+            break;
 	    }
 	}
 
@@ -746,6 +747,12 @@
 	 * FIXME: tag the conversion table to the bitmap image
 	 */
 	for(i=0; i<palsize; ++i) {
+#if 1 // Roy 
+		// Not check when pixtype is MWPF_TRUECOLOR0888.
+		if (psd->pixtype == MWPF_TRUECOLOR8888)
+			cr = GETPALENTRY(palette, i) | 0xff000000UL;
+		else
+#endif
 		cr = GETPALENTRY(palette, i);
 		convtable[i] = GdFindColor(psd, cr);
 	}
@@ -806,7 +813,8 @@
 			for(yoff=0; yoff<pimage->palsize; ++yoff)
 				convtable[yoff] = yoff;
 		} else GdMakePaletteConversionTable(psd, pimage->palette,
-			pimage->palsize, convtable, MERGEPALETTE);
+                                            pimage->palsize, convtable, MERGEPALETTE);
+                                            //pimage->palsize,convtable,LOADPALETTE);
 
 		/* The following is no longer used.  One reason is that it required */
 		/* the transparent color to be unique, which was unnessecary        */
@@ -858,7 +866,6 @@
 
 		/* DPRINTF("Nano-X: GdDrawImage (%d,%d) %dx%d x=%d-%d\n  ",
 		   x,y,width,height,minx,maxx); */
-
 		while (height > 0) {
 
 			cr = *data++;
@@ -923,76 +930,67 @@
 		/* printf("End of image\n"); */
 	} else if ((bpp == 24) || (bpp == 32)) {
 		long trans;
+		int inx0, inx1, inx2;
+		register unsigned long *addr = psd->addr;        \
 
-		while (height > 0) {
-			/* RGB rather than BGR byte order? */
-			trans = cr = rgborder
-				? MWRGB(imagebits[0], imagebits[1],
-					imagebits[2])
-				: MWRGB(imagebits[2], imagebits[1],
-					imagebits[0]);
-
-			imagebits += 3;
-
-			if (bpp == 32) {
-				/*
-				 * FIXME Currently, XPM is the only image
-				 * decoder that creates 32bpp images with
-				 * transparency. This is done specifying the
-				 * transparent color 0x01000000, using 0x01
-				 * in the alpha channel as the indicator.
-				 */
-				if (*imagebits++ == 0x01)
-					trans = 0x01000000;
-			}
-
-			/* handle transparent color */
-			if (transcolor != trans) {
+		inx0 = rgborder ? 0 : 2;
+		inx1 = 1;
+		inx2 = rgborder ? 2 : 0;
 
-				switch (psd->pixtype) {
-				case MWPF_PALETTE:
-				default:
-					pixel = GdFindColor(psd, cr);
-					break;
-				case MWPF_TRUECOLOR8888:
-					pixel = COLOR2PIXEL8888(cr);
-					break;
-				case MWPF_TRUECOLOR0888:
-				case MWPF_TRUECOLOR888:
-					pixel = COLOR2PIXEL888(cr);
-					break;
-				case MWPF_TRUECOLOR565:
-					pixel = COLOR2PIXEL565(cr);
-					break;
-				case MWPF_TRUECOLOR555:
-					pixel = COLOR2PIXEL555(cr);
-					break;
-				case MWPF_TRUECOLOR332:
-					pixel = COLOR2PIXEL332(cr);
-					break;
+		switch (psd->pixtype) {
+		default:
+			while (height > 0) {
+				for ( ;x <= maxx; x++ ) {
+					trans = cr = MWRGB(imagebits[inx0], imagebits[inx1],
+									   imagebits[inx2]);
+					imagebits += 3;
+					if ((transcolor==0xffffffff) || (transcolor != trans)) {
+						MACRO_COLOR2PIXEL(psd, cr);
+						MACRO_DRAWPIXEL(psd, x, y, pixel);
+					}
 				}
-
-				if (clip == CLIP_VISIBLE
-				    || GdClipPoint(psd, x, y))
-					psd->DrawPixel(psd, x, y, pixel);
-#if 0
-				/* fix: use clipmaxx to clip quicker */
-				else if (clip != CLIP_VISIBLE && !clipresult
-					 && x > clipmaxx) {
-					x = maxx;
+				x = minx;
+				y += yoff;
+				height--;
+				imagebits += extra;
+			}
+			break;
+		case MWPF_TRUECOLOR8888:
+			while (height > 0) {
+				for ( ;x <= maxx; x++ ) {
+					trans = cr = MWRGB(imagebits[inx0], imagebits[inx1],
+									   imagebits[inx2]);
+					imagebits += 3;
+					if ((transcolor==0xffffffff) || (transcolor != trans)) {
+						BPP32_COLOR2PIXEL(psd, cr);
+						BPP32_DRAWPIXEL(psd, x, y, pixel);
+					}
 				}
-#endif
+				x = minx;
+				y += yoff;
+				height--;
+				imagebits += extra;
 			}
-
-			if (x++ == maxx) {
+			break;
+		case MWPF_TRUECOLOR565:
+			while (height > 0) {
+				for ( ;x <= maxx; x++ ) {
+					trans = cr = MWRGB(imagebits[inx0], imagebits[inx1],
+									   imagebits[inx2]);
+					imagebits += 3;
+					if ((transcolor==0xffffffff) || (transcolor != trans)) {
+						BPP16_COLOR2PIXEL(psd, cr);
+						BPP16_DRAWPIXEL(psd, x, y, pixel);
+					}
+				}
 				x = minx;
 				y += yoff;
 				height--;
 				imagebits += extra;
 			}
+			break;
 		}
 	} else {  /* bpp == 8, 4, or 1, palettized image. */
-
 		bitcount = 0;
 		while (height > 0) {
 			if (bitcount <= 0) {
@@ -1005,7 +1003,6 @@
 				bitcount = 0;
 				if (bitvalue == transcolor)
 					goto next;
-
 				pixel = convtable[bitvalue];
 				break;
 			case 4:
diff -urN /home/greg/net/microwindows-0.90/src/engine/devfont.c ./engine/devfont.c
--- /home/greg/net/microwindows-0.90/src/engine/devfont.c	2003-05-11 11:17:38.000000000 -0700
+++ ./engine/devfont.c	2008-09-18 01:39:55.000000000 -0700
@@ -16,6 +16,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
 #include "device.h"
 #include "devfont.h"
 #include "../drivers/genfont.h"
@@ -366,6 +370,260 @@
 	return pfont->fontprocs->GetFontInfo(pfont, pfontinfo);
 }
 
+int UC16_to_BIG5(const unsigned short *uc16, int cc, unsigned char *ascii)
+{
+    FILE* fp;
+    char buffer[256];
+    int i=0,j=0;
+    unsigned char *filebuffer, ch, cl;
+    unsigned short *uc16pp;
+    int length = 0;
+    struct stat sb;
+
+    uc16pp=(unsigned short *) uc16;
+    sprintf(buffer,"/font/UBG2BG.KU");
+
+    if(stat(buffer, &sb)){
+        printf ("Could not stat file:%s \n", buffer);
+        return -1;
+    }
+    length = sb.st_size;
+
+    if(!(fp = fopen(buffer, "rb"))) {
+        printf ("Error.\nThe %s file can not be found!\n",buffer);
+        return -1;
+    }
+
+    filebuffer= (unsigned char *)malloc ( length);
+    if(fread(filebuffer, sizeof(char),length, fp) < length) {
+        printf ("Error in reading UBG2BG.ku file!\n");
+        fclose(fp);
+        return -1;
+    }
+    fclose(fp);
+
+    while(1){
+        if(j>=cc){
+            ascii[i]=0;
+            break;
+        }
+        ch = (uc16pp[j] >> 8) & 0xFF;
+        cl = uc16pp[j] & 0xFF;
+        if((ch == 0)&&( cl ==0)){
+            ascii[i]=0;
+            break;
+        }
+        else{
+            if(ch == 0){
+                ascii[i]= cl;
+                i++;
+                j++;
+            }
+            else{
+                unsigned int p1=0,p2=length-4,p;
+                unsigned int c1,c2,c,d;
+                c1=((unsigned int)filebuffer[p1])*0x100+(filebuffer[p1+1]);
+                c2=((unsigned int)filebuffer[p2])*0x100+(filebuffer[p2+1]);
+                d=(unsigned int)(ch*0x100+cl);
+                if(c1==d){
+                    ascii[i]=filebuffer[p1+2];
+                    ascii[i+1]=filebuffer[p1+3];
+                    goto findit;
+                }
+                if(c2==d){
+                    ascii[i]=filebuffer[p2+2];
+                    ascii[i+1]=filebuffer[p2+3];
+                    goto findit;
+                }
+                while(1){
+                    p=(((p2-p1)/2+p1)>>2)<<2;
+                    c=((unsigned int )filebuffer[p])*0x100+(filebuffer[p+1]);
+                    if(d==c){   /* find it*/
+                        ascii[i]=filebuffer[p+2];
+                        ascii[i+1]=filebuffer[p+3];
+                        break;
+                    }
+                    else if(p2<=p1+4){  /* can't find.*/
+                        ascii[i]='?';   /* ((uc16p)+j);*/
+                        ascii[i+1]='?'; /* ((uc16p)+j+1);*/
+                        break;
+                    }
+                    else if(d<c){
+                        p2=p;
+                        c2=c;
+                    }
+                    else{
+                        p1=p;
+                        c1=c;
+                    }
+                }
+            findit:
+                i+=2;
+                j+=1;
+            }
+        }
+    }
+    free(filebuffer);
+    return i;
+}
+
+int UC16_to_GB(const unsigned short *uc16, int cc, unsigned char *ascii)
+{
+    FILE* fp;
+    char buffer[256];
+    int i=0,j=0;
+    unsigned char *filebuffer, ch, cl;
+    unsigned short *uc16pp;
+    int length = 0;
+    struct stat sb;
+
+    uc16pp=(unsigned short *) uc16;
+    sprintf(buffer,"/font/UGB2GB.KU");
+
+    if(stat(buffer, &sb)){
+        printf ("Could not stat file:%s\n", buffer);
+        return -1;
+    }
+    length = sb.st_size;
+
+    if(!(fp = fopen(buffer, "rb"))) {
+        printf ("Error.\nThe %s file can not be found!\n",buffer);
+        return -1;
+    }
+
+    filebuffer= (unsigned char *)malloc ( length);
+    if(fread(filebuffer, sizeof(char),length, fp) < length) {
+        printf ("Error in reading UGB2GB.KU file!\n");
+        fclose(fp);
+        return -1;
+    }
+    fclose(fp);
+
+    while(1){
+        if(j>=cc){
+            ascii[i]=0;
+            break;
+        }
+        ch = (uc16pp[j] >> 8) & 0xFF;
+        cl = uc16pp[j] & 0xFF;
+        if((ch == 0)&&( cl ==0)){
+            ascii[i]=0;
+            break;
+        }
+        else{
+            if(ch == 0){
+                ascii[i]= cl;
+                i++;
+                j++;
+            }
+            else{
+                unsigned int p1=0,p2=length-4,p;
+                unsigned int c1,c2,c,d;
+                c1=((unsigned int)filebuffer[p1])*0x100+(filebuffer[p1+1]);
+                c2=((unsigned int)filebuffer[p2])*0x100+(filebuffer[p2+1]);
+                d=(unsigned int)(ch*0x100+cl);
+                if(c1==d){
+                    ascii[i]=filebuffer[p1+2];
+                    ascii[i+1]=filebuffer[p1+3];
+                    goto findit;
+                }
+                if(c2==d){
+                    ascii[i]=filebuffer[p2+2];
+                    ascii[i+1]=filebuffer[p2+3];
+                    goto findit;
+                }
+                while(1){
+                    p=(((p2-p1)/2+p1)>>2)<<2;
+                    c=((unsigned int )filebuffer[p])*0x100+(filebuffer[p+1]);
+                    if(d==c){   /* find it*/
+                        ascii[i]=filebuffer[p+2];
+                        ascii[i+1]=filebuffer[p+3];
+                        break;
+                    }
+                    else if(p2<=p1+4){  /* can't find.*/
+                        ascii[i]='?';   /* ((uc16p)+j);*/
+                        ascii[i+1]='?'; /* ((uc16p)+j+1);*/
+                        break;
+                    }
+                    else if(d<c){
+                        p2=p;
+                        c2=c;
+                    }
+                    else{
+                        p1=p;
+                        c1=c;
+                    }
+                }
+            findit:
+                i+=2;
+                j+=1;
+            }
+        }
+    }
+    free(filebuffer);
+    return i;
+}
+
+int UC16_to_EN(const unsigned short *uc16, int cc, unsigned char *ascii)
+{
+    int i=0,j=0;
+    unsigned char ch, cl;
+    unsigned short *uc16pp;
+
+    uc16pp=(unsigned short *) uc16;
+
+    while(1){
+        if(j>=cc){
+            ascii[i]=0;
+            break;
+        }
+        ch = (uc16pp[j] >> 8) & 0xFF;
+        cl = uc16pp[j] & 0xFF;
+        if((ch == 0)&&( cl ==0)){
+            ascii[i]=0;
+            break;
+        }else if(ch == 0){
+            ascii[i]= cl;
+            i++;
+            j++;
+        }else {
+            ascii[i]='?';
+            ascii[i+1]='?';
+            i+=2;
+            j+=1;
+        }
+    }
+    return i;
+}
+
+int ucs16_to_ascii(char *istr, int cc, char *ostr)
+{
+    char *locale;
+
+    locale = getenv("LOCALE");
+    if(locale == NULL)
+        locale = "en";
+    if(!strcmp(locale, "tc"))
+        return UC16_to_BIG5((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "sc"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "en"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "fr"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "it"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "po"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "ge"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    else if(!strcmp(locale, "sp"))
+        return UC16_to_EN((unsigned short *)istr, cc, ostr);
+    /* default tanslate to en */
+    return UC16_to_EN((unsigned short *)istr, cc, ostr);
+}
+
+
 /**
  * Draws text onto a drawing surface (e.g. the screen or a double-buffer).
  * Uses the current font, current foreground color, and possibly the
@@ -453,9 +711,7 @@
 	MWBOOL		bgstate;
 	int		clip;
 
-	if (flags & MWTF_DBCSMASK)
-		dbcs_gettextsize(pfont, istr, cc, flags, &width, &height, &base);
-	else pfont->fontprocs->GetTextSize(pfont, str, cc, flags, &width, &height, &base);
+    pfont->fontprocs->GetTextSize(pfont, str, cc, flags, &width, &height, &base);
 	
 	if (flags & MWTF_BASELINE)
 		y -= base;
@@ -498,13 +754,26 @@
 	 * we draw them using the normal pfont->fontprocs->GetTextBits.
 	 */
 	while (--cc >= 0 && x < psd->xvirtres) {
-		if (flags & MWTF_DBCSMASK)
-			dbcs_gettextbits(pfont, *istr++, flags, &bitmap, &width,
-				&height, &base);
-		else pfont->fontprocs->GetTextBits(pfont, *str++, &bitmap, &width,
-			&height, &base);
-
-
+        unsigned int ch = *str++;
+#if HAVE_BIG5_SUPPORT
+        /* chinese big5 decoding*/
+        if (ch >= 0xA1 && ch <= 0xF9 && cc >= 1 &&
+            ((*str >= 0x40 && *str <= 0x7E) ||
+             (*str >= 0xA1 && *str <= 0xFE)) ) {
+                ch = (ch << 8) | *str++;
+                --cc;
+        }
+#endif
+#if HAVE_GB2312_SUPPORT
+        /* chinese gb2312 decoding*/
+        if (ch >= 0xA1 && ch < 0xF8 && cc >= 1 &&
+            *str >= 0xA1 && *str < 0xFF) {
+                ch = (ch << 8) | *str++;
+                --cc;
+        }
+#endif
+        pfont->fontprocs->GetTextBits(pfont, ch, &bitmap, &width,
+                                      &height, &base);
 		if (clip == CLIP_VISIBLE)
 			drawbitmap(psd, x, y, width, height, bitmap);
 		else
@@ -620,6 +889,15 @@
 		*out++ = src;
 	    else 
 		switch(psd->pixtype) {
+	        case MWPF_TRUECOLOR8888:
+		    d = BITS(dst, 16, 0xff);
+		    r = (unsigned char)(((BITS(src, 16, 0xff) - d)*a)>>8) + d;
+		    d = BITS(dst, 8, 0xff);
+		    g = (unsigned char)(((BITS(src, 8, 0xff) - d)*a)>>8) + d;
+		    d = BITS(dst, 0, 0xff);
+		    b = (unsigned char)(((BITS(src, 0, 0xff) - d)*a)>>8) + d;
+		    *out++ = (0xff << 24) | (r << 16) | (g << 8) | b;
+		    break;
 	        case MWPF_TRUECOLOR0888:
 	        case MWPF_TRUECOLOR888:
 		    d = BITS(dst, 16, 0xff);
@@ -752,13 +1030,10 @@
 		istr = buf16;
 	}
 
-#if HAVE_HZK_SUPPORT
-	if(iflags == MWTF_UC16 && oflags == MWTF_ASCII) {
-		/* only support uc16 convert to ascii now...*/
-		cc = UC16_to_GB( istr, cc, ostr);
-		return cc;
-	}
-#endif
+    if(iflags == MWTF_UC16 && oflags == MWTF_ASCII) {
+        cc = ucs16_to_ascii((char *)istr, cc, (char *)ostr);
+        return cc;
+    }
 
 	icc = cc;
 	cc = 0;
diff -urN /home/greg/net/microwindows-0.90/src/engine/devimage.c ./engine/devimage.c
--- /home/greg/net/microwindows-0.90/src/engine/devimage.c	2003-05-16 10:49:39.000000000 -0700
+++ ./engine/devimage.c	2008-09-18 01:39:55.000000000 -0700
@@ -25,12 +25,19 @@
 #include <ctype.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#if !defined(HAVE_PNG_SUPPORT)
+#include <setjmp.h>
+#endif
 #include "device.h"
 #include "swap.h"
 #if HAVE_MMAP
 #include <sys/mman.h>
 #endif
 
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+#include "devmalloc.h"
+#endif
+
 #if MW_FEATURE_IMAGES /* whole file */
 
 /* cached image list*/
@@ -60,6 +67,7 @@
 		MWBOOL fast_grayscale);
 #endif
 #if defined(HAVE_PNG_SUPPORT)
+#include <png.h>    // To let it can compile with another setjmp.h
 static int  LoadPNG(buffer_t *src, PMWIMAGEHDR pimage);
 #endif
 #if defined(HAVE_GIF_SUPPORT)
@@ -293,6 +301,7 @@
   }
 #else
   buffer = malloc(s.st_size);
+
   if (!buffer) {
      EPRINTF("GdLoadImageFromFile: Couldn't load image %s\n", path);
      close(fd);
@@ -343,6 +352,7 @@
 	pimage->imagebits = NULL;
 	pimage->palette = NULL;
 	pimage->transcolor = -1L;
+	pimage->palsize = 0;
 
 #if defined(HAVE_TIFF_SUPPORT)
 	/* must be first... no buffer support yet*/
@@ -459,7 +469,11 @@
 		image2.palsize = pimage->palsize;
 		image2.palette = pimage->palette;	/* already allocated*/
 		image2.transcolor = pimage->transcolor;
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+		if( (image2.imagebits = STATIC_malloc(image2.pitch * height)) == NULL) { 
+#else
 		if( (image2.imagebits = malloc(image2.pitch*height)) == NULL) {
+#endif /* defined(STATIC_BUFFER_FOR_IMAGE) */
 			EPRINTF("GdDrawImageToFit: no memory\n");
 			return;
 		}
@@ -472,8 +486,12 @@
 		/* Stretch full source to destination rectangle*/
 		GdStretchImage(pimage, NULL, &image2, &rcDst);
 		GdDrawImage(psd, x, y, &image2);
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+		STATIC_free(image2.imagebits);
+#else
 		free(image2.imagebits);
-	} else
+#endif /* defined(STATIC_BUFFER_FOR_IMAGE) */
+	} else 
 		GdDrawImage(psd, x, y, pimage);
 }
 
@@ -494,8 +512,13 @@
 		pimage = pItem->pimage;
 
 		/* delete image bits*/
-		if(pimage->imagebits)
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+		if (pimage->imagebits) 
+			STATIC_free(pimage->imagebits);
+#else
+		if(pimage->imagebits) 
 			free(pimage->imagebits);
+#endif /* defined(STATIC_BUFFER_FOR_IMAGE) */
 		if(pimage->palette)
 			free(pimage->palette);
 
@@ -815,6 +838,20 @@
 	return;
 }
 
+struct my_error_mgr {
+	struct jpeg_error_mgr pub;	/* "public" fields */
+	jmp_buf setjmp_buffer;		/* for return to caller */
+};
+typedef struct my_error_mgr *my_error_ptr;
+
+
+METHODDEF(void) my_error_exit (j_common_ptr cinfo) {
+	
+	my_error_ptr myerr = (my_error_ptr)cinfo->err;
+	(*cinfo->err->output_message)(cinfo);
+	longjmp(myerr->setjmp_buffer, 1); // Return control to the setjmp point
+}
+
 static int
 LoadJPEG(buffer_t * src, PMWIMAGEHDR pimage, PSD psd, MWBOOL fast_grayscale)
 {
@@ -823,7 +860,11 @@
 	unsigned char magic[8];
 	struct jpeg_source_mgr smgr;
 	struct jpeg_decompress_struct cinfo;
+#if 0
 	struct jpeg_error_mgr jerr;
+#else
+    struct my_error_mgr jerr;
+#endif
 #if FASTJPEG
 	extern MWPALENTRY mwstdpal8[256];
 #else
@@ -836,10 +877,19 @@
 		return 0;
 	if (magic[0] != 0xFF || magic[1] != 0xD8)
 		return 0;	/* not JPEG image */
-
+#if 0
 	bread(src, magic, 8);
-	if (strncmp(magic+4, "JFIF", 4) != 0)
+	if (strncmp(magic+4, "JFIF", 4) != 0 && strncmp(magic+4, "Exif", 4) != 0)
 		return 0;	/* not JPEG image */
+#endif
+	/* check EOI too */
+	bseek(src, 0, SEEK_SET);
+	if ( src && src->start && src->size-2 > 0 && 
+	     !((src->start[src->size-2] == 0xFF && src->start[src->size-1] == 0xD9) ||
+	       (src->start[src->size-2] == 0xD9 && src->start[src->size-1] == 0xFF))){
+		fprintf(stderr, "[%s:%d], JPEG EOI incorrect: 0x%X%X\n", __FUNCTION__, __LINE__, src->start[src->size-2],src->start[src->size-1]);
+		return 0;	/* JPEG image has no end */
+	}
 
 	bread(src, 0, SEEK_SET);
 	pimage->imagebits = NULL;
@@ -847,7 +897,12 @@
 
 	/* Step 1: allocate and initialize JPEG decompression object */
 	/* We set up the normal JPEG error routines. */
-	cinfo.err = jpeg_std_error(&jerr);
+	cinfo.err = jpeg_std_error(&jerr.pub);
+	jerr.pub.error_exit = my_error_exit;
+	if (setjmp(jerr.setjmp_buffer)) {	
+		fprintf(stderr, "jpeg lib error\n");
+		goto ERROR;
+	}
 
 	/* Now we can initialize the JPEG decompression object. */
 	jpeg_create_decompress(&cinfo);
@@ -925,7 +980,11 @@
 		&pimage->bytesperpixel);
 	pimage->compression = MWIMAGE_RGB;	/* RGB not BGR order*/
 	pimage->palsize = (pimage->bpp == 8)? 256: 0;
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+	pimage->imagebits = STATIC_malloc(pimage->pitch * pimage->height);
+#else
 	pimage->imagebits = malloc(pimage->pitch * pimage->height);
+#endif /* defined(STATIC_BUFFER_FOR_IMAGE) */
 	if(!pimage->imagebits)
 		goto err;
 	pimage->palette = NULL;
@@ -965,7 +1024,7 @@
 err:
 	/* Step 7: Finish decompression */
 	jpeg_finish_decompress (&cinfo);
-
+ERROR:
 	/* Step 8: Release JPEG decompression object */
 	jpeg_destroy_decompress (&cinfo);
 
@@ -977,7 +1036,7 @@
 #endif /* defined(HAVE_JPEG_SUPPORT)*/
 
 #if defined(HAVE_PNG_SUPPORT)
-#include <png.h>
+//#include <png.h>  // include png.h in previous section.
 /* png_jmpbuf() macro is not defined prior to libpng-1.0.6*/
 #ifndef png_jmpbuf
 #define png_jmpbuf(png_ptr)	((png_ptr)->jmpbuf)
@@ -1037,12 +1096,38 @@
 
 	pimage->width = width;
 	pimage->height = height;
+#if defined(ALPHA_BLENDING_FOR_PNG)
+	if (colourtype & PNG_COLOR_MASK_ALPHA) {
+		pimage->bpp = 32;
+		pimage->planes = 1;
+	} else if ((colourtype & PNG_COLOR_TYPE_RGB) && (pnginfo->num_trans > 0)) {
+		pimage->bpp = 32;
+		pimage->planes = 1;
+	} else { 
+#endif
 	pimage->bpp = 24;
 	pimage->planes = 1;
+#if defined(ALPHA_BLENDING_FOR_PNG)
+	}
+#endif
+#if defined(ALPHA_BLENDING_FOR_PNG)
+	if (pimage->transcolor == 0xffffffff)
+		pimage->transcolor = 0xffeae6dd;
+#endif
 	ComputePitch(pimage->bpp, pimage->width, &pimage->pitch,
 						&pimage->bytesperpixel);
+#if defined(ALPHA_BLENDING_FOR_PNG)
+	pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
+#else
 	pimage->compression = MWIMAGE_RGB;
-        if(!(pimage->imagebits = malloc(pimage->pitch * pimage->height))) {
+#endif
+	//printf("LoadPNG: bpp=%d,height=%d,width=%d,transcolor=%lx\n", pimage->bpp, pimage->height, pimage->width, pimage->transcolor);
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+	pimage->imagebits = STATIC_malloc(pimage->pitch * pimage->height);
+#else
+	pimage->imagebits = malloc(pimage->pitch * pimage->height);
+#endif
+        if(!pimage->imagebits) {
 		png_destroy_read_struct(&state, &pnginfo, NULL);
 		goto nomem;
         }
@@ -1056,12 +1141,21 @@
 	png_set_expand(state);
 	if(bit_depth == 16)
 		png_set_strip_16(state);
+#if defined(ALPHA_BLENDING_FOR_PNG)
+#else
 	if(colourtype & PNG_COLOR_MASK_ALPHA)
 		png_set_strip_alpha(state);
+#endif
 	if(colourtype == PNG_COLOR_TYPE_GRAY ||
 			colourtype == PNG_COLOR_TYPE_GRAY_ALPHA)
 		png_set_gray_to_rgb(state);
 
+#if defined(ALPHA_BLENDING_FOR_PNG)
+	/* set load image pixel format 'BGRA' */
+	if ((colourtype == PNG_COLOR_TYPE_RGB && pnginfo->num_trans > 0)  ||
+	    colourtype == PNG_COLOR_TYPE_RGB_ALPHA)
+		png_set_bgr(state);
+#endif
 	png_read_image(state, rows);
 
 	png_read_end(state, NULL);
@@ -1071,7 +1165,17 @@
 	return 1;
 
 nomem:
+	printf("LoadPNG: Out of memory.\n");
 	EPRINTF("LoadPNG: Out of memory\n");
+	if (pimage->imagebits){
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+		STATIC_free(pimage->imagebits);
+#else
+		free(pimage->imagebits);
+#endif
+	}
+	if (rows)
+		free(rows);
 	return 2;
 }
 #endif /* defined(HAVE_PNG_SUPPORT)*/
@@ -1601,8 +1705,11 @@
 	    return 1;		/* image load ok*/
 
 done:
-    if (pimage->imagebits)
-	    free(pimage->imagebits);
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+    if (pimage->imagebits) STATIC_free(pimage->imagebits);
+#else
+    if (pimage->imagebits) free(pimage->imagebits);
+#endif
     if (pimage->palette)
 	    free(pimage->palette);
     return 2;			/* image load error*/
@@ -1621,6 +1728,35 @@
     for (i = 0; i < number; ++i) {
 	if (!ReadOK(src, rgb, sizeof(rgb)))
 	    return 1;
+
+#if 0
+//Aaron add
+     if ((rgb[1]>=200)&& (rgb[2]>=200))
+       {
+#if 1
+         if (
+             ( rgb[1]>=228 && rgb[1]<=228+8)&&
+             ( rgb[2]>=216 && rgb[2]<=216+8))
+#endif
+	if((rgb[0]==234) && (rgb[1]==230) && (rgb[2]==221))
+           {
+                 } else
+                 {
+      //           rgb[0] = 220;
+                   rgb[1] = 220;
+                   rgb[2] = 220;
+                 }
+           } 
+//Aaron end 
+
+	//if(rgb[0]>=228 && rgb[0] <=236 && rgb[1] >= 228 && rgb[1] <= 236 && rgb[2] >= 216 & rgb[2] <= 224) 
+/*	{
+	   rgb[0]==234;
+	   rgb[1]==230;
+	   rgb[2]==221;
+	}
+*/
+#endif
 	buffer[CM_RED][i] = rgb[0];
 	buffer[CM_GREEN][i] = rgb[1];
 	buffer[CM_BLUE][i] = rgb[2];
@@ -1870,8 +2006,12 @@
     ComputePitch(8, len, &pimage->pitch, &pimage->bytesperpixel);
     pimage->compression = 0;
     pimage->palsize = cmapSize;
-    pimage->palette = malloc(256*sizeof(MWPALENTRY));
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+    pimage->imagebits = STATIC_malloc(height*pimage->pitch);
+#else
     pimage->imagebits = malloc(height*pimage->pitch);
+#endif
+    pimage->palette = malloc(256*sizeof(MWPALENTRY));
     if(!pimage->imagebits || !pimage->palette)
 	    return 0;
 
@@ -1975,8 +2115,7 @@
 					&pimage->height) == 2) {
 				pimage->bpp = 1;
 				gothdrs = 1;
-				if(!(pimage->palette = malloc(
-						sizeof(MWPALENTRY) * 2))) {
+				if(!(pimage->palette = malloc(sizeof(MWPALENTRY) * 2))) { 
 					EPRINTF("Out of memory\n");
 					return 2;
 				}
@@ -2279,7 +2418,6 @@
 	  pimage->palsize = colors;
 
 	  ComputePitch(pimage->bpp, col, &pimage->pitch, &pimage->bytesperpixel);
-
 	  pimage->imagebits = malloc(pimage->pitch * pimage->height); 
 	  imageptr = (unsigned char *) pimage->imagebits;
 
@@ -2546,9 +2684,7 @@
 	continue;
       }
     }
-
   free(colorheap);
-
   if (status != LOAD_DONE)
     return(-1);
   return(1);
@@ -2582,7 +2718,8 @@
 	pimage->palette = NULL;
 
 	/* upside down, RGB order (with alpha)*/
-	pimage->compression = MWIMAGE_RGB | MWIMAGE_UPSIDEDOWN;
+	pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL |
+		MWIMAGE_UPSIDEDOWN;
 
 	/* Allocate image */
 	if ((pimage->imagebits = malloc(size * sizeof(uint32))) == NULL)
diff -urN /home/greg/net/microwindows-0.90/src/engine/devmalloc.c ./engine/devmalloc.c
--- /home/greg/net/microwindows-0.90/src/engine/devmalloc.c	1969-12-31 16:00:00.000000000 -0800
+++ ./engine/devmalloc.c	2008-09-18 01:39:55.000000000 -0700
@@ -0,0 +1,102 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "devmalloc.h"
+
+#define IMAGE_BUF_SIZE 			(JPG_DECODE_BUF_WIDTH*JPG_DECODE_BUF_HEIGHT*4)
+#define IMAGE_MAX_NUM 			1
+
+struct static_buf_t {
+	char      *buf;
+	char      *physical;
+	char      *virt;
+	int        size;
+	int        used;
+};
+
+static int    sbuf_init_flag = 1;
+static struct static_buf_t sbuf[IMAGE_MAX_NUM];
+
+int STATIC_malloc_init()
+{
+	int i;
+
+	if (sbuf_init_flag)  {
+		memset(&sbuf, 0, sizeof(sbuf));
+		for (i = 0; i < IMAGE_MAX_NUM; i++) {
+			sbuf[i].size = IMAGE_BUF_SIZE;
+#if HAVE_DEVICE_MEM_SUPPORT
+			sbuf[i].physical = engine_hal_malloc_rua_buf(sbuf[i].size);
+			sbuf[i].virt = 	engine_hal_rua_map(sbuf[i].physical, sbuf[i].size);
+			sbuf[i].buf = sbuf[i].virt;
+#else
+			sbuf[i].buf  = malloc(sbuf[i].size);
+#endif
+			if (sbuf[i].buf == NULL ) {
+				fprintf(stderr, "%s:%d, malloc %d failed!\n",
+					__FUNCTION__, __LINE__, sbuf[i].size);
+			}
+			sbuf[i].used= 0;
+		}
+		sbuf_init_flag = 0;
+	}
+
+	return 0;
+}
+
+void *STATIC_malloc(int size)
+{
+	void *addr = NULL;
+	int i, found = 0;
+
+	for (i = 0; i < IMAGE_MAX_NUM; i++) {
+		if (sbuf[i].used == 0) {
+			found = 1;
+			break;
+		}
+	}
+	
+	if (found && size <= sbuf[i].size) {
+		sbuf[i].used = 1;
+		addr = sbuf[i].buf;
+	} else {
+		addr = malloc(size);
+	}
+
+	return addr;
+}
+
+void STATIC_free(void *p)
+{
+	int i;
+
+	for (i = 0; i < IMAGE_MAX_NUM; i++) {
+		if (sbuf[i].buf == p) {
+			sbuf[i].used = 0;
+			return;	
+		}
+	}
+	free(p);
+}
+
+int STATIC_malloc_destroy(void)
+{
+	int i;
+
+	for (i = 0; i < IMAGE_MAX_NUM; i++) {
+		if (sbuf[i].buf) {
+#if HAVE_DEVICE_MEM_SUPPORT			
+			engine_hal_rua_unmap(sbuf[i].physical, sbuf[i].virt, sbuf[i].size);
+			engine_hal_free_rua_buf(sbuf[i].physical);
+#else
+			free(sbuf[i].buf);
+#endif
+			sbuf[i].buf  = NULL;
+			sbuf[i].size = 0;
+			sbuf[i].used = 0;
+			return;	
+		}
+	}
+	sbuf_init_flag = 0;
+
+	return 0;
+}
diff -urN /home/greg/net/microwindows-0.90/src/engine/devopen.c ./engine/devopen.c
--- /home/greg/net/microwindows-0.90/src/engine/devopen.c	2003-05-10 21:26:27.000000000 -0700
+++ ./engine/devopen.c	2008-09-18 01:39:55.000000000 -0700
@@ -30,7 +30,10 @@
  * Color entries below this value won't be overwritten by user
  * programs or bitmap display conversion tables.
  */
-#define FIRSTUSERPALENTRY	24  /* first writable pal entry over 16 color*/
+
+//Fixed by Walker 2005/4/1. We must load all color from the palette when fb is 8bpp
+#define FIRSTUSERPALENTRY	255
+//#define FIRSTUSERPALENTRY	24  /* first writable pal entry over 16 color*/
 
        MWPIXELVAL gr_foreground;      /* current foreground color */
        MWPIXELVAL gr_background;      /* current background color */
@@ -286,38 +289,86 @@
 MWPIXELVAL
 GdFindColor(PSD psd, MWCOLORVAL c)
 {
+	unsigned int r,g,b;
+	//float mean = 0.0f;
+	//float brightness = 0.0f;
+
 	/*
 	 * Handle truecolor displays.
 	 */
 	switch(psd->pixtype) {
 	case MWPF_TRUECOLOR8888:
+		//printf("COLOR2PIXEL8888\n");
 		return COLOR2PIXEL8888(c);
 
 	case MWPF_TRUECOLOR0888:
 	case MWPF_TRUECOLOR888:
 		/* create 24 bit 8/8/8 pixel (0x00RRGGBB) from RGB colorval*/
 		/*RGB2PIXEL888(REDVALUE(c), GREENVALUE(c), BLUEVALUE(c))*/
+		//printf("COLOR2PIXEL888\n");
 		return COLOR2PIXEL888(c);
 
 	case MWPF_TRUECOLOR565:
 		/* create 16 bit 5/6/5 format pixel from RGB colorval*/
-		/*RGB2PIXEL565(REDVALUE(c), GREENVALUE(c), BLUEVALUE(c))*/
+		
+		/*
+		Kenn Slagter
+			modified so that the brightness in our dma device
+			is reduced to appear the same as that on my monitor.
+		*/
+		
+		//GOOD COLOR BUT NO BACKDROP BECAUSE OF KEYCOLOR
+		//LEAVE ALL KEY COLOR ALONE OK!!! 
+		
+		//printf("COLOR R=%x G=%x B=%x \n",REDVALUE(c),GREENVALUE(c),BLUEVALUE(c));
+		
+		return COLOR2PIXEL565(c);
+		r = REDVALUE(c);
+		g = GREENVALUE(c);
+		b = BLUEVALUE(c);
+				
+		if  (r==0xff && b==0xff && g==0xff ) return COLOR2PIXEL565(c); //RGB2PIXEL565(REDVALUE(c),GREENVALUE(c),BLUEVALUE(c));
+		else if ( r >= 228 &&  r <= 236 &&
+			  g >= 228 &&  g <= 236 &&
+			  b >= 216 &&  b <= 224) return COLOR2PIXEL565(c);
+		else return RGB2PIXEL565((REDVALUE(c) * 7 / 10),(GREENVALUE(c) * 7 / 10),(BLUEVALUE(c) * 7 / 10));
+		//return RGB2PIXEL565((REDVALUE(c)>>1),(GREENVALUE(c)>>1),(BLUEVALUE(c)>>1));
+		
+		
+		/*
+		r = REDVALUE(c);
+		g = GREENVALUE(c);
+		b = BLUEVALUE(c);
+		mean = ((r*5)+(g*6)+(b*5))/16;
+		brightness = mean/0xff;
+		//lower clamp
+		if(brightness < 0.5) brightness = 0.5;
+		r *= brightness;
+		g *= brightness;
+		b *= brightness;
+		return RGB2PIXEL565(r,g,b);
+		*/		
+		
+		//printf("COLOR2PIXEL565\n");
 		return COLOR2PIXEL565(c);
 
 	case MWPF_TRUECOLOR555:
 		/* create 16 bit 5/5/5 format pixel from RGB colorval*/
 		/*RGB2PIXEL555(REDVALUE(c), GREENVALUE(c), BLUEVALUE(c))*/
+		//printf("COLOR2PIXEL555\n");
 		return COLOR2PIXEL555(c);
 
 	case MWPF_TRUECOLOR332:
 		/* create 8 bit 3/3/2 format pixel from RGB colorval*/
 		/*RGB2PIXEL332(REDVALUE(c), GREENVALUE(c), BLUEVALUE(c))*/
+		//printf("COLOR2PIXEL332\n");
 		return COLOR2PIXEL332(c);
 	}
 
 	/* case MWPF_PALETTE: must be running 1, 2, 4 or 8 bit palette*/
 
 	/* search palette for closest match*/
+	//printf("return findNearestColor\n");
 	return GdFindNearestColor(gr_palette, (int)gr_ncolors, c);
 }
 
@@ -385,7 +436,7 @@
 	case MWPF_TRUECOLOR888:
 		return PIXEL888TOCOLORVAL(pixel);
 
-	case MWPF_TRUECOLOR565:
+	case MWPF_TRUECOLOR565:	
 		return PIXEL565TOCOLORVAL(pixel);
 
 	case MWPF_TRUECOLOR555:
diff -urN /home/greg/net/microwindows-0.90/src/engine/font_dbcs.c ./engine/font_dbcs.c
--- /home/greg/net/microwindows-0.90/src/engine/font_dbcs.c	2003-05-04 10:25:40.000000000 -0700
+++ ./engine/font_dbcs.c	2008-09-18 01:39:55.000000000 -0700
@@ -19,6 +19,7 @@
 big5_gettextbits(PMWFONT pfont, unsigned int ch, const MWIMAGEBITS **retmap,
 	MWCOORD *pwidth, MWCOORD *pheight, MWCOORD *pbase)
 {
+#if 0
 	unsigned int	CH = ch >> 8;
 	unsigned int	CL = ch & 0xFF;
 	int		pos;	/* ((CH - 0xA1) * 94 + (CL - 0xA1)) * 18; */
@@ -55,6 +56,7 @@
 	*pheight = 12;
 	*pbase = 0;
 	*retmap = map;
+#endif
 }
 #endif /* HAVE_BIG5_SUPPORT*/
 
diff -urN /home/greg/net/microwindows-0.90/src/engine/font_freetype2.c ./engine/font_freetype2.c
--- /home/greg/net/microwindows-0.90/src/engine/font_freetype2.c	2003-05-14 06:55:56.000000000 -0700
+++ ./engine/font_freetype2.c	2008-09-18 01:39:55.000000000 -0700
@@ -237,6 +237,16 @@
  * The freetype library instance - a singleton.
  */
 static FT_Library freetype2_library = NULL;
+/* odie added for chinese font support.
+    set g_iFontFaceIndex to 1, if use Arphic chinese fonts.
+*/
+int g_iFontFaceIndex = 0;
+#if 1
+#define FNT_DEBUG printf
+#else
+#define FNT_DEBUG(...)
+#endif
+
 
 #if HAVE_FREETYPE_2_CACHE
 /**
@@ -330,18 +340,20 @@
 	if (fontdata->isBuffer) {
 		unsigned char * buffer = fontdata->data.buffer.data;
 		unsigned length = fontdata->data.buffer.length;
+		FNT_DEBUG("freetype2_face_requester: buffer\n");
 		/* DPRINTF("Font magic = '%c%c%c%c', len = %u @ freetype2_face_requester\n", 
 		   (char)buffer[0], (char)buffer[1],
 		   (char)buffer[2], (char)buffer[3],
 		   length); */
 		assert(buffer);
-		return FT_New_Memory_Face(library, buffer, length, 0, aface);
+		return FT_New_Memory_Face(library, buffer, length, g_iFontFaceIndex, aface);
 	} else {
 		char * filename = fontdata->data.filename;
+		FNT_DEBUG("freetype2_face_requester: file\n");
 		/* DPRINTF("Loading font from file '%s' @ freetype2_face_requester\n", 
 		   filename); */
 		assert(filename);
-		return FT_New_Face(library, filename, 0, aface);
+		return FT_New_Face(library, filename, g_iFontFaceIndex, aface);
 	}
 }
 #endif
@@ -445,7 +457,7 @@
 #if HAVE_FREETYPE_2_CACHE
 	int first_time = 0;
 #endif
-
+	FNT_DEBUG("freetype2_createfont...\n");
 	/* Initialization */
 	if (freetype2_library == NULL) {
 		/* Init freetype library */
@@ -454,7 +466,7 @@
 		}
 	}
 
-	fontname = malloc(6 + strlen(name) + strlen(freetype2_font_dir));
+	fontname = calloc(1, 6 + strlen(name) + strlen(freetype2_font_dir));
 	if (fontname == NULL)
 		return NULL;
 
@@ -467,11 +479,14 @@
 		strcat(fontname, name);
 	}
 
+	//printf("In %s:%d: fontname = %s\n", __FUNCTION__, __LINE__, fontname);
+#if 0
 	/* check for extension */
 	if ((p = strrchr(fontname, '.')) == NULL ||
 	    ((strcmpi(p, ".ttf") != 0) && (strcmpi(p, ".pfr") != 0))) {
 		strcat(fontname, ".ttf");
 	}
+#endif
 #if HAVE_FREETYPE_2_CACHE
 	faceid = freetype2_fonts;
 	while ( (faceid != NULL) && (0 != strcmpi(faceid->data.filename, fontname)) )
@@ -542,7 +557,7 @@
 	unsigned char *buffercopy;
 
 	assert(buffer);
-
+	FNT_DEBUG("freetype2_createfontfrombuffer...\n");
 	/* Initialization */
 	if (freetype2_library == NULL) {
 		/* Init freetype library */
@@ -554,13 +569,17 @@
 	faceid = (freetype2_fontdata *) calloc(sizeof(freetype2_fontdata), 1);
 	if (!faceid)
 		return NULL;
-
+/* odie modified for share one font buffer to multi-font */
+#if 0 /* original */
 	buffercopy = (unsigned char *) malloc(length);
 	if (!buffercopy) {
 		free(faceid);
 		return NULL;
 	}
 	memcpy(buffercopy, buffer, length);
+#else
+	buffercopy = (unsigned char*)buffer;
+#endif
 
 	faceid->isBuffer = TRUE;
 	faceid->data.buffer.length = length;
@@ -615,9 +634,15 @@
 	pf->faceid = faceid;
 	pf->filename = filename;
 #if HAVE_FREETYPE_2_CACHE
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+	pf->imagedesc.face_id = (FTC_FaceID)faceid;
+	pf->imagedesc.width = 0;	/* Will be set by GdSetFontSize */
+	pf->imagedesc.height = 0;	/* Will be set by GdSetFontSize */
+#else
 	pf->imagedesc.font.face_id = faceid;
 	pf->imagedesc.font.pix_width = 0;	/* Will be set by GdSetFontSize */
 	pf->imagedesc.font.pix_height = 0;	/* Will be set by GdSetFontSize */
+#endif
 #if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,3)
 	pf->imagedesc.flags = 0;	/* Will be set by GdSetFontAttr */
 #else
@@ -664,8 +689,26 @@
 #if HAVE_FREETYPE_2_CACHE
 	/* Check that the font file exists and is valid */
 	/*DPRINTF("freetype2_createfont_internal(): testing\n");*/
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+    {
+        FTC_ScalerRec  scaler;
+
+        scaler.face_id = pf->imagedesc.face_id;
+        scaler.width   = pf->imagedesc.width;
+        scaler.height  = pf->imagedesc.height;
+        scaler.pixel   = 1;
+
+        error = FTC_Manager_LookupFace( freetype2_cache_manager
+            , pf->imagedesc.face_id, &face );
+        if ( !error ){
+        	error = FTC_Manager_LookupSize(freetype2_cache_manager,
+    	        &scaler, &size);
+        }
+    }
+#else
 	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
 	    &(pf->imagedesc.font), &face, &size);
+#endif
 	if (error != FT_Err_Ok) {
 		EPRINTF("Nano-X-Freetype2: Freetype 2 error %lx trying to load font.\n",
 		    (unsigned long)error);
@@ -710,7 +753,11 @@
 #if HAVE_FREETYPE_2_CACHE
 			FTC_Manager_Reset(freetype2_cache_manager);
 #endif
+/* odie modified for share one font buffer to multi-font */
+#if 0 /* original */
 			free(pf->faceid->data.buffer.data);
+#else
+#endif
 			free(pf->faceid);
 		}
 	}
@@ -812,8 +859,14 @@
 	pixel_width = fontsize;
 
 #if HAVE_FREETYPE_2_CACHE
+
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+	pf->imagedesc.width  = pixel_width;
+	pf->imagedesc.height = pixel_height;
+#else
 	pf->imagedesc.font.pix_width  = pixel_width;
 	pf->imagedesc.font.pix_height = pixel_height;
+#endif
 #else
 	/* We want real pixel sizes ... not points ... */
 	FT_Set_Pixel_Sizes(pf->face, pixel_width, pixel_height);
@@ -1006,11 +1059,20 @@
                         int *pascent,
                         int *pdescent)
 {
+#ifdef NO_CHARMAP_WORKAROUND
+	int glyph = 0;
+	
+	if (face->charmap == NULL) {
+		glyph = (ch < 0x80) ? ch : 0;
+	} else {
+		glyph = LOOKUP_CHAR(pf, face, ch);
+	}
+#else
 	int glyph = LOOKUP_CHAR(pf, face, ch);
+#endif
 	return freetype2_get_glyph_size(pf, face, glyph, padvance, pascent, pdescent);
 }
 
-
 /**
  * Return information about a specified font.
  *
@@ -1040,8 +1102,26 @@
 	assert(pfontinfo);
 
 #if HAVE_FREETYPE_2_CACHE
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+    {
+        FTC_ScalerRec  scaler;
+
+        scaler.face_id = pf->imagedesc.face_id;
+        scaler.width   = pf->imagedesc.width;
+        scaler.height  = pf->imagedesc.height;
+        scaler.pixel   = 1;
+
+        error = FTC_Manager_LookupFace( freetype2_cache_manager
+            , pf->imagedesc.face_id, &face );
+        if ( !error ){
+        	error = FTC_Manager_LookupSize(freetype2_cache_manager,
+    	        &scaler, &size);
+        }
+    }
+#else
 	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
 					&(pf->imagedesc.font), &face, &size);
+#endif
 	if (error) {
 		EPRINTF("Freetype 2 error 0x%x getting font info.\n", error);
 		return FALSE;
@@ -1075,6 +1155,7 @@
 	pfontinfo->height = pfontinfo->baseline + pfontinfo->descent;
 	leading = ROUND_26_6_TO_INT(metrics->height - (metrics->ascender + abs(metrics->descender)));
 	pfontinfo->linespacing = pfontinfo->height + leading;
+	//printf("In %s:%d: maxwidth = %d, maxascent = %d, maxdescent = %d, fixed = %d, baseline = %d, descent = %d, height = %d, linespacing = %d\n", __FUNCTION__, __LINE__, pfontinfo->maxwidth, pfontinfo->maxascent, pfontinfo->maxdescent, pfontinfo->fixed, pfontinfo->baseline, pfontinfo->descent, pfontinfo->height, pfontinfo->linespacing);
 
 	//DPRINTF("Nano-X-Freetype2: Font metrics:"
 	//    "\n    maxwidth = %3d"
@@ -1092,8 +1173,8 @@
 	pfontinfo->firstchar = 0;
 	pfontinfo->lastchar = 0xFFFFU;
 
-	for (ch = 0; ch < 256; ch++) {
-		int advance;
+	for (ch = pfontinfo->firstchar; ch < pfontinfo->lastchar; ch++) {
+		int advance = 0;
 		if (freetype2_get_char_size(pf, face, ch, &advance, NULL, NULL))
 		{
 			/* Error - assume default */
@@ -1110,7 +1191,6 @@
 	return TRUE;
 }
 
-
 /**
  * Draws text onto a screen or pixmap.
  *
@@ -1138,8 +1218,12 @@
 	int curchar;
 	int use_kerning;
 	int last_glyph_code = 0;	/* Used for kerning */
+	int last_height = 0;
 	driver_gc_t blit_instructions;
 	int blit_op;
+#if 1 // Roy
+	MWFONTINFO fontinfo;
+#endif
 
 	assert(pf);
 	assert(psd);
@@ -1148,8 +1232,26 @@
 	//DPRINTF("Nano-X-Freetype2: freetype2_drawtext(x=%d, y=%d) called\n", ax, ay);
 
 #if HAVE_FREETYPE_2_CACHE
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+    {
+        FTC_ScalerRec  scaler;
+
+        scaler.face_id = pf->imagedesc.face_id;
+        scaler.width   = pf->imagedesc.width;
+        scaler.height  = pf->imagedesc.height;
+        scaler.pixel   = 1;
+
+        error = FTC_Manager_LookupFace( freetype2_cache_manager
+            , pf->imagedesc.face_id, &face );
+        if ( !error ){
+        	error = FTC_Manager_LookupSize(freetype2_cache_manager,
+    	        &scaler, &size);
+        }
+    }
+#else
 	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
 					&(pf->imagedesc.font), &face, &size);
+#endif
 	if (error) {
 		EPRINTF("Freetype 2 error 0x%x getting font for drawtext.\n",
 			error);
@@ -1206,6 +1308,10 @@
 		/*DPRINTF("Nano-X-Freetype2: freetype2_drawtext() using SLOW routine\n"); */
 		pos.x = 0;
 		for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+			if (face->charmap == NULL) curchar = (str[i] < 0x80) ? str[i] : 0;
+			else {
+#endif
 			curchar = LOOKUP_CHAR(pf, face, str[i]);
 
 			if (use_kerning && last_glyph_code && curchar) {
@@ -1217,6 +1323,9 @@
 				//        (int)kerning_delta.x, (int)kerning_delta.x/64);
 				pos.x += kerning_delta.x & (~63);
 			}
+#ifdef NO_CHARMAP_WORKAROUND
+			}
+#endif
 			last_glyph_code = curchar;
 
 			/* FIXME: Should use an image cache to optimize
@@ -1283,6 +1392,10 @@
 		ay += (pos.y >> 6);
 
 		for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+			if (face->charmap == NULL) curchar = (str[i] < 0x80) ? str[i] : 0;
+			else {
+#endif
 			curchar = LOOKUP_CHAR(pf, face, str[i]);
 
 			if (use_kerning && last_glyph_code && curchar) {
@@ -1292,6 +1405,9 @@
 
 				ax += (kerning_delta.x >> 6);
 			}
+#ifdef NO_CHARMAP_WORKAROUND
+			}
+#endif
 			last_glyph_code = curchar;
 
 #if HAVE_FREETYPE_2_CACHE
@@ -1301,6 +1417,7 @@
 			if (error)
 				continue;
 
+
 			blit_instructions.dstx = ax + sbit->left;
 			blit_instructions.dsty = ay - sbit->top;
 			blit_instructions.dstw = sbit->width;
@@ -1389,8 +1506,26 @@
 	FT_BBox glyph_bbox;
 
 #if HAVE_FREETYPE_2_CACHE
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+    {
+        FTC_ScalerRec  scaler;
+
+        scaler.face_id = pf->imagedesc.face_id;
+        scaler.width   = pf->imagedesc.width;
+        scaler.height  = pf->imagedesc.height;
+        scaler.pixel   = 1;
+
+        error = FTC_Manager_LookupFace( freetype2_cache_manager
+            , pf->imagedesc.face_id, &face );
+        if ( !error ){
+        	error = FTC_Manager_LookupSize(freetype2_cache_manager,
+    	        &scaler, &size);
+        }
+    }
+#else
 	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
 					&(pf->imagedesc.font), &face, &size);
+#endif
 	if (error) {
 		EPRINTF("Freetype 2 error 0x%x getting font info.\n", error);
 		*pwidth = 0;
@@ -1417,6 +1552,10 @@
 	pos.y = 0;
 
 	for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (face->charmap == NULL) curchar = (str[i] < 0x80) ? str[i] : 0;
+		else {
+#endif
 		curchar = LOOKUP_CHAR(pf, face, str[i]);
 
 		if (use_kerning && last_glyph_code && curchar) {
@@ -1425,6 +1564,9 @@
 
 			pos.x += kerning_delta.x & (~63);
 		}
+#ifdef NO_CHARMAP_WORKAROUND
+		}
+#endif
 		last_glyph_code = curchar;
 
 		/* FIXME: Should use an image cache to optimize
@@ -1511,13 +1653,13 @@
 	FT_Face face;
 	FT_Size size;
 	const unsigned short *str = text;
-	int char_index;
-	int total_advance;
+	int char_index = 0;
+	int total_advance = 0;
 	int max_ascent;
 	int max_descent;
-	int advance;
-	int ascent;
-	int descent;
+	int advance = 0;
+	int ascent = 0;
+	int descent = 0;
 	FT_Error error;
 	FT_Vector kerning_delta;
 	int use_kerning;
@@ -1525,9 +1667,27 @@
 	int last_glyph_code = 0;	/* Used for kerning */
 
 #if HAVE_FREETYPE_2_CACHE
+#if HAVE_FREETYPE_VERSION_AFTER_OR_EQUAL(2,1,8) /*odie added*/
+    {
+        FTC_ScalerRec  scaler;
+
+        scaler.face_id = pf->imagedesc.face_id;
+        scaler.width   = pf->imagedesc.width;
+        scaler.height  = pf->imagedesc.height;
+        scaler.pixel   = 1;
+
+        error = FTC_Manager_LookupFace( freetype2_cache_manager
+            , pf->imagedesc.face_id, &face );
+        if ( !error ){
+        	error = FTC_Manager_LookupSize(freetype2_cache_manager,
+    	        &scaler, &size);
+        }
+    }
+#else
 	error = FTC_Manager_Lookup_Size(freetype2_cache_manager,
 					&(pf->imagedesc.font), &face,
 					&size);
+#endif
 	if (error) {
 		EPRINTF("Freetype 2 error 0x%x getting font info.\n",
 			error);
@@ -1553,6 +1713,10 @@
 	max_descent = 0;
 
 	for (char_index = 0; char_index < char_count; char_index++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (face->charmap == NULL) cur_glyph_code = (str[char_index] < 0x80) ? str[char_index] : 0;
+		else {
+#endif
 		cur_glyph_code = LOOKUP_CHAR(pf, face, str[char_index]);
 
 		if (use_kerning && last_glyph_code && cur_glyph_code) {
@@ -1564,11 +1728,15 @@
 			   (int)ax, (int)(kerning_delta.x >> 6), (int)kerning_delta.x); */
 			total_advance += (kerning_delta.x >> 6);
 		}
+#ifdef NO_CHARMAP_WORKAROUND
+		}
+#endif
 		last_glyph_code = cur_glyph_code;
 
 		error = freetype2_get_glyph_size(pf, face, cur_glyph_code, &advance, &ascent, &descent);
 		if (error)
 			continue;
+		//printf("In %s:%d: text = 0x%x, glyph_code = %d, advance = %d, ascent = %d, descent = %d\n", __FUNCTION__, __LINE__, str[char_index], cur_glyph_code, advance, ascent, descent);
 
 		total_advance += advance;
 		if (max_ascent < ascent)
@@ -1580,6 +1748,7 @@
 	*pwidth = total_advance;
 	*pheight = max_ascent + max_descent;
 	*pbase = max_ascent;
+	//printf("In %s:%d: pwidth = %d, pheight = %d, pbase = %d\n", __FUNCTION__, __LINE__, *pwidth, *pheight, *pbase);
 
 	/*EPRINTF("Nano-X-Freetype2: freetype2_gettextsize(): numchars = %d, w = %d, h = %d, base = %d\n",
 	   cc, *pwidth, *pheight, *pbase); */
diff -urN /home/greg/net/microwindows-0.90/src/engine/font_freetype.c ./engine/font_freetype.c
--- /home/greg/net/microwindows-0.90/src/engine/font_freetype.c	2003-05-10 08:29:54.000000000 -0700
+++ ./engine/font_freetype.c	2008-09-18 01:39:55.000000000 -0700
@@ -36,6 +36,9 @@
 	TT_Matrix 	matrix;
 	TT_Glyph 	glyph;
 	MWBOOL 		can_kern;
+#ifdef NO_CHARMAP_WORKAROUND
+	MWBOOL		unicode_map;
+#endif
 	short 		last_glyph_code;
 	short 		last_pen_pos;
 } MWFREETYPEFONT;
@@ -105,6 +108,9 @@
 	TT_Face_Properties 	properties;
 	char *			p;
 	char			fontname[128];
+#ifdef NO_CHARMAP_WORKAROUND
+	unsigned short		j;
+#endif
 
 	/* check for pathname prefix*/
 	if (strchr(name, '/') != NULL)
@@ -115,11 +121,14 @@
 		strcat(fontname, name);
 	}
 
+	printf("In %s:%d: fontname = %s\n", __FUNCTION__, __LINE__, fontname);
+#if 0
 	/* check for extension*/
 	if ((p = strrchr(fontname, '.')) == NULL ||
 	    strcmp(p, ".ttf") != 0) {
 		strcat(fontname, ".ttf");
 	}
+#endif
 
 	/* allocate font structure*/
 	pf = (PMWFREETYPEFONT)calloc(sizeof(MWFREETYPEFONT), 1);
@@ -127,6 +136,10 @@
 		return NULL;
 	pf->fontprocs = &freetype_procs;
 
+#ifdef NO_CHARMAP_WORKAROUND
+	pf->unicode_map = FALSE;
+#endif
+
 	/* Load face */
 	if (TT_Open_Face (engine, fontname, &pf->face) != TT_Err_Ok)
 		goto out;
@@ -188,12 +201,29 @@
 			 		(encoding == TT_APPLE_ID_DEFAULT)))
 		{
 			TT_Get_CharMap (pf->face, i, &pf->char_map);
+#ifdef NO_CHARMAP_WORKAROUND
+			pf->unicode_map = TRUE;
+#endif
 			i = n + 1;
 		}
 	}
 	if (i == n) {
 		DPRINTF("freetype_createfont: no unicode map table\n");
+#ifdef NO_CHARMAP_WORKAROUND
+		// Try again.
+		if (pf->unicode_map == FALSE) { 
+			for (j = 0; j < n; j++) { 
+				TT_Get_CharMap_ID(pf->face, j, &platform, &encoding);
+				if (((platform == TT_PLATFORM_MACINTOSH) && (encoding == TT_MS_ID_SYMBOL_CS)) ||
+					((platform == TT_PLATFORM_MICROSOFT) && (encoding == TT_MS_ID_SYMBOL_CS))) {
+					TT_Get_CharMap(pf->face, j, &pf->char_map);
+					j = n + 1;
+				}
+			}
+		}
+#else
 		goto out;
+#endif
 	}
 	
 	GdSetFontSize((PMWFONT)pf, height);
@@ -241,9 +271,13 @@
 {
 	TT_Glyph_Metrics metrics;
 	
+#ifdef NO_CHARMAP_WORKAROUND
+	if (TT_Load_Glyph(pf->instance, pf->glyph, (pf->unicode_map == FALSE) ? glyph_index : TT_Char_Index(pf->char_map, glyph_index), TTLOAD_SCALE_GLYPH | TTLOAD_HINT_GLYPH) != TT_Err_Ok)
+#else
     	if (TT_Load_Glyph ( pf->instance, pf->glyph,
 		TT_Char_Index (pf->char_map,glyph_index),
 		TTLOAD_SCALE_GLYPH|TTLOAD_HINT_GLYPH) != TT_Err_Ok)
+#endif
     	{
 		/* Try to load default glyph: index 0 */
 		if (TT_Load_Glyph ( pf->instance, pf->glyph, 0,
@@ -354,9 +388,13 @@
 	/*gr_background = gr_foreground + 1;*/
 
 	/* Now draw the bitmap ... */
+#if 1 // Roy
+	GdArea(psd, x_offset + xmin, y_offset - (ymin + height), width, height,
+		bitmap, psd->pixtype);
+#else
 	GdArea(psd, x_offset + xmin, y_offset - (ymin + height), width, height,
 		bitmap, MWPF_PIXELVAL);
-
+#endif
 	/*gr_background = save;*/
 
 	free (bitmap);
@@ -427,6 +465,10 @@
 	startx = x;
 	starty = y;
 	for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (str[i] < 0x80) ? str[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map, str[i]);
 
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
@@ -581,6 +623,10 @@
 	pf->last_pen_pos = -32767;
 	
 	for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (str[i] < 0x80) ? str[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map, str[i]);
 
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
@@ -706,6 +752,10 @@
 	     *lpnFit=-1;
 	for (i = 0; i < cc; i++) 
 	{
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (text[i] < 0x80) ? text[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map,text[i]);
 		
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
diff -urN /home/greg/net/microwindows-0.90/src/engine/font_freetype.cache.c ./engine/font_freetype.cache.c
--- /home/greg/net/microwindows-0.90/src/engine/font_freetype.cache.c	2003-05-10 08:29:54.000000000 -0700
+++ ./engine/font_freetype.cache.c	2008-09-18 01:39:55.000000000 -0700
@@ -329,6 +329,9 @@
 	TT_Matrix 	matrix;
 	TT_Glyph 	glyph;
 	MWBOOL 		can_kern;
+#ifdef NO_CHARMAP_WORKAROUND
+	MWBOOL		unicode_map;
+#endif
 	short 		last_glyph_code;
 	short 		last_pen_pos;
 #if MWFREETYPEFONT_CACHE
@@ -401,6 +404,9 @@
 	TT_Face_Properties 	properties;
 	char *			p;
 	char			fontname[128];
+#ifdef NO_CHARMAP_WORKAROUND
+	unsigned short j;
+#endif
 
 	/* check for pathname prefix*/
 	if (strchr(name, '/') != NULL)
@@ -411,11 +417,14 @@
 		strcat(fontname, name);
 	}
 
+	printf("In %s:%d: fontname = %s\n", __FILE__, __LINE__, fontname);
+#if 0 // Not necessary
 	/* check for extension*/
 	if ((p = strrchr(fontname, '.')) == NULL ||
 	    strcmp(p, ".ttf") != 0) {
 		strcat(fontname, ".ttf");
 	}
+#endif
 
 	/* allocate font structure*/
 	pf = (PMWFREETYPEFONT)calloc(sizeof(MWFREETYPEFONT), 1);
@@ -423,6 +432,10 @@
 		return NULL;
 	pf->fontprocs = &freetype_procs;
 
+#ifdef NO_CHARMAP_WORKAROUND
+	pf->unicode_map = FALSE;
+#endif
+	
 	/* Load face */
 	if (TT_Open_Face (engine, fontname, &pf->face) != TT_Err_Ok)
 		goto out;
@@ -484,12 +497,29 @@
 			 		(encoding == TT_APPLE_ID_DEFAULT)))
 		{
 			TT_Get_CharMap (pf->face, i, &pf->char_map);
+#ifdef NO_CHARMAP_WORKAROUND
+			pf->unicode_map = TRUE;
+#endif
 			i = n + 1;
 		}
 	}
 	if (i == n) {
 		DPRINTF("freetype_createfont: no unicode map table\n");
+#ifdef NO_CHARMAP_WORKAROUND
+		// Try again.
+		if (pf->unicode_map == FALSE) {
+			for (j = 0; 0 < n; j++) {
+				TT_Get_CharMap_ID(pf->face, j, &platform, &encoding);
+				if (((platform == TT_PLATFORM_MACINTOSH) && (encoding == TT_MS_ID_SYMBOL_CS)) ||
+					((platform == TT_PLATFORM_MICROSOFT) && (encoding == TT_MS_ID_SYMBOL_CS))) {
+					TT_Get_CharMap(pf->face, j, &pf->char_map);
+					j = n + 1;
+				}
+			}
+		}
+#else
 		goto out;
+#endif
 	}
 	
 	GdSetFontSize((PMWFONT)pf, height);
@@ -499,6 +529,7 @@
 	return pf;
 
 out:
+	printf("In %s:%d: freetype_createfont failed.\n", __FUNCTION__, __LINE__);
 	free(pf);
 	return NULL;
 }
@@ -537,9 +568,13 @@
 {
 	TT_Glyph_Metrics metrics;
 
+#ifdef NO_CHARMAP_WORKAROUND
+	        if (TT_Load_Glyph(pf->instance, pf->glyph, (pf->unicode_map == FALSE) ? glyph_index : TT_Char_Index(pf->char_map, glyph_index), TTLOAD_SCALE_GLYPH | TTLOAD_HINT_GLYPH) != TT_Err_Ok)
+#else
     	if (TT_Load_Glyph ( pf->instance, pf->glyph,
 		TT_Char_Index (pf->char_map,glyph_index),
 		TTLOAD_SCALE_GLYPH|TTLOAD_HINT_GLYPH) != TT_Err_Ok)
+#endif
     	{
 		/* Try to load default glyph: index 0 */
 		if (TT_Load_Glyph ( pf->instance, pf->glyph, 0,
@@ -717,9 +752,14 @@
 #endif
 	  }
 
+#if 1 // Roy
+	GdArea(psd, x_offset + xmin, y_offset - (ymin + height), width, height,
+		bitmap, psd->pixtype);
+#else		
 	/* Now draw the bitmap ... */
 	GdArea(psd, x_offset + xmin, y_offset - (ymin + height), width, height,
 		bitmap, MWPF_PIXELVAL);
+#endif
 
 #if !MWFREETYPEFONT_CACHEBITMAP
 	free(bitmap);
@@ -790,6 +830,10 @@
 	startx = x;
 	starty = y;
 	for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (str[i] < 0x80) ? str[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map, str[i]);
 
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
@@ -944,6 +988,10 @@
 	pf->last_pen_pos = -32767;
 	
 	for (i = 0; i < cc; i++) {
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (str[i] < 0x80) ? str[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map, str[i]);
 
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
@@ -1077,6 +1125,10 @@
 	     *lpnFit=-1;
 	for (i = 0; i < cc; i++) 
 	{
+#ifdef NO_CHARMAP_WORKAROUND
+		if (pf->unicode_map == FALSE) curchar = (text[i] < 0x80) ? text[i] : 0;
+		else
+#endif
 		curchar = TT_Char_Index (pf->char_map,text[i]);
 		
 		if (TT_Load_Glyph (pf->instance, pf->glyph, curchar,
Binary files /home/greg/net/microwindows-0.90/src/fonts/ttf2bdf and ./fonts/ttf2bdf differ
diff -urN /home/greg/net/microwindows-0.90/src/fonts/ttf2c.sh ./fonts/ttf2c.sh
--- /home/greg/net/microwindows-0.90/src/fonts/ttf2c.sh	1969-12-31 16:00:00.000000000 -0800
+++ ./fonts/ttf2c.sh	2008-09-18 01:39:53.000000000 -0700
@@ -0,0 +1,15 @@
+#!/bin/sh
+#export FONT_PATH="/home/erwin/acer/bgtr00b.ttf"
+export FONT_PATH="/home/erwin/acer/bhei01b.ttf"
+
+./ttf2bdf -t arial16 -r 72 -p 16 -l "1_255"  $FONT_PATH -o arial16.bdf
+./ttf2bdf -t arial20 -r 72 -p 20 -l "1_255" $FONT_PATH -o arial20.bdf
+./ttf2bdf -t arial24 -r 72 -p 24 -l "1_255" $FONT_PATH -o arial24.bdf
+./ttf2bdf -t arial28 -r 72 -p 28 -l "1_255" $FONT_PATH -o arial28.bdf
+echo "ttf2bdf Complete"
+sleep 1
+./convbdf.pl -limit 255 arial16.bdf > arial16.c
+./convbdf.pl -limit 255 arial20.bdf > arial20.c
+./convbdf.pl -limit 255 arial24.bdf > arial24.c
+./convbdf.pl -limit 255 arial28.bdf > arial28.c
+echo "convbdf Complete"
diff -urN /home/greg/net/microwindows-0.90/src/include/device.h ./include/device.h
--- /home/greg/net/microwindows-0.90/src/include/device.h	2003-05-13 10:19:06.000000000 -0700
+++ ./include/device.h	2008-09-18 01:39:54.000000000 -0700
@@ -19,8 +19,8 @@
 #define ANIMATEPALETTE	0			/* =1 animated palette test*/
 #define FONTMAPPER	0			/* =1 for Morten's font mapper*/
 #define USE_ALLOCA	1			/* alloca() is available */
-#define FASTJPEG	1			/* =1 for temp quick jpeg 8bpp*/
 #define HAVE_MMAP       1       		/* =1 to use mmap if available*/
+#define TRANSLATE_ESCAPE_SEQUENCES  1		/* =1 to parse fnkeys w/tty driver*/
 
 #if !((DOS_DJGPP) || (__PACIFIC__) || (DOS_TURBOC))
 #define MW_FEATURE_IMAGES 1		/* =1 to enable GdLoadImage* / GdDrawImage* */
@@ -102,8 +102,8 @@
 	int		firstchar;	/* first character in bitmap*/
 	int		size;		/* font size in characters*/
 	MWIMAGEBITS *	bits;		/* 16-bit right-padded bitmap data*/
-	unsigned long *offset;		/* 256 offsets into bitmap data*/
-	unsigned char *	width;		/* 256 character widths or 0 if fixed*/
+	unsigned long *offset;		/* offsets into bitmap data*/
+	unsigned char *	width;		/* character widths or 0 if fixed*/
 	int		defaultchar;	/* default char (not glyph index)*/
 	long		bits_size;	/* # words of MWIMAGEBITS bits*/
 } MWCFONT, *PMWCFONT;
@@ -327,6 +327,7 @@
 	int	pixtype;	/* format of pixel value*/
 	int	flags;		/* device flags*/
 	void *	addr;		/* address of memory allocated (memdc or fb)*/
+	void *  physical; 
 
 	PSD	(*Open)(PSD psd);
 	void	(*Close)(PSD psd);
@@ -376,6 +377,7 @@
 #define PSF_HAVEOP_COPY		0x0008	/* psd->DrawArea can do area copy*/
 #define PSF_ADDRMALLOC		0x0010	/* psd->addr was malloc'd*/
 #define PSF_ADDRSHAREDMEM	0x0020	/* psd->addr is shared memory*/
+#define PSF_ADDRDEVMALLOC	0x0040	/* psd->addr was malloc'd from device*/
 
 /* Interface to Mouse Device Driver*/
 typedef struct _mousedevice {
@@ -841,6 +843,11 @@
 int  	GdReadKeyboard(MWKEY *buf, MWKEYMOD *modifiers, MWSCANCODE *scancode);
 extern KBDDEVICE kbddev;
 
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+int  	GdOpenKeyboard2(void);
+extern KBDDEVICE kbddev2;
+#endif
+
 /* devimage.c */
 #if MW_FEATURE_IMAGES
 int	GdLoadImageFromBuffer(PSD psd, void *buffer, int size, int flags);
@@ -941,4 +948,97 @@
 #endif
 #endif
 
+/*
+ * Added by wills for devdraw better performance
+ */
+#define BPP16_COLOR2PIXEL(psd, cr)                      \
+do {                                                    \
+                pixel = COLOR2PIXEL565(cr);             \
+} while(0)
+
+#define BPP32_COLOR2PIXEL(psd, cr)                      \
+do {                                                    \
+                pixel = COLOR2PIXEL8888(cr);            \
+} while(0)
+
+#define MACRO_COLOR2PIXEL(psd, cr)                      \
+do {                                                    \
+        switch (psd->pixtype) {                         \
+        case MWPF_PALETTE:                              \
+        default:                                        \
+                pixel = GdFindColor(psd, cr);           \
+                break;                                  \
+        case MWPF_TRUECOLOR8888:                        \
+                pixel = COLOR2PIXEL8888(cr);            \
+                break;                                  \
+        case MWPF_TRUECOLOR0888:                        \
+        case MWPF_TRUECOLOR888:                         \
+                pixel = COLOR2PIXEL888(cr);             \
+                break;                                  \
+        case MWPF_TRUECOLOR565:                         \
+                pixel = COLOR2PIXEL565(cr);             \
+                break;                                  \
+        case MWPF_TRUECOLOR555:                         \
+                pixel = COLOR2PIXEL555(cr);             \
+                break;                                  \
+        case MWPF_TRUECOLOR332:                         \
+                pixel = COLOR2PIXEL332(cr);             \
+                break;                                  \
+        }                                               \
+} while(0)
+
+#define BPP16_DRAWPIXEL(psd, x, y ,pixel)               \
+do {                                                    \
+                unsigned short *addr = psd->addr;       \
+                addr[x + y * psd->linelen] = pixel;     \
+} while(0)
+
+#define BPP32_DRAWPIXEL(psd, x, y ,pixel)               \
+do {                                                    \
+                addr[x + y * psd->linelen] = pixel;     \
+} while(0)
+
+
+#define MACRO_DRAWPIXEL(psd, x, y ,pixel)               \
+do {                                                    \
+        switch (psd->pixtype) {                         \
+        case MWPF_PALETTE:                              \
+        default:                                        \
+                psd->DrawPixel(psd, x, y, pixel);       \
+                break;                                  \
+        case MWPF_TRUECOLOR8888:                        \
+                {                                       \
+                  unsigned long *addr = psd->addr;      \
+                                                        \
+                  addr[x + y * psd->linelen] = pixel;   \
+                }                                       \
+                break;                                  \
+        case MWPF_TRUECOLOR0888:                        \
+        case MWPF_TRUECOLOR888:                         \
+                {                                       \
+                  unsigned long *addr = psd->addr;      \
+                                                        \
+                  addr[x + y * psd->linelen] = pixel;   \
+                }                                       \
+                break;                                  \
+        case MWPF_TRUECOLOR565:                         \
+                {                                       \
+                  unsigned short *addr = psd->addr;     \
+                                                        \
+                  addr[x + y * psd->linelen] = pixel;   \
+                }                                       \
+                break;                                  \
+        case MWPF_TRUECOLOR555:                         \
+                {                                       \
+                  unsigned short *addr = psd->addr;     \
+                                                        \
+                  addr[x + y * psd->linelen] = pixel;   \
+                }                                       \
+                break;                                  \
+        case MWPF_TRUECOLOR332:                         \
+                psd->DrawPixel(psd, x, y, pixel);       \
+                break;                                  \
+        }                                               \
+} while(0)
+
 #endif /*_DEVICE_H*/
diff -urN /home/greg/net/microwindows-0.90/src/include/devmalloc.h ./include/devmalloc.h
--- /home/greg/net/microwindows-0.90/src/include/devmalloc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./include/devmalloc.h	2008-09-18 01:39:54.000000000 -0700
@@ -0,0 +1,8 @@
+#ifndef __DEVMALLOC_H_
+#define __DEVMALLOC_H_
+int   STATIC_malloc_init( void );
+int   STATIC_malloc_destroy( void );
+void *STATIC_malloc(int size);
+void  STATIC_free(void *p);
+#endif
+
diff -urN /home/greg/net/microwindows-0.90/src/include/memfix.sh ./include/memfix.sh
--- /home/greg/net/microwindows-0.90/src/include/memfix.sh	2003-02-26 11:00:43.000000000 -0800
+++ ./include/memfix.sh	2008-09-18 01:39:54.000000000 -0700
@@ -1,3 +1,3 @@
 #! /bin/sh
 # Run from microwin/src
-find . \( -path './demos' -prune \) -o \( -name '*.[ch]' -a \! -name mwsystem.h -a -print \) | xargs perl -i.bak -pwe 's/malloc(\s*\()/GdMalloc$1/g; s/calloc(\s*\()/GdCalloc$1/g; s/strdup(\s*\()/GdStrDup$1/g; s/free(\s*\()/GdFree$1/g;'
+find . \( -path './demos' -prune \) -o \( -name '*.[ch]' -a \! -name mwsystem.h -a \! -name XtoNX.h -a \! -name convbmp.c -a \! -name convbdf.c -print \) | xargs perl -i.bak -pwe 's/malloc(\s*\()/GdMalloc$1/g; s/calloc(\s*\()/GdCalloc$1/g; s/strdup(\s*\()/GdStrDup$1/g; s/free(\s*\()/GdFree$1/g;'
diff -urN /home/greg/net/microwindows-0.90/src/include/mwtypes.h ./include/mwtypes.h
--- /home/greg/net/microwindows-0.90/src/include/mwtypes.h	2003-05-10 13:06:35.000000000 -0700
+++ ./include/mwtypes.h	2008-09-18 01:39:54.000000000 -0700
@@ -142,6 +142,25 @@
 /* stretch src -> dst*/
 #define MWROP_STRETCH		0x25000000L
 
+/* ignore keycolor copy mode */
+#define MWROP_COPY_IK           0x26000000L  
+
+/* replace keycolor */
+#define MWROP_COPY_RK           0x27000000L
+
+/* src->dst and the set dst alpha channel as constant alpha */
+#define MWROP_COPY_ALPHA        0x28000000L
+#define MWROP_OVERALPHACHANNEL MWROP_COPY_ALPHA
+
+/* blend the src to dst and the set dst alpha channel as constant alpha */
+#define MWROP_COPY_ALPHABLEND   0x29000000L
+
+#define MWROP_DISTORT		0x30000000L
+
+#define MWROP_SWITCH_BUFFER		0x290000L	/* Used for switch double buffer for GFX engine */
+
+#define MWROP_SCALE				0x30000L	/* Used to scale src's context for GFX engine */
+
 /* Use the MWMODE value in the graphics context
  * to choose the appropriate MWROP value.
  * (This is only valid in calls to the Nano-X API,
@@ -327,6 +346,9 @@
 	int	vs_height;
 	int	ws_width;	/* workspace width/height*/
 	int	ws_height;
+#ifdef __EM86XX__ // Roy 
+	void* gfxcontext;
+#endif
 } MWSCREENINFO, *PMWSCREENINFO;
 
 /* client side window framebuffer info*/
diff -urN /home/greg/net/microwindows-0.90/src/Makefile.rules ./Makefile.rules
--- /home/greg/net/microwindows-0.90/src/Makefile.rules	2003-05-13 10:00:17.000000000 -0700
+++ ./Makefile.rules	2008-09-18 01:39:55.000000000 -0700
@@ -5,7 +5,7 @@
 #
 # This makefile should be placed at the top of a project hierarchy
 #
-# NOTE: The TOP environment variable should be set to that top directory
+# NOTE: The MW_DIR_SRC environment variable should be set to that top directory
 ##############################################################################
 
 ifeq ($(ARCH), DJGPP)
@@ -16,31 +16,39 @@
 
 # install directories for headers and libraries
 INSTALL_PREFIX  = /usr
-INSTALL_USER    = root
-INSTALL_GROUP   = root
-INSTALL_GROUP_2 = bin
+
+INSTALL_OWNER1  = #-o root -g root
+INSTALL_OWNER2  = #-o root -g bin
+
 HDRINSTALLDIR = $(INSTALL_PREFIX)/include/microwin
 LIBINSTALLDIR = $(INSTALL_PREFIX)/lib
 BININSTALLDIR = $(INSTALL_PREFIX)/bin
 
-INSTALL_DIR   = install -c -m 755 -o $(INSTALL_USER) -g $(INSTALL_GROUP) -d
-INSTALL_HDR   = install -c -m 644 -o $(INSTALL_USER) -g $(INSTALL_GROUP_2)
-INSTALL_LIB   = install -c -m 644 -o $(INSTALL_USER) -g $(INSTALL_GROUP_2)
-INSTALL_BIN   = install -c -m 755 -o $(INSTALL_USER) -g $(INSTALL_GROUP_2)
+INSTALL_DIR   = install -c -m 755 $(INSTALL_OWNER1) -d
+INSTALL_HDR   = install -c -m 644 $(INSTALL_OWNER2)
+INSTALL_LIB   = install -c -m 644 $(INSTALL_OWNER2)
+INSTALL_BIN   = install -c -m 755 $(INSTALL_OWNER2)
 
 ##############################################################################
 # Defines, includes, and core libraries.  Controlled by the config file.
 ##############################################################################
 
 # Defines
-DEFINES += -DMWPIXEL_FORMAT=$(SCREEN_PIXTYPE)
+DEFINES += -DMWPIXEL_FORMAT=$(SCREEN_PIXTYPE) 
 
 # Includes
-INCLUDEDIRS += -I. -I$(TOP)/include
+INCLUDEDIRS += -I. -I$(MW_DIR_SRC)/include
 
 # Libraries required for the 'engine' functionality.
 MW_CORE_LIBS :=
 
+ifeq ($(STATIC_BUFFER_FOR_IMAGE), Y)
+DEFINES += -DSTATIC_BUFFER_FOR_IMAGE=1
+endif
+
+ifeq ($(ALPHA_BLENDING_FOR_PNG), Y)
+DEFINES += -DALPHA_BLENDING_FOR_PNG=1
+endif
 
 ifeq ($(VTSWITCH), Y)
 DEFINES += -DVTSWITCH=1
@@ -105,6 +113,41 @@
 endif
 endif
 
+ifeq ($(NO_CHARMAP_WORKAROUND), Y)
+DEFINES += -DNO_CHARMAP_WORKAROUND
+endif
+
+ifeq ($(USE_ARPHIC_FONT), Y)
+DEFINES += -DARPHIC_FONT_WORKAROUND_FOR_SPACE
+endif
+
+DEFINES += -DDESKTOP_WIDTH=$(DESKTOP_WIDTH)
+DEFINES += -DDESKTOP_HEIGHT=$(DESKTOP_HEIGHT)
+
+ifeq ($(EM86XX), Y)
+ifeq ($(SIGMA86_CHIP_NO), SMP8634)
+DEFINES += -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=9 -DDEMUX_PSF=1 -DEM86XX_MODE=EM86XX_MODEID_STANDALONE  -DGCC4_TOOLCHAIN -D__EM86XX__
+else
+DEFINES += -DEM86XX_CHIP=EM86XX_CHIPID_TANGO15 \
+           -DEM86XX_MODE=EM86XX_MODEID_STANDALONE -D__EM86XX__ -DEM86XX_REVISION=66 -DDEMUX_PSF=1  
+endif
+ifeq ($(SIGMA86_CHIP_NO), EM8620L)
+DEFINES += -D__EM8620__ -D__HW_STRETCH__
+else
+DEFINES += -D__EM8622__ -D__HW_STRETCH__
+endif
+
+ifeq ($(WAIT_FOR_COMMANDS), Y)
+DEFINES += -DWAIT_FOR_COMMANDS
+endif
+
+RUA_DIR ?= ${EM86XX_SDK}
+lib_ext ?= so
+
+INCLUDEDIRS += -I$(EM86XX_SDK) -I$(EM86XX_SDK)/samples -I.
+LDFLAGS +=  -L$(EM86XX_SDK)/lib -Xlinker --start-group -lrua -lllad -lsamples -lrmvdemux -lrmavicore -ldcc -lrmwmdrmndstub -lgbus -lrmdrm -lrmcore -lrmjpeg -lrmpng -lrmungif -lrmzlib -lrmhttp -lrmscc -lrmrtk86 -lrmmp4api -lrmmp4 -lrmmp4core -lrmdescriptordecoder -lrmmpeg4framework -lrmcpputils -lrmasfdemux -lrmasfdemuxcore -lrmcw -lrmdetectorapi -lrmdetector -lrmdetector3 -lrmdetector3api -lrmremote -lrmcdfs -lrmwmaprodecoder -lrmwmaprodecodercore -lrmec3transcoder -lrmdtcpinterface -lndsp -Xlinker --end-group  -ldl -rdynamic 
+endif
+
 ifeq ($(HAVE_FNT_SUPPORT), Y)
 DEFINES += -DHAVE_FNT_SUPPORT=1
 DEFINES += -DFNT_FONT_DIR="\"$(FNT_FONT_DIR)"\"
@@ -133,25 +176,10 @@
 LDFLAGS += -lm
 endif
 
-ifeq ($(HAVE_FREETYPE_2_SUPPORT), Y)
-ifeq ($(HAVE_FREETYPE_SUPPORT), Y)
-$(error Having both FreeType 1 and FreeType 2 support is not allowed.)
-endif
-DEFINES += -DHAVE_FREETYPE_2_SUPPORT=1
-DEFINES += -DFREETYPE_FONT_DIR=\"$(FREETYPE_FONT_DIR)\"
-MW_CORE_LIBS += $(LIBFT2LIB)
-# GCC 3.2 complains if system directories (e.g. /usr/include) are
-# specified with "-I".  For most INCxxx, we simply allow the
-# value to be set to empty to mean "no -I required".
-# Since FT2 requires $(INCFT2LIB)/freetype2 to always be
-# specified, we take a slightly different (and less reliable)
-# approach and simply skip the well-known system directories.
-ifneq ($(INCFT2LIB),/usr/include)
-ifneq ($(INCFT2LIB),/usr/local/include)
-INCLUDEDIRS += -I$(INCFT2LIB)
-endif
-endif
-INCLUDEDIRS += -I$(INCFT2LIB)/freetype2
+ifeq ($(HAVE_DEVICE_MEM_SUPPORT), Y)
+DEFINES += -DHAVE_DEVICE_MEM_SUPPORT=1
+DEFINES += -DDEVICE_MEM_MALLOC_MIN=\"$(DEVICE_MEM_MALLOC_MIN)\"
+DEFINES += -DDEVICE_MEM_MALLOC_MAX=\"$(DEVICE_MEM_MALLOC_MAX)\"
 endif
 
 ifeq ($(HAVE_PCF_SUPPORT), Y)
@@ -172,6 +200,10 @@
 DEFINES += -DHAVE_BIG5_SUPPORT=1
 endif
 
+ifeq ($(USE_HBF_FONT), Y)
+DEFINES += -DUSE_HBF_FONT=1
+endif
+
 ifeq ($(HAVE_GB2312_SUPPORT), Y)
 DEFINES += -DHAVE_GB2312_SUPPORT=1
 endif
@@ -207,6 +239,44 @@
 
 endif
 
+
+ifdef JPG_DECODE_BUF_WIDTH
+DEFINES += -DJPG_DECODE_BUF_WIDTH=$(JPG_DECODE_BUF_WIDTH)
+else
+DEFINES += -DJPG_DECODE_BUF_WIDTH=720
+endif
+
+
+ifdef JPG_DECODE_BUF_HEIGHT
+DEFINES += -DJPG_DECODE_BUF_HEIGHT=$(JPG_DECODE_BUF_HEIGHT)
+else
+DEFINES += -DJPG_DECODE_BUF_HEIGHT=480
+endif
+
+# NOTE: Don't need FILEIO support for FreeType 2, since it can load
+# from memory buffers.
+
+ifeq ($(HAVE_FREETYPE_2_SUPPORT), Y)
+ifeq ($(HAVE_FREETYPE_SUPPORT), Y)
+$(error Having both FreeType 1 and FreeType 2 support is not allowed.)
+endif
+DEFINES += -DHAVE_FREETYPE_2_SUPPORT=1
+DEFINES += -DFREETYPE_FONT_DIR=\"$(FREETYPE_FONT_DIR)\"
+MW_CORE_LIBS += $(LIBFT2LIB)
+# GCC 3.2 complains if system directories (e.g. /usr/include) are
+# specified with "-I".  For most INCxxx, we simply allow the
+# value to be set to empty to mean "no -I required".
+# Since FT2 requires $(INCFT2LIB)/freetype2 to always be
+# specified, we take a slightly different (and less reliable)
+# approach and simply skip the well-known system directories.
+ifneq ($(INCFT2LIB),/usr/include)
+ifneq ($(INCFT2LIB),/usr/local/include)
+INCLUDEDIRS += -I$(INCFT2LIB)
+endif
+endif
+INCLUDEDIRS += -I$(INCFT2LIB)/freetype2
+endif
+
 ifeq ($(NOFONTSORCLIPPING), Y)
 DEFINES += -DNOFONTSORCLIPPING=1
 endif
@@ -260,6 +330,8 @@
 DEFINES += -DSCREEN_WIDTH=$(SCREEN_WIDTH)
 endif
 
+
+
 ifdef SCREEN_DEPTH
 DEFINES += -DSCREEN_DEPTH=$(SCREEN_DEPTH)
 endif
@@ -272,6 +344,14 @@
 DEFINES += -DTPHELIO=1
 endif
 
+ifeq ($(LIRCMOUSE), Y)
+DEFINES += -DMW_LIRC_MOUSE=1
+endif
+
+ifeq ($(LIRCKBD2), Y)
+DEFINES += -DMW_FEATURE_TWO_KEYBOARDS=1
+endif
+
 # Nano-X specific stuff
 ifeq ($(NANOX), Y)
 
@@ -294,6 +374,13 @@
 
 endif
 
+ifeq ($(MMAP_SHARED_FLAGS), Y)
+DEFINES += -DMMAP_SHARED_FLAGS
+endif
+
+ifeq ($(MMAP_PAGE_ALIGNMENT), Y)
+DEFINES += -DMMAP_PAGE_ALIGNMENT
+endif
 
 ##############################################################################
 # Extra compiler flags.
@@ -343,10 +430,10 @@
 #OPTFLAGS += -DNDEBUG
 endif
 
-CFLAGS += $(INCLUDEDIRS)
-HOSTCFLAGS := $(INCLUDEDIRS)
+MAKEDEPCFLAGS :=
+HOSTCFLAGS :=
 CPPFLAGS += $(DEFINES)
-LDFLAGS += -L$(TOP)/lib
+LDFLAGS += -L$(MW_DIR_LIB)
 ifeq ($(ARCH), TRIMEDIA)
 ARFLAGS = r
 else
@@ -369,7 +456,7 @@
 ifeq ($(HOME)/microwin/Arch.rules,$(wildcard $(HOME)/microwin/Arch.rules))
 include $(HOME)/microwin/Arch.rules
 else
-include $(TOP)/Arch.rules
+include $(MW_DIR_SRC)/Arch.rules
 endif
 
 # Tools ...
@@ -383,6 +470,13 @@
 CP = cp
 MV = mv
 
+# Note: We don't put INCLUDEDIRS in HOSTCFLAGS.
+# When cross-compiling, we want to use the target headers for
+# generating dependencies (MAKEDEPCFLAGS), but the host's default
+# headers for compiling tools (HOSTCFLAGS).
+CFLAGS += $(INCLUDEDIRS)
+MAKEDEPCFLAGS += $(INCLUDEDIRS)
+
 ##############################################################################
 # Libraries.
 #
@@ -391,32 +485,22 @@
 ##############################################################################
 
 MWINLIBS = \
-	$(TOP)/lib/libmwin.a \
-	$(TOP)/lib/libmwinlib.a\
-	$(TOP)/lib/libmwengine.a \
-	$(TOP)/lib/libmwdrivers.a \
-	$(TOP)/lib/libmwfonts.a \
-	$(TOP)/lib/libmwimages.a \
+	$(MW_DIR_LIB)/libmwin.a \
+	$(MW_DIR_LIB)/libmwimages.a \
 	$(MW_CORE_LIBS)
-CCMWINLIBS = -lmwin -lmwinlib -lmwengine -lmwdrivers -lmwfonts -lmwin -lmwimages -lm $(MW_CORE_LIBS)
+CCMWINLIBS = -lmwin -lmwimages -lm $(MW_CORE_LIBS)
 
-ifeq ($(LINK_APP_INTO_SERVER), Y)
-NANOXCLIENTLIBS += \
-	$(TOP)/lib/libnano-X.a \
-	$(TOP)/lib/libmwengine.a \
-	$(TOP)/lib/libmwdrivers.a \
-	$(TOP)/lib/libmwfonts.a \
-	$(MW_CORE_LIBS)
-CCNANOXCLIENTLIBS += -lnano-X -lmwengine -lmwdrivers -lmwfonts $(MW_CORE_LIBS)
-else
-NANOXCLIENTLIBS += $(TOP)/lib/libnano-X.a
+NANOXCLIENTLIBS += $(MW_DIR_LIB)/libnano-X.a
 CCNANOXCLIENTLIBS += -lnano-X
+ifeq ($(LINK_APP_INTO_SERVER), Y)
+NANOXCLIENTLIBS += $(MW_CORE_LIBS)
+CCNANOXCLIENTLIBS += $(MW_CORE_LIBS)
 endif
 
 NANOXSERVERLIBS += \
-	$(TOP)/lib/libmwengine.a \
-	$(TOP)/lib/libmwdrivers.a \
-	$(TOP)/lib/libmwfonts.a \
+	$(MW_DIR_LIB)/libmwengine.a \
+	$(MW_DIR_LIB)/libmwdrivers.a \
+	$(MW_DIR_LIB)/libmwfonts.a \
 	$(MW_CORE_LIBS)
 CCNANOXSERVERLIBS += -lmwengine -lmwdrivers -lmwfonts
 ifeq ($(SHAREDLIBS), Y)
@@ -433,6 +517,10 @@
 NANOXCLIENTLIBS += -lgrx20
 endif
 
+ifeq ($(NOMMU), Y)
+LDFLAGS += -Wl,-elf2flt
+endif
+
 ifeq ($(ARCH), FREEBSD-X86)
 # For forkpty in nxterm.
 NANOXCLIENTLIBS += -lutil
@@ -447,33 +535,45 @@
 .SILENT:
 endif
 
-.PHONY: default subdirs clean cleandepend cleandepend-notsubdir xconfig makedestdirs
+.PHONY: default subdirs clean cleanapps xconfig makedestdirs
 
 # Add any exportable variable here
-export TOP ARCH CONFIG
+export MW_DIR_SRC MW_DIR_BIN MW_DIR_LIB MW_DIR_OBJ ARCH CONFIG
+
+# Do not use standard rules such as .c.o
+.SUFFIXES:
+
+# Do not delete "intermediate" files, such as the .c
+# files created from bitmaps and fonts.
+.SECONDARY:
 
 #
 # This is the default target
 # It looks for sub-directories with makefiles in it and tries to execute them
 #
 ifeq ($(SHAREDLIBS), Y)
-default: $(TOP)/bin $(TOP)/lib subdirs $(TOP)/lib/$(LIBNAME) $(TOP)/lib/$(LIBNAMESO)
+default: $(MW_DIR_BIN) $(MW_DIR_LIB) subdirs $(MW_DIR_LIB)/$(LIBNAME) $(MW_DIR_LIB)/$(LIBNAMESO)
 else
-default: $(TOP)/bin $(TOP)/lib subdirs $(TOP)/lib/$(LIBNAME)
+default: $(MW_DIR_BIN) $(MW_DIR_LIB) subdirs $(MW_DIR_LIB)/$(LIBNAME)
 endif
 
 # 'dirs' can be pre-specified
 ifeq ($(dirs), )
-dirs =	$(shell for file in `\ls`; \
-	do if [ -d $$file -a $$file != "demos" ]; then \
-	if [ -f $$file/Makefile ]; then echo $$file; fi; fi; done)
+# Look for all subdirectories that contain a Makefile,
+# but ignore the demos/ directory (if present).
+# Save the list of directory names to $(dirs) - this
+# variable is empty if the directories do not exist.
+dirs := $(dir $(wildcard $(MW_DIR_SRC)/$(MW_DIR_RELATIVE)*/Makefile))
+dirs := $(filter-out $(MW_DIR_SRC)/$(MW_DIR_RELATIVE)demos/,$(dirs))
 endif
 
 # 'demos' can be pre-specified
 ifeq ($(demos), )
-demos =	$(shell for file in `\ls`; \
-	do if [ -d $$file -a $$file = "demos" ]; then \
-	if [ -f $$file/Makefile ]; then echo $$file; fi; fi; done)
+# Look for the subdirectory demos/ that contains a Makefile,
+# if present.
+# Save the directory name to $(demos) - this variable is
+# empty if the directory does not exist.
+demos := $(dir $(wildcard $(MW_DIR_SRC)/$(MW_DIR_RELATIVE)demos/Makefile))
 endif
 
 #
@@ -493,142 +593,208 @@
 
 makedestdirs:
 ifeq ($(ARCH), DJGPP)
-
 	$(shell set CURDIR=$(pwd);)
-
-	$(shell \
-	if [ ! -d $(TOP)/bin ]; \
-	then mkdir $(TOP)/bin; fi;)
-
-	$(shell \
-	if [ ! -d $(TOP)/lib ]; \
-	then mkdir $(TOP)/lib; fi;)
-
+	[ -d $(MW_DIR_BIN) ] || mkdir $(MW_DIR_BIN)
+	[ -d $(MW_DIR_LIB) ] || mkdir $(MW_DIR_LIB)
 endif
 	@#
 
 #
+# This rule creates the directory for the target.
+#
+define MW_RULE_MAKE_TARGET_DIR
+[ -d $(dir $@) ] || mkdir -p $(dir $@)
+endef
+
+#
 # If a library name is specified,
 # a library of that name will be created with objects in that directory
 #
 ifneq ($(LIBNAME),)
-$(TOP)/lib/$(LIBNAME): $(OBJS) $(CXXOBJS)
-	@echo "Creating library $@ ..."
-	$(AR) $(ARFLAGS) $(TOP)/lib/$(LIBNAME) $(OBJS) $(CXXOBJS) $(ASMOBJS)
+$(MW_DIR_LIB)/$(LIBNAME): $(OBJS) $(CXXOBJS)
+	@echo "Creating library $(patsubst $(MW_DIR_LIB)/%,%,$@) ..."
+	$(AR) $(ARFLAGS) $(MW_DIR_LIB)/$(LIBNAME) $(OBJS) $(CXXOBJS) $(ASMOBJS)
 endif
 
 #
 # If a shared object library name is specified, link this object
 #
 ifeq ($(SHAREDLIBS), Y)
-$(TOP)/lib/$(LIBNAMESO): $(TOP)/lib/$(LIBNAME)
-	@echo "Creating shared library $@ ..."
+$(MW_DIR_LIB)/$(LIBNAMESO): $(MW_DIR_LIB)/$(LIBNAME)
+	@echo "Creating shared library $(patsubst $(MW_DIR_LIB)/%,%,$@) ..."
 	$(LD) -shared -o $@ --whole-archive $^
 endif
 
 #
 # Make sure that bin and lib directories exist
 #
-$(TOP)/bin $(TOP)/lib: 
+$(MW_DIR_BIN) $(MW_DIR_LIB): 
 	@mkdir -p $@
 
 #
-# Dependencies target for C files
+# This rule generates a dependencies *.d file from a C or C++ source file.
+# The .d file is placed in the same directory as the .o file.
 #
-.depend: $(OBJS:.o=.c) $(CXXOBJS:.o=.cc)
-	@echo "Updating dependencies in $(CURDIR) ..."
-	$(SHELL) -ec '$(HOSTCC) -MM $(CPPFLAGS) $(HOSTCFLAGS) $(OBJS:.o=.c) \
-	| sed '\''s/\($*\)\.o[ :]*/\1.o \$@ : $$(TOP)\/config /g'\'' > $@; \
-	[ -s $@ ] || rm -f $@'
+# The sed script replaces the short .o filename produced by gcc with the
+# full filename used by make.  This is only necessary if make is using
+# a filename including a directory part, since some [all?] versions of
+# gcc will remove the directory.  However, it does not hurt to always
+# use the sed script.
+#
+# Note that on error, this rule removes the (incomplete) .d file, and
+# also removes the .o file so that the rule will be run again next
+# time the user runs make.
+#
+define MW_RULE_DEPEND_C
+	$(HOSTCC) -MM $(MAKEDEPCFLAGS) $(DEFINES) $< \
+		| sed 's/.*\.o[ :]*/$(subst /,\/,$@) : /g' \
+		> $(basename $@).d \
+		|| (rm $@ $(basename $@).d ; exit 1)
+endef
 
 #
 # Compilation target for C files
 #
-%.o:%.c
-	@echo "Compiling $< ..."
+$(MW_DIR_OBJ)/%.o: $(MW_DIR_SRC)/%.c $(CONFIG)
+	@echo "Compiling $(patsubst $(MW_DIR_SRC)/%,%,$<) ..."
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@$(MW_RULE_MAKE_TARGET_DIR)
+endif
 	$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<
+	$(MW_RULE_DEPEND_C)
 
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+#
+# Compilation target for generated C files
+# (e.g. C files generated from bitmaps, fonts, etc)
+#
+$(MW_DIR_OBJ)/%.o: $(MW_DIR_OBJ)/%.c $(CONFIG)
+	@echo "Compiling $(patsubst $(MW_DIR_OBJ)/%,%,$<) ..."
+	@$(MW_RULE_MAKE_TARGET_DIR)
+	$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<
+	$(MW_RULE_DEPEND_C)
+endif
 
 #
 # Compilation target for C++ files
 #
-%.o:%.cc
-	@echo "C++ compiling $< ..."
+$(MW_DIR_OBJ)/%.o: $(MW_DIR_SRC)/%.cc $(CONFIG)
+	@echo "Compiling $(patsubst $(MW_DIR_SRC)/%,%,$<) ..."
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@$(MW_RULE_MAKE_TARGET_DIR)
+endif
+	$(CXX) -c $(CFLAGS) $(CXXFLAGS) -o $@ $<
+	$(MW_RULE_DEPEND_C)
+
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+#
+# Compilation target for generated C++ files
+#
+$(MW_DIR_OBJ)/%.o: $(MW_DIR_OBJ)/%.cc $(CONFIG)
+	@echo "Compiling $(patsubst $(MW_DIR_OBJ)/%,%,$<) ..."
+	@$(MW_RULE_MAKE_TARGET_DIR)
 	$(CXX) -c $(CFLAGS) $(CXXFLAGS) -o $@ $<
+	$(MW_RULE_DEPEND_C)
+endif
 
 #
 # Compilation target for bmp file conversion
 #
-%.c:%.bmp $(TOP)/bin/convbmp
-	echo "Generating $@ from bitmap file ..."
-	$(TOP)/bin/convbmp -o $@ $<
+$(MW_DIR_OBJ)/%.c: $(MW_DIR_SRC)/%.bmp $(MW_DIR_BIN)/convbmp
+	echo "Converting $(patsubst $(MW_DIR_SRC)/%,%,$<) ..."
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@$(MW_RULE_MAKE_TARGET_DIR)
+endif
+	$(MW_DIR_BIN)/convbmp -o $@ $<
 
 #
 # Compilation target for tool that does bmp file conversion
 #
-$(TOP)/bin/convbmp: $(TOP)/mwin/bmp/convbmp.c
-	echo "Building $@ tool ..."
+$(MW_DIR_BIN)/convbmp: $(MW_DIR_SRC)/mwin/bmp/convbmp.c
+	echo "Building $(patsubst $(MW_DIR_BIN)/%,%,$@) tool ..."
 	$(HOSTCC) $(HOSTCFLAGS) $< -o $@
 
 #
 # Compilation target for bdf font file conversion
 #
-%.c:%.bdf $(TOP)/bin/convbdf
-	echo "Generating $@ from font file ..."
-	$(TOP)/bin/convbdf -c -o $@ $<
+$(MW_DIR_OBJ)/%.c: $(MW_DIR_SRC)/%.bdf $(MW_DIR_BIN)/convbdf
+	echo "Converting $(patsubst $(MW_DIR_SRC)/%,%,$<) ..."
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@$(MW_RULE_MAKE_TARGET_DIR)
+endif
+	$(MW_DIR_BIN)/convbdf -c -o $@ $<
 
 #
 # Compilation target for tool that does bdf font file conversion
 #
-$(TOP)/bin/convbdf: $(TOP)/fonts/convbdf.c
-	echo "Building $@ tool ..."
+$(MW_DIR_BIN)/convbdf: $(MW_DIR_SRC)/fonts/convbdf.c
+	echo "Building $(patsubst $(MW_DIR_BIN)/%,%,$@) tool ..."
 	$(HOSTCC) $(HOSTCFLAGS) $< -o $@
 
 xconfig:
 	./xconfigure
 
 # don't clean lib dir
-cleanapps: cleandepend-notsubdir
-	@echo "Cleaning directory       $(CURDIR) ..."
-	$(RM) core *~ *.bak *.o TAGS
-	$(RM) bin/*
+cleanapps:
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@echo "Cleaning $(MW_DIR_RELATIVE) ..."
+	$(RM) -rf $(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)
+#	$(RM) -rf $(MW_DIR_BIN)/
+#	mkdir $(MW_DIR_BIN)
+endif
+	@echo "Cleaning directory $(MW_DIR_RELATIVE) ..."
+	$(RM) \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)core \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*~ \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.bak \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.o \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.d \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)TAGS \
+		$(MW_DIR_BIN)/*
 	$(foreach dir, $(dirs), $(MAKE) -C $(dir) cleanapps;)
 	$(foreach dir, $(demos), $(MAKE) -C $(dir) cleanapps;)
 
-clean: cleandepend-notsubdir
-	@echo "Cleaning directory       $(CURDIR) ..."
-	$(RM) core *~ *.bak *.o TAGS
-	$(RM) $(TOP)/lib/*.a $(TOP)/lib/*.so
-	$(shell cd $(TOP)/bin && \
-		for file in `\ls`; do if [ ! -d $$file ]; \
-		then $(RM) $$file; fi; done; cd $(TOP))
+clean:
+ifneq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
+	@echo "Cleaning $(MW_DIR_RELATIVE) ..."
+	$(RM) -rf $(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)
+#	$(RM) -rf $(MW_DIR_BIN)/ $(MW_DIR_LIB)/
+#	mkdir $(MW_DIR_BIN)
+#	mkdir $(MW_DIR_LIB)
+endif
+	@echo "Cleaning directory $(MW_DIR_RELATIVE) ..."
+	$(RM) \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)core \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*~ \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.bak \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.o \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.d \
+		$(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)TAGS \
+		$(MW_DIR_LIB)/*.a \
+		$(MW_DIR_LIB)/*.so
+	for file in $(wildcard $(MW_DIR_BIN)/*); do \
+		if [ ! -d $$file ]; then \
+			$(RM) $$file; \
+		fi; \
+	done
 	$(foreach dir, $(dirs), $(MAKE) -C $(dir) clean;)
 	$(foreach dir, $(demos), $(MAKE) -C $(dir) clean;)
 
-
-cleandepend-notsubdir:
-	@echo "Cleaning dependencies in $(CURDIR) ..."
-	$(RM) .depend
-
-cleandepend: cleandepend-notsubdir
-	$(foreach dir, $(dirs), $(MAKE) -C $(dir) cleandepend;)	
-	$(foreach dir, $(demos), $(MAKE) -C $(dir) cleandepend;)	
-
 install: default
 	$(INSTALL_DIR) $(HDRINSTALLDIR)
 	echo "Copying hdrs to $(HDRINSTALLDIR)"
-	$(INSTALL_HDR) include/*.h $(HDRINSTALLDIR)
+	$(INSTALL_HDR) $(MW_DIR_SRC)/include/*.h $(HDRINSTALLDIR)
 	echo "Copying libs to $(LIBINSTALLDIR)"
 	$(INSTALL_DIR) $(LIBINSTALLDIR)
-	$(INSTALL_LIB) lib/*.a $(LIBINSTALLDIR)
+	$(INSTALL_LIB) $(MW_DIR_LIB)/*.a $(LIBINSTALLDIR)
 ifeq ($(SHAREDLIBS), Y)
-	$(INSTALL_LIB) lib/*.so $(LIBINSTALLDIR)
+	$(INSTALL_LIB) $(MW_DIR_LIB)/*.so $(LIBINSTALLDIR)
 endif
 ifeq ($(NANOX), Y)
 ifeq ($(LINK_APP_INTO_SERVER), N)
 	echo "Copying binaries to $(BININSTALLDIR)"
 	$(INSTALL_DIR) $(BININSTALLDIR)
-	$(INSTALL_BIN) bin/nano-X $(BININSTALLDIR)
+	$(INSTALL_BIN) $(MW_DIR_BIN)/nano-X $(BININSTALLDIR)
 else
 	rm -f $(BININSTALLDIR)/nano-X
 endif
@@ -652,8 +818,8 @@
 ifneq ($(MAKECMDGOALS), cleandepend)
 ifneq ($(MAKECMDGOALS), realclean)
 ifneq ($(MAKECMDGOALS), xconfig)
-ifneq ($(OBJS),)
--include .depend
+ifneq ($(wildcard $(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.d),)
+-include $(wildcard $(MW_DIR_OBJ)/$(MW_DIR_RELATIVE)*.d)
 endif
 endif
 endif
diff -urN /home/greg/net/microwindows-0.90/src/nanox/clientfb.c ./nanox/clientfb.c
--- /home/greg/net/microwindows-0.90/src/nanox/clientfb.c	2003-05-11 12:51:18.000000000 -0700
+++ ./nanox/clientfb.c	2008-09-18 01:39:54.000000000 -0700
@@ -74,7 +74,7 @@
 		fbdev = "/dev/fb0";
 	frame_fd = open(fbdev, O_RDWR);
 	if (frame_fd < 0) {
-		printf("Can't open framebuffer device\n");
+		printf("%s Can't open framebuffer device\n", __FILE__);
 		UNLOCK(&nxGlobalLock);
 		return NULL;
 	}
diff -urN /home/greg/net/microwindows-0.90/src/nanox/srvfunc.c ./nanox/srvfunc.c
--- /home/greg/net/microwindows-0.90/src/nanox/srvfunc.c	2003-05-29 15:33:52.000000000 -0700
+++ ./nanox/srvfunc.c	2008-09-18 01:39:54.000000000 -0700
@@ -15,7 +15,7 @@
 static int	nextid = GR_ROOT_WINDOW_ID + 1;
 
 static void CheckNextEvent(GR_EVENT *ep, GR_BOOL doCheckEvent);
- 
+
 /*
  * Return information about the screen for clients to use.
  */
@@ -280,8 +280,15 @@
 		if (pp) {
 			psd = pp->psd;
 			/* deallocate pixmap memory*/
-			if (psd->flags & PSF_ADDRMALLOC)
+#if HAVE_DEVICE_MEM_SUPPORT
+			if (psd->flags & PSF_ADDRDEVMALLOC) {
+				engine_hal_rua_unmap(psd->physical, psd->addr, psd->size);
+				engine_hal_free_rua_buf(psd->physical);
+			} else
+#endif
+			if (psd->flags & PSF_ADDRMALLOC) {
 				free(psd->addr);
+			}
 
 			/* deallocate mem gc*/
 			psd->FreeMemGC(psd);
@@ -1822,8 +1829,19 @@
 
 	/* Allocate space for pixel values */
         if (!pixels) {
-	        pixels = calloc(size, 1);
-		psd->flags |= PSF_ADDRMALLOC;
+#if HAVE_DEVICE_MEM_SUPPORT
+		if ((size> atoi(DEVICE_MEM_MALLOC_MIN)) && (size < atoi(DEVICE_MEM_MALLOC_MAX))){
+			pixels = engine_hal_malloc_rua_buf(size);
+			psd->physical = pixels;
+			psd->flags |= PSF_ADDRDEVMALLOC;
+			pixels = engine_hal_rua_map(pixels, size);
+			psd->addr = pixels;
+		} else 
+#endif
+		{
+			pixels = calloc(size, 1);
+			psd->flags |= PSF_ADDRMALLOC;
+		}
 	}
 	if (!pixels) {
 		free(pp);
@@ -1848,9 +1866,9 @@
         listpp = pp;
 	
 	id = pp->id;
-	
 	SERVER_UNLOCK();
 	
+
 	return id;
 }
 
@@ -2573,6 +2591,7 @@
  * Fill a rectangle in the specified drawable using the specified
  * graphics context.
  */
+//PSD lastpsd;
 void
 GrFillRect(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
 	GR_SIZE width, GR_SIZE height)
@@ -2584,7 +2603,11 @@
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 		case GR_DRAW_TYPE_WINDOW:
 	        case GR_DRAW_TYPE_PIXMAP:
-			GdFillRect(dp->psd, dp->x + x, dp->y + y, width,height);
+	        	//William 0822
+	        	//fprintf(stderr, "GrFillRect: dp->psd:%08x x:%d y:%d w:%d h:%d\n", dp->psd, dp->x + x, dp->y + y, width,height);
+	        	//if(dp->psd != lastpsd) assert(0);
+	        	//lastpsd = dp->psd;
+				GdFillRect(dp->psd, dp->x + x, dp->y + y, width,height);
 			break;
 	}
 
@@ -3789,8 +3812,10 @@
 	/*GdStretchBlit(dp->psd, dx, dy, dw, dh,
 	   srcpsd,  sx, sy, sw, sh,
 	   op); */
-	GdStretchBlitEx(dp->psd, dx1, dy1, dx2, dy2,
-			srcpsd, sx1, sy1, sx2, sy2, op);
+//	GdStretchBlitEx(dp->psd, dx1, dy1, dx2, dy2,
+//			srcpsd, sx1, sy1, sx2, sy2, op);
+	GdStretchBlit(dp->psd, dx1, dy1, dx2-dx1+1, dy2-dy1+1,
+			srcpsd, sx1, sy1, sx2-sx1+1, sy2-sy1+1, op);
 	/* DPRINTF("Nano-X: GrStretchArea() done GdStretchBlitEx()\n"); */
 	//GdFixCursor(srcpsd); /* FIXME*/
 
diff -urN /home/greg/net/microwindows-0.90/src/nanox/srvmain.c ./nanox/srvmain.c
--- /home/greg/net/microwindows-0.90/src/nanox/srvmain.c	2003-05-17 22:58:42.000000000 -0700
+++ ./nanox/srvmain.c	2008-09-18 01:39:54.000000000 -0700
@@ -39,6 +39,10 @@
 #include <linuxmt/time.h>
 #endif
 
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+#include "devmalloc.h"
+#endif
+
 /*
  * External definitions defined here.
  */
@@ -81,8 +85,11 @@
 GR_CLIENT	*current_client;	/* the client we are currently talking*/
 char		*current_shm_cmds;
 int		current_shm_cmds_size;
-int		keyb_fd;		/* the keyboard file descriptor */
-int		mouse_fd;		/* the mouse file descriptor */
+static int	keyb_fd;		/* the keyboard file descriptor */
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+static int	keyb2_fd;		/* the keyboard file descriptor */
+#endif
+static int	mouse_fd;		/* the mouse file descriptor */
 char		*curfunc;		/* the name of the current server func*/
 GR_BOOL		screensaver_active;	/* time before screensaver activates */
 GR_SELECTIONOWNER selection_owner;	/* the selection owner and typelist */
@@ -252,6 +259,9 @@
 		}
 		GsAcceptClientFd(999);
 		curclient = root_client;
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+		STATIC_malloc_init();
+#endif
 	}
 	SERVER_UNLOCK();
 #endif
@@ -266,6 +276,9 @@
 {
 	SERVER_LOCK();
 	GsClose(current_fd);
+#if defined(STATIC_BUFFER_FOR_IMAGE)
+	STATIC_malloc_destroy();
+#endif
 	SERVER_UNLOCK();
 }
 
@@ -509,6 +522,13 @@
 		if (keyb_fd > setsize)
 			setsize = keyb_fd;
 	}
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+	if(keyb2_fd >= 0) {
+		FD_SET(keyb2_fd, &rfds);
+		if (keyb2_fd > setsize)
+			setsize = keyb2_fd;
+	}
+#endif
 #if NONETWORK
 	/* handle registered input file descriptors*/
 	for (fd = 0; fd < regfdmax; fd++) {
@@ -557,7 +577,11 @@
 				continue;
 
 		/* If data is present on the keyboard fd, service it: */
-		if(keyb_fd >= 0 && FD_ISSET(keyb_fd, &rfds))
+		if( (keyb_fd >= 0 && FD_ISSET(keyb_fd, &rfds))
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+		 || (keyb2_fd >= 0 && FD_ISSET(keyb2_fd, &rfds))
+#endif
+		  )
 			while(GsCheckKeyboardEvent())
 				continue;
 
@@ -668,6 +692,13 @@
 		if (keyb_fd > *maxfd)
 			*maxfd = keyb_fd;
 	}
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+	if(keyb2_fd >= 0) {
+		FD_SET(keyb2_fd, rfds);
+		if (keyb2_fd > *maxfd)
+			*maxfd = keyb2_fd;
+	}
+#endif
 
 	/* handle registered input file descriptors*/
 	for (fd = 0; fd < regfdmax; fd++) {
@@ -710,7 +741,11 @@
 			continue;
 
 	/* If data is present on the keyboard fd, service it: */
-	if(keyb_fd >= 0 && FD_ISSET(keyb_fd, rfds))
+	if( (keyb_fd >= 0 && FD_ISSET(keyb_fd, rfds))
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+	 || (keyb2_fd >= 0 && FD_ISSET(keyb2_fd, rfds))
+#endif
+	  )
 		while(GsCheckKeyboardEvent())
 			continue;
 
@@ -828,6 +863,15 @@
 		return -1;
 	}
 
+#ifdef MW_FEATURE_TWO_KEYBOARDS
+	if ((keyb2_fd = GdOpenKeyboard2()) == -1) {
+		EPRINTF("Cannot initialise second keyboard\n");
+		/*GsCloseSocket();*/
+		free(wp);
+		return -1;
+	}
+#endif
+
 	if ((psd = GdOpenScreen()) == NULL) {
 		EPRINTF("Cannot initialise screen\n");
 		/*GsCloseSocket();*/
