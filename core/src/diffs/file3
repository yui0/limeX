diff --git a/src/ChangeLog b/src/ChangeLog
index e31d1f8..01c823d 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,5 +1,16 @@
+4 Dec 2010
+	* added FrameBlit and FrameStretchBlit subdriver framebuffer blits
+	* removed Blit from fblin32/24/16/8 subdrivers, renamed driver proc BlitFallback
+	* rewrote APPLYOP for speed, optimized fblin32/24/16/8 pixel/hline/vline drawing
+	* MWROP_BLENDCONSTANT supported in 16/24/32bpp frameblit only (was 8/16/24/32bpp)
+	* frameblit src_over supported in 32bpp only, otherwise copy
+	* rewrote GdStretchBlitEx upper/lower layers to use frameblit_stretch_xxxx
+	* removed StretchBlitEx from subdrivers
+	* background pixmap draw now uses SRC_OVER, added SRC_OVER/XOR_FGBG to GdStretchBlit/GdBlit
+	* fix bug in 24bpp stretchblit (dst_y_step = dstpsd->linelen*3), needs fix in 0.92
+	* deprecated MWROP_SRCCOPY, use MWROP_COPY
 29 Nov 2010
-	* rewrote GdBlit to use frameblit_copy rather than old format psd->Blit
+	* rewrote GdBlit to use frameblit_xxxx rather than old format psd->Blit
 	* added framebuffer frameblit_copy, copies backwards if required, used in GdBlit MWROP_COPY
 	* combined portrait blits for rgba/rgb/mono, added rgba output for psp
 	* cleaned up SCREENDEV struct, deprecated many screen drivers (see src/DEPRECATED)
@@ -79,7 +90,7 @@
 	* added GdConvBlitInternal path from GdDrawImage for very fast image blitting (32bpp hw only)
 		if image decoder uses MWIF_ image format then GdConversionBlit/GdConvBlitInternal used
 		otherwise emulated with old GdDrawImage routine pixel by pixel
-11 June 2010 (Version 0.92)
+Version 0.92 - 11 June 2010 - greg@censoft.com
 	* fix freetype 2 off-by-one height bug (ascent + descent != height)
 10 June 2010
 	* added capabilities flag word in font subdriver for h/w scaling
diff --git a/src/FIXME b/src/FIXME
index be79d15..06068b5 100644
--- a/src/FIXME
+++ b/src/FIXME
@@ -1,13 +1,6 @@
-add psd->BlitFrameCopy for 16/24/32, rewrite/remove Blit entrypoints to use BLITPARMS
-check 255 alpha required on 8888_8888 copy (from GdBitmap or convblit)
-check slight change in GrReadArea->GrArea using GdBitmap vs convblit (alpha/nxroach)
-	appears that GdBitmap using GdBitmapByPoint isn't writing alpha=255
-check whether seperate portrait mode blits required
-add XOR_FGBG and SRC_OVER from fblin32alpha.c to fblin32.c
-	make applyOp work for SRC_OVER
-	fblin32alpha.c draws SRCOVER in pixel, h/vline, add to fblin32.c
+remove GdFillRect in GsWpDrawBackgroundPixmap (added for SRCOVER)
+rewrite GdStretchImage to use convblit_stretch
 
-plans for GdArea Translation, GdReadArea blit?
 bin/mdemo requires extra mouse press/move to redraw on X11
 remove seperate driver procs and combine to single SUBDRIVER in screendevice
 rename orgsubdriver, left_subdriver etc
@@ -26,10 +19,9 @@ fix vncserver.c support (drawarea, etc)
 FT2 don't use antialias settings if no HAVEOP_ALPHACOL driver entry point
 
 16bpp convblits are endian-specific
-write convblits for 24/32bpp non-bgra systems (rename TRUECOLOR macros?)
-fblin32.c blit uses src[3] for alpha, will only work on BGRA and BGRA formats
-	applyOp4 may need fixing, uses ADDR32
-change driver fblinear_blit routines for 32bpp to BLITPARMS struct
+rename TRUECOLOR macros to match image byte order, or use upper vs lower case
+bgra/rgba blit uses src[3] for alpha, will only work on BGRA and BGRA formats
+fblin32alpha.c draws SRCOVER in pixel, h/vline, add to fblin32.c
 
 remove FT1 from Config/configs*
 config option to eliminate not needed subdrivers?
@@ -39,6 +31,11 @@ deprecate old screen drivers, fontmapper, !DYNAMICREGIONS
 	fix mwin/winfonts.c::EnumFonts GdGetFontList/GdFreeFontList/GdTextSizeEx for FT1
 	add GdGetTextSizeEx/GdGetFontList to FT2 from FT1
 
+check 255 alpha required on 8888_8888 copy (from GdBitmap or convblit)
+check slight change in GrReadArea->GrArea using GdBitmap vs convblit (alpha/nxroach)
+	appears that GdBitmap using GdBitmapByPoint isn't writing alpha=255
+plans for GdArea Translation, GdReadArea blit?
+
 drawarea alphamap, copytrans, copyall(=convblit copy vs srcover)
 	check srcover vs copy for RGBA8888 images
 
@@ -50,14 +47,11 @@ autoportrait works great except for when change occurs and cursor still on?
 	(fblin32 blit: assert h < 0)
 
 fblin32alpha.c/fblin32.c:
-	fix SRC_OVER in applyOp
 	check alpha offset in passed pixmap alpha channel
 	add MWROP_* compositing handling (currently only SRC_OVER alpha blend)
 	check whether alpha != 0 check needed
 		fblin32alpha.c always draws alpha in drawpixel, drawh, drawv
 		#define ALPHABLEND, what does it do now?
-	update stretchblitex in fblin32.c for SRC_OVER
-	check fblin24.c, fblin16.c against fblin32.c/a
 	check MWPIXELVAL has alpha in drawpixel etc routines, possibly remove for 24bpp?
 	check MWPF_ values in case statements in GdDrawImage for 12/18bpp cases, use default
 	look at code generated for = vs += muldiv255, and fblin32alpha longword calcs
diff --git a/src/config b/src/config
index da9422d..c403e7d 100644
--- a/src/config
+++ b/src/config
@@ -250,8 +250,8 @@ FRAMEBUFFER              = N
 # X11 startup screen width, height, (depth for palette mode only)
 # USE_EXPOSURE=Y for XFree86 4.x or if your backing store not working
 X11                      = Y
-SCREEN_WIDTH             = 800
-SCREEN_HEIGHT            = 600
+SCREEN_WIDTH             = 810
+SCREEN_HEIGHT            = 640
 SCREEN_DEPTH             = 8
 USE_EXPOSURE             = Y
 
diff --git a/src/demos/mwin/mdemo.c b/src/demos/mwin/mdemo.c
index 5a1304e..45a1622 100644
--- a/src/demos/mwin/mdemo.c
+++ b/src/demos/mwin/mdemo.c
@@ -219,9 +219,9 @@ ChildWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
 		/* blit offscreen with physical screen*/
 		//BitBlt(ps.hdc, 0, 0, rc.right*4/5, rc.bottom*4/5, hdcMem,
-			//0, 0, MWROP_SRCCOPY);
+			//0, 0, MWROP_COPY);
 		StretchBlt(ps.hdc, 0, 0, rc.right*4/5, rc.bottom*4/5, hdcMem,
-			0, 0, image->width, image->height, MWROP_SRCCOPY);
+			0, 0, image->width, image->height, MWROP_COPY);
 		DeleteObject(SelectObject(hdcMem, hbmpOrg));
 		DeleteDC(hdcMem);
 }
diff --git a/src/demos/mwin/mdemo.stretch.c b/src/demos/mwin/mdemo.stretch.c
index db1a934..524a7bc 100644
--- a/src/demos/mwin/mdemo.stretch.c
+++ b/src/demos/mwin/mdemo.stretch.c
@@ -189,8 +189,8 @@ ChildWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 		DrawDIB(hdcMem, 0, 0, image);
 
 		/* blit offscreen with physical screen*/
-		//BitBlt(ps.hdc, 0, 0, rc.right, rc.bottom, hdcMem, 0, 0, MWROP_SRCCOPY);
-		StretchBlt(ps.hdc, 0, 0, rc.right, rc.bottom, hdcMem, 0, 0, image->width, image->height, MWROP_SRCCOPY);
+		//BitBlt(ps.hdc, 0, 0, rc.right, rc.bottom, hdcMem, 0, 0, MWROP_COPY);
+		StretchBlt(ps.hdc, 0, 0, rc.right, rc.bottom, hdcMem, 0, 0, image->width, image->height, MWROP_COPY);
 		DeleteObject(SelectObject(hdcMem, hbmpOrg));
 		DeleteDC(hdcMem);
 
diff --git a/src/demos/mwin/mstretch.c b/src/demos/mwin/mstretch.c
index 1ea05a1..03ab40b 100644
--- a/src/demos/mwin/mstretch.c
+++ b/src/demos/mwin/mstretch.c
@@ -57,7 +57,7 @@ ChildWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
 		/* stretch blit offscreen with physical screen*/
 		StretchBlt(ps.hdc, 0, 0, rc.right, rc.bottom, hdcMem,
-			0, 0, image->width, image->height, MWROP_SRCCOPY);
+			0, 0, image->width, image->height, MWROP_COPY);
 		DeleteObject(SelectObject(hdcMem, hbmpOrg));
 		DeleteDC(hdcMem);
 		EndPaint(hwnd, &ps);
diff --git a/src/demos/nanox/demo5.c b/src/demos/nanox/demo5.c
index 75dd3c4..a2607bd 100644
--- a/src/demos/nanox/demo5.c
+++ b/src/demos/nanox/demo5.c
@@ -295,7 +295,7 @@ do_buttonup(GR_EVENT_BUTTON	*bp)
 			GrLine(w4, gc3, bp->x, bp->y, linexpos, lineypos);
 		}
 		lineok = GR_FALSE;
-	        GrCopyArea(w1, gc4, 200,200, 200,200, p1,0,0,MWROP_SRCCOPY);
+	        GrCopyArea(w1, gc4, 200,200, 200,200, p1,0,0,MWROP_COPY);
 		return;
 	}
 
diff --git a/src/demos/nanox/demo6.c b/src/demos/nanox/demo6.c
index 17b1add..a826add 100644
--- a/src/demos/nanox/demo6.c
+++ b/src/demos/nanox/demo6.c
@@ -25,7 +25,7 @@ static void do_exposure(GR_EVENT_EXPOSURE *event)
 {
 	/* The window has been exposed so redraw it */
 #ifdef USE_PIXMAPS
-	GrCopyArea(window, gc, 0, 0, width, height, pmap, 0, 0, MWROP_SRCCOPY);
+	GrCopyArea(window, gc, 0, 0, width, height, pmap, 0, 0, MWROP_COPY);
 #else
 	GrArea(window, gc, 0, 0, width, height, data, MWPF_RGB);
 #endif
@@ -139,8 +139,7 @@ int main(int argc, char *argv[])
 
 #ifdef USE_PIXMAPS
 	/* Paint the pixmap onto it */
-	GrCopyArea(window, gc, 0, 0, width, height, pmap, 0, 0,
-							MWROP_SRCCOPY);
+	GrCopyArea(window, gc, 0, 0, width, height, pmap, 0, 0, MWROP_COPY);
 #else
 	GrArea(window, gc, 0, 0, width, height, data, MWPF_RGB);
 #endif
diff --git a/src/demos/nanox/ft2test.c b/src/demos/nanox/ft2test.c
index b2acc3d..f098d90 100644
--- a/src/demos/nanox/ft2test.c
+++ b/src/demos/nanox/ft2test.c
@@ -10,7 +10,8 @@
 //#define FONT	"DejaVuSans-Bold.ttf"
 #define FONT	"arial.ttf"
 
-#define IMAGE	 "bin/tux.gif"
+//#define IMAGE	 "bin/tux.gif"
+#define IMAGE	 "mwin/bmp/alphademo.png"
 
 void draw_ellipse(GR_GC_ID gc, int x, int y, int color, char *text);
 void test_ft2_antialias(void);
@@ -75,7 +76,7 @@ test_stretchblit(void)
 	x = sinfo.cols - image_info.width*4;
 	y = sinfo.rows - image_info.height*4;
 	wid = GrNewWindowEx(GR_WM_PROPS_APPWINDOW, NULL,
-		GR_ROOT_WINDOW_ID, x, y, image_info.width*3, image_info.height*3, GR_COLOR_GREEN);
+		GR_ROOT_WINDOW_ID, x, y, image_info.width/3, image_info.height/3, GR_COLOR_GREEN);
 
 	GrSelectEvents(wid, GR_EVENT_MASK_CLOSE_REQ |
 			GR_EVENT_MASK_MOUSE_POSITION |
diff --git a/src/demos/nanox/nxterm.c b/src/demos/nanox/nxterm.c
index 92b2862..2f6ccd3 100644
--- a/src/demos/nanox/nxterm.c
+++ b/src/demos/nanox/nxterm.c
@@ -177,7 +177,7 @@ void hide_cursor (void)
 void vscroll(int lines)
 {
     hide_cursor();
-    GrCopyArea(w1,gc1,0, 0, winw, winh-(lines*fonh), w1, 0, lines*fonh, MWROP_SRCCOPY);
+    GrCopyArea(w1,gc1,0, 0, winw, winh-(lines*fonh), w1, 0, lines*fonh, MWROP_COPY);
     GrSetGCForeground(gc1,gi.background);    
     GrFillRect(w1, gc1, 0, winh-(lines*fonh), winw, lines*fonh);
     GrSetGCForeground(gc1,gi.foreground);    
diff --git a/src/demos/vnc/vncviewer/nanox.c b/src/demos/vnc/vncviewer/nanox.c
index d298879..2ff9d04 100644
--- a/src/demos/vnc/vncviewer/nanox.c
+++ b/src/demos/vnc/vncviewer/nanox.c
@@ -204,7 +204,7 @@ XCopyArea(Display *dpy, Window src, Window dst, GR_GC_ID gc,
         int x1, int y1, int w, int h, int x2, int y2)
 {
 /*	printf("XCopyArea: src=%d, dst=%d, w=%d, h=%d\n",src, dst, w, h); */
-	GrCopyArea(dst, gc, x2, y2, w, h, src, x1, y1, MWROP_SRCCOPY);
+	GrCopyArea(dst, gc, x2, y2, w, h, src, x1, y1, MWROP_COPY);
 	return(0);
 }
 
diff --git a/src/drivers/deprecated/fblin32alpha.c b/src/drivers/deprecated/fblin32alpha.c
index 82798be..4e66853 100644
--- a/src/drivers/deprecated/fblin32alpha.c
+++ b/src/drivers/deprecated/fblin32alpha.c
@@ -12,7 +12,7 @@
  *	2) no 8888 convblit functions defined (yet) (means slow GdDrawImage and portrait mode text)
  *		internal convblits for font drawing (mono byte lsb/msb/alpha, no mono word msb)
  *		portrait mode emulates rotation by copying, then calling internal convblit - slow!
- *	3) can draw using SRC_OVER in drawpixel/hline/vline
+ *	3) can draw using SRC_OVER in drawpixel/hline/vline and StretchBlitEx (also XOR_FGBG)
  *
  * Written by Koninklijke Philips Electronics N.V.
  * Based on the existing 32bpp (no alpha) driver:
diff --git a/src/drivers/fb.c b/src/drivers/fb.c
index 9d13728..d886ebe 100644
--- a/src/drivers/fb.c
+++ b/src/drivers/fb.c
@@ -92,7 +92,7 @@ set_data_format(PSD psd)
 		data_format = MWIF_RGB565;
 		break;
 	case MWPF_TRUECOLOR555:
-		data_format = MWIF_RGB565;
+		data_format = MWIF_RGB555;
 		break;
 	case MWPF_TRUECOLOR332:
 		data_format = MWIF_RGB332;
diff --git a/src/drivers/fb.h b/src/drivers/fb.h
index 6c53a25..3040713 100644
--- a/src/drivers/fb.h
+++ b/src/drivers/fb.h
@@ -26,478 +26,137 @@ typedef unsigned char *		ADDR8;
 typedef unsigned short *	ADDR16;
 typedef uint32_t *			ADDR32;
 
-/* Note that the following ROP macro implements the
+/* Note that the following APPLYOP macro implements the
  * Porter-Duff rules assuming that source and destination
  * both have an alpha of 1.0.  Drivers that support alpha
  * should provide a better implementation of these rules.
+ *
+ * The following are not handled yet:
+ *		MWROP_SRC_IN
+ *		MWROP_SRC_ATOP
+ *		MWROP_DST_OVER
+ *		MWROP_DST_IN
+ *		MWROP_DST_ATOP
+ *		MWROP_SRC_OUT
+ *		MWROP_DST_OUT
+ *		MWROP_PORTERDUFF_XOR
+ *
+ * Arguments:
+ *	op		- MWROP code
+ *	width	- repeat count
+ *	STYPE	- src 'type' e.g. (ADDR32) or (MWPIXELVAL)
+ *	s		- src pointer or value
+ *	DTYPE	- dst 'type' e.g. *(ADDR32)
+ *	d		- dst pointer
+ *	ssz		- src pointer increment
+ *	dsz		- dst pointer increment
  */
 
- /* The following are not handled yet:
-		MWROP_SRC_IN
-		MWROP_SRC_ATOP
-		MWROP_DST_OVER
-		MWROP_DST_IN
-		MWROP_DST_ATOP
-		MWROP_SRC_OUT
-		MWROP_DST_OUT
-		MWROP_PORTERDUFF_XOR
- */
-
-/* ROP macro for 16 drawing modes*/
-#define CHECK(f,d)	
-
-
-/* applyOp w/stored dst*/
-#define	applyOp2(cnt, op, src, d, type)		\
+/* applyOp with count, src ptr, ssz/dsz increment*/
+#define	APPLYOP(op, width, STYPE, s, DTYPE, d, ssz, dsz)	\
 	{											\
-		int  count = cnt;						\
+		int  count = width;						\
 		switch (op) {							\
-		case MWROP_SRCTRANSCOPY:				\
-			while(--count >= 0) {				\
-				*d = (*d)? *d:src;				\
-				++d; }							\
-			break;								\
-		case MWROP_XOR:						\
-			while(--count >= 0) {				\
-				*d ^= (src);					\
-				++d; }							\
-			CHECK("XOR", *d);					\
-			break;								\
-		case MWROP_AND:						\
-			while(--count >= 0) {				\
-				*d &= (src);					\
-				++d; }							\
-			CHECK("AND", *d);					\
-			break;								\
-		case MWROP_OR:							\
-			while(--count >= 0) {				\
-				*d |= (src);					\
-				++d; }							\
-			CHECK("OR", *d);					\
-			break;								\
-		case MWROP_SRC_OUT:					\
-		case MWROP_DST_OUT:					\
-		case MWROP_PORTERDUFF_XOR:				\
-		case MWROP_CLEAR:						\
-			while(--count >= 0) {				\
-				*d = 0;							\
-				++d; }							\
-			CHECK("CLEAR", *d);					\
-			break;								\
-		case MWROP_SET:						\
-			while(--count >= 0) {				\
-				*d = ~0;						\
-				++d; }							\
-			CHECK("SET", *d);				\
-			break;								\
-		case MWROP_EQUIV:						\
-			while(--count >= 0) {				\
-				*d = ~(*d ^ (src));				\
-				++d; }							\
-			CHECK("EQUIV", *d);					\
-			break;								\
-		case MWROP_NOR:						\
-			while(--count >= 0) {				\
-				*d = ~(*d | (src));				\
-				++d; }							\
-			CHECK("NOR", *d);					\
-			break;								\
-		case MWROP_NAND:						\
-			while(--count >= 0) {				\
-				*d = ~(*d & (src));				\
-				++d; }							\
-			CHECK("NAND", *d);					\
-			break;								\
-		case MWROP_INVERT:						\
-			while(--count >= 0) {				\
-				*d = ~*d;						\
-				++d; }							\
-			CHECK("INVERT", *d);				\
-			break;								\
-		case MWROP_COPYINVERTED:				\
-			while(--count >= 0) {				\
-				*d = ~(src);					\
-				++d; }							\
-			CHECK("COPYINVERTED", *d);			\
-			break;								\
-		case MWROP_ORINVERTED:					\
-			while(--count >= 0) {				\
-				*d |= ~(src);					\
-				++d; }							\
-			CHECK("ORINVERTED", *d);			\
-			break;								\
-		case MWROP_ANDINVERTED:				\
-			while(--count >= 0) {				\
-				*d &= ~(src);					\
-				++d; }							\
-			CHECK("ANDINVERTED", *d);			\
-			break;								\
-		case MWROP_ORREVERSE:					\
-			while(--count >= 0) {				\
-				*d = ~*d | (src);				\
-				++d; }							\
-			CHECK("ORREVERSE", *d);				\
-			break;								\
-		case MWROP_ANDREVERSE:					\
-			while(--count >= 0) {				\
-				*d = ~*d & (src);				\
-				++d; }							\
-			CHECK("ANDREVERSE", *d);			\
-			break;								\
-		case MWROP_SRC_OVER:					\
-		case MWROP_SRC_IN:						\
-		case MWROP_SRC_ATOP:					\
 		case MWROP_COPY:						\
-			while(--count >= 0) {				\
-				*d = (src);						\
-				++d; }							\
-			CHECK("COPY", *d);					\
-			break;								\
-		case MWROP_DST_OVER:					\
-		case MWROP_DST_IN:						\
-		case MWROP_DST_ATOP:					\
-		case MWROP_NOOP:						\
-			CHECK("NOOP", *d);					\
-			break;								\
-		case MWROP_XOR_FGBG:					\
-			while(--count >= 0) {				\
-				*d ^= (src) ^ gr_background;	\
-				++d; }							\
-			CHECK("XOR_FGBG", *d);				\
-			break;								\
-		}										\
-	}
-
-/* applyOp2 with count and step*/
-#define	applyOp3(cnt, step, op, src, d, type)	\
-	{											\
-		int  count = cnt;						\
-		switch (op) {							\
-		case MWROP_SRCTRANSCOPY:				\
-			while(--count >= 0) {				\
-				*d = (*d)? *d:src;				\
-				d += step; }					\
-			break;								\
-		case MWROP_XOR:						\
-			while(--count >= 0) {				\
-				*d ^= (src);					\
-				d += step; }					\
-			CHECK("XOR", *d);					\
-			break;								\
-		case MWROP_AND:						\
-			while(--count >= 0) {				\
-				*d &= (src);					\
-				d += step; }					\
-			CHECK("AND", *d);					\
-			break;								\
-		case MWROP_OR:							\
-			while(--count >= 0) {				\
-				*d |= (src);					\
-				d += step; }					\
-			CHECK("OR", *d);					\
-			break;								\
-		case MWROP_SRC_OUT:					\
-		case MWROP_DST_OUT:					\
-		case MWROP_PORTERDUFF_XOR:				\
-		case MWROP_CLEAR:						\
-			while(--count >= 0) {				\
-				*d = 0;							\
-				d += step; }					\
-			CHECK("CLEAR", *d);					\
-			break;								\
-		case MWROP_SET:						\
-			while(--count >= 0) {				\
-				*d = ~0;						\
-				d += step; }					\
-			CHECK("SET", *d);				\
-			break;								\
-		case MWROP_EQUIV:						\
-			while(--count >= 0) {				\
-				*d = ~(*d ^ (src));				\
-				d += step; }					\
-			CHECK("EQUIV", *d);					\
-			break;								\
-		case MWROP_NOR:						\
-			while(--count >= 0) {				\
-				*d = ~(*d | (src));				\
-				d += step; }					\
-			CHECK("NOR", *d);					\
-			break;								\
-		case MWROP_NAND:						\
-			while(--count >= 0) {				\
-				*d = ~(*d & (src));				\
-				d += step; }					\
-			CHECK("NAND", *d);					\
-			break;								\
-		case MWROP_INVERT:						\
-			while(--count >= 0) {				\
-				*d = ~*d;						\
-				d += step; }					\
-			CHECK("INVERT", *d);				\
-			break;								\
-		case MWROP_COPYINVERTED:				\
-			while(--count >= 0) {				\
-				*d = ~(src);					\
-				d += step; }					\
-			CHECK("COPYINVERTED", *d);			\
-			break;								\
-		case MWROP_ORINVERTED:					\
-			while(--count >= 0) {				\
-				*d |= ~(src);					\
-				d += step; }					\
-			CHECK("ORINVERTED", *d);			\
-			break;								\
-		case MWROP_ANDINVERTED:				\
-			while(--count >= 0) {				\
-				*d &= ~(src);					\
-				d += step; }					\
-			CHECK("ANDINVERTED", *d);			\
-			break;								\
-		case MWROP_ORREVERSE:					\
-			while(--count >= 0) {				\
-				*d = ~*d | (src);				\
-				d += step; }					\
-			CHECK("ORREVERSE", *d);				\
-			break;								\
-		case MWROP_ANDREVERSE:					\
-			while(--count >= 0) {				\
-				*d = ~*d & (src);				\
-				d += step; }					\
-			CHECK("ANDREVERSE", *d);			\
-			break;								\
 		case MWROP_SRC_OVER:					\
 		case MWROP_SRC_IN:						\
 		case MWROP_SRC_ATOP:					\
-		case MWROP_COPY:						\
 			while(--count >= 0) {				\
-				*d = (src);						\
-				d += step; }					\
-			CHECK("COPY", *d);					\
-			break;								\
-		case MWROP_DST_OVER:					\
-		case MWROP_DST_IN:						\
-		case MWROP_DST_ATOP:					\
-		case MWROP_NOOP:						\
-			CHECK("NOOP", *d);					\
+				DTYPE d = STYPE s;				\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_XOR_FGBG:					\
+		case MWROP_PORTERDUFF_XOR:				\
 			while(--count >= 0) {				\
-				*d ^= (src) ^ gr_background;	\
-				d += step; }					\
-			CHECK("XOR_FGBG", *d);				\
+				DTYPE d ^= (STYPE s) ^ gr_background; \
+				d += dsz; s += ssz; }			\
 			break;								\
-		}										\
-	}
-
-/* applyOp2 with count and src/dst incr*/
-#define	applyOp4(cnt, op, s, d, type)			\
-	{											\
-		int  count = cnt;						\
-		switch (op) {							\
 		case MWROP_SRCTRANSCOPY:				\
 			while(--count >= 0) {				\
-				*d = (*d)? *d:*s;				\
-				++d; ++s; }						\
+				DTYPE d = (DTYPE d)? DTYPE d: STYPE s; \
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_XOR:						\
+		case MWROP_XOR:							\
 			while(--count >= 0) {				\
-				*d ^= (*s);						\
-				++d; ++s; }						\
-			CHECK("XOR", *d);					\
+				DTYPE d ^= STYPE s;				\
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_AND:						\
+		case MWROP_AND:							\
 			while(--count >= 0) {				\
-				*d &= (*s);						\
-				++d; ++s; }						\
-			CHECK("AND", *d);					\
+				DTYPE d &= STYPE s;				\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_OR:							\
 			while(--count >= 0) {				\
-				*d |= (*s);						\
-				++d; ++s; }						\
-			CHECK("OR", *d);					\
+				DTYPE d |= STYPE s;				\
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_SRC_OUT:					\
-		case MWROP_DST_OUT:					\
-		case MWROP_PORTERDUFF_XOR:				\
+		case MWROP_SRC_OUT:						\
+		case MWROP_DST_OUT:						\
 		case MWROP_CLEAR:						\
 			while(--count >= 0) {				\
-				*d = 0;							\
-				++d; ++s; }						\
-			CHECK("CLEAR", *d);					\
+				DTYPE d = 0;					\
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_SET:						\
+		case MWROP_SET:							\
 			while(--count >= 0) {				\
-				*d = ~0;						\
-				++d; ++s; }						\
-			CHECK("SET", *d);				\
+				DTYPE d = ~0;					\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_EQUIV:						\
 			while(--count >= 0) {				\
-				*d = ~(*d ^ (*s));				\
-				++d; ++s; }						\
-			CHECK("EQUIV", *d);					\
+				DTYPE d = ~(DTYPE d ^ STYPE s); \
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_NOR:						\
+		case MWROP_NOR:							\
 			while(--count >= 0) {				\
-				*d = ~(*d | (*s));				\
-				++d; ++s; }						\
-			CHECK("NOR", *d);					\
+				DTYPE d = ~(DTYPE d | STYPE s); \
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_NAND:						\
 			while(--count >= 0) {				\
-				*d = ~(*d & (*s));				\
-				++d; ++s; }						\
-			CHECK("NAND", *d);					\
+				DTYPE d = ~(DTYPE d & STYPE s); \
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_INVERT:						\
 			while(--count >= 0) {				\
-				*d = ~*d;						\
-				++d; ++s; }						\
-			CHECK("INVERT", *d);				\
+				DTYPE d = ~DTYPE d;				\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_COPYINVERTED:				\
 			while(--count >= 0) {				\
-				*d = ~(*s);					\
-				++d; ++s; }						\
-			CHECK("COPYINVERTED", *d);			\
+				DTYPE d = ~STYPE s;				\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_ORINVERTED:					\
 			while(--count >= 0) {				\
-				*d |= ~(*s);					\
-				++d; ++s; }						\
-			CHECK("ORINVERTED", *d);			\
+				DTYPE d |= ~STYPE s;			\
+				d += dsz; s += ssz; }			\
 			break;								\
-		case MWROP_ANDINVERTED:				\
+		case MWROP_ANDINVERTED:					\
 			while(--count >= 0) {				\
-				*d &= ~(*s);					\
-				++d; ++s;}						\
-			CHECK("ANDINVERTED", *d);			\
+				DTYPE d &= ~STYPE s;			\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_ORREVERSE:					\
 			while(--count >= 0) {				\
-				*d = ~*d | (*s);				\
-				++d; ++s; }						\
-			CHECK("ORREVERSE", *d);				\
+				DTYPE d = ~DTYPE d | STYPE s; 	\
+				d += dsz; s += ssz; }			\
 			break;								\
 		case MWROP_ANDREVERSE:					\
 			while(--count >= 0) {				\
-				*d = ~*d & (*s);				\
-				++d; ++s; }						\
-			CHECK("ANDREVERSE", *d);			\
-			break;								\
-		case MWROP_SRC_OVER:					\
-		case MWROP_SRC_IN:						\
-		case MWROP_SRC_ATOP:					\
-		case MWROP_COPY:						\
-			while(--count >= 0) {				\
-				*d = (*s);						\
-				++d; ++s; }						\
-			CHECK("COPY", *d);					\
+				DTYPE d = ~DTYPE d & STYPE s; 	\
+				d += dsz; s += ssz; }			\
 			break;								\
+		case MWROP_NOOP:						\
 		case MWROP_DST_OVER:					\
 		case MWROP_DST_IN:						\
 		case MWROP_DST_ATOP:					\
-		case MWROP_NOOP:						\
-			CHECK("NOOP", *d);					\
-			break;								\
-		case MWROP_XOR_FGBG:					\
-			while(--count >= 0) {				\
-				*d ^= (*s) ^ gr_background;		\
-				++d; ++s; }						\
-			CHECK("XOR_FGBG", *d);				\
 			break;								\
 		}										\
 	}
 
-/* applyOp w/stored dst*/
-#define	applyOp(op, src, pdst, type)		\
-	{							\
-	type d = (pdst);			\
-	switch (op) {				\
-	case MWROP_SRCTRANSCOPY:   \
-		*d = (*d)? *d:src;		\
-		break;              \
-	case MWROP_XOR:			\
-		*d ^= (src);			\
-		CHECK("XOR", *d);		\
-		break;				\
-	case MWROP_AND:			\
-		*d &= (src);			\
-		CHECK("AND", *d);		\
-		break;				\
-	case MWROP_OR:				\
-		*d |= (src);			\
-		CHECK("OR", *d);		\
-		break;				\
-	case MWROP_SRC_OUT:		\
-	case MWROP_DST_OUT:		\
-	case MWROP_PORTERDUFF_XOR:		\
-	case MWROP_CLEAR:			\
-		*d = 0;				\
-		CHECK("CLEAR", *d);		\
-		break;				\
-	case MWROP_SET:			\
-		*d = ~0;			\
-		CHECK("SET", *d);		\
-		break;				\
-	case MWROP_EQUIV:			\
-		*d = ~(*d ^ (src));		\
-		CHECK("EQUIV", *d);		\
-		break;				\
-	case MWROP_NOR:			\
-		*d = ~(*d | (src));		\
-		CHECK("NOR", *d);		\
-		break;				\
-	case MWROP_NAND:			\
-		*d = ~(*d & (src));		\
-		CHECK("NAND", *d);		\
-		break;				\
-	case MWROP_INVERT:			\
-		*d = ~*d;			\
-		CHECK("INVERT", *d);		\
-		break;				\
-	case MWROP_COPYINVERTED:		\
-		*d = ~(src);			\
-		CHECK("COPYINVERTED", *d);	\
-		break;				\
-	case MWROP_ORINVERTED:			\
-		*d |= ~(src);			\
-		CHECK("ORINVERTED", *d);	\
-		break;				\
-	case MWROP_ANDINVERTED:		\
-		*d &= ~(src);			\
-		CHECK("ANDINVERTED", *d);	\
-		break;				\
-	case MWROP_ORREVERSE:			\
-		*d = ~*d | (src);		\
-		CHECK("ORREVERSE", *d);		\
-		break;				\
-	case MWROP_ANDREVERSE:			\
-		*d = ~*d & (src);		\
-		CHECK("ANDREVERSE", *d);	\
-		break;				\
-	case MWROP_SRC_OVER:		\
-	case MWROP_SRC_IN:			\
-	case MWROP_SRC_ATOP:		\
-	case MWROP_COPY:			\
-		*d = (src);			\
-		CHECK("COPY", *d);		\
-		break;				\
-	case MWROP_DST_OVER:		\
-	case MWROP_DST_IN:			\
-	case MWROP_DST_ATOP:		\
-	case MWROP_NOOP:			\
-		CHECK("NOOP", *d);		\
-		break;				\
-	case MWROP_XOR_FGBG:		\
-		*d ^= (src) ^ gr_background;	\
-		CHECK("XOR_FGBG", *d);		\
-		break;				\
-	}					\
-}
-
-/* applyOp w/return value*/
+/* APPLYOP w/return value - used only in fblin4.c*/
 #define DEFINE_applyOpR				\
 static inline int applyOpR(op, src, dst)	\
 {						\
@@ -583,10 +242,9 @@ void fbportrait_left_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MW
 void fbportrait_left_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
 void fbportrait_left_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
-void fbportrait_left_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_left_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc);
+void fbportrait_left_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc);
+void fbportrait_left_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc);
 
 void fbportrait_right_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
 MWPIXELVAL fbportrait_right_readpixel(PSD psd, MWCOORD x, MWCOORD y);
@@ -595,10 +253,9 @@ void fbportrait_right_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, M
 void fbportrait_right_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
 void fbportrait_right_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
-void fbportrait_right_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_right_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc);
+void fbportrait_right_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc);
+void fbportrait_right_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc);
 
 void fbportrait_down_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
 MWPIXELVAL fbportrait_down_readpixel(PSD psd, MWCOORD x, MWCOORD y);
@@ -607,7 +264,6 @@ void fbportrait_down_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MW
 void fbportrait_down_fillrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2, MWPIXELVAL c);
 void fbportrait_down_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op);
-void fbportrait_down_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op);
+void fbportrait_down_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc);
+void fbportrait_down_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc);
+void fbportrait_down_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc);
diff --git a/src/drivers/fblin1.c b/src/drivers/fblin1.c
index c25a80d..407a2ed 100644
--- a/src/drivers/fblin1.c
+++ b/src/drivers/fblin1.c
@@ -233,7 +233,8 @@ static SUBDRIVER fblinear1_none = {
 	linear1_drawvertline,
 	gen_fillrect,
 	linear1_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear1_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin16.c b/src/drivers/fblin16.c
index 8083354..a47f4d0 100644
--- a/src/drivers/fblin16.c
+++ b/src/drivers/fblin16.c
@@ -1,8 +1,7 @@
 /*
  * Copyright (c) 1999, 2000, 2001, 2007 Greg Haerr <greg@censoft.com>
- * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
  *
- * 16bpp Linear Video Driver for Microwindows
+ * 16bpp Linear Video Driver for Microwindows (RGB565 or RGB555)
  *
  * Inspired from Ben Pfaff's BOGL <pfaffben@debian.org>
  */
@@ -20,19 +19,6 @@
 #include "convblit.h"
 #include "fb.h"
 
-#define USE_16BIT_ACCESS 0	/* =1 to force 16 bit display access*/
-
-#if USE_16BIT_ACCESS
-#define memcpy(d,s,nbytes)	memcpy16(d,s,(nbytes)>>1)
-#define memmove(d,s,nbytes)	memcpy16(d,s,(nbytes)>>1)
-static void
-memcpy16(unsigned short *dst, unsigned short *src, int nwords)
-{
-	while (--nwords >= 0)
-		*dst++ = *src++;
-}
-#endif
-
 /* Calc linelen and mmap size, return 0 on fail*/
 static int
 linear16_init(PSD psd)
@@ -49,6 +35,7 @@ linear16_init(PSD psd)
 static void
 linear16_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
+	register ADDR16	addr = ((ADDR16)psd->addr) + x + y * psd->linelen;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -57,13 +44,13 @@ linear16_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 #endif
 	DRAWON;
 	if(gr_mode == MWROP_COPY)
-		((ADDR16)psd->addr)[x + y * psd->linelen] = c;
+		*addr = c;
 	else
-		applyOp(gr_mode, c, &((ADDR16)psd->addr)[x + y * psd->linelen], ADDR16);
+		APPLYOP(gr_mode, 1, (MWPIXELVAL), c, *(ADDR16), addr, 0, 0);
+	DRAWOFF;
 
 	if (psd->Update)
 		psd->Update(psd, x, y, 1, 1);
-	DRAWOFF;
 }
 
 /* Read pixel at x, y*/
@@ -83,7 +70,7 @@ static void
 linear16_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	register ADDR16	addr = ((ADDR16)psd->addr) + x1 + y * psd->linelen;
-	MWCOORD X1 = x1;
+	int width = x2-x1+1;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x1 >= 0 && x1 < psd->xres);
@@ -94,21 +81,18 @@ linear16_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 #endif
 
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		/* FIXME: memsetw(dst, c, x2-x1+1)*/
-		while(x1++ <= x2)
+	if(gr_mode == MWROP_COPY)
+	{
+		int w = width;
+		while(--w >= 0)
 			*addr++ = c;
-	} else {
-		applyOp2(x2-x1+1, gr_mode, c, addr, ADDR16);
-		/*while (x1++ <= x2) {
-			applyOp(gr_mode, c, addr, ADDR16);
-			++addr;
-		}*/
 	}
+	else
+		APPLYOP(gr_mode, width, (MWPIXELVAL), c, *(ADDR32), addr, 0, 1);
+	DRAWOFF;
 
 	if (psd->Update)
-		psd->Update(psd, X1, y, x2-X1+1, 1);
-	DRAWOFF;
+		psd->Update(psd, x1, y, width, 1);
 }
 
 /* Draw a vertical line from x,y1 to x,y2 including final point*/
@@ -116,8 +100,8 @@ static void
 linear16_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	int	linelen = psd->linelen;
-	MWCOORD Y1 = y1;
 	register ADDR16	addr = ((ADDR16)psd->addr) + x + y1 * linelen;
+	int height = y2-y1+1;
 #if DEBUG
 	assert (addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -128,377 +112,21 @@ linear16_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 #endif
 
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(y1++ <= y2) {
+	if(gr_mode == MWROP_COPY)
+	{
+		int h = height;
+		while (--h >= 0)
+		{
 			*addr = c;
 			addr += linelen;
 		}
-	} else {
-		applyOp3(y2-y1+1, linelen, gr_mode, c, addr, ADDR16);
-		/*while (y1++ <= y2) {
-			applyOp(gr_mode, c, addr, ADDR16);
-			addr += linelen;
-		}*/
 	}
-
-	if (psd->Update)
-		psd->Update(psd, x, Y1, 1, y2-Y1+1);
-	DRAWOFF;
-}
-
-/* srccopy bitblt*/
-static void
-linear16_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
-	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
-{
-	ADDR16	dst = dstpsd->addr;
-	ADDR16	src = srcpsd->addr;
-	int	i;
-	int	dlinelen = dstpsd->linelen;
-	int	slinelen = srcpsd->linelen;
-	int H = h;
-#if DEBUG
-	assert (dst != 0);
-	assert (dstx >= 0 && dstx < dstpsd->xres);
-	assert (dsty >= 0 && dsty < dstpsd->yres);
-	assert (w > 0);
-	assert (h > 0);
-	assert (src != 0);
-	assert (srcx >= 0 && srcx < srcpsd->xres);
-	assert (srcy >= 0 && srcy < srcpsd->yres);
-	assert (dstx+w <= dstpsd->xres);
-	assert (dsty+h <= dstpsd->yres);
-	assert (srcx+w <= srcpsd->xres);
-	assert (srcy+h <= srcpsd->yres);
-#endif
-	dst += dstx + dsty * dlinelen;
-	src += srcx + srcy * slinelen;
-
-	DRAWON;
-
-	if (op == MWROP_BLENDCONSTANT) {
-	unsigned int alpha = 150;
-
-	if (dstpsd->pixtype == MWPF_TRUECOLOR565) {
-		while(--h >= 0) {
-			for(i=0; i<w; ++i) {
-				unsigned int s = *src++;
-				unsigned int d = *dst;
-				unsigned int t = d & 0xf800;
-				unsigned int m1, m2, m3;
-				m1 = (((((s & 0xf800) - t)*alpha)>>8) & 0xf800) + t;
-				t = d & 0x07e0;
-				m2 = (((((s & 0x07e0) - t)*alpha)>>8) & 0x07e0) + t;
-				t = d & 0x001f;
-				m3 = (((((s & 0x001f) - t)*alpha)>>8) & 0x001f) + t;
-				*dst++ = m1 | m2 | m3;
-			}
-			dst += dlinelen - w;
-			src += slinelen - w;
-		}
-	} else {
-		/* 5/5/5 format*/
-		while(--h >= 0) {
-			for(i=0; i<w; ++i) {
-				unsigned int s = *src++;
-				unsigned int d = *dst;
-				unsigned int t = d & 0x7c00;
-				unsigned int m1, m2, m3;
-				m1 = (((((s & 0x7c00) - t)*alpha)>>8) & 0x7c00) + t;
-				t = d & 0x03e0;
-				m2 = (((((s & 0x03e0) - t)*alpha)>>8) & 0x03e0) + t;
-				t = d & 0x001f;
-				m3 = (((((s & 0x001f) - t)*alpha)>>8) & 0x001f) + t;
-				*dst++ = m1 | m2 | m3;
-			}
-			dst += dlinelen - w;
-			src += slinelen - w;
-		}
-	}
-	} else if (op == MWROP_COPY) {
-		/* copy from bottom up if dst in src rectangle*/
-		/* memmove is used to handle x case*/
-		if (srcy < dsty) {
-			src += (h-1) * slinelen;
-			dst += (h-1) * dlinelen;
-			slinelen *= -1;
-			dlinelen *= -1;
-		}
-		while (--h >= 0) {
-			/* a _fast_ memcpy is a _must_ in this routine*/
-			memmove(dst, src, w<<1);
-			dst += dlinelen;
-			src += slinelen;
-		}
-	} else {
-		while (--h >= 0) {
-			applyOp4(w, op, src, dst, ADDR16);
-			dst += dlinelen - w;
-			src += slinelen - w;
-		}
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dstx, dsty, w, H);
+	else
+		APPLYOP(gr_mode, height, (MWPIXELVAL), c, *(ADDR16), addr, 0, linelen);
 	DRAWOFF;
-}
-
-/*
- * This stretchblit code was originally written for the TriMedia
- * VLIW CPU.  Therefore it uses RESTRICT pointers, and the special
- * one-assembler-opcode pseudo-functions SIGN and ABS.
- *
- * (The 'restrict' extension is in C99, so for a C99 compiler you
- * could "#define RESTRICT restrict" or put
- * "CFLAGS += -DRESTRICT=restrict" in the makefile).
- *
- * Compatibility definitions:
- */
-#ifndef RESTRICT
-#define RESTRICT
-#endif
-#ifndef SIGN
-#define SIGN(x) (((x) > 0) ? 1 : (((x) == 0) ? 0 : -1))
-#endif
-#ifndef ABS
-#define ABS(x) (((x) >= 0) ? (x) : -(x))
-#endif
-
-/* Blit a 16-bit image.
- * Can stretch the image by any X and/or Y scale factor.
- * Can flip the image in the X and/or Y axis.
- *
- * This is the faster version with no per-pixel multiply and a single
- * decision tree for the inner loop, by Jon.  Based on Alex's original
- * all-integer version.
- *
- * Paramaters:
- * srf              - Dest surface
- * dest_x_start
- * dest_y_start    - Top left corner of dest rectangle
- * width, height   - Size in dest co-ordinates.
- * x_denominator   - Denominator for source X value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * y_denominator   - Denominator for source Y value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * src_x_fraction  -
- * src_y_fraction  - Point in source that corresponds to the top left corner
- *                   of the pixel (dest_x_start, dest_y_start).  This is a
- *                   fraction - to get a float, divide by y_denominator.
- * x_step_fraction - X step in src for an "x++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   x_denominator for a float.
- * y_step_fraction - Y step in src for a  "y++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   y_denominator for a float.
- * image           - Source image.
- * op              - Raster operation, currently ignored.
- */
-static void
-linear16_stretchblitex(PSD dstpsd,
-			 PSD srcpsd,
-			 MWCOORD dest_x_start,
-			 MWCOORD dest_y_start,
-			 MWCOORD width,
-			 MWCOORD height,
-			 int x_denominator,
-			 int y_denominator,
-			 int src_x_fraction,
-			 int src_y_fraction,
-			 int x_step_fraction,
-			 int y_step_fraction,
-			 int op)
-{
-	/* Pointer to the current pixel in the source image */
-	unsigned short *RESTRICT src_ptr;
-
-	/* Pointer to x=xs1 on the next line in the source image */
-	unsigned short *RESTRICT next_src_ptr;
-
-	/* Pointer to the current pixel in the dest image */
-	unsigned short *RESTRICT dest_ptr;
-
-	/* Pointer to x=xd1 on the next line in the dest image */
-	unsigned short *next_dest_ptr;
-
-	/* Keep track of error in the source co-ordinates */
-	int x_error;
-	int y_error;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_one;
-	int src_y_step_one;
-
-	/* normal steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_normal;
-	int src_y_step_normal;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int x_error_step_normal;
-	int y_error_step_normal;
-
-	/* Countdown to the end of the destination image */
-	int x_count;
-	int y_count;
-
-	/* Start position in source, in whole pixels */
-	int src_x_start;
-	int src_y_start;
-
-	/* Error values for start X position in source */
-	int x_error_start;
-
-	/* 1-unit step down dest, in bytes. */
-	int dest_y_step;
-
-	/*DPRINTF("Nano-X: linear32_stretchflipblit( dest=(%d,%d) %dx%d )\n",
-	       dest_x_start, dest_y_start, width, height);*/
-
-	/* We add half a dest pixel here so we're sampling from the middle of
-	 * the dest pixel, not the top left corner.
-	 */
-	src_x_fraction += (x_step_fraction >> 1);
-	src_y_fraction += (y_step_fraction >> 1);
-
-	/* Seperate the whole part from the fractions.
-	 *
-	 * Also, We need to do lots of comparisons to see if error values are
-	 * >= x_denominator.  So subtract an extra x_denominator for speed - then
-	 * we can just check if it's >= 0.
-	 */
-	src_x_start = src_x_fraction / x_denominator;
-	src_y_start = src_y_fraction / y_denominator;
-	x_error_start = src_x_fraction - (src_x_start + 1) * x_denominator;
-	y_error = src_y_fraction - (src_y_start + 1) * y_denominator;
-
-	/* precalculate various deltas */
-
-	src_x_step_normal = x_step_fraction / x_denominator;
-	src_x_step_one = SIGN(x_step_fraction);
-	x_error_step_normal = ABS(x_step_fraction) - ABS(src_x_step_normal) * x_denominator;
-
-	src_y_step_normal = y_step_fraction / y_denominator;
-	src_y_step_one = SIGN(y_step_fraction) * srcpsd->linelen;
-	y_error_step_normal = ABS(y_step_fraction) - ABS(src_y_step_normal) * y_denominator;
-	src_y_step_normal *= srcpsd->linelen;
-
-	/* DPRINTF("linear16_stretchblitex: X: One step=%d, err-=%d; normal step=%d, err+=%d\n"
-	   "Y: One step=%d, err-=%d; normal step=%d, err+=%d\n",
-	   src_x_step_one, x_denominator, src_x_step_normal, x_error_step_normal,
-	   src_y_step_one, y_denominator, src_y_step_normal, y_error_step_normal);
-	 */
-
-	/* Pointer to the first source pixel */
-	next_src_ptr = ((unsigned short *) srcpsd->addr) + src_y_start * srcpsd->linelen + src_x_start;
-
-	/* Cache the width of a scanline in dest */
-	dest_y_step = dstpsd->linelen;
 
-	/* Pointer to the first dest pixel */
-	next_dest_ptr = ((unsigned short *) dstpsd->addr) + (dest_y_start * dest_y_step) + dest_x_start;
-
-	/*
-	 * Note: The MWROP_SRC case below is a simple expansion of the
-	 * default case.  It can be removed without significant speed
-	 * penalty if you need to reduce code size.
-	 *
-	 * The MWROP_CLEAR case could be removed.  But it is a large
-	 * speed increase for a small quantity of code.
-	 */
-	switch (op) {
-	case MWROP_SRC:
-		/* Benchmarking shows that this while loop is faster than the equivalent
-		 * for loop: for(y_count=0; y_count<height; y_count++) { ... }
-		 */
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = *src_ptr;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-
-	case MWROP_CLEAR:
-		y_count = height;
-		while (y_count-- > 0) {
-			dest_ptr = next_dest_ptr;
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = 0;
-			}
-			next_dest_ptr += dest_y_step;
-		}
-		break;
-
-	default:
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				applyOp(op, *src_ptr, dest_ptr, ADDR16);
-				dest_ptr++;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dest_x_start, dest_y_start, width, height);
+	if (psd->Update)
+		psd->Update(psd, x, y1, 1, height);
 }
 
 static SUBDRIVER fblinear16_none = {
@@ -508,8 +136,9 @@ static SUBDRIVER fblinear16_none = {
 	linear16_drawhorzline,
 	linear16_drawvertline,
 	gen_fillrect,
-	linear16_blit,
-	linear16_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_16bpp,
+	frameblit_stretch_16bpp,
 	convblit_copy_mask_mono_byte_msb_16bpp,		/* ft2 non-alias*/
 	convblit_copy_mask_mono_byte_lsb_16bpp,		/* t1 non-alias*/
 	convblit_copy_mask_mono_word_msb_16bpp,		/* core/pcf non-alias*/
@@ -526,8 +155,9 @@ static SUBDRIVER fblinear16_left = {
 	fbportrait_left_drawhorzline,
 	fbportrait_left_drawvertline,
 	fbportrait_left_fillrect,
-	fbportrait_left_blit,
-	fbportrait_left_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_16bpp,
+	frameblit_stretch_16bpp,
 	convblit_copy_mask_mono_byte_msb_16bpp,
 	convblit_copy_mask_mono_byte_lsb_16bpp,
 	convblit_copy_mask_mono_word_msb_16bpp,
@@ -544,8 +174,9 @@ static SUBDRIVER fblinear16_right = {
 	fbportrait_right_drawhorzline,
 	fbportrait_right_drawvertline,
 	fbportrait_right_fillrect,
-	fbportrait_right_blit,
-	fbportrait_right_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_16bpp,
+	frameblit_stretch_16bpp,
 	convblit_copy_mask_mono_byte_msb_16bpp,
 	convblit_copy_mask_mono_byte_lsb_16bpp,
 	convblit_copy_mask_mono_word_msb_16bpp,
@@ -562,8 +193,9 @@ static SUBDRIVER fblinear16_down = {
 	fbportrait_down_drawhorzline,
 	fbportrait_down_drawvertline,
 	fbportrait_down_fillrect,
-	fbportrait_down_blit,
-	fbportrait_down_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_16bpp,
+	frameblit_stretch_16bpp,
 	convblit_copy_mask_mono_byte_msb_16bpp,
 	convblit_copy_mask_mono_byte_lsb_16bpp,
 	convblit_copy_mask_mono_word_msb_16bpp,
diff --git a/src/drivers/fblin1rev.c b/src/drivers/fblin1rev.c
index 52dba30..757f80a 100644
--- a/src/drivers/fblin1rev.c
+++ b/src/drivers/fblin1rev.c
@@ -236,7 +236,8 @@ static SUBDRIVER fblinear1_none = {
 	linear1_drawvertline,
 	gen_fillrect,
 	linear1_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear1_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin2.c b/src/drivers/fblin2.c
index 85a52ce..ccbc4b0 100644
--- a/src/drivers/fblin2.c
+++ b/src/drivers/fblin2.c
@@ -232,7 +232,8 @@ static SUBDRIVER fblinear2_none = {
 	linear2_drawvertline,
 	gen_fillrect,
 	linear2_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear2_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin24.c b/src/drivers/fblin24.c
index 29ef501..64bcae9 100644
--- a/src/drivers/fblin24.c
+++ b/src/drivers/fblin24.c
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 2000, 2001, 2010 Greg Haerr <greg@censoft.com>
- * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
  *
  * 24bpp Linear Video Driver for Microwindows (BGR byte order)
  * Writes memory image: |B|G|R| MWPF_TRUECOLOR888
@@ -28,44 +27,44 @@ linear24_init(PSD psd)
 static void
 linear24_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
-	ADDR8	addr = psd->addr;
-	MWUCHAR	r, g, b;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x + y * psd->linelen) * 3;
+	MWUCHAR r = PIXEL888RED(c);
+	MWUCHAR g = PIXEL888GREEN(c);
+	MWUCHAR b = PIXEL888BLUE(c);
 #if DEBUG
-	assert (addr != 0);
+	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
 	assert (y >= 0 && y < psd->yres);
 #endif
-	r = PIXEL888RED(c);
-	g = PIXEL888GREEN(c);
-	b = PIXEL888BLUE(c);
-	addr += (x + y * psd->linelen) * 3;
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		*addr++ = b;
-		*addr++ = g;
-		*addr = r;
-	} else {
-		applyOp(gr_mode, b, addr, ADDR8); ++addr;
-		applyOp(gr_mode, g, addr, ADDR8); ++addr;
-		applyOp(gr_mode, r, addr, ADDR8);
+	if(gr_mode == MWROP_COPY)
+	{
+		addr[0] = b;
+		addr[1] = g;
+		addr[2] = r;
+	}
+	else
+	{
+		APPLYOP(gr_mode, 1, (MWUCHAR), b, *(ADDR8), addr, 0, 1);
+		APPLYOP(gr_mode, 1, (MWUCHAR), g, *(ADDR8), addr, 0, 1);
+		APPLYOP(gr_mode, 1, (MWUCHAR), r, *(ADDR8), addr, 0, 1);
 	}
+	DRAWOFF;
 
 	if (psd->Update)
 		psd->Update(psd, x, y, 1, 1);
-	DRAWOFF;
 }
 
 /* Read pixel at x, y*/
 static MWPIXELVAL
 linear24_readpixel(PSD psd, MWCOORD x, MWCOORD y)
 {
-	ADDR8	addr = psd->addr;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x + y * psd->linelen) * 3;
 #if DEBUG
-	assert (addr != 0);
+	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
 	assert (y >= 0 && y < psd->yres);
 #endif
-	addr += (x + y * psd->linelen) * 3;
 	return RGB2PIXEL888(addr[2], addr[1], addr[0]);
 }
 
@@ -73,48 +72,53 @@ linear24_readpixel(PSD psd, MWCOORD x, MWCOORD y)
 static void
 linear24_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
-	ADDR8	addr = psd->addr;
-	MWUCHAR	r, g, b;
-	MWCOORD X1 = x1;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x1 + y * psd->linelen) * 3;
+	MWUCHAR r = PIXEL888RED(c);
+	MWUCHAR g = PIXEL888GREEN(c);
+	MWUCHAR b = PIXEL888BLUE(c);
+	int w = x2-x1+1;
 #if DEBUG
-	assert (addr != 0);
+	assert (psd->addr != 0);
 	assert (x1 >= 0 && x1 < psd->xres);
 	assert (x2 >= 0 && x2 < psd->xres);
 	assert (x2 >= x1);
 	assert (y >= 0 && y < psd->yres);
 #endif
-	r = PIXEL888RED(c);
-	g = PIXEL888GREEN(c);
-	b = PIXEL888BLUE(c);
-	addr += (x1 + y * psd->linelen) * 3;
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(x1++ <= x2) {
+	if(gr_mode == MWROP_COPY)
+	{
+		while(--w >= 0)
+		{
 			*addr++ = b;
 			*addr++ = g;
 			*addr++ = r;
 		}
-	} else {
-		while (x1++ <= x2) {
-			applyOp(gr_mode, b, addr, ADDR8); ++addr;
-			applyOp(gr_mode, g, addr, ADDR8); ++addr;
-			applyOp(gr_mode, r, addr, ADDR8); ++addr;
+	}
+	else
+	{
+		while(--w >= 0)
+		{
+			APPLYOP(gr_mode, 1, (MWUCHAR), b, *(ADDR8), addr, 0, 1);
+			APPLYOP(gr_mode, 1, (MWUCHAR), g, *(ADDR8), addr, 0, 1);
+			APPLYOP(gr_mode, 1, (MWUCHAR), r, *(ADDR8), addr, 0, 1);
 		}
 	}
+	DRAWOFF;
 
 	if (psd->Update)
-		psd->Update(psd, X1, y, x2-X1+1, 1);
-	DRAWOFF;
+		psd->Update(psd, x1, y, x2-x1+1, 1);
 }
 
 /* Draw a vertical line from x,y1 to x,y2 including final point*/
 static void
 linear24_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
-	ADDR8	addr = psd->addr;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x + y1 * psd->linelen) * 3;
 	int	linelen = psd->linelen * 3;
-	MWUCHAR	r, g, b;
-	MWCOORD Y1 = y1;
+	MWUCHAR r = PIXEL888RED(c);
+	MWUCHAR g = PIXEL888GREEN(c);
+	MWUCHAR b = PIXEL888BLUE(c);
+	int height = y2-y1+1;
 #if DEBUG
 	assert (addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -122,378 +126,31 @@ linear24_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 	assert (y2 >= 0 && y2 < psd->yres);
 	assert (y2 >= y1);
 #endif
-	r = PIXEL888RED(c);
-	g = PIXEL888GREEN(c);
-	b = PIXEL888BLUE(c);
-	addr += (x + y1 * psd->linelen) * 3;
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(y1++ <= y2) {
+	if(gr_mode == MWROP_COPY)
+	{
+		while (--height >= 0)
+		{
 			addr[0] = b;
 			addr[1] = g;
 			addr[2] = r;
 			addr += linelen;
 		}
-	} else {
-		while (y1++ <= y2) {
-			applyOp(gr_mode, b, &addr[0], ADDR8);
-			applyOp(gr_mode, g, &addr[1], ADDR8);
-			applyOp(gr_mode, r, &addr[2], ADDR8);
-			addr += linelen;
-		}
 	}
-
-	if (psd->Update)
-		psd->Update(psd, x, Y1, 1, y2-Y1+1);
-	DRAWOFF;
-}
-
-/* srccopy bitblt, opcode is currently ignored*/
-static void
-linear24_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
-	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
-{
-	ADDR8	dst = dstpsd->addr;
-	ADDR8	src = srcpsd->addr;
-	int	i;
-	int	dlinelen = dstpsd->linelen * 3;
-	int	slinelen = srcpsd->linelen * 3;
-	int	dlinelen_minus_w = (dstpsd->linelen - w) * 3;
-	int	slinelen_minus_w = (srcpsd->linelen - w) * 3;
-	int H = h;
-#if DEBUG
-	assert (dst != 0);
-	assert (dstx >= 0 && dstx < dstpsd->xres);
-	assert (dsty >= 0 && dsty < dstpsd->yres);
-	assert (w > 0);
-	assert (h > 0);
-	assert (src != 0);
-	assert (srcx >= 0 && srcx < srcpsd->xres);
-	assert (srcy >= 0 && srcy < srcpsd->yres);
-	assert (dstx+w <= dstpsd->xres);
-	assert (dsty+h <= dstpsd->yres);
-	assert (srcx+w <= srcpsd->xres);
-	assert (srcy+h <= srcpsd->yres);
-#endif
-	DRAWON;
-	dst += (dstx + dsty * dstpsd->linelen) * 3;
-	src += (srcx + srcy * srcpsd->linelen) * 3;
-
-	if (op == MWROP_BLENDCONSTANT) {
-	uint32_t alpha = 150;
-
-	while(--h >= 0) {
-		for(i=0; i<w; ++i) {
-			if (alpha != 0) {
-				register uint32_t pd = *dst;
-				*dst++ = muldiv255(alpha, *src++ - pd) + pd;
-				pd = *dst;
-				*dst++ = muldiv255(alpha, *src++ - pd) + pd;
-				pd = *dst;
-				*dst++ = muldiv255(alpha, *src++ - pd) + pd;
-			} else {
-				dst += 3;
-				src += 3;
-			}
-		}
-		dst += dlinelen_minus_w;
-		src += slinelen_minus_w;
-	}
-	} else if (op == MWROP_COPY) {
-		/* copy from bottom up if dst in src rectangle*/
-		/* memmove is used to handle x case*/
-		if (srcy < dsty) {
-			src += (h-1) * slinelen;
-			dst += (h-1) * dlinelen;
-			slinelen *= -1;
-			dlinelen *= -1;
-		}
-		while(--h >= 0) {
-			/* a _fast_ memcpy is a _must_ in this routine*/
-			memmove(dst, src, w*3);
-			dst += dlinelen;
-			src += slinelen;
-		}
-	} else {
-		while (--h >= 0) {
-			applyOp4(w*3, op, src, dst, ADDR8);
-			dst += dlinelen_minus_w;
-			src += slinelen_minus_w;
+	else
+	{
+		while (--height >= 0)
+		{
+			APPLYOP(gr_mode, 1, (MWUCHAR), b, *(ADDR8), addr, 0, 1);
+			APPLYOP(gr_mode, 1, (MWUCHAR), g, *(ADDR8), addr, 0, 1);
+			APPLYOP(gr_mode, 1, (MWUCHAR), r, *(ADDR8), addr, 0, 1);
+			addr += linelen - 3;
 		}
 	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dstx, dsty, w, H);
 	DRAWOFF;
-}
-
-/*
- * This stretchblit code was originally written for the TriMedia
- * VLIW CPU.  Therefore it uses RESTRICT pointers, and the special
- * one-assembler-opcode pseudo-functions SIGN and ABS.
- *
- * (The 'restrict' extension is in C99, so for a C99 compiler you
- * could "#define RESTRICT restrict" or put
- * "CFLAGS += -DRESTRICT=restrict" in the makefile).
- *
- * Compatibility definitions:
- */
-#ifndef RESTRICT
-#define RESTRICT
-#endif
-#ifndef SIGN
-#define SIGN(x) (((x) > 0) ? 1 : (((x) == 0) ? 0 : -1))
-#endif
-#ifndef ABS
-#define ABS(x) (((x) >= 0) ? (x) : -(x))
-#endif
-
-/* Blit a 24-bit image.
- * Can stretch the image by any X and/or Y scale factor.
- * Can flip the image in the X and/or Y axis.
- *
- * This is the faster version with no per-pixel multiply and a single
- * decision tree for the inner loop, by Jon.  Based on Alex's original
- * all-integer version.
- *
- * Paramaters:
- * srf              - Dest surface
- * dest_x_start
- * dest_y_start    - Top left corner of dest rectangle
- * width, height   - Size in dest co-ordinates.
- * x_denominator   - Denominator for source X value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * y_denominator   - Denominator for source Y value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * src_x_fraction  -
- * src_y_fraction  - Point in source that corresponds to the top left corner
- *                   of the pixel (dest_x_start, dest_y_start).  This is a
- *                   fraction - to get a float, divide by y_denominator.
- * x_step_fraction - X step in src for an "x++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   x_denominator for a float.
- * y_step_fraction - Y step in src for a  "y++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   y_denominator for a float.
- * image           - Source image.
- * op              - Raster operation, currently ignored.
- */
-static void
-linear24_stretchblitex(PSD dstpsd,
-			 PSD srcpsd,
-			 MWCOORD dest_x_start,
-			 MWCOORD dest_y_start,
-			 MWCOORD width,
-			 MWCOORD height,
-			 int x_denominator,
-			 int y_denominator,
-			 int src_x_fraction,
-			 int src_y_fraction,
-			 int x_step_fraction,
-			 int y_step_fraction,
-			 int op)
-{
-	/* Pointer to the current pixel in the source image */
-	unsigned char *RESTRICT src_ptr;
 
-	/* Pointer to x=xs1 on the next line in the source image */
-	unsigned char *RESTRICT next_src_ptr;
-
-	/* Pointer to the current pixel in the dest image */
-	unsigned char *RESTRICT dest_ptr;
-
-	/* Pointer to x=xd1 on the next line in the dest image */
-	unsigned char *next_dest_ptr;
-
-	/* Keep track of error in the source co-ordinates */
-	int x_error;
-	int y_error;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_one;
-	int src_y_step_one;
-
-	/* normal steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_normal;
-	int src_y_step_normal;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int x_error_step_normal;
-	int y_error_step_normal;
-
-	/* Countdown to the end of the destination image */
-	int x_count;
-	int y_count;
-
-	/* Start position in source, in whole pixels */
-	int src_x_start;
-	int src_y_start;
-
-	/* Error values for start X position in source */
-	int x_error_start;
-
-	/* 1-unit step down dest, in bytes. */
-	int dest_y_step;
-
-	/*DPRINTF("Nano-X: linear24_stretchflipblit( dest=(%d,%d) %dx%d )\n",
-	       dest_x_start, dest_y_start, width, height);*/
-
-	/* We add half a dest pixel here so we're sampling from the middle of
-	 * the dest pixel, not the top left corner.
-	 */
-	src_x_fraction += (x_step_fraction >> 1);
-	src_y_fraction += (y_step_fraction >> 1);
-
-	/* Seperate the whole part from the fractions.
-	 *
-	 * Also, We need to do lots of comparisons to see if error values are
-	 * >= x_denominator.  So subtract an extra x_denominator for speed - then
-	 * we can just check if it's >= 0.
-	 */
-	src_x_start = src_x_fraction / x_denominator;
-	src_y_start = src_y_fraction / y_denominator;
-	x_error_start = src_x_fraction - (src_x_start + 1) * x_denominator;
-	y_error = src_y_fraction - (src_y_start + 1) * y_denominator;
-
-	/* precalculate various deltas */
-
-	src_x_step_normal = x_step_fraction / x_denominator;
-	src_x_step_one = SIGN(x_step_fraction);
-	x_error_step_normal = ABS(x_step_fraction) - ABS(src_x_step_normal) * x_denominator;
-
-	src_y_step_normal = y_step_fraction / y_denominator;
-	src_y_step_one = SIGN(y_step_fraction) * srcpsd->linelen;
-	y_error_step_normal = ABS(y_step_fraction) - ABS(src_y_step_normal) * y_denominator;
-	src_y_step_normal *= srcpsd->linelen;
-
-	/* DPRINTF("linear24_stretchblitex: X: One step=%d, err-=%d; normal step=%d, err+=%d\n"
-		"Y: One step=%d, err-=%d; normal step=%d, err+=%d\n",
-	   src_x_step_one, x_denominator, src_x_step_normal, x_error_step_normal,
-	   src_y_step_one, y_denominator, src_y_step_normal, y_error_step_normal);
-	 */
-
-	/* Pointer to the first source pixel */
-	next_src_ptr = ((unsigned char *) srcpsd->addr) + 3 * (src_y_start * srcpsd->linelen + src_x_start);
-
-	/* Cache the width of a scanline in dest */
-	dest_y_step = dstpsd->linelen;
-
-	/* Pointer to the first dest pixel */
-	next_dest_ptr = ((unsigned char *) dstpsd->addr) + 3 * (dest_y_start * dest_y_step + dest_x_start);
-
-	/* Convert from pixels to bytes (only for this 24bpp mode) */
-	src_x_step_normal *= 3;
-	src_x_step_one *= 3;
-	src_y_step_normal *= 3;
-	src_y_step_one *= 3;
-
-	/*
-	 * Note: The MWROP_SRC case below is a simple expansion of the
-	 * default case.  It can be removed without significant speed
-	 * penalty if you need to reduce code size.
-	 *
-	 * The MWROP_CLEAR case could be removed.  But it is a large
-	 * speed increase for a small quantity of code.
-	 */
-	switch (op) {
-	case MWROP_SRC:
-		/* Benchmarking shows that this while loop is faster than the equivalent
-		 * for loop: for(y_count=0; y_count<height; y_count++) { ... }
-		 */
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = src_ptr[0];
-				*dest_ptr++ = src_ptr[1];
-				*dest_ptr++ = src_ptr[2];
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-
-	case MWROP_CLEAR:
-		y_count = height;
-		while (y_count-- > 0) {
-			dest_ptr = next_dest_ptr;
-			x_count = width * 3;
-			while (x_count-- > 0) {
-				*dest_ptr++ = 0;
-			}
-			next_dest_ptr += dest_y_step;
-		}
-		break;
-
-	default:
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				applyOp(op, src_ptr[0], dest_ptr, ADDR8);
-				dest_ptr++;
-				applyOp(op, src_ptr[1], dest_ptr, ADDR8);
-				dest_ptr++;
-				applyOp(op, src_ptr[2], dest_ptr, ADDR8);
-				dest_ptr++;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dest_x_start, dest_y_start, width, height);
+	if (psd->Update)
+		psd->Update(psd, x, y1, 1, y2-y1+1);
 }
 
 static SUBDRIVER fblinear24_none = {
@@ -503,8 +160,9 @@ static SUBDRIVER fblinear24_none = {
 	linear24_drawhorzline,
 	linear24_drawvertline,
 	gen_fillrect,
-	linear24_blit,
-	linear24_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_24bpp,
+	frameblit_stretch_24bpp,
 	convblit_copy_mask_mono_byte_msb_bgr,		/* ft2 non-alias*/
 	convblit_copy_mask_mono_byte_lsb_bgr,		/* t1 non-alias*/
 	convblit_copy_mask_mono_word_msb_bgr,		/* core/pcf non-alias*/
@@ -521,8 +179,9 @@ static SUBDRIVER fblinear24_left = {
 	fbportrait_left_drawhorzline,
 	fbportrait_left_drawvertline,
 	fbportrait_left_fillrect,
-	fbportrait_left_blit,
-	fbportrait_left_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_24bpp,
+	frameblit_stretch_24bpp,
 	convblit_copy_mask_mono_byte_msb_bgr,
 	convblit_copy_mask_mono_byte_lsb_bgr,
 	convblit_copy_mask_mono_word_msb_bgr,
@@ -539,8 +198,9 @@ static SUBDRIVER fblinear24_right = {
 	fbportrait_right_drawhorzline,
 	fbportrait_right_drawvertline,
 	fbportrait_right_fillrect,
-	fbportrait_right_blit,
-	fbportrait_right_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_24bpp,
+	frameblit_stretch_24bpp,
 	convblit_copy_mask_mono_byte_msb_bgr,
 	convblit_copy_mask_mono_byte_lsb_bgr,
 	convblit_copy_mask_mono_word_msb_bgr,
@@ -557,8 +217,9 @@ static SUBDRIVER fblinear24_down = {
 	fbportrait_down_drawhorzline,
 	fbportrait_down_drawvertline,
 	fbportrait_down_fillrect,
-	fbportrait_down_blit,
-	fbportrait_down_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_24bpp,
+	frameblit_stretch_24bpp,
 	convblit_copy_mask_mono_byte_msb_bgr,
 	convblit_copy_mask_mono_byte_lsb_bgr,
 	convblit_copy_mask_mono_word_msb_bgr,
diff --git a/src/drivers/fblin2rev.c b/src/drivers/fblin2rev.c
index e8ce444..831470f 100644
--- a/src/drivers/fblin2rev.c
+++ b/src/drivers/fblin2rev.c
@@ -232,7 +232,8 @@ static SUBDRIVER fblinear2_none = {
 	linear2_drawvertline,
 	gen_fillrect,
 	linear2_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear2_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin32.c b/src/drivers/fblin32.c
index 9238600..ee4ef23 100644
--- a/src/drivers/fblin32.c
+++ b/src/drivers/fblin32.c
@@ -1,6 +1,5 @@
 /*
  * Copyright (c) 1999, 2000, 2001, 2010 Greg Haerr <greg@censoft.com>
- * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
  *
  * 32bpp Linear Video Driver for Microwindows (BGRA or RGBA byte order)
  * Writes memory image: |B|G|R|A| LE 0xARGB BE 0xBGRA MWPF_TRUECOLOR8888
@@ -31,6 +30,7 @@ linear32_init(PSD psd)
 static void
 linear32_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
+	register ADDR32	addr = ((ADDR32)psd->addr) + x + y * psd->linelen;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -38,9 +38,9 @@ linear32_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 #endif
 	DRAWON;
 	if (gr_mode == MWROP_COPY)
-		((ADDR32)psd->addr)[x + y * psd->linelen] = c;
+		*addr = c;
 	else
-		applyOp(gr_mode, c, &((ADDR32)psd->addr)[x + y * psd->linelen], ADDR32);
+		APPLYOP(gr_mode, 1, (MWPIXELVAL), c, *(ADDR32), addr, 0, 0);
 	DRAWOFF;
 
 	if (psd->Update)
@@ -64,7 +64,7 @@ static void
 linear32_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
 	register ADDR32	addr = ((ADDR32)psd->addr) + x1 + y * psd->linelen;
-	MWCOORD X1 = x1;
+	int width = x2-x1+1;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x1 >= 0 && x1 < psd->xres);
@@ -73,19 +73,18 @@ linear32_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 	assert (y >= 0 && y < psd->yres);
 #endif
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(x1++ <= x2)		/* memsetl(addr, c, x2-x1+1)*/
+	if(gr_mode == MWROP_COPY)
+	{
+		int w = width;
+		while(--w >= 0)
 			*addr++ = c;
-	} else {
-		while(x1++ <= x2) {
-			applyOp(gr_mode, c, addr, ADDR32);
-			++addr;
-		}
 	}
+	else
+		APPLYOP(gr_mode, width, (MWPIXELVAL), c, *(ADDR32), addr, 0, 1);
 	DRAWOFF;
 
 	if (psd->Update)
-		psd->Update(psd, X1, y, x2-X1+1, 1);
+		psd->Update(psd, x1, y, width, 1);
 }
 
 /* Draw a vertical line from x,y1 to x,y2 including final point*/
@@ -93,8 +92,8 @@ static void
 linear32_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	int	linelen = psd->linelen;
-	MWCOORD Y1 = y1;
 	register ADDR32	addr = ((ADDR32)psd->addr) + x + y1 * linelen;
+	int height = y2-y1+1;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -103,428 +102,21 @@ linear32_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 	assert (y2 >= y1);
 #endif
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(y1++ <= y2) {
+	if(gr_mode == MWROP_COPY)
+	{
+		int h = height;
+		while (--h >= 0)
+		{
 			*addr = c;
 			addr += linelen;
 		}
-	} else {
-		while(y1++ <= y2) {
-			applyOp(gr_mode, c, addr, ADDR32);
-			addr += linelen;
-		}
-	}
-
-	if (psd->Update)
-		psd->Update(psd, x, Y1, 1, y2-Y1+1);
-	DRAWOFF;
-}
-
-/* srccopy bitblt*/
-static void
-linear32_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
-	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
-{
-	ADDR8	dst8, src8;
-	ADDR32	dst = dstpsd->addr;
-	ADDR32	src = srcpsd->addr;
-	int	i;
-	int	dlinelen = dstpsd->linelen;
-	int	slinelen = srcpsd->linelen;
-	int	dlinelen_minus_w4;
-	int	slinelen_minus_w4;
-	int	H = h;
-#if DEBUG
-	assert (dst != 0);
-	assert (dstx >= 0 && dstx < dstpsd->xres);
-	assert (dsty >= 0 && dsty < dstpsd->yres);
-	assert (w > 0);
-	assert (h > 0);
-	assert (src != 0);
-	assert (srcx >= 0 && srcx < srcpsd->xres);
-	assert (srcy >= 0 && srcy < srcpsd->yres);
-	assert (dstx+w <= dstpsd->xres);
-	assert (dsty+h <= dstpsd->yres);
-	assert (srcx+w <= srcpsd->xres);
-	assert (srcy+h <= srcpsd->yres);
-#endif
-	dst += dstx + dsty * dlinelen;
-	src += srcx + srcy * slinelen;
-
-	DRAWON;
-
-	if (op == MWROP_BLENDCONSTANT) {
-	uint32_t alpha = 150;
-
-	dlinelen_minus_w4 = (dlinelen - w) * 4;
-	slinelen_minus_w4 = (slinelen - w) * 4;
-	src8 = (ADDR8)src;
-	dst8 = (ADDR8)dst;
-
-	while(--h >= 0) {
-		for(i=0; i<w; ++i) {
-			if (alpha != 0) {
-#if 0
- 				// d = muldiv255(a, d - s) + s;
-				uint32_t ssa = 255 - alpha;
-				uint32_t ps = *src8++;
-				*dst8 = muldiv255(ssa, *dst8 - ps) + ps;
-				++dst8;
-				ps = *src8++;
-				*dst8 = muldiv255(ssa, *dst8 - ps) + ps;
-				++dst8;
-				ps = *src8++;
-				*dst8 = muldiv255(ssa, *dst8 - ps) + ps;
-				++dst8;
-
-				//d = muldiv255(d, 255 - a) + a;
-				*dst8 = muldiv255(*dst8, 255 - alpha) + alpha;
-				++dst8;
-				++src8;
-#endif
-#if 1
- 				// d = muldiv255(a, s - d) + d
-				uint32_t pd = *dst8;
-				*dst8++ = muldiv255(alpha, *src8++ - pd) + pd;
-				pd = *dst8;
-				*dst8++ = muldiv255(alpha, *src8++ - pd) + pd;
-				pd = *dst8;
-				*dst8++ = muldiv255(alpha, *src8++ - pd) + pd;
-
-				// d += muldiv255(a, 255 - d)
-				*dst8 += muldiv255(alpha, 255 - *dst);
-				++dst8;
-				++src8;
-#endif
-			} else {
-				// src alpha 0, leave dst alpha as is
-				dst8 += 4;
-				src8 += 4;
-			}
-		}
-		dst8 += dlinelen_minus_w4;
-		src8 += slinelen_minus_w4;
-	}
-
-	} else if (op == MWROP_COPY) {
-		/* copy from bottom up if dst in src rectangle*/
-		/* memmove is used to handle x case*/
-		if (srcy < dsty) {
-			src += (h-1) * slinelen;
-			dst += (h-1) * dlinelen;
-			slinelen *= -1;
-			dlinelen *= -1;
-		}
-		while(--h >= 0) {
-			/* a _fast_ memmove is a _must_ in this routine*/
-			memmove(dst, src, w<<2);
-			dst += dlinelen;
-			src += slinelen;
-		}
-	} else if (op == MWROP_SRC_OVER) {
-		src8 = (ADDR8)src;
-		dst8 = (ADDR8)dst;
-		while (h--) {
-			for (i = w; --i >= 0;) {
-				register uint32_t as;
-
-				if ((as = src8[3]) == 255) {	//FIXME constant ok only with BGRA and RGBA formats
-					dst8[0] = src8[0];
-					dst8[1] = src8[1];
-					dst8[2] = src8[2];
-					dst8[3] = src8[3];
-					src8 += 4;
-					dst8 += 4;
-				} else if (as != 0) {
- 					// d = muldiv255(a, s - d) + d
-					register uint32_t pd = *dst8;
-					*dst8++ = muldiv255(as, *src8++ - pd) + pd;
-					pd = *dst8;
-					*dst8++ = muldiv255(as, *src8++ - pd) + pd;
-					pd = *dst8;
-					*dst8++ = muldiv255(as, *src8++ - pd) + pd;
-
-					//d = muldiv255(d, 255 - a) + a
-					*dst8 = muldiv255(*dst8, 255 - as) + as;	// FIXME see above
-					++dst8;
-					++src8;
-				} else {
-					// src alpha 0, leave dst alpha as is
-					src8 += 4;
-					dst8 += 4;
-				}
-			}
-			dst8 += (dlinelen - w) * 4;
-			src8 += (slinelen - w) * 4;
-		}
-	} else {
-		while (--h >= 0) {
-			applyOp4(w, op, src, dst, ADDR32);					// FIXME see above
-			dst += dlinelen - w;
-			src += slinelen - w;
-		}
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dstx, dsty, w, H);
-	DRAWOFF;
-}
-
-/*
- * This stretchblit code was originally written for the TriMedia
- * VLIW CPU.  Therefore it uses RESTRICT pointers, and the special
- * one-assembler-opcode pseudo-functions SIGN and ABS.
- *
- * (The 'restrict' extension is in C99, so for a C99 compiler you
- * could "#define RESTRICT restrict" or put
- * "CFLAGS += -DRESTRICT=restrict" in the makefile).
- *
- * Compatibility definitions:
- */
-#ifndef RESTRICT
-#define RESTRICT
-#endif
-#ifndef SIGN
-#define SIGN(x) (((x) > 0) ? 1 : (((x) == 0) ? 0 : -1))
-#endif
-#ifndef ABS
-#define ABS(x) (((x) >= 0) ? (x) : -(x))
-#endif
-
-/* Blit a 32-bit image.
- * Can stretch the image by any X and/or Y scale factor.
- * Can flip the image in the X and/or Y axis.
- *
- * This is the faster version with no per-pixel multiply and a single
- * decision tree for the inner loop, by Jon.  Based on Alex's original
- * all-integer version.
- *
- * Paramaters:
- * srf              - Dest surface
- * dest_x_start
- * dest_y_start    - Top left corner of dest rectangle
- * width, height   - Size in dest co-ordinates.
- * x_denominator   - Denominator for source X value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * y_denominator   - Denominator for source Y value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * src_x_fraction  -
- * src_y_fraction  - Point in source that corresponds to the top left corner
- *                   of the pixel (dest_x_start, dest_y_start).  This is a
- *                   fraction - to get a float, divide by y_denominator.
- * x_step_fraction - X step in src for an "x++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   x_denominator for a float.
- * y_step_fraction - Y step in src for a  "y++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   y_denominator for a float.
- * image           - Source image.
- * op              - Raster operation, currently ignored.
- */
-static void
-linear32_stretchblitex(PSD dstpsd,
-			 PSD srcpsd,
-			 MWCOORD dest_x_start,
-			 MWCOORD dest_y_start,
-			 MWCOORD width,
-			 MWCOORD height,
-			 int x_denominator,
-			 int y_denominator,
-			 int src_x_fraction,
-			 int src_y_fraction,
-			 int x_step_fraction,
-			 int y_step_fraction,
-			 int op)
-{
-	/* Pointer to the current pixel in the source image */
-	uint32_t *RESTRICT src_ptr;
-
-	/* Pointer to x=xs1 on the next line in the source image */
-	uint32_t *RESTRICT next_src_ptr;
-
-	/* Pointer to the current pixel in the dest image */
-	uint32_t *RESTRICT dest_ptr;
-
-	/* Pointer to x=xd1 on the next line in the dest image */
-	uint32_t *next_dest_ptr;
-
-	/* Keep track of error in the source co-ordinates */
-	int x_error;
-	int y_error;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_one;
-	int src_y_step_one;
-
-	/* normal steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_normal;
-	int src_y_step_normal;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int x_error_step_normal;
-	int y_error_step_normal;
-
-	/* Countdown to the end of the destination image */
-	int x_count;
-	int y_count;
-
-	/* Start position in source, in whole pixels */
-	int src_x_start;
-	int src_y_start;
-
-	/* Error values for start X position in source */
-	int x_error_start;
-
-	/* 1-unit step down dest, in bytes. */
-	int dest_y_step;
-
-	/*DPRINTF("Nano-X: linear32_stretchflipblit( dest=(%d,%d) %dx%d )\n",
-	       dest_x_start, dest_y_start, width, height);*/
-
-	/* We add half a dest pixel here so we're sampling from the middle of
-	 * the dest pixel, not the top left corner.
-	 */
-	src_x_fraction += (x_step_fraction >> 1);
-	src_y_fraction += (y_step_fraction >> 1);
-
-	/* Seperate the whole part from the fractions.
-	 *
-	 * Also, We need to do lots of comparisons to see if error values are
-	 * >= x_denominator.  So subtract an extra x_denominator for speed - then
-	 * we can just check if it's >= 0.
-	 */
-	src_x_start = src_x_fraction / x_denominator;
-	src_y_start = src_y_fraction / y_denominator;
-	x_error_start = src_x_fraction - (src_x_start + 1) * x_denominator;
-	y_error = src_y_fraction - (src_y_start + 1) * y_denominator;
-
-	/* precalculate various deltas */
-	src_x_step_normal = x_step_fraction / x_denominator;
-	src_x_step_one = SIGN(x_step_fraction);
-	x_error_step_normal = ABS(x_step_fraction) - ABS(src_x_step_normal) * x_denominator;
-
-	src_y_step_normal = y_step_fraction / y_denominator;
-	src_y_step_one = SIGN(y_step_fraction) * srcpsd->linelen;
-	y_error_step_normal = ABS(y_step_fraction) - ABS(src_y_step_normal) * y_denominator;
-	src_y_step_normal *= srcpsd->linelen;
-
-	/* DPRINTF("linear32_stretchblitex: X: One step=%d, err-=%d; normal step=%d, err+=%d\n"
-		"Y: One step=%d, err-=%d; normal step=%d, err+=%d\n",
-	   src_x_step_one, x_denominator, src_x_step_normal, x_error_step_normal,
-	   src_y_step_one, y_denominator, src_y_step_normal, y_error_step_normal);
-	 */
-
-	/* Pointer to the first source pixel */
-	next_src_ptr = ((uint32_t *) srcpsd->addr) + src_y_start * srcpsd->linelen + src_x_start;
-
-	/* Cache the width of a scanline in dest */
-	dest_y_step = dstpsd->linelen;
-
-	/* Pointer to the first dest pixel */
-	next_dest_ptr = ((uint32_t *) dstpsd->addr) + (dest_y_start * dest_y_step) + dest_x_start;
-
-	/*
-	 * Note: The MWROP_SRC case below is a simple expansion of the
-	 * default case.  It can be removed without significant speed
-	 * penalty if you need to reduce code size.
-	 *
-	 * The MWROP_CLEAR case could be removed.  But it is a large
-	 * speed increase for a small quantity of code.
-	 */
-	DRAWON;
-	switch (op) {
-	case MWROP_SRC:
-		/* Benchmarking shows that this while loop is faster than the equivalent
-		 * for loop: for(y_count=0; y_count<height; y_count++) { ... }
-		 */
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = *src_ptr;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-
-	case MWROP_CLEAR:
-		y_count = height;
-		while (y_count-- > 0) {
-			dest_ptr = next_dest_ptr;
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = 0;
-			}
-			next_dest_ptr += dest_y_step;
-		}
-		break;
-
-	default:
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				applyOp(op, *src_ptr, dest_ptr, ADDR32);
-				dest_ptr++;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
 	}
+	else
+		APPLYOP(gr_mode, height, (MWPIXELVAL), c, *(ADDR32), addr, 0, linelen);
 	DRAWOFF;
 
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dest_x_start, dest_y_start, width, height);
+	if (psd->Update)
+		psd->Update(psd, x, y1, 1, height);
 }
 
 static SUBDRIVER fblinear32_none = {
@@ -534,8 +126,9 @@ static SUBDRIVER fblinear32_none = {
 	linear32_drawhorzline,
 	linear32_drawvertline,
 	gen_fillrect,
-	linear32_blit,
-	linear32_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_xxxa8888,
+	frameblit_stretch_xxxa8888,
 #if MWPIXEL_FORMAT == MWPF_TRUECOLORABGR
 	convblit_copy_mask_mono_byte_msb_rgba,
 	convblit_copy_mask_mono_byte_lsb_rgba,
@@ -562,8 +155,9 @@ static SUBDRIVER fblinear32_left = {
 	fbportrait_left_drawhorzline,
 	fbportrait_left_drawvertline,
 	fbportrait_left_fillrect,
-	fbportrait_left_blit,
-	fbportrait_left_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_xxxa8888,
+	frameblit_stretch_xxxa8888,
 #if MWPIXEL_FORMAT == MWPF_TRUECOLORABGR
 	convblit_copy_mask_mono_byte_msb_rgba,
 	convblit_copy_mask_mono_byte_lsb_rgba,
@@ -590,8 +184,9 @@ static SUBDRIVER fblinear32_right = {
 	fbportrait_right_drawhorzline,
 	fbportrait_right_drawvertline,
 	fbportrait_right_fillrect,
-	fbportrait_right_blit,
-	fbportrait_right_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_xxxa8888,
+	frameblit_stretch_xxxa8888,
 #if MWPIXEL_FORMAT == MWPF_TRUECOLORABGR
 	convblit_copy_mask_mono_byte_msb_rgba,
 	convblit_copy_mask_mono_byte_lsb_rgba,
@@ -618,8 +213,9 @@ static SUBDRIVER fblinear32_down = {
 	fbportrait_down_drawhorzline,
 	fbportrait_down_drawvertline,
 	fbportrait_down_fillrect,
-	fbportrait_down_blit,
-	fbportrait_down_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_xxxa8888,
+	frameblit_stretch_xxxa8888,
 #if MWPIXEL_FORMAT == MWPF_TRUECOLORABGR
 	convblit_copy_mask_mono_byte_msb_rgba,
 	convblit_copy_mask_mono_byte_lsb_rgba,
diff --git a/src/drivers/fblin4.c b/src/drivers/fblin4.c
index 7127881..b8021a2 100644
--- a/src/drivers/fblin4.c
+++ b/src/drivers/fblin4.c
@@ -43,15 +43,15 @@ linear4_init(PSD psd)
 static void
 linear4_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
-	ADDR8 addr = ((ADDR8)psd->addr) + (x>>1) + y * psd->linelen;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x>>1) + y * psd->linelen;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
 	assert (y >= 0 && y < psd->yres);
 	assert (c < psd->ncolors);
 #endif
-	DRAWON;
 	INVERT(c);
+	DRAWON;
 	if(gr_mode == MWROP_COPY) {
 		*addr = (*addr & notmask[x&1]) | (c << ((1-(x&1))<<2));
 	} else {
@@ -89,8 +89,8 @@ linear4_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 	assert (y >= 0 && y < psd->yres);
 	assert (c < psd->ncolors);
 #endif
-	DRAWON;
 	INVERT(c);
+	DRAWON;
 	if(gr_mode == MWROP_COPY) {
 		while(x1 <= x2) {
 			*addr = (*addr & notmask[x1&1]) | (c << ((1-(x1&1))<<2));
@@ -113,7 +113,7 @@ static void
 linear4_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	int	linelen = psd->linelen;
-	ADDR8 addr = ((ADDR8)psd->addr) + (x>>1) + y1 * linelen;
+	register ADDR8 addr = ((ADDR8)psd->addr) + (x>>1) + y1 * linelen;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -149,7 +149,7 @@ linear4_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	int	i;
 	int	dlinelen = dstpsd->linelen;
 	int	slinelen = srcpsd->linelen;
-
+#if DEBUG
 	assert (dstpsd->addr != 0);
 	assert (dstx >= 0 && dstx < dstpsd->xres);
 	assert (dsty >= 0 && dsty < dstpsd->yres);
@@ -162,7 +162,7 @@ linear4_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	assert (dsty+h <= dstpsd->yres);
 	assert (srcx+w <= srcpsd->xres);
 	assert (srcy+h <= srcpsd->yres);
-
+#endif
 	if (op > MWROP_SIMPLE_MAX)
 		op = MWROP_COPY;
 	dst = ((ADDR8)dstpsd->addr) + (dstx>>1) + dsty * dlinelen;
@@ -427,7 +427,8 @@ static SUBDRIVER fblinear4_none = {
 	linear4_drawvertline,
 	gen_fillrect,
 	linear4_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear4_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin4rev.c b/src/drivers/fblin4rev.c
index d12c785..f40b165 100644
--- a/src/drivers/fblin4rev.c
+++ b/src/drivers/fblin4rev.c
@@ -147,7 +147,7 @@ linear4_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	int	i;
 	int	dlinelen = dstpsd->linelen;
 	int	slinelen = srcpsd->linelen;
-
+#if DEBUG
 	assert (dstpsd->addr != 0);
 	assert (dstx >= 0 && dstx < dstpsd->xres);
 	assert (dsty >= 0 && dsty < dstpsd->yres);
@@ -160,7 +160,7 @@ linear4_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	assert (dsty+h <= dstpsd->yres);
 	assert (srcx+w <= srcpsd->xres);
 	assert (srcy+h <= srcpsd->yres);
-
+#endif
 	DRAWON;
 	dst = ((ADDR8)dstpsd->addr) + (dstx>>1) + dsty * dlinelen;
 	src = ((ADDR8)srcpsd->addr) + (srcx>>1) + srcy * slinelen;
@@ -414,7 +414,8 @@ static SUBDRIVER fblinear4_none = {
 	linear4_drawvertline,
 	gen_fillrect,
 	linear4_blit,
-	NULL,		/* StretchBlitEx*/
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	linear4_convblit_copy_mask_mono_byte_msb,
 	NULL,		/* BlitCopyMaskMonoByteLSB*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fblin8.c b/src/drivers/fblin8.c
index 3e546ea..882d03b 100644
--- a/src/drivers/fblin8.c
+++ b/src/drivers/fblin8.c
@@ -15,8 +15,8 @@
 #define __OPTIMIZE__
 #endif
 #include <string.h>
-
 #include "device.h"
+#include "convblit.h"
 #include "fb.h"
 
 /*
@@ -31,7 +31,7 @@
  */
 static unsigned short *alpha_to_rgb = NULL;
 static unsigned char  *rgb_to_palindex = NULL;
-int init_alpha_lookup(void);
+static int init_alpha_lookup(void);
 
 /* Calc linelen and mmap size, return 0 on fail*/
 static int
@@ -47,6 +47,7 @@ linear8_init(PSD psd)
 static void
 linear8_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 {
+	register ADDR8	addr = ((ADDR8)psd->addr) + x + y * psd->linelen;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -55,13 +56,13 @@ linear8_drawpixel(PSD psd, MWCOORD x, MWCOORD y, MWPIXELVAL c)
 #endif
 	DRAWON;
 	if(gr_mode == MWROP_COPY)
-		((ADDR8)psd->addr)[x + y * psd->linelen] = c;
+		*addr = c;
 	else
-		applyOp(gr_mode, c, &((ADDR8)psd->addr)[ x + y * psd->linelen], ADDR8);
+		APPLYOP(gr_mode, 1, (MWPIXELVAL), c, *(ADDR8), addr, 0, 0);
+	DRAWOFF;
 
 	if (psd->Update)
 		psd->Update(psd, x, y, 1, 1);
-	DRAWOFF;
 }
 
 /* Read pixel at x, y*/
@@ -80,8 +81,8 @@ linear8_readpixel(PSD psd, MWCOORD x, MWCOORD y)
 static void
 linear8_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 {
-	register ADDR8 addr = ((ADDR8)psd->addr) + x1 + y * psd->linelen;
-	MWCOORD X1 = x1;
+	register ADDR8	addr = ((ADDR8)psd->addr) + x1 + y * psd->linelen;
+	int width = x2-x1+1;
 #if DEBUG
 	assert (addr != 0);
 	assert (x1 >= 0 && x1 < psd->xres);
@@ -90,19 +91,19 @@ linear8_drawhorzline(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c)
 	assert (y >= 0 && y < psd->yres);
 	assert (c < psd->ncolors);
 #endif
-	DRAWON;
 	if(gr_mode == MWROP_COPY)
-		memset(addr, c, x2 - x1 + 1);
-	else {
-		while(x1++ <= x2) {
-			applyOp(gr_mode, c, addr, ADDR8);
-			++addr;
-		}
+	{
+		//memset(addr, c, width);
+		int w = width;
+		while(--w >= 0)
+			*addr++ = c;
 	}
+	else
+		APPLYOP(gr_mode, width, (MWPIXELVAL), c, *(ADDR8), addr, 0, 1);
+	DRAWOFF;
 
 	if (psd->Update)
-		psd->Update(psd, X1, y, x2-X1+1, 1);
-	DRAWOFF;
+		psd->Update(psd, x1, y, width, 1);
 }
 
 /* Draw a vertical line from x,y1 to x,y2 including final point*/
@@ -110,8 +111,8 @@ static void
 linear8_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 {
 	int	linelen = psd->linelen;
-	MWCOORD Y1 = y1;
 	register ADDR8 addr = ((ADDR8)psd->addr) + x + y1 * linelen;
+	int height = y2-y1+1;
 #if DEBUG
 	assert (psd->addr != 0);
 	assert (x >= 0 && x < psd->xres);
@@ -121,374 +122,25 @@ linear8_drawvertline(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c)
 	assert (c < psd->ncolors);
 #endif
 	DRAWON;
-	if(gr_mode == MWROP_COPY) {
-		while(y1++ <= y2) {
+	if(gr_mode == MWROP_COPY)
+	{
+		int h = height;
+		while (--h >= 0)
+		{
 			*addr = c;
 			addr += linelen;
 		}
-	} else {
-		while(y1++ <= y2) {
-			applyOp(gr_mode, c, addr, ADDR8);
-			addr += linelen;
-		}
 	}
-
-	if (psd->Update)
-		psd->Update(psd, x, Y1, 1, y2-Y1+1);
-	DRAWOFF;
-}
-
-/* srccopy bitblt*/
-static void
-linear8_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
-	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
-{
-	ADDR8	dst;
-	ADDR8	src;
-	int	dlinelen = dstpsd->linelen;
-	int	slinelen = srcpsd->linelen;
-	int H = h;
-#if DEBUG
-	assert (dstpsd->addr != 0);
-	assert (dstx >= 0 && dstx < dstpsd->xres);
-	assert (dsty >= 0 && dsty < dstpsd->yres);
-	assert (w > 0);
-	assert (h > 0);
-	assert (srcpsd->addr != 0);
-	assert (srcx >= 0 && srcx < srcpsd->xres);
-	assert (srcy >= 0 && srcy < srcpsd->yres);
-	assert (dstx+w <= dstpsd->xres);
-	assert (dsty+h <= dstpsd->yres);
-	assert (srcx+w <= srcpsd->xres);
-	assert (srcy+h <= srcpsd->yres);
-#endif
-	dst = ((ADDR8)dstpsd->addr) + dstx + dsty * dlinelen;
-	src = ((ADDR8)srcpsd->addr) + srcx + srcy * slinelen;
-
-	DRAWON;
-
-	if (op == MWROP_BLENDCONSTANT) {
-	unsigned int srcalpha = 150;
-	unsigned int dstalpha;
-	int i;
-
-	/* create alpha lookup tables*/
-	if(!rgb_to_palindex) {
-		if (!init_alpha_lookup())
-			goto copy;
-	}
-
-	/* 
-	 * Create 5 bit alpha value index for 256 color indexing.
-	 * Destination alpha is (1 - source) alpha
-	 */
-	dstalpha = ((srcalpha >> 3) ^ 31) << 8;
-	srcalpha =  (srcalpha >> 3) << 8;
-
-	while(--h >= 0) {
-	    for(i=0; i<w; ++i) {
-			/* Get source RGB555 value for source alpha value*/
-			unsigned short s = alpha_to_rgb[srcalpha + *src++];
-
-			/* Get destination RGB555 value for dest alpha value*/
-			unsigned short d = alpha_to_rgb[dstalpha + *dst];
-
-			/* Add RGB values together and get closest palette index to it*/
-			*dst++ = rgb_to_palindex[s + d];
-	    }
-	    dst += dlinelen - w;
-	    src += slinelen - w;
-	}
-	} else if (op == MWROP_COPY) {
-copy:
-		/* copy from bottom up if dst in src rectangle*/
-		/* memmove is used to handle x case*/
-		if (srcy < dsty) {
-			src += (h-1) * slinelen;
-			dst += (h-1) * dlinelen;
-			slinelen *= -1;
-			dlinelen *= -1;
-		}
-
-		while(--h >= 0) {
-			/* a _fast_ memcpy is a _must_ in this routine*/
-			memmove(dst, src, w);
-			dst += dlinelen;
-			src += slinelen;
-		}
-	} else {
-		while (--h >= 0) {
-			applyOp4(w, op, src, dst, ADDR8);
-			dst += dlinelen - w;
-			src += slinelen - w;
-		}
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dstx, dsty, w, H);
+	else
+		APPLYOP(gr_mode, height, (MWPIXELVAL), c, *(ADDR8), addr, 0, linelen);
 	DRAWOFF;
-}
-
-/*
- * This stretchblit code was originally written for the TriMedia
- * VLIW CPU.  Therefore it uses RESTRICT pointers, and the special
- * one-assembler-opcode pseudo-functions SIGN and ABS.
- *
- * (The 'restrict' extension is in C99, so for a C99 compiler you
- * could "#define RESTRICT restrict" or put
- * "CFLAGS += -DRESTRICT=restrict" in the makefile).
- *
- * Compatibility definitions:
- */
-#ifndef RESTRICT
-#define RESTRICT
-#endif
-#ifndef SIGN
-#define SIGN(x) (((x) > 0) ? 1 : (((x) == 0) ? 0 : -1))
-#endif
-#ifndef ABS
-#define ABS(x) (((x) >= 0) ? (x) : -(x))
-#endif
-
-/* Blit a 8-bit image.
- * Can stretch the image by any X and/or Y scale factor.
- * Can flip the image in the X and/or Y axis.
- *
- * This is the faster version with no per-pixel multiply and a single
- * decision tree for the inner loop, by Jon.  Based on Alex's original
- * all-integer version.
- *
- * Paramaters:
- * srf              - Dest surface
- * dest_x_start
- * dest_y_start    - Top left corner of dest rectangle
- * width, height   - Size in dest co-ordinates.
- * x_denominator   - Denominator for source X value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * y_denominator   - Denominator for source Y value fractions.  Note that
- *                   this must be even, and all the numerators must also be
- *                   even, so we can easily divide by 2.
- * src_x_fraction  -
- * src_y_fraction  - Point in source that corresponds to the top left corner
- *                   of the pixel (dest_x_start, dest_y_start).  This is a
- *                   fraction - to get a float, divide by y_denominator.
- * x_step_fraction - X step in src for an "x++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   x_denominator for a float.
- * y_step_fraction - Y step in src for a  "y++" step in dest.  May be negative
- *                   (for a flip).  Expressed as a fraction - divide it by
- *                   y_denominator for a float.
- * image           - Source image.
- * op              - Raster operation, currently ignored.
- */
-static void
-linear8_stretchblitex(PSD dstpsd,
-			 PSD srcpsd,
-			 MWCOORD dest_x_start,
-			 MWCOORD dest_y_start,
-			 MWCOORD width,
-			 MWCOORD height,
-			 int x_denominator,
-			 int y_denominator,
-			 int src_x_fraction,
-			 int src_y_fraction,
-			 int x_step_fraction,
-			 int y_step_fraction,
-			 int op)
-{
-	/* Pointer to the current pixel in the source image */
-	unsigned char *RESTRICT src_ptr;
-
-	/* Pointer to x=xs1 on the next line in the source image */
-	unsigned char *RESTRICT next_src_ptr;
-
-	/* Pointer to the current pixel in the dest image */
-	unsigned char *RESTRICT dest_ptr;
-
-	/* Pointer to x=xd1 on the next line in the dest image */
-	unsigned char *next_dest_ptr;
 
-	/* Keep track of error in the source co-ordinates */
-	int x_error;
-	int y_error;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_one;
-	int src_y_step_one;
-
-	/* normal steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int src_x_step_normal;
-	int src_y_step_normal;
-
-	/* 1-unit steps "forward" through the source image, as steps in the image
-	 * byte array.
-	 */
-	int x_error_step_normal;
-	int y_error_step_normal;
-
-	/* Countdown to the end of the destination image */
-	int x_count;
-	int y_count;
-
-	/* Start position in source, in whole pixels */
-	int src_x_start;
-	int src_y_start;
-
-	/* Error values for start X position in source */
-	int x_error_start;
-
-	/* 1-unit step down dest, in bytes. */
-	int dest_y_step;
-
-	/* DPRINTF("Nano-X: linear8_stretchflipblit( dest=(%d,%d) %dx%d )\n",
-	       dest_x_start, dest_y_start, width, height);*/
-
-	/* We add half a dest pixel here so we're sampling from the middle of
-	 * the dest pixel, not the top left corner.
-	 */
-	src_x_fraction += (x_step_fraction >> 1);
-	src_y_fraction += (y_step_fraction >> 1);
-
-	/* Seperate the whole part from the fractions.
-	 *
-	 * Also, We need to do lots of comparisons to see if error values are
-	 * >= x_denominator.  So subtract an extra x_denominator for speed - then
-	 * we can just check if it's >= 0.
-	 */
-	src_x_start = src_x_fraction / x_denominator;
-	src_y_start = src_y_fraction / y_denominator;
-	x_error_start = src_x_fraction - (src_x_start + 1) * x_denominator;
-	y_error = src_y_fraction - (src_y_start + 1) * y_denominator;
-
-	/* precalculate various deltas */
-
-	src_x_step_normal = x_step_fraction / x_denominator;
-	src_x_step_one = SIGN(x_step_fraction);
-	x_error_step_normal = ABS(x_step_fraction) - ABS(src_x_step_normal) * x_denominator;
-
-	src_y_step_normal = y_step_fraction / y_denominator;
-	src_y_step_one = SIGN(y_step_fraction) * srcpsd->linelen;
-	y_error_step_normal = ABS(y_step_fraction) - ABS(src_y_step_normal) * y_denominator;
-	src_y_step_normal *= srcpsd->linelen;
-
-	/* DPRINTF("linear8_stretchblitex: X: One step=%d, err-=%d; normal step=%d, err+=%d\n"
-		"Y: One step=%d, err-=%d; normal step=%d, err+=%d\n",
-	   src_x_step_one, x_denominator, src_x_step_normal, x_error_step_normal,
-	   src_y_step_one, y_denominator, src_y_step_normal, y_error_step_normal);
-	 */
-
-	/* Pointer to the first source pixel */
-	next_src_ptr = ((unsigned char *) srcpsd->addr) + src_y_start * srcpsd->linelen + src_x_start;
-
-	/* Cache the width of a scanline in dest */
-	dest_y_step = dstpsd->linelen;
-
-	/* Pointer to the first dest pixel */
-	next_dest_ptr = ((unsigned char *) dstpsd->addr) + (dest_y_start * dest_y_step) + dest_x_start;
-
-	/*
-	 * Note: The MWROP_SRC case below is a simple expansion of the
-	 * default case.  It can be removed without significant speed
-	 * penalty if you need to reduce code size.
-	 *
-	 * The MWROP_CLEAR case could be removed.  But it is a large
-	 * speed increase for a small quantity of code.
-	 */
-	switch (op) {
-	case MWROP_SRC:
-		/* Benchmarking shows that this while loop is faster than the equivalent
-		 * for loop: for(y_count=0; y_count<height; y_count++) { ... }
-		 */
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = *src_ptr;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-
-	case MWROP_CLEAR:
-		y_count = height;
-		while (y_count-- > 0) {
-			dest_ptr = next_dest_ptr;
-			x_count = width;
-			while (x_count-- > 0) {
-				*dest_ptr++ = 0;
-			}
-			next_dest_ptr += dest_y_step;
-		}
-		break;
-
-	default:
-		y_count = height;
-		while (y_count-- > 0) {
-			src_ptr = next_src_ptr;
-			dest_ptr = next_dest_ptr;
-
-			x_error = x_error_start;
-
-			x_count = width;
-			while (x_count-- > 0) {
-				applyOp(op, *src_ptr, dest_ptr, ADDR8);
-				dest_ptr++;
-
-				src_ptr += src_x_step_normal;
-				x_error += x_error_step_normal;
-
-				if (x_error >= 0) {
-					src_ptr += src_x_step_one;
-					x_error -= x_denominator;
-				}
-			}
-
-			next_dest_ptr += dest_y_step;
-
-			next_src_ptr += src_y_step_normal;
-			y_error += y_error_step_normal;
-
-			if (y_error >= 0) {
-				next_src_ptr += src_y_step_one;
-				y_error -= y_denominator;
-			}
-		}
-		break;
-	}
-
-	if (dstpsd->Update)
-		dstpsd->Update(dstpsd, dest_x_start, dest_y_start, width, height);
+	if (psd->Update)
+		psd->Update(psd, x, y1, 1, height);
 }
 
 /* FIXME create lookup table whenever palette changed*/
-int
+static int
 init_alpha_lookup(void)
 {
 	int	i, a;
@@ -970,8 +622,9 @@ static SUBDRIVER fblinear8_none = {
 	linear8_drawhorzline,
 	linear8_drawvertline,
 	gen_fillrect,
-	linear8_blit,
-	linear8_stretchblitex,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_8bpp,
+	frameblit_stretch_8bpp,
 	linear8_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
 	linear8_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/	/* core, PCF, FNT will use GdBitmap fallback*/
@@ -981,6 +634,63 @@ static SUBDRIVER fblinear8_none = {
 	NULL		/* BlitCopyRGB888*/				/* images will use GdDrawImageByPoint fallback*/
 };
 
+SUBDRIVER fblinear8_left = {
+	NULL,
+	fbportrait_left_drawpixel,
+	fbportrait_left_readpixel,
+	fbportrait_left_drawhorzline,
+	fbportrait_left_drawvertline,
+	fbportrait_left_fillrect,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_8bpp,
+	frameblit_stretch_8bpp,
+	fbportrait_left_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
+	fbportrait_left_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
+	NULL,		/* BlitCopyMaskMonoWordMSB*/
+	fbportrait_left_convblit_blend_mask_alpha_byte,		/* FT2/T1 anti-alias*/
+	NULL,		/* BlitSrcOverRGBA8888*/
+	NULL,		/* BlitSrcOverRGBA8888*/
+	NULL		/* BlitCopyRGB888*/
+};
+
+SUBDRIVER fblinear8_right = {
+	NULL,
+	fbportrait_right_drawpixel,
+	fbportrait_right_readpixel,
+	fbportrait_right_drawhorzline,
+	fbportrait_right_drawvertline,
+	fbportrait_right_fillrect,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_8bpp,
+	frameblit_stretch_8bpp,
+	fbportrait_right_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
+	fbportrait_right_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
+	NULL,		/* BlitCopyMaskMonoWordMSB*/
+	fbportrait_right_convblit_blend_mask_alpha_byte,	/* FT2/T1 anti-alias*/
+	NULL,		/* BlitSrcOverRGBA8888*/
+	NULL,		/* BlitSrcOverRGBA8888*/
+	NULL		/* BlitCopyRGB888*/
+};
+
+SUBDRIVER fblinear8_down = {
+	NULL,
+	fbportrait_down_drawpixel,
+	fbportrait_down_readpixel,
+	fbportrait_down_drawhorzline,
+	fbportrait_down_drawvertline,
+	fbportrait_down_fillrect,
+	NULL,			/* no fallback Blit - uses BlitFrameBlit*/
+	frameblit_8bpp,
+	frameblit_stretch_8bpp,
+	fbportrait_down_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
+	fbportrait_down_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
+	NULL,		/* BlitCopyMaskMonoWordMSB*/
+	fbportrait_down_convblit_blend_mask_alpha_byte,		/* FT2/T1 anti-alias*/
+	NULL,		/* BlitCopyRGBA8888*/
+	NULL,		/* BlitSrcOverRGBA8888*/
+	NULL		/* BlitCopyRGB888*/
+};
+
 PSUBDRIVER fblinear8[4] = {
-	&fblinear8_none, &fbportrait_left, &fbportrait_right, &fbportrait_down
+	&fblinear8_none, &fblinear8_left, &fblinear8_right, &fblinear8_down
 };
diff --git a/src/drivers/fbportrait_down.c b/src/drivers/fbportrait_down.c
index 5dbb087..a48a7e0 100644
--- a/src/drivers/fbportrait_down.c
+++ b/src/drivers/fbportrait_down.c
@@ -72,28 +72,12 @@ void
 fbportrait_down_blit(PSD dstpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int op)
 {
-    dstpsd->orgsubdriver->Blit(dstpsd, dstpsd->xvirtres-destx-w, dstpsd->yvirtres-desty-h,   
+    dstpsd->orgsubdriver->BlitFallback(dstpsd, dstpsd->xvirtres-destx-w, dstpsd->yvirtres-desty-h,   
  		w, h, srcpsd, srcpsd->xvirtres-srcx-w, srcpsd->yvirtres-srcy-h, op);  
 
 }
 
 void
-fbportrait_down_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op)
-{ 
-	// X -> xmax - X - w
-	// Y -> ymax - Y - h
-	dstpsd->orgsubdriver->StretchBlitEx(dstpsd, srcpsd,
-		dstpsd->xvirtres - dest_x_start - width, dstpsd->yvirtres - dest_y_start - height,
-		width, height, x_denominator, y_denominator,
-		srcpsd->xvirtres - src_x_fraction - width, srcpsd->yvirtres - src_y_fraction - height,
-		x_step_fraction, y_step_fraction,
-		op);
-}
-
-static void
 fbportrait_down_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 {
 	ADDR8 alpha_in, alpha_out;
@@ -146,7 +130,7 @@ fbportrait_down_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_down_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -202,7 +186,7 @@ fbportrait_down_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_down_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -266,7 +250,8 @@ SUBDRIVER fbportrait_down = {
 	fbportrait_down_drawvertline,
 	fbportrait_down_fillrect,
 	fbportrait_down_blit,
-	fbportrait_down_stretchblitex,
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	fbportrait_down_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
 	fbportrait_down_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fbportrait_left.c b/src/drivers/fbportrait_left.c
index 5552be2..770a94b 100644
--- a/src/drivers/fbportrait_left.c
+++ b/src/drivers/fbportrait_left.c
@@ -71,27 +71,11 @@ void
 fbportrait_left_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 	PSD srcpsd, MWCOORD srcx,MWCOORD srcy,int op)
 {
-	dstpsd->orgsubdriver->Blit(dstpsd, desty, dstpsd->xvirtres-destx-w,
+	dstpsd->orgsubdriver->BlitFallback(dstpsd, desty, dstpsd->xvirtres-destx-w,
 		h, w, srcpsd, srcy, srcpsd->xvirtres-srcx-w, op);
 }
 
 void
-fbportrait_left_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op)
-{ 
-	// X -> Y
- 	// Y -> maxx - X - w
-	dstpsd->orgsubdriver->StretchBlitEx(dstpsd, srcpsd,
-		dest_y_start, dstpsd->xvirtres - dest_x_start - width,
-		height, width, y_denominator, x_denominator,
-		src_y_fraction, srcpsd->xvirtres - src_x_fraction - width,
-		y_step_fraction, x_step_fraction,
-		op);
-}
-
-static void
 fbportrait_left_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 {
 	ADDR8 alpha_in, alpha_out;
@@ -145,7 +129,7 @@ fbportrait_left_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_left_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -201,7 +185,7 @@ fbportrait_left_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_left_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -265,7 +249,8 @@ SUBDRIVER fbportrait_left = {
 	fbportrait_left_drawvertline,
 	fbportrait_left_fillrect,
 	fbportrait_left_blit,
-	fbportrait_left_stretchblitex,
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	fbportrait_left_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
 	fbportrait_left_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/fbportrait_right.c b/src/drivers/fbportrait_right.c
index 1439bb7..0470ebd 100644
--- a/src/drivers/fbportrait_right.c
+++ b/src/drivers/fbportrait_right.c
@@ -68,27 +68,11 @@ void
 fbportrait_right_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
 	PSD srcpsd, MWCOORD srcx,MWCOORD srcy,int op)
 {
-	dstpsd->orgsubdriver->Blit(dstpsd, dstpsd->yvirtres-desty-h, destx,
+	dstpsd->orgsubdriver->BlitFallback(dstpsd, dstpsd->yvirtres-desty-h, destx,
 		h, w, srcpsd, srcpsd->yvirtres-srcy-h, srcx, op);
 }
 
 void
-fbportrait_right_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-	MWCOORD width, int height, int x_denominator, int y_denominator,
-	int src_x_fraction, int src_y_fraction,
-	int x_step_fraction, int y_step_fraction, int op)
-{ 
-	// X -> maxy - y - h
-	// Y -> X
-	dstpsd->orgsubdriver->StretchBlitEx(dstpsd, srcpsd,
-		dstpsd->yvirtres - dest_y_start - height, dest_x_start,
-		height, width, y_denominator, x_denominator,
-		srcpsd->yvirtres - src_y_fraction - height, src_x_fraction,
-		y_step_fraction, x_step_fraction,
-		op);
-}
-
-static void
 fbportrait_right_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 {
 	ADDR8 alpha_in, alpha_out;
@@ -141,7 +125,7 @@ fbportrait_right_convblit_blend_mask_alpha_byte(PSD dstpsd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_right_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -197,7 +181,7 @@ fbportrait_right_convblit_copy_mask_mono_byte_msb(PSD psd, PMWBLITPARMS gc)
 	FREEA(l_gc.data);
 }
 
-static void
+void
 fbportrait_right_convblit_copy_mask_mono_byte_lsb(PSD psd, PMWBLITPARMS gc)
 {
 	ADDR8 pixel_in, pixel_out;
@@ -261,7 +245,8 @@ SUBDRIVER fbportrait_right = {
 	fbportrait_right_drawvertline,
 	fbportrait_right_fillrect,
 	fbportrait_right_blit,
-	fbportrait_right_stretchblitex,
+	NULL,		/* FrameBlit*/
+	NULL,		/* FrameStretchBlit*/
 	fbportrait_right_convblit_copy_mask_mono_byte_msb,	/* FT2 non-alias*/
 	fbportrait_right_convblit_copy_mask_mono_byte_lsb,	/* T1LIB non-alias*/
 	NULL,		/* BlitCopyMaskMonoWordMSB*/
diff --git a/src/drivers/genmem.c b/src/drivers/genmem.c
index 9728e9e..3de14df 100644
--- a/src/drivers/genmem.c
+++ b/src/drivers/genmem.c
@@ -272,13 +272,14 @@ set_subdriver(PSD psd, PSUBDRIVER subdriver, MWBOOL init)
 	psd->DrawHorzLine 	= subdriver->DrawHorzLine;
 	psd->DrawVertLine 	= subdriver->DrawVertLine;
 	psd->FillRect	 	= subdriver->FillRect;
-	psd->Blit 			= subdriver->Blit;
-	psd->StretchBlitEx	= subdriver->StretchBlitEx;
+	psd->BlitFallback 	= subdriver->BlitFallback;
+	psd->FrameBlit 				 = subdriver->FrameBlit;
+	psd->FrameStretchBlit 		 = subdriver->FrameStretchBlit;
 	psd->BlitCopyMaskMonoByteMSB = subdriver->BlitCopyMaskMonoByteMSB;
 	psd->BlitCopyMaskMonoByteLSB = subdriver->BlitCopyMaskMonoByteLSB;
 	psd->BlitCopyMaskMonoWordMSB = subdriver->BlitCopyMaskMonoWordMSB;
 	psd->BlitBlendMaskAlphaByte  = subdriver->BlitBlendMaskAlphaByte;
-	psd->BlitCopyRGBA8888     = subdriver->BlitCopyRGBA8888;
+	psd->BlitCopyRGBA8888     	 = subdriver->BlitCopyRGBA8888;
 	psd->BlitSrcOverRGBA8888     = subdriver->BlitSrcOverRGBA8888;
 	psd->BlitCopyRGB888          = subdriver->BlitCopyRGB888;
 
@@ -298,13 +299,14 @@ get_subdriver(PSD psd, PSUBDRIVER subdriver)
 	subdriver->DrawHorzLine 	= psd->DrawHorzLine;
 	subdriver->DrawVertLine 	= psd->DrawVertLine;
 	subdriver->FillRect	 		= psd->FillRect;
-	subdriver->Blit 			= psd->Blit;
-	subdriver->StretchBlitEx	= psd->StretchBlitEx;
+	subdriver->BlitFallback 	= psd->BlitFallback;
+	subdriver->FrameBlit 			   = psd->FrameBlit;
+	subdriver->FrameStretchBlit 	   = psd->FrameStretchBlit;
 	subdriver->BlitCopyMaskMonoByteMSB = psd->BlitCopyMaskMonoByteMSB;
 	subdriver->BlitCopyMaskMonoByteLSB = psd->BlitCopyMaskMonoByteLSB;
 	subdriver->BlitCopyMaskMonoWordMSB = psd->BlitCopyMaskMonoWordMSB;
 	subdriver->BlitBlendMaskAlphaByte  = psd->BlitBlendMaskAlphaByte;
-	subdriver->BlitCopyRGBA8888     = psd->BlitCopyRGBA8888;
+	subdriver->BlitCopyRGBA8888        = psd->BlitCopyRGBA8888;
 	subdriver->BlitSrcOverRGBA8888     = psd->BlitSrcOverRGBA8888;
 	subdriver->BlitCopyRGB888          = psd->BlitCopyRGB888;
 }
diff --git a/src/drivers/scr_fb.c b/src/drivers/scr_fb.c
index 2b9f0e1..7620e23 100644
--- a/src/drivers/scr_fb.c
+++ b/src/drivers/scr_fb.c
@@ -36,7 +36,7 @@
 #define PATH_EMULATORFB		"/tmp/fb0"	/* framebuffer emulator when used*/
 #define XRES				640			/* default fb emulator xres*/
 #define YRES				480			/* default fb emulator yres*/
-#define BPP					32			/* default bpp, 1,2,4,8,15,16,24,32, use 15 for 16bpp 5/5/5*/
+#define BPP					1			/* default bpp, 1,2,4,8,15,16,24,32, use 15 for 16bpp 5/5/5*/
 
 #define EMBEDDEDPLANET	0	/* =1 for kluge embeddedplanet ppc framebuffer*/
 
diff --git a/src/drivers/vncserver.c b/src/drivers/vncserver.c
index 8a0a48a..be9b894 100644
--- a/src/drivers/vncserver.c
+++ b/src/drivers/vncserver.c
@@ -62,11 +62,6 @@ static void	 (*_FillRect)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,
                 MWCOORD y2,MWPIXELVAL c);
 static void	 (*_Blit)(PSD destpsd, MWCOORD destx, MWCOORD desty, MWCOORD w,
                 MWCOORD h,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,long op);
-//static void	 (*_DrawArea)(PSD psd, driver_gc_t *gc);
-static void  (*_StretchBlitEx)(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-				MWCOORD width, int height, int x_denominator, int y_denominator,
-				int src_x_fraction, int src_y_fraction,
-				int x_step_fraction, int y_step_fraction, long op);
 
 static void UndrawCursor(void)
 {
@@ -141,6 +136,8 @@ static void stubBlit( PSD destpsd, MWCOORD destx, MWCOORD desty, MWCOORD w,
                 MarkRect( destx, desty, destx + w, desty + h );
 
 }
+
+#if 0
 static void stubStretchBlitEx(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
 	MWCOORD width, int height, int x_denominator, int y_denominator,
 	int src_x_fraction, int src_y_fraction,
@@ -153,7 +150,8 @@ static void stubStretchBlitEx(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int
         if ( dstpsd == actualpsd )
                 MarkRect( dest_x_start, dest_y_start, dest_x_start + width, dest_y_start + height );
 }
-        
+#endif
+
 static void clientgone(rfbClientPtr cl)
 {
         clients_connected--;
@@ -562,7 +560,7 @@ int GdOpenVNC( PSD psd, int argc, char *argv[] )
    _FillRect = psd->FillRect;
    _Blit = psd->Blit;
 //   _DrawArea = psd->DrawArea;
-   _StretchBlitEx = psd->StretchBlitEx;
+//   _StretchBlitEx = psd->StretchBlitEx;
    
 
    /* Set the screen driver drawing functions to vnc stubs */
diff --git a/src/drivers/vtswitch.c b/src/drivers/vtswitch.c
index f59f4fe..48f1d4e 100644
--- a/src/drivers/vtswitch.c
+++ b/src/drivers/vtswitch.c
@@ -49,12 +49,7 @@ static void	null_fillrect(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,
 			MWCOORD y2,MWPIXELVAL c) {}
 static void	null_blit(PSD dstpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,
 			MWCOORD h,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,
-			long op) {}
-static void	null_stretchblitex(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start,
-			MWCOORD dest_y_start, MWCOORD width, MWCOORD height,
-			int x_denominator, int y_denominator,
-			int src_x_fraction, int src_y_fraction,
-			int x_step_fraction, int y_step_fraction, long op) {}
+			int op) {}
 static void null_convblit(PSD psd, PMWBLITPARMS parms) {}
 
 static SUBDRIVER nulldriver = {
@@ -65,7 +60,8 @@ static SUBDRIVER nulldriver = {
 	null_drawvertline,
 	null_fillrect,
 	null_blit,
-	null_stretchblitex,
+	null_convblit,
+	null_convblit,
 	null_convblit,
 	null_convblit,
 	null_convblit,
diff --git a/src/engine/Objects.rules b/src/engine/Objects.rules
index 33d8c71..a721bbb 100644
--- a/src/engine/Objects.rules
+++ b/src/engine/Objects.rules
@@ -20,6 +20,7 @@ MW_CORE_OBJS += \
 	$(MW_DIR_OBJ)/engine/devblit.o \
 	$(MW_DIR_OBJ)/engine/convblit_8888.o \
 	$(MW_DIR_OBJ)/engine/convblit_mask.o \
+	$(MW_DIR_OBJ)/engine/convblit_frameb.o \
 	$(MW_DIR_OBJ)/engine/devfont.o \
 	$(MW_DIR_OBJ)/engine/devmouse.o \
 	$(MW_DIR_OBJ)/engine/devkbd.o \
diff --git a/src/engine/convblit_8888.c b/src/engine/convblit_8888.c
index dcfdcb4..4579032 100644
--- a/src/engine/convblit_8888.c
+++ b/src/engine/convblit_8888.c
@@ -132,18 +132,19 @@ static inline void convblit_8888(PSD psd, PMWBLITPARMS gc, int mode,
 					alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
 
 					/* d = muldiv255(255-a, d - s) + s*/
-					((unsigned short *)d)[0] = muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
+					((unsigned short *)d)[0] =
+						muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
 				}
 				else
 				{
- 					/* d += muldiv255(a, 255 - d)*/
-					if (DA >= 0)
-						d[DA] += muldiv255(alpha, 255 - d[DA]);
-
  					/* d += muldiv255(a, s - d)*/
 					d[DR] += muldiv255(alpha, s[SR] - d[DR]);
 					d[DG] += muldiv255(alpha, s[SG] - d[DG]);
 					d[DB] += muldiv255(alpha, s[SB] - d[DB]);
+
+ 					/* d += muldiv255(a, 255 - d)*/
+					if (DA >= 0)
+						d[DA] += muldiv255(alpha, 255 - d[DA]);
 				}
 			}
 			d += dsz;
@@ -285,155 +286,3 @@ void convblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc)
 {
 	convblit_8888(psd, gc, COPY, 2, 0,0,0,-1, 2, 0,0,0,-1, psd->portrait);
 }
-
-/* framebuffer pixel format blit - must handle backwards copy, different rotation code*/
-static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
-	int SSZ, int SR, int SG, int SB, int SA,
-	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)
-{
-	unsigned char *src, *dst;
-	int width, height, tmp;
-	int src_pitch = gc->src_pitch;
-	int dst_pitch = gc->dst_pitch;	/* dst: next line down*/
-	int ssz = SSZ;
-	int dsz = DSZ;					/* dst: next pixel over*/
-
-	/*
-	 * For psd -> psd blits, the orientation between psd's is always
-	 * the same, so the blit move itself doesn't change. Here,
-	 * we just transform the x,y,w,h coordinates to get to the
-	 * the "top left" of the bitmap psd->addr. These rotations
-	 * slightly different than the rotations required for the
-	 * convblits where we actually copy memory differently
-	 * depending on the orientation.
-	 */
-	switch (PORTRAIT) {
-	case LEFT:
-		// X = Y
-		// Y = xmax - X - W
-		// W = H
-		// H = W
-		tmp = gc->dsty;
-		gc->dsty = psd->xvirtres - gc->dstx - gc->width;
-		gc->dstx = tmp;
-
-		tmp = gc->srcy;
-		gc->srcy = gc->srcpsd->xvirtres - gc->srcx - gc->width;
-		gc->srcx = tmp;
-
-		tmp = gc->width;
-		gc->width = gc->height;
-		gc->height = tmp;
-		break;
-
-	case RIGHT:
-		// X = ymax - Y - H
-		// Y = X
-		// W = H
-		// H = W
-		tmp = gc->dstx;
-		gc->dstx = psd->yvirtres - gc->dsty - gc->height;
-		gc->dsty = tmp;
-
-		tmp = gc->srcx;
-		gc->srcx = gc->srcpsd->yvirtres - gc->srcy - gc->height;
-		gc->srcy = tmp;
-
-		tmp = gc->width;
-		gc->width = gc->height;
-		gc->height = tmp;
-		break;
-
-	case DOWN:
-		// X = xmax - X - W
-		// Y = ymax - Y - H
-		gc->dstx = psd->xvirtres - gc->dstx - gc->width;
-		gc->dsty = psd->yvirtres - gc->dsty - gc->height;
-
-		gc->srcx = gc->srcpsd->xvirtres - gc->srcx - gc->width;
-		gc->srcy = gc->srcpsd->yvirtres - gc->srcy - gc->height;
-		break;
-	}
-
-	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
-	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;
-
-	width = gc->width;
-	height = gc->height;
-
-	/* check for backwards copy if dst in src rect, in same psd*/
-	if (gc->data == gc->data_out)
-	{
-		if (gc->srcy < gc->dsty)
-		{
-			/* copy from bottom upwards*/
-			src += (height - 1) * gc->src_pitch;
-			dst += (height - 1) * gc->dst_pitch;
-			src_pitch = -src_pitch;
-			dst_pitch = -dst_pitch;
-		}
-		if (gc->srcx < gc->dstx)
-		{
-			/* copy from right to left*/
-			src += (width - 1) * SSZ;
-			dst += (width - 1) * DSZ;
-			ssz = -ssz;
-			dsz = -dsz;
-		}
-	}
-
-	DRAWON;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = width;
-
-		while (--w >= 0)
-		{
-			/* inline implementation will optimize out all compares in inner loop*/
-			if (DSZ == 2)
-			{
-				if (SSZ == 2)
-					((unsigned short *)d)[0] = ((unsigned short *)s)[0];
-				else
-					((unsigned short *)d)[0] = RGB2PIXEL(s[SR], s[SG], s[SB]);
-			}
-			else
-			{
-				if (DA >= 0)
-					d[DA] = (SA >= 0)? s[SA]: 255;
-				d[DR] = s[SR];
-				d[DG] = s[SG];
-				d[DB] = s[SB];
-			}
-			d += dsz;
-			s += ssz;
-		}
-		src += src_pitch;
-		dst += dst_pitch;
-	}
-	DRAWOFF;
-
-	/* update screen bits if driver requires it*/
-	if (psd->Update)
-		psd->Update(psd, gc->dstx, gc->dsty, gc->width, gc->height);
-}
-
-/* framebuffer pixel format copy blit - 32bpp*/
-void frameblit_copy_8888_8888(PSD psd, PMWBLITPARMS gc)
-{
-	frameblit_8888(psd, gc, 4, R,G,B,A, 4, R,G,B,A, psd->portrait);
-}
-
-/* framebuffer pixel format copy blit - 24bpp*/
-void frameblit_copy_888_888(PSD psd, PMWBLITPARMS gc)
-{
-	frameblit_8888(psd, gc, 3, R,G,B,-1, 3, R,G,B,-1, psd->portrait);
-}
-
-/* framebuffer pixel format copy blit - 16bpp*/
-void frameblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc)
-{
-	frameblit_8888(psd, gc, 2, 0,0,0,-1, 2, 0,0,0,-1, psd->portrait);
-}
diff --git a/src/engine/convblit_frameb.c b/src/engine/convblit_frameb.c
index b37e09d..758b972 100644
--- a/src/engine/convblit_frameb.c
+++ b/src/engine/convblit_frameb.c
@@ -30,17 +30,18 @@
 #define COPY	0		/* mode parm*/
 #define SRCOVER	1
 
-/* framebuffer pixel format blit - must handle backwards copy, different rotation code*/
-static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
+/* framebuffer pixel format blit - must handle backwards copy, nonstd rotation code*/
+static inline void frameblit_blit(PSD psd, PMWBLITPARMS gc,
 	int SSZ, int SR, int SG, int SB, int SA,
 	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)
 {
-	unsigned char *src, *dst;
-	int width, height, tmp;
 	int src_pitch = gc->src_pitch;
 	int dst_pitch = gc->dst_pitch;	/* dst: next line down*/
+	int op = gc->op;
 	int ssz = SSZ;
 	int dsz = DSZ;					/* dst: next pixel over*/
+	unsigned char *src, *dst;
+	int width, height, tmp;
 
 	/*
 	 * For psd -> psd blits, the orientation between psd's is always
@@ -53,10 +54,7 @@ static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
 	 */
 	switch (PORTRAIT) {
 	case LEFT:
-		// X = Y
-		// Y = xmax - X - W
-		// W = H
-		// H = W
+		/* rotate left: X = Y, Y = xmax - X - W, W = H*/
 		tmp = gc->dsty;
 		gc->dsty = psd->xvirtres - gc->dstx - gc->width;
 		gc->dstx = tmp;
@@ -71,10 +69,7 @@ static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
 		break;
 
 	case RIGHT:
-		// X = ymax - Y - H
-		// Y = X
-		// W = H
-		// H = W
+		/* rotate right: X = ymax - Y - H, Y = X, W = H*/
 		tmp = gc->dstx;
 		gc->dstx = psd->yvirtres - gc->dsty - gc->height;
 		gc->dsty = tmp;
@@ -89,8 +84,7 @@ static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
 		break;
 
 	case DOWN:
-		// X = xmax - X - W
-		// Y = ymax - Y - H
+		/* rotate down: X = xmax - X - W, Y = ymax - Y - H*/
 		gc->dstx = psd->xvirtres - gc->dstx - gc->width;
 		gc->dsty = psd->yvirtres - gc->dsty - gc->height;
 
@@ -126,36 +120,169 @@ static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
 		}
 	}
 
+	/* src_over supported for 32bpp framebuffer only*/
+	if (op == MWROP_SRC_OVER && psd->bpp != 32)
+		op = MWROP_COPY;
+
+	/*
+	 * NOTE: The default implementation uses APPLYOP() which forces a
+	 * switch() within the inner loop to select the rop code.  
+	 * A fast implementation of MWROP_COPY is provided for speed.
+	 * Any other rop can be sped up by including a case for it, and
+	 * calling APPLYOP with a constant op parameter.
+	 *
+	 * The SRC_OVER case must be handled seperately, as APPLYOP doesn't
+	 * handle it, along with the other compositing Porter-Duff ops. FIXME
+	 */
 	DRAWON;
-	while (--height >= 0)
-	{
-		register unsigned char *d = dst;
-		register unsigned char *s = src;
-		int w = width;
+	switch (op) {
+	case MWROP_COPY:
+printf("blit copy\n");
+		/* fast copy implementation, almost identical to default case below*/
+		while (--height >= 0)
+		{
+			register unsigned char *d = dst;
+			register unsigned char *s = src;
+			int w = width;
 
-		while (--w >= 0)
+			while (--w >= 0)
+			{
+				/* inline implementation will optimize out switch statement*/
+				switch (DSZ) {
+				case 4:
+					*(ADDR32)d = *(ADDR32)s;
+					break;
+				case 3:
+					d[0] = s[0];
+					d[1] = s[1];
+					d[2] = s[2];
+					break;
+				case 2:
+					*(ADDR16)d = *(ADDR16)s;
+					break;
+				case 1:
+					*(ADDR8)d = *(ADDR8)s;
+					break;
+				}
+				d += dsz;
+				s += ssz;
+			}
+			src += src_pitch;
+			dst += dst_pitch;
+		}
+		break;
+
+	case MWROP_SRC_OVER:
+printf("blit src_over\n");
+		/* src_over only supported on 32bpp framebuffer*/
+		while (--height >= 0)
 		{
-			/* inline implementation will optimize out all compares in inner loop*/
-			if (DSZ == 2)
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
 			{
-				if (SSZ == 2)
-					((unsigned short *)d)[0] = ((unsigned short *)s)[0];
-				else
-					((unsigned short *)d)[0] = RGB2PIXEL(s[SR], s[SG], s[SB]);
+				unsigned int alpha;
+				if ((alpha = s[SA]) == 255)				/* copy source*/
+				{
+					d[DR] = s[SR];
+					d[DG] = s[SG];
+					d[DB] = s[SB];
+					d[DA] = s[SA];
+				}
+				else if (alpha != 0)					/* blend source w/dest*/
+				{
+ 					/* d += muldiv255(a, s - d)*/
+					d[DR] += muldiv255(alpha, s[SR] - d[DR]);
+					d[DG] += muldiv255(alpha, s[SG] - d[DG]);
+					d[DB] += muldiv255(alpha, s[SB] - d[DB]);
+
+ 					/* d += muldiv255(a, 255 - d)*/
+					d[DA] += muldiv255(alpha, 255 - d[DA]);
+				}
+				d += dsz;
+				s += ssz;
 			}
-			else
+			src += src_pitch;
+			dst += dst_pitch;
+		}
+		break;
+
+	case MWROP_BLENDCONSTANT:
+		/* only supported on 24/32bpp framebuffer*/
+		while (--height >= 0)
+		{
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
 			{
-				if (DA >= 0)
-					d[DA] = (SA >= 0)? s[SA]: 255;
-				d[DR] = s[SR];
-				d[DG] = s[SG];
-				d[DB] = s[SB];
+				unsigned int alpha = 150;	/* blend src/dst with constant alpha*/
+				if (DSZ == 2) {
+					unsigned short val = ((unsigned short *)s)[0];
+					unsigned short sr = REDMASK(val);
+					unsigned short sg = GREENMASK(val);
+					unsigned short sb = BLUEMASK(val);
+					alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
+
+					/* d = muldiv255(255-a, d - s) + s*/
+					((unsigned short *)d)[0] =
+						muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
+				}
+				else
+				{
+ 					/* d += muldiv255(a, s - d)*/
+					d[DR] += muldiv255(alpha, s[SR] - d[DR]);
+					d[DG] += muldiv255(alpha, s[SG] - d[DG]);
+					d[DB] += muldiv255(alpha, s[SB] - d[DB]);
+
+ 					/* d += muldiv255(a, 255 - d)*/
+					if (DA >= 0)
+						d[DA] += muldiv255(alpha, 255 - d[DA]);
+				}
+				d += dsz;
+				s += ssz;
 			}
-			d += dsz;
-			s += ssz;
+			src += src_pitch;
+			dst += dst_pitch;
+		}
+		break;
+
+	default:
+printf("blit op %d\n", op);
+		while (--height >= 0)
+		{
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+
+			/* inline implementation will optimize out switch statement*/
+			switch (DSZ) {
+			case 4:
+				APPLYOP(op, width, *(ADDR32), s, *(ADDR32), d, ssz, dsz);
+				break;
+			case 3:
+				{
+					int w = width;
+					while (--w >= 0)
+					{
+						APPLYOP(op, 3, *(ADDR8), s, *(ADDR8), d, 1, 1);
+						s += ssz - 3;
+						d += dsz - 3;
+					}
+				}
+				break;
+			case 2:
+				APPLYOP(op, width, *(ADDR16), s, *(ADDR16), d, ssz, dsz);
+				break;
+			case 1:
+				APPLYOP(op, width, *(ADDR8), s, *(ADDR8), d, ssz, dsz);
+				break;
+			}
+			src += src_pitch;
+			dst += dst_pitch;
 		}
-		src += src_pitch;
-		dst += dst_pitch;
 	}
 	DRAWOFF;
 
@@ -165,19 +292,457 @@ static inline void frameblit_8888(PSD psd, PMWBLITPARMS gc,
 }
 
 /* framebuffer pixel format copy blit - 32bpp*/
-void frameblit_copy_8888_8888(PSD psd, PMWBLITPARMS gc)
+void frameblit_xxxa8888(PSD psd, PMWBLITPARMS gc)
 {
-	frameblit_8888(psd, gc, 4, R,G,B,A, 4, R,G,B,A, psd->portrait);
+	/* NOTE: src_copy works for alpha in fourth byte only (RGBA and BGRA)*/
+	frameblit_blit(psd, gc, 4, R,G,B,A, 4, R,G,B,A, psd->portrait);
 }
 
 /* framebuffer pixel format copy blit - 24bpp*/
-void frameblit_copy_888_888(PSD psd, PMWBLITPARMS gc)
+void frameblit_24bpp(PSD psd, PMWBLITPARMS gc)
 {
-	frameblit_8888(psd, gc, 3, R,G,B,-1, 3, R,G,B,-1, psd->portrait);
+	frameblit_blit(psd, gc, 3, B,G,R,-1, 3, B,G,R,-1, psd->portrait);
 }
 
 /* framebuffer pixel format copy blit - 16bpp*/
-void frameblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc)
+void frameblit_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	frameblit_blit(psd, gc, 2, 0,0,0,0, 2, 0,0,0,1, psd->portrait);
+}
+
+/* framebuffer pixel format copy blit - 8bpp*/
+void frameblit_8bpp(PSD psd, PMWBLITPARMS gc)
+{
+	frameblit_blit(psd, gc, 1, 0,0,0,0, 1, 0,0,0,0, psd->portrait);
+}
+
+/* framebuffer pixel format stretch blit - src/dst rotation code, no backwards copy*/
+static inline void frameblit_stretchblit(PSD dstpsd, PMWBLITPARMS gc,
+	int SSZ, int SR, int SG, int SB, int SA,
+	int DSZ, int DR, int DG, int DB, int DA, int PORTRAIT)
+{
+	int src_x_step = gc->src_x_step; 		/* normal steps in source image*/
+	int src_y_step = gc->src_y_step; 
+	int src_x_step_one = gc->src_x_step_one; /* 1-unit steps in source image*/
+	int src_y_step_one = gc->src_y_step_one;
+	int err_x_step = gc->err_x_step; 		/* 1-unit error steps in source image*/
+	int err_y_step = gc->err_y_step;
+	int err_y = gc->err_y; 					/* source coordinate error tracking*/
+	int err_x = gc->err_x;
+	int dst_y_step;							/* normal steps in dest image*/
+	int x_denominator = gc->x_denominator;
+	int y_denominator = gc->y_denominator;
+	int op = gc->op;
+	int width = gc->width;
+	int height = gc->height;
+	int ssz, dsz;							/* inner loop step*/
+	int src_pitch, dst_pitch;				/* outer loop step*/
+	int tmp;
+	unsigned char * src;			/* source image ptr*/
+	unsigned char * dst;			/* dest image ptr*/
+
+	/*
+	 * Although this is a framebuffer format blit and the
+	 * orientation between psd's is the same, we use the
+	 * convblit coordinate rotation code, but rotate both
+	 * source and dest coordinates.  This is required because
+	 * the src/dst rotation is computed in the upper level code
+	 * and the passed stretchblit step parms can't be rotated
+	 * without recalcing the original data.
+	 */
+	switch (PORTRAIT) {
+	case NONE:
+		dsz = DSZ;					/* src/dst: next pixel over*/
+		ssz = SSZ;
+		dst_pitch = gc->dst_pitch;	/* src/dst: next line down*/
+		src_pitch = gc->src_pitch;
+		break;
+
+	case LEFT:
+		/* change src/dst top left to lower left for left portrait*/
+		/* rotate left: X -> Y, Y -> maxx - X*/
+		tmp = gc->dsty;
+		gc->dsty = dstpsd->xvirtres - gc->dstx - 1;
+		gc->dstx = tmp;
+
+		tmp = gc->srcy;
+		gc->srcy = gc->srcpsd->xvirtres - gc->srcx - 1;
+		gc->srcx = tmp;
+
+		dsz = -gc->dst_pitch;		/* src/dst: next row up*/
+		ssz = -gc->src_pitch;
+		dst_pitch = DSZ;			/* src/dst: next pixel right*/
+		src_pitch = SSZ;
+		break;
+
+	case RIGHT:
+		/* change src/dst top left to upper right for right portrait*/
+ 		/* Rotate right: X -> maxy - y - h, Y -> X, W -> H, H -> W*/
+		tmp = gc->dstx;
+		gc->dstx = dstpsd->yvirtres - gc->dsty - 1;
+		gc->dsty = tmp;
+
+		tmp = gc->srcx;
+		gc->srcx = gc->srcpsd->yvirtres - gc->srcy - 1;
+		gc->srcy = tmp;
+
+		dsz = gc->dst_pitch;		/* src/dst: next pixel down*/
+		ssz = gc->src_pitch;
+		dst_pitch = -DSZ;			/* src/dst: next pixel left*/
+		src_pitch = -SSZ;
+		break;
+
+	case DOWN:
+		/* change src/dst top left to lower right for down portrait*/
+ 		/* Rotate down: X -> maxx - x - w, Y -> maxy - y - h*/
+		gc->dstx = dstpsd->xvirtres - gc->dstx - 1;
+		gc->dsty = dstpsd->yvirtres - gc->dsty - 1;
+
+		gc->srcx = gc->srcpsd->xvirtres - gc->srcx - 1;
+		gc->srcy = gc->srcpsd->yvirtres - gc->srcy - 1;
+
+		ssz = dsz = -DSZ;			/* src/dst: next pixel left*/
+		dst_pitch = -gc->dst_pitch;	/* src/dst: next pixel up*/
+		src_pitch = -gc->src_pitch;
+		break;
+	}
+
+	/* adjust step values based on bytes per pixel and pitch*/
+	src_x_step 		*= ssz;
+	src_x_step_one  *= ssz;
+	src_y_step 		*= src_pitch;
+	src_y_step_one  *= src_pitch;
+	dst_y_step 		 = dst_pitch;
+
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
+	dst = ((unsigned char *)gc->data_out) + gc->dsty * gc->dst_pitch + gc->dstx * DSZ;
+
+	/* src_over supported for 32bpp framebuffer only*/
+	if (op == MWROP_SRC_OVER && dstpsd->bpp != 32)
+		op = MWROP_COPY;
+
+	/*
+	 * NOTE: The default implementation uses APPLYOP() which forces a
+	 * switch() within the inner loop to select the rop code.  
+	 * A fast implementation of MWROP_COPY is provided for speed.
+	 * Any other rop can be sped up by including a case for it, and
+	 * calling APPLYOP with a constant op parameter.  The MWROP_XOR_FGBG
+	 * example shows this.  A specialized very fast example of
+	 * MWROP_CLEAR is also included.
+	 *
+	 * The SRC_OVER case must be handled seperately, as APPLYOP doesn't
+	 * handle it, along with the other compositing Porter-Duff ops. FIXME
+	 */
+	DRAWON;
+	switch (op) {
+	case MWROP_COPY:
+printf("sblit copy\n");
+		/* fast copy implementation, almost identical to default case below*/
+		while (--height >= 0)
+		{
+			unsigned char *s = src;
+			unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
+			{
+				/* inline implementation will optimize out switch statement*/
+				switch (DSZ) {
+				case 4:
+					*(ADDR32)d = *(ADDR32)s;
+					break;
+				case 3:
+					d[0] = s[0];
+					d[1] = s[1];
+					d[2] = s[2];
+					break;
+				case 2:
+					*(ADDR16)d = *(ADDR16)s;
+					break;
+				case 1:
+					*(ADDR8)d = *(ADDR8)s;
+					break;
+				}
+				d += dsz;
+				s += src_x_step;
+
+				err_x += err_x_step;
+				if (err_x >= 0) {
+					s += src_x_step_one;
+					err_x -= x_denominator;
+				}
+			}
+			dst += dst_y_step;
+			src += src_y_step;
+
+			err_y += err_y_step;
+			if (err_y >= 0) {
+				src += src_y_step_one;
+				err_y -= y_denominator;
+			}
+		}
+		break;
+
+	case MWROP_SRC_OVER:
+printf("sblit src_over\n");
+		/* src_over only supported on 32bpp framebuffer*/
+		while (--height >= 0)
+		{
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
+			{
+#if 1	/* endian-neutral code - reads/writes bytes only*/
+				unsigned int alpha;
+				if ((alpha = s[SA]) == 255)				/* copy source*/
+				{
+					d[DR] = s[SR];
+					d[DG] = s[SG];
+					d[DB] = s[SB];
+					d[DA] = s[SA];
+				}
+				else if (alpha != 0)					/* blend source w/dest*/
+				{
+ 					/* d += muldiv255(a, s - d)*/
+					d[DR] += muldiv255(alpha, s[SR] - d[DR]);
+					d[DG] += muldiv255(alpha, s[SG] - d[DG]);
+					d[DB] += muldiv255(alpha, s[SB] - d[DB]);
+
+ 					/* d += muldiv255(a, 255 - d)*/
+					d[DA] += muldiv255(alpha, 255 - d[DA]);
+				}
+#else /* 32bit read/write - little endian only!*/
+				uint32_t psr, psg, psb, as, pd;
+				uint32_t c = *(ADDR32)s;
+
+				/*
+				 * NOTE: following blend only works with alpha in high byte!!
+				 * This is ok for BGRA and RGBA image formats and little endian cpu
+				 */
+				if ((as = (c >> 24)) == 255)
+					*(ADDR32)d = c;
+				else
+				if (as != 0)
+				{
+					psr = c & 0x00FF0000UL;
+					psg = c & 0x0000FF00UL;
+					psb = c & 0x000000FFUL;
+					/*
+				 	 * Flip the direction of alpha, so it's
+				 	 * backwards from it's usual meaning.
+				 	 * This is because the equation below is most
+				 	 * easily written with source and dest interchanged
+					 * (with ps split beforehand).
+				 	 *
+				 	 * Alpha is then adjusted +1 for 92% accurate blend
+				 	 * with one multiply and shift.
+				 	 */
+					as = 255 - as + 1;
+					pd = *(ADDR32)d;
+					*(ADDR32)d = 
+						((((((pd & 0x00FF0000UL) - psr) * as) >> 8) + psr) & 0x00FF0000UL) |
+						((((((pd & 0x0000FF00UL) - psg) * as) >> 8) + psg) & 0x0000FF00UL) |
+						((((((pd & 0x000000FFUL) - psb) * as) >> 8) + psb) & 0x000000FFUL) |
+					 ((((256-as) << 24) + ((pd & 0xFF000000UL) >> 8) * as) & 0xFF000000UL);
+				  }
+#endif
+				d += dsz;
+				s += src_x_step;
+
+				err_x += err_x_step;
+				if (err_x >= 0) {
+					s += src_x_step_one;
+					err_x -= x_denominator;
+				}
+			}
+			dst += dst_y_step;
+			src += src_y_step;
+
+			err_y += err_y_step;
+			if (err_y >= 0) {
+				src += src_y_step_one;
+				err_y -= y_denominator;
+			}
+		}
+		break;
+#if EXAMPLE
+	/* sample fast implementation for MWROP_CLEAR rop*/
+	case MWROP_CLEAR:
+		while (--height >= 0)
+		{
+			unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
+			{
+				/* inline implementationn will optimize out switch statement*/
+				switch (DSZ) {
+				case 4:
+					*(ADDR32)d = 0;
+					break;
+				case 3:
+					d[2] = d[1] = d[0] = 0;
+					break;
+				case 2:
+					*(ADDR16)d = 0;
+					break;
+				case 1:
+					*(ADDR8)d = 0;
+					break;
+				}
+				d += dsz;
+			}
+			dst += dst_y_step;
+		}
+		break;
+
+	/* sample fast implementation for MWROP_XOR_FGBG rop*/
+	case MWROP_XOR_FGBG:
+		while (--height >= 0)
+		{
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
+			{
+				/* inline implementation will optimize out switch statement and APPLYOP switch*/
+				switch (DSZ) {
+				case 4:
+					APPLYOP(MWROP_XOR_FGBG, 1, *(ADDR32), s, *(ADDR32), d, 0, 0);
+					break;
+				case 3:
+					APPLYOP(op, 3, *(ADDR8), s, *(ADDR8), d, 1, 1);
+					s -= 3;		// required for APPLYOP FIXME
+					d -= 3;
+					break;
+				case 2:
+					APPLYOP(MWROP_XOR_FGBG, 1, *(ADDR16), s, *(ADDR16), d, 0, 0);
+					break;
+				case 1:
+					APPLYOP(MWROP_XOR_FGBG, 1, *(ADDR8), s, *(ADDR8), d, 0, 0);
+					break;
+				}
+				d += dsz;
+				s += src_x_step;
+
+				err_x += err_x_step;
+				if (err_x >= 0) {
+					s += src_x_step_one;
+					err_x -= x_denominator;
+				}
+			}
+			dst += dst_y_step;
+			src += src_y_step;
+
+			err_y += err_y_step;
+			if (err_y >= 0) {
+				src += src_y_step_one;
+				err_y -= y_denominator;
+			}
+		}
+		break;
+#endif /* EXAMPLE*/
+
+	default:
+printf("sblit op %d\n", op);
+		while (--height >= 0)
+		{
+			register unsigned char *s = src;
+			register unsigned char *d = dst;
+			int w = width;
+
+			while (--w >= 0)
+			{
+				/* inline implementation will optimize out switch statement*/
+				switch (DSZ) {
+				case 4:
+					APPLYOP(op, 1, *(ADDR32), s, *(ADDR32), d, 0, 0);
+					break;
+				case 3:
+					APPLYOP(op, 3, *(ADDR8), s, *(ADDR8), d, 1, 1);
+					s -= 3;		// required for APPLYOP FIXME
+					d -= 3;
+					break;
+				case 2:
+					APPLYOP(op, 1, *(ADDR16), s, *(ADDR16), d, 0, 0);
+					break;
+				case 1:
+					APPLYOP(op, 1, *(ADDR8), s, *(ADDR8), d, 0, 0);
+					break;
+				}
+				d += dsz;
+				s += src_x_step;
+
+				err_x += err_x_step;
+				if (err_x >= 0) {
+					s += src_x_step_one;
+					err_x -= x_denominator;
+				}
+			}
+			dst += dst_y_step;
+			src += src_y_step;
+
+			err_y += err_y_step;
+			if (err_y >= 0) {
+				src += src_y_step_one;
+				err_y -= y_denominator;
+			}
+		}
+		break;
+	}
+	DRAWOFF;
+
+	/* switch could be optimized out with constant PORTRAIT paramater*/
+	switch (PORTRAIT) {
+	case NONE:
+		dstpsd->Update(dstpsd, gc->dstx, gc->dsty, gc->width, gc->height);
+		break;
+
+	case LEFT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		dstpsd->Update(dstpsd, gc->dstx, gc->dsty - gc->width + 1, gc->height, gc->width);
+		break;
+
+	case RIGHT:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		dstpsd->Update(dstpsd, gc->dstx - gc->height + 1, gc->dsty, gc->height, gc->width);
+		break;
+
+	case DOWN:
+		/* adjust x,y,w,h to physical top left and w/h*/
+		dstpsd->Update(dstpsd, gc->dstx - gc->width + 1, gc->dsty - gc->height + 1, gc->width, gc->height);
+		break;
+	}
+}
+
+/* framebuffer pixel format stretch blit - 32bpp with alpha in 4th byte*/
+void
+frameblit_stretch_xxxa8888(PSD psd, PMWBLITPARMS gc)
+{
+	/* NOTE: src_copy works for alpha in fourth byte only (RGBA and BGRA)*/
+	frameblit_stretchblit(psd, gc, 4, R,G,B,A, 4, R,G,B,A, psd->portrait);
+}
+
+/* framebuffer pixel format stretch blit - 24bpp*/
+void
+frameblit_stretch_24bpp(PSD psd, PMWBLITPARMS gc)
+{
+	frameblit_stretchblit(psd, gc, 3, 0,0,0,-1, 3, 0,0,0,-1, psd->portrait);
+}
+
+/* framebuffer pixel format stretch blit - 16bpp*/
+void
+frameblit_stretch_16bpp(PSD psd, PMWBLITPARMS gc)
+{
+	frameblit_stretchblit(psd, gc, 2, 0,0,0,-1, 2, 0,0,0,-1, psd->portrait);
+}
+
+/* framebuffer pixel format stretch blit - 8bpp*/
+void
+frameblit_stretch_8bpp(PSD psd, PMWBLITPARMS gc)
 {
-	frameblit_8888(psd, gc, 2, 0,0,0,-1, 2, 0,0,0,-1, psd->portrait);
+	frameblit_stretchblit(psd, gc, 1, 0,0,0,-1, 1, 0,0,0,-1, psd->portrait);
 }
diff --git a/src/engine/convblit_mask.c b/src/engine/convblit_mask.c
index e2127a9..31696cc 100644
--- a/src/engine/convblit_mask.c
+++ b/src/engine/convblit_mask.c
@@ -394,11 +394,11 @@ static inline void convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc,
 						((unsigned short *)d)[0] = RGB2PIXEL(bg_r, bg_g, bg_b);
 					else
 					{
-						if (DA >= 0)
-							d[DA] = bg_a;
 						d[DR] = bg_r;
 						d[DG] = bg_g;
 						d[DB] = bg_b;
+						if (DA >= 0)
+							d[DA] = bg_a;
 					}
 				} 
 			}
@@ -408,11 +408,11 @@ static inline void convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc,
 					((unsigned short *)d)[0] = RGB2PIXEL(fg_r, fg_g, fg_b);
 				else
 				{
-					if (DA >= 0)
-						d[DA] = fg_a;
 					d[DR] = fg_r;
 					d[DG] = fg_g;
 					d[DB] = fg_b;
+					if (DA >= 0)
+						d[DA] = fg_a;
 				}
 			}
 			else									/* blend source w/dest or passed bg*/
@@ -430,14 +430,14 @@ static inline void convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc,
 					}
 					else
 					{
- 						/*d = muldiv255(a, 255 - d) + d*/
-						if (DA >= 0)
-							d[DA] = muldiv255(alpha, 255 - bg_a) + bg_a;
-
  						/* d = muldiv255(a, s - d) + d*/
 						d[DR] = muldiv255(alpha, fg_r - bg_r) + bg_r;
 						d[DG] = muldiv255(alpha, fg_g - bg_g) + bg_g;
 						d[DB] = muldiv255(alpha, fg_b - bg_b) + bg_b;
+
+ 						/*d = muldiv255(a, 255 - d) + d*/
+						if (DA >= 0)
+							d[DA] = muldiv255(alpha, 255 - bg_a) + bg_a;
 					}
 				}
 				else
@@ -449,7 +449,8 @@ static inline void convblit_blend_mask_alpha_byte(PSD psd, PMWBLITPARMS gc,
 						alpha = 255 - alpha + 1; /* flip alpha then add 1 (see muldiv255)*/
 
 						/* d = muldiv255(255-a, d - s) + s*/
-						((unsigned short *)d)[0] = muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
+						((unsigned short *)d)[0] =
+							muldiv255_16bpp(((unsigned short *)d)[0], sr, sg, sb, alpha);
 					}
 					else
 					{
diff --git a/src/engine/devblit.c b/src/engine/devblit.c
index 94ba6ba..ac40056 100644
--- a/src/engine/devblit.c
+++ b/src/engine/devblit.c
@@ -20,6 +20,13 @@
 #include "device.h"
 #include "convblit.h"
 
+#ifndef SIGN
+#define SIGN(x)		(((x) > 0) ? 1 : (((x) == 0) ? 0 : -1))
+#endif
+#ifndef ABS
+#define ABS(x)		(((x) >= 0) ? (x) : -(x))
+#endif
+
 extern MWPIXELVAL gr_foreground;      /* current foreground color */
 extern MWPIXELVAL gr_background;      /* current background color */
 extern MWBOOL 	  gr_usebg;    	      /* TRUE if background drawn in pixmaps */
@@ -206,21 +213,14 @@ GdConversionBlit(PSD psd, PMWBLITPARMS parms)
 static void
 GdBlitInternal(PSD psd, PMWBLITPARMS parms)
 {
-	switch (parms->op) {
-	case MWROP_COPY:
-		if (psd->bpp == 32)
-			frameblit_copy_8888_8888(psd, parms);
-		else if (psd->bpp == 24)
-			frameblit_copy_888_888(psd, parms);
-		else if (psd->bpp == 16)
-			frameblit_copy_16bpp_16bpp(psd, parms);
-		else break;
-		return;
-	}
+		if (psd->FrameBlit)
+			psd->FrameBlit(psd, parms);
+		else {
+			printf("GdBlitInternal: no convblit for op %d, using psd->Blit fallback\n", parms->op);
 
-	printf("GdBlitInternal: no convblit for op %d, using psd->Blit fallback\n", parms->op);
-	psd->Blit(psd, parms->dstx, parms->dsty, parms->width, parms->height,
-		parms->srcpsd, parms->srcx, parms->srcy, parms->op);
+			psd->BlitFallback(psd, parms->dstx, parms->dsty, parms->width, parms->height,
+				parms->srcpsd, parms->srcx, parms->srcy, parms->op);
+		}
 }
 
 /**
@@ -238,7 +238,7 @@ GdBlitInternal(PSD psd, PMWBLITPARMS parms)
  */
 void
 GdBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD width, MWCOORD height,
-	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int32_t rop)
+	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, int rop)
 {
 	int			count;
 	MWBLITPARMS parms;
@@ -294,8 +294,9 @@ if (srcpsd != dstpsd) printf("GdBlit: SRCPSD != DSTPSD\n");
 		parms.srcy = srcy;
 		parms.dstx = dstx;
 		parms.dsty = dsty;
+
 		GdBlitInternal(dstpsd, &parms);
-		//dstpsd->Blit(dstpsd, dstx, dsty, width, height, srcpsd, srcx, srcy, rop);
+
 		GdFixCursor(dstpsd);
 		if (dstpsd != srcpsd)
 			GdFixCursor(srcpsd);
@@ -356,175 +357,17 @@ printf("GdBlit invis\n");
 			parms.srcy = srcy + (py1 - dsty);
 			parms.dstx = px1;
 			parms.dsty = py1;
-			GdBlitInternal(dstpsd, &parms);
-			//dstpsd->Blit(dstpsd, px1, py1, pw, ph, srcpsd, srcx + (px1-dstx), srcy + (py1-dsty), rop);
-		}
-		++prc;
-	}
-	GdFixCursor(dstpsd);
-}
-
-#if 0000 /* THIS FUNCTION IS DEPCRECATED, USE GdStretchBlitEx*/
-/* experimental globals for ratio bug when src != 0*/
-/* Only used by fblin16.c */
-int g_row_inc, g_col_inc;
-
-/**
- * Stretch source rectangle of pixels to destination rectangle quickly
- *
- * @param dstpsd Drawing surface to draw to.
- * @param dstx Destination X co-ordinate.
- * @param dsty Destination Y co-ordinate.
- * @param dstw Width of destination rectangle.
- * @param dsth Height of destination rectangle.
- * @param srcpsd Drawing surface to copy from.
- * @param srcx Source X co-ordinate.
- * @param srcy Source Y co-ordinate.
- * @param srcw Width of source rectangle.
- * @param srch Height of source rectangle.
- * @param rop Raster operation.
- */
-void
-GdStretchBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw,
-	MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy, MWCOORD srcw,
-	MWCOORD srch, int32_t rop)
-{
-	int count;
-#if DYNAMICREGIONS
-	MWRECT *	prc;
-	extern MWCLIPREGION *clipregion;
-#else
-	MWCLIPRECT *	prc;
-	extern MWCLIPRECT cliprects[];
-	extern int clipcount;
-#endif
-
-#if 1 /* FIXME*/
-	/* Use new improved stretchblit if the driver supports it */
-	if (dstpsd->StretchBlitEx) {
-		GdStretchBlitEx(dstpsd, dstx, dsty,
-				dstx + dstw - 1, dsty + dsth - 1,
-				srcpsd, srcx, srcy,
-				srcx + srcw - 1, srcy + srch - 1,
-				rop);
-		return;
-	}
-#endif
-
-g_row_inc = g_col_inc = 0;
-
-	/* check for driver stretch blit implementation*/
-	if (!dstpsd->StretchBlit)
-		return;
-
-	/*FIXME: compare bpp's and convert if necessary*/
-	assert(dstpsd->planes == srcpsd->planes);
-	assert(dstpsd->bpp == srcpsd->bpp);
-	
-	/* clip blit rectangle to source screen/bitmap size*/
-	/* we must do this because there isn't any source clipping setup*/
-	if(srcx < 0) {
-		srcw += srcx;
-		/*dstx -= srcx;*/
-		srcx = 0;
-	}
-	if(srcy < 0) {
-		srch += srcy;
-		/*dsty -= srcy;*/
-		srcy = 0;
-	}
-	if(srcx+srcw > srcpsd->xvirtres)
-		srcw = srcpsd->xvirtres - srcx;
-	if(srcy+srch > srcpsd->yvirtres)
-		srch = srcpsd->yvirtres - srcy;
-
-	/* temp dest clipping for partially visible case*/
-	if(dstx+dstw > dstpsd->xvirtres)
-		dstw = dstpsd->xvirtres - dstx;
-	if(dsty+dsth > dstpsd->yvirtres)
-		dsth = dstpsd->yvirtres - dsty;
-
-	switch(GdClipArea(dstpsd, dstx, dsty, dstx+dstw-1, dsty+dsth-1)) {
-	case CLIP_VISIBLE:
-		/* check cursor in src region*/
-		GdCheckCursor(dstpsd, srcx, srcy, srcx+srcw-1, srcy+srch-1);
-		dstpsd->StretchBlit(dstpsd, dstx, dsty, dstw, dsth,
-			srcpsd, srcx, srcy, srcw, srch, rop);
-		GdFixCursor(dstpsd);
-		return;
-
-	case CLIP_INVISIBLE:
-		return;
-	}
-
-	/* Partly clipped, we'll blit using destination clip
-	 * rectangles, and offset the blit accordingly.
-	 * Since the destination is already clipped, we
-	 * only need to clip the source here.
-	 */
-#if DYNAMICREGIONS
-	prc = clipregion->rects;
-	count = clipregion->numRects;
-#else
-	prc = cliprects;
-	count = clipcount;
-#endif
-	while(--count >= 0) {
-		int rx1, rx2, ry1, ry2;
-		int px1, px2, py1, py2;
-		int pw, ph;
-		int sx, sy, sw, sh;
-#if DYNAMICREGIONS
-		rx1 = prc->left;
-		ry1 = prc->top;
-		rx2 = prc->right;
-		ry2 = prc->bottom;
-#else
-		rx1 = prc->x;
-		ry1 = prc->y;
-		rx2 = prc->x + prc->width;
-		ry2 = prc->y + prc->height;
-#endif
-		/* Check:  does this rect intersect the one we want to draw? */
-		px1 = dstx;
-		py1 = dsty;
-		px2 = dstx + dstw;
-		py2 = dsty + dsth;
-		if (px1 < rx1) px1 = rx1;
-		if (py1 < ry1) py1 = ry1;
-		if (px2 > rx2) px2 = rx2;
-		if (py2 > ry2) py2 = ry2;
 
-		pw = px2 - px1;
-		ph = py2 - py1;
-		if(pw > 0 && ph > 0) {
-			/* calc proper src/dst offset for stretch rect*/
-g_row_inc = (srch << 16) / dsth;
-g_col_inc = (srcw << 16) / dstw;
-			sw = pw * srcw / dstw;
-			sh = ph * srch / dsth;
-
-			if (sw > 0 && sh > 0) {
-				sx = srcx + (px1-dstx) * srcw / dstw;
-				sy = srcy + (py1-dsty) * srch / dsth;
-/*printf("P %d,%d,%d,%d   %d,%d\n", sx, sy, sw, sh, g_row_inc, g_col_inc);*/
-
-				/* check cursor in dest and src regions*/
-				GdCheckCursor(dstpsd, px1, py1, px2-1, py2-1);
-				GdCheckCursor(dstpsd, srcx, srcy, srcx+srcw, srcy+srch);
-				dstpsd->StretchBlit(dstpsd, px1, py1, pw, ph, srcpsd,
-					sx, sy, sw, sh, rop);
-			}
+			GdBlitInternal(dstpsd, &parms);
 		}
 		++prc;
 	}
 	GdFixCursor(dstpsd);
 }
-#endif /* DEPRECATED*/
 
 /**
  * A proper stretch blit.  Supports flipping the image.
- * Paramaters are co-ordinates of two points in the source, and
+ * Parameters are co-ordinates of two points in the source, and
  * two corresponding points in the destination.  The image is scaled
  * and flipped as needed to make the two points correspond.  The
  * top-left corner is drawn, the bottom right one isn't [i.e.
@@ -532,45 +375,46 @@ g_col_inc = (srcw << 16) / dstw;
  * at (0,0), (0,1), (1,0), (1,1).  It does not include the points
  * where x=2 or y=2.]
  *
+ * Can stretch the image by any X and/or Y scale factor.
+ * Can flip the image in the X and/or Y axis.
+ *
+ * This is the faster version with no per-pixel multiply and a single
+ * decision tree for the inner loop, by Jon.  Based on Alex's original
+ * all-integer version.
+ *
  * Raster ops are not yet fully implemented - see the low-level
  * drivers for details.
  *
  * Note that we do not support overlapping blits.
  *
  * @param dstpsd Drawing surface to draw to.
- * @param d1_x Destination X co-ordinate of first corner.
- * @param d1_y Destination Y co-ordinate of first corner.
- * @param d2_x Destination X co-ordinate of second corner.
- * @param d2_y Destination Y co-ordinate of second corner.
+ * @param dx1 Destination X co-ordinate of first corner.
+ * @param dy1 Destination Y co-ordinate of first corner.
+ * @param dx2 Destination X co-ordinate of second corner.
+ * @param dy2 Destination Y co-ordinate of second corner.
  * @param srcpsd Drawing surface to copy from.
- * @param s1_x Source X co-ordinate of first corner.
- * @param s1_y Source Y co-ordinate of first corner.
- * @param s2_x Source X co-ordinate of second corner.
- * @param s2_y Source Y co-ordinate of second corner.
+ * @param sx1 Source X co-ordinate of first corner.
+ * @param sy1 Source Y co-ordinate of first corner.
+ * @param sx2 Source X co-ordinate of second corner.
+ * @param sy2 Source Y co-ordinate of second corner.
  * @param rop Raster operation.
  */
 void
-GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
-	MWCOORD d2_y, PSD srcpsd, MWCOORD s1_x, MWCOORD s1_y, MWCOORD s2_x,
-	MWCOORD s2_y, int32_t rop)
+GdStretchBlitEx(PSD dstpsd, MWCOORD dx1, MWCOORD dy1, MWCOORD dx2,
+	MWCOORD dy2, PSD srcpsd, MWCOORD sx1, MWCOORD sy1, MWCOORD sx2,
+	MWCOORD sy2, int rop)
 {
-	/* Scale factors (as fractions, numerator/denominator) */
-	int src_x_step_numerator;
-	int src_x_step_denominator;
-	int src_y_step_numerator;
-	int src_y_step_denominator;
-
-	/* Clipped dest co-ords */
-	MWCOORD c1_x;
-	MWCOORD c1_y;
-	MWCOORD c2_x;
-	MWCOORD c2_y;
-
-	/* Initial source co-ordinates, as a fraction (denominators as above) */
-	int src_x_start_exact;
-	int src_y_start_exact;
-
-	/* Used by the clipping code. */
+	int x_numerator;		/* Scale factors (as fractions, numerator/denominator) */
+	int x_denominator;
+	int y_numerator;
+	int y_denominator;
+	int x_start_fraction;	/* Initial source co-ordinates, as a fraction (denominators as above) */
+	int y_start_fraction;
+	MWCOORD cx1;			/* Clipped dest co-ords */
+	MWCOORD cy1;
+	MWCOORD cx2;
+	MWCOORD cy2;
+	MWBLITPARMS parms;
 #if DYNAMICREGIONS
 	int 		count;
 	MWRECT *	prc;
@@ -582,214 +426,188 @@ GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 	extern int	clipcount;
 #endif
 
-	assert(srcpsd);
-	assert(dstpsd);
+	/* source and dest pixmaps must be same format and rotation*/
+	assert(dstpsd->data_format == srcpsd->data_format);
+	assert(dstpsd->portrait == srcpsd->portrait);
 
 	/* DPRINTF("Nano-X: GdStretchBlitEx(dst=%x (%d,%d)-(%d,%d), src=%x (%d,%d)-(%d,%d), op=0x%lx\n",
-	           (int) dstpsd, (int) d1_x, (int) d1_y, (int) d2_x, (int) d2_y,
-	           (int) srcpsd, (int) s1_x, (int) s1_y, (int) s2_x, (int) s2_y, rop); */
+	           (int) dstpsd, (int) dx1, (int) dy1, (int) dx2, (int) dy2,
+	           (int) srcpsd, (int) sx1, (int) sy1, (int) sx2, (int) sy2, rop); */
 
 	/* Sort co-ordinates so d1 is top left, d2 is bottom right. */
-	if (d1_x > d2_x) {
-		register MWCOORD tmp = d2_x;
-		d2_x = d1_x;
-		d1_x = tmp;
-		tmp = s2_x;
-		s2_x = s1_x;
-		s1_x = tmp;
+	if (dx1 > dx2) {
+		MWCOORD tmp = dx2;
+		dx2 = dx1;
+		dx1 = tmp;
+		tmp = sx2;
+		sx2 = sx1;
+		sx1 = tmp;
 	}
 
-	if (d1_y > d2_y) {
-		register MWCOORD tmp = d2_y;
-		d2_y = d1_y;
-		d1_y = tmp;
-		tmp = s2_y;
-		s2_y = s1_y;
-		s1_y = tmp;
+	if (dy1 > dy2) {
+		MWCOORD tmp = dy2;
+		dy2 = dy1;
+		dy1 = tmp;
+		tmp = sy2;
+		sy2 = sy1;
+		sy1 = tmp;
 	}
 
-	if ((d2_x < 0) || (d2_y < 0)
-	    || (d1_x > dstpsd->xvirtres)
-	    || (d1_y > dstpsd->yvirtres)
-	    || (d1_x == d2_x)
-	    || (d1_y == d2_y)) {
-		/* Destination rectangle is entirely off screen, or is zero-sized*/
-		/* DPRINTF("Nano-X: GdStretchBlitEx: CLIPPED OFF (dest rect offscreen or 0)\n"); */
+	/* Destination rectangle is entirely off screen, or is zero-sized*/
+	if (dx2 < 0 || dy2 < 0 || dx1 > dstpsd->xvirtres || dy1 > dstpsd->yvirtres ||
+		dx1 == dx2 || dy1 == dy2) {
 		return;
 	}
 
 	/* If we're not stretching or flipping, use the standard blit (faster)*/
-	if ((d2_x - d1_x == s2_x - s1_x) && (d2_y - d1_y == s2_y - s1_y)) {
-		GdBlit(dstpsd, d1_x, d1_y, d2_x - d1_x, d2_y - d1_y, srcpsd, s1_x, s1_y, rop);
+	if ((dx2 - dx1 == sx2 - sx1) && (dy2 - dy1 == sy2 - sy1)) {
+		GdBlit(dstpsd, dx1, dy1, dx2 - dx1, dy2 - dy1, srcpsd, sx1, sy1, rop);
 		return;
 	}
 
-	if (!dstpsd->StretchBlitEx) {
-		EPRINTF("GdStretchBlitEx NOT SUPPORTED on this target\n");
+	/* check for driver, there's no fallback*/
+	if (!dstpsd->FrameStretchBlit) {
+		DPRINTF("GdStretchBlitInternal: no convblit for op %d\n", rop);
 		return;
 	}
 
 	/* Need to preserve original values, so make a copy we can clip. */
-	c1_x = d1_x;
-	c1_y = d1_y;
-	c2_x = d2_x;
-	c2_y = d2_y;
+	cx1 = dx1;
+	cy1 = dy1;
+	cx2 = dx2;
+	cy2 = dy2;
 
-	/* Calculate how far in source co-ordinates is
-	 * equivalent to one pixel in dest co-ordinates.
+ 	/*
+	 * Calculate how far in source co-ordinates is equivalent to one pixel in dest co-ordinates.
+	 *
+ 	 * x_denominator   -
+ 	 * y_denominator   - Denominator for source X or Y value fractions.  Note that
+ 	 *                   this must be even, and all the numerators must also be
+ 	 *                   even, so we can easily divide by 2.
+ 	 * x_fraction  	   -
+ 	 * y_fraction      - Point in source that corresponds to the top left corner
+ 	 *                   of the pixel (dstx, dsty).  This is a fraction - to get
+ 	 *					 a float, divide by y_denominator.
+ 	 * x_numerator     -
+ 	 * y_numerator     - X step in src for an x++/y++ step in dest.  May be negative
+ 	 *                   (for a flip).  Expressed as a fraction - divide it by
+ 	 *                   x/y_denominator for a float.
+	 *
 	 * This is stored as a fraction (numerator/denominator).
 	 * The numerator may be > denominator.  The numerator
 	 * may be negative, the denominator is always positive.
 	 *
-	 * We need half this distance for some purposes,
-	 * hence the *2.
+	 * We need half this distance for some purposes, hence the *2.
 	 *
-	 * The +1s are because we care about *sizes*, not
-	 * deltas.  (Without the +1s it just doesn't
-	 * work properly.)
+	 * The +1s are because we care about *sizes*, not deltas.  
+	 * (Without the +1s it just doesn't work properly.)
 	 */
-	src_x_step_numerator = (s2_x - s1_x + 1) << 1;
-	src_x_step_denominator = (d2_x - d1_x + 1) << 1;
-	src_y_step_numerator = (s2_y - s1_y + 1) << 1;
-	src_y_step_denominator = (d2_y - d1_y + 1) << 1;
+	x_numerator = (sx2 - sx1 + 1) << 1;
+	x_denominator = (dx2 - dx1 + 1) << 1;
+	y_numerator = (sy2 - sy1 + 1) << 1;
+	y_denominator = (dy2 - dy1 + 1) << 1;
 
 	/* Clip the image so that the destination X co-ordinates
-	 * in c1_x and c2_x map to a point on the source image.
+	 * in cx1 and cx2 map to a point on the source image.
 	 */
-	if ((s1_x < 0) || (s1_x > srcpsd->xvirtres) || (s2_x < 0) || (s2_x > srcpsd->xvirtres)) {
-		/* Calculate where the left of the source image will end up,
-		 * in dest co-ordinates.
-		 */
-		int i1_x = d1_x - (s1_x * src_x_step_denominator) / src_x_step_numerator;
+	if (sx1 < 0 || sx1 > srcpsd->xvirtres || sx2 < 0 || sx2 > srcpsd->xvirtres) {
+		/* Calculate where the left of the source image will end up, in dest co-ordinates*/
+		int ix1 = dx1 - (sx1 * x_denominator) / x_numerator;
 
-		/* Calculate where the right of the source image will end up,
-		 * in dest co-ordinates.
-		 */
-		int i2_x = d1_x +
-			((srcpsd->xvirtres - s1_x) * src_x_step_denominator + src_x_step_denominator - 1)
-				/ src_x_step_numerator;
+		/* Calculate where the right of the source image will end up, in dest co-ordinates*/
+		int ix2 = dx1 + ((srcpsd->xvirtres - sx1) * x_denominator + x_denominator - 1) / x_numerator;
 
 		/* Since we may be doing a flip, "left" and "right" in the statements
 		 * above do not necessarily correspond to "left" and "right" in the
 		 * destination image, which is where we're clipping.  So sort the
 		 * X co-ordinates.
 		 */
-		if (i1_x > i2_x) {
-			register int temp = i1_x;
-			i1_x = i2_x;
-			i2_x = temp;
+		if (ix1 > ix2) {
+			int temp = ix1;
+			ix1 = ix2;
+			ix2 = temp;
 		}
 
-		/* Check for total invisibility */
-		if (c2_x < i1_x || c1_x > i2_x) {
-			/* DPRINTF("Nano-X: GdStretchBlitEx: CLIPPED OFF (source X checks)\n"); */
+		/* Check for total invisibility - source X checks*/
+		if (cx2 < ix1 || cx1 > ix2)
 			return;
-		}
 
 		/* Perform partial clip */
-		if (c1_x < i1_x) c1_x = i1_x;
-		if (c2_x > i2_x) c2_x = i2_x;
+		if (cx1 < ix1) cx1 = ix1;
+		if (cx2 > ix2) cx2 = ix2;
 	}
 
 	/* Clip the image so that the destination Y co-ordinates
-	 * in c1_y and c2_y map to a point on the source image.
+	 * in cy1 and cy2 map to a point on the source image.
 	 */
-	if ((s1_y < 0) || (s1_y > srcpsd->yvirtres) || (s2_y < 0) || (s2_y > srcpsd->yvirtres)) {
-		/* Calculate where the top of the source image will end up,
-		 * in dest co-ordinates.
-		 */
-		int i1_y = d1_y - (s1_y * src_y_step_denominator) / src_y_step_numerator;
+	if (sy1 < 0 || sy1 > srcpsd->yvirtres || sy2 < 0 || sy2 > srcpsd->yvirtres) {
+		/* Calculate where the top of the source image will end up, in dest co-ordinates*/
+		int iy1 = dy1 - (sy1 * y_denominator) / y_numerator;
 
-		/* Calculate where the bottom of the source image will end up,
-		 * in dest co-ordinates.
-		 */
-		int i2_y = d1_y + 
-			((srcpsd->yvirtres - s1_y) * src_y_step_denominator + src_y_step_denominator - 1)
-				/ src_y_step_numerator;
+		/* Calculate where the bottom of the source image will end up, in dest co-ordinates*/
+		int iy2 = dy1 + ((srcpsd->yvirtres - sy1) * y_denominator + y_denominator - 1) / y_numerator;
 
 		/* Since we may be doing a flip, "top" and bottom" in the statements
 		 * above do not necessarily correspond to "top" and bottom" in the
 		 * destination image, which is where we're clipping.  So sort the
 		 * Y co-ordinates.
 		 */
-		if (i1_y > i2_y) {
-			register int temp = i1_y;
-			i1_y = i2_y;
-			i2_y = temp;
+		if (iy1 > iy2) {
+			int temp = iy1;
+			iy1 = iy2;
+			iy2 = temp;
 		}
 
-		/* Check for total invisibility */
-		if (c2_y < i1_y || c1_y > i2_y) {
-			/* DPRINTF("Nano-X: GdStretchBlitEx: CLIPPED OFF (source Y checks)\n"); */
+		/* Check for total invisibility - source Y checks*/
+		if (cy2 < iy1 || cy1 > iy2)
 			return;
-		}
 
 		/* Perform partial clip */
-		if (c1_y < i1_y) c1_y = i1_y;
-		if (c2_y > i2_y) c2_y = i2_y;
+		if (cy1 < iy1) cy1 = iy1;
+		if (cy2 > iy2) cy2 = iy2;
 	}
 
-	/* Clip against dest window (NOT dest clipping region). */
-	if (c1_x < 0) c1_x = 0;
-	if (c1_y < 0) c1_y = 0;
-	if (c2_x > dstpsd->xvirtres) c2_x = dstpsd->xvirtres;
-	if (c2_y > dstpsd->yvirtres) c2_y = dstpsd->yvirtres;
+	/* Clip against physical screen*/
+	if (cx1 < 0) cx1 = 0;
+	if (cy1 < 0) cy1 = 0;
+	if (cx2 > dstpsd->xvirtres) cx2 = dstpsd->xvirtres;
+	if (cy2 > dstpsd->yvirtres) cy2 = dstpsd->yvirtres;
 
-	/* Final fully-offscreen check */
-	if (c1_x >= c2_x || c1_y >= c2_y) {
-		/* DPRINTF("Nano-X: GdStretchBlitEx: CLIPPED OFF (final check)\n"); */
+	/* Final fully-offscreen clip check */
+	if (cx1 >= cx2 || cy1 >= cy2)
 		return;
-	}
 
-	/* Well, if we survived that lot, then we now have a destination
-	 * rectangle defined in (c1_x,c1_y)-(c2_x,c2_y).
-	 */
+	/* We now have a destination rectangle defined in (cx1,cy1)-(cx2,cy2)*/
 
 	/* DPRINTF("Nano-X: GdStretchBlitEx: Clipped rect: (%d,%d)-(%d,%d)\n",
-	       (int) c1_x, (int) c1_y, (int) c2_x, (int) c2_y); */
-
-	/* Calculate the position in the source rectange that is equivalent
-	 * to the top-left of the destination rectangle.
-	 */
-	src_x_start_exact = s1_x * src_x_step_denominator + (c1_x - d1_x) * src_x_step_numerator;
-	src_y_start_exact = s1_y * src_y_step_denominator + (c1_y - d1_y) * src_y_step_numerator;
+	       (int) cx1, (int) cy1, (int) cx2, (int) cy2); */
 
-	/* OK, clipping so far has been against physical bounds, we now have
-	 * to worry about user defined clip regions.
-	 */
-	switch (GdClipArea(dstpsd, c1_x, c1_y, c2_x - 1, c2_y - 1)) {
-	case CLIP_INVISIBLE:
-		/* DPRINTF("Nano-X: GdStretchBlitEx: CLIPPED OFF (GdClipArea check)\n"); */
-		return;
-	case CLIP_VISIBLE:
-		/* FIXME: check cursor in src region */
-		/* GdCheckCursor(srcpsd, c1_x, c1_y, c2_x-1, c2_y-1); */
-		/* DPRINTF("Nano-X: GdStretchBlitEx: no more clipping needed\n"); */
-		dstpsd->StretchBlitEx(dstpsd, srcpsd,
-					c1_x, c1_y,
-					c2_x - c1_x,
-					c2_y - c1_y,
-					src_x_step_denominator,
-					src_y_step_denominator,
-					src_x_start_exact,
-					src_y_start_exact,
-					src_x_step_numerator,
-					src_y_step_numerator, rop);
-		/* GdFixCursor(srcpsd); */
-		GdFixCursor(dstpsd);
+	/* clip against other windows*/
+	if (GdClipArea(dstpsd, cx1, cy1, cx2 - 1, cy2 - 1) == CLIP_INVISIBLE)
 		return;
 
-	}
-	/* DPRINTF("Nano-X: GdStretchBlitEx: complex clipping needed\n"); */
+	//GdCheckCursor(dstpsd, cx1, cy1, cx2-1, cy2-1);	/* onetime cursor check in dst region*/
+	//GdCheckCursor(srcpsd, sx1, sy1, sx2 - 1, sy2 - 1);/* check cursor in src region*/
 
-	/* FIXME: check cursor in src region */
-	/* GdCheckCursor(srcpsd, c1_x, c1_y, c2_x-1, c2_y-1); */
+	/* Calculate the starting position (fraction) in the source rectange
+	 * that is equivalent to the top-left of the destination rectangle.
+	 */
+	x_start_fraction = sx1 * x_denominator + (cx1 - dx1) * x_numerator;
+	y_start_fraction = sy1 * y_denominator + (cy1 - dy1) * y_numerator;
 
+	/* set invariant parameters*/
+	parms.op = rop;
+	parms.data_format = dstpsd->data_format;
+	parms.data = srcpsd->addr;
+	parms.src_pitch = srcpsd->pitch;
+	parms.data_out = dstpsd->addr;
+	parms.dst_pitch = dstpsd->pitch;
+	parms.srcpsd = srcpsd;
+	parms.x_denominator = x_denominator;
+	parms.y_denominator = y_denominator;
 
-	/* Partly clipped, we'll blit using destination clip
-	 * rectangles, and offset the blit accordingly.
-	 * Since the destination is already clipped, we
-	 * only need to clip the source here.
+	/* We'll blit using destination clip rectangles, and offset the blit accordingly.
+	 * Since the destination is already clipped, we only need to clip the source here.
 	 */
 #if DYNAMICREGIONS
 	prc = clipregion->rects;
@@ -799,93 +617,64 @@ GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 	count = clipcount;
 #endif
 	while (--count >= 0) {
-		int r1_x, r2_x, r1_y, r2_y;
+		int rx1, rx2, ry1, ry2;
 #if DYNAMICREGIONS
-		r1_x = prc->left;
-		r1_y = prc->top;
-		r2_x = prc->right;
-		r2_y = prc->bottom;
+		rx1 = prc->left;
+		ry1 = prc->top;
+		rx2 = prc->right;
+		ry2 = prc->bottom;
 #else
-		r1_x = prc->x;
-		r1_y = prc->y;
-		r2_x = prc->x + prc->width;
-		r2_y = prc->y + prc->height;
+		rx1 = prc->x;
+		ry1 = prc->y;
+		rx2 = prc->x + prc->width;
+		ry2 = prc->y + prc->height;
 #endif
-
 		/* Check:  does this rect intersect the one we want to draw? */
 		/* Clip r1-r2 so it's inside c1-c2 */
-		if (r1_x < c1_x) r1_x = c1_x;
-		if (r1_y < c1_y) r1_y = c1_y;
-		if (r2_x > c2_x) r2_x = c2_x;
-		if (r2_y > c2_y) r2_y = c2_y;
-
-		if (r1_x < r2_x && r1_y < r2_y) {
-			/* So we're drawing to:
-			 * destination rectangle (r1_x, r1_y) - (r2_x, r2_y)
-			 * source start co-ords:
-			 * x = src_x_start_exact + (r1_x - c1_x)*src_x_step_numerator
-			 * y = src_y_start_exact + (r1_y - c1_y)*src_y_step_numerator
-			 */
-
-			/* check cursor in dest region */
-			GdCheckCursor(dstpsd, r1_x, r1_y, r2_x - 1, r2_y - 1);
-			dstpsd->StretchBlitEx(dstpsd, srcpsd,
-						r1_x, r1_y,
-						r2_x - r1_x,
-						r2_y - r1_y,
-						src_x_step_denominator,
-						src_y_step_denominator,
-						src_x_start_exact + (r1_x - c1_x) * src_x_step_numerator,
-						src_y_start_exact + (r1_y - c1_y) * src_y_step_numerator,
-						src_x_step_numerator,
-						src_y_step_numerator,
-						rop);
+		if (rx1 < cx1) rx1 = cx1;
+		if (ry1 < cy1) ry1 = cy1;
+		if (rx2 > cx2) rx2 = cx2;
+		if (ry2 > cy2) ry2 = cy2;
+
+		/* So we're drawing to destination rectangle (rx1, ry1) - (rx2, ry2)
+		 * x_fraction = x_start_fraction + (rx1 - cx1)*x_numerator
+		 * y_fraction = y_start_fraction + (ry1 - cy1)*y_numerator
+		 */
+		if (rx1 < rx2 && ry1 < ry2) {
+			/* Source starting point (fraction).  Add half a pixel here so we're
+			 * sampling from the middle of the pixel, not the top left corner.
+	 		 */
+			int x_fraction = (x_start_fraction + (rx1 - cx1) * x_numerator) + (x_numerator >> 1);
+			int y_fraction = (y_start_fraction + (ry1 - cy1) * y_numerator) + (y_numerator >> 1);
+
+			/* set src/dst starting points (pixel)*/
+			parms.dstx = rx1;
+			parms.dsty = ry1;
+			parms.width = rx2 - rx1;
+			parms.height = ry2 - ry1;
+			parms.srcx = x_fraction / x_denominator;	/* seperate whole part from fraction*/
+			parms.srcy = y_fraction / y_denominator;
+
+			/* We need to do lots of comparisons to see if error values
+	 		 * are >= x_denominator.  So subtract an extra x_denominator for speed,
+	 		 * then we can just check if it's >= 0.
+	 		 */
+			parms.err_x = x_fraction - (parms.srcx + 1) * x_denominator;
+			parms.err_y = y_fraction - (parms.srcy + 1) * y_denominator;
+
+			/* calculate various deltas for fast blitter source stepping*/
+			parms.src_x_step = x_numerator / x_denominator;
+			parms.src_x_step_one = SIGN(x_numerator);
+			parms.err_x_step = ABS(x_numerator) - ABS(parms.src_x_step) * x_denominator;
+			parms.src_y_step = y_numerator / y_denominator;
+			parms.src_y_step_one = SIGN(y_numerator);
+			parms.err_y_step = ABS(y_numerator) - ABS(parms.src_y_step) * y_denominator;
+
+			GdCheckCursor(dstpsd, rx1, ry1, rx2 - 1, ry2 - 1);	/* check cursor in dest region */
+			dstpsd->FrameStretchBlit(dstpsd, &parms);
 		}
 		++prc;
 	}
 	GdFixCursor(dstpsd);
-	/* GdFixCursor(srcpsd); */
+	//GdFixCursor(srcpsd);
 }
-
-#if DEBUG
-void GdPrintBitmap(PMWBLITPARMS gc, int SSZ)
-{
-	unsigned char *src;
-	int height;
-	unsigned int v;
-
-	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
-
-	printf("Image %d,%d SSZ %d\n", gc->width, gc->height, SSZ);
-	height = gc->height;
-	while (--height >= 0)
-	{
-		register unsigned char *s = src;
-		int w = gc->width;
-
-		while (--w >= 0)
-		{
-			switch (SSZ) {
-			case 2:
-				v = s[0] | (s[1] << 8);
-				v = PIXEL565RED(v) + PIXEL565GREEN(v) + PIXEL565BLUE(v);
-				printf("%c", "_.:;oVM@X"[v]);
-				break;
-			case 3:
-				v = (s[0] + s[1] + s[2]) / 3;
-				printf("%c", "_.:;oVM@X"[v >> 5]);
-				break;
-			case 4:
-				//if (s[4])
-					v = (s[0] + s[1] + s[2]) / 3;
-				//else v = 256;
-				printf("%c", "_.:;oVM@X"[v >> 5]);
-				break;
-			}
-			s += SSZ;				/* src: next pixel right*/
-		}
-		printf("\n");
-		src += gc->src_pitch;		/* src: next line down*/
-	}
-}
-#endif
diff --git a/src/engine/devopen.c b/src/engine/devopen.c
index 17843f0..412018c 100644
--- a/src/engine/devopen.c
+++ b/src/engine/devopen.c
@@ -651,3 +651,46 @@ GdCaptureScreen(char *path)
 	return 0;
 }
 #endif /* !VXWORKS*/
+
+#if DEBUG
+void GdPrintBitmap(PMWBLITPARMS gc, int SSZ)
+{
+	unsigned char *src;
+	int height;
+	unsigned int v;
+
+	src = ((unsigned char *)gc->data)     + gc->srcy * gc->src_pitch + gc->srcx * SSZ;
+
+	printf("Image %d,%d SSZ %d\n", gc->width, gc->height, SSZ);
+	height = gc->height;
+	while (--height >= 0)
+	{
+		register unsigned char *s = src;
+		int w = gc->width;
+
+		while (--w >= 0)
+		{
+			switch (SSZ) {
+			case 2:
+				v = s[0] | (s[1] << 8);
+				v = PIXEL565RED(v) + PIXEL565GREEN(v) + PIXEL565BLUE(v);
+				printf("%c", "_.:;oVM@X"[v]);
+				break;
+			case 3:
+				v = (s[0] + s[1] + s[2]) / 3;
+				printf("%c", "_.:;oVM@X"[v >> 5]);
+				break;
+			case 4:
+				//if (s[4])
+					v = (s[0] + s[1] + s[2]) / 3;
+				//else v = 256;
+				printf("%c", "_.:;oVM@X"[v >> 5]);
+				break;
+			}
+			s += SSZ;				/* src: next pixel right*/
+		}
+		printf("\n");
+		src += gc->src_pitch;		/* src: next line down*/
+	}
+}
+#endif
diff --git a/src/engine/image_xpm.c b/src/engine/image_xpm.c
index 456d2e9..3c90032 100644
--- a/src/engine/image_xpm.c
+++ b/src/engine/image_xpm.c
@@ -159,7 +159,7 @@ GdDecodeXPM(buffer_t * src, PMWIMAGEHDR pimage, PSD psd)
 				pimage->bpp = 32;
 				pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
 				pimage->data_format = MWIF_RGBA8888;
-printf("xpm 32bpp ARGB8888\n");
+printf("xpm 32bpp RGBA8888\n");
 			}
 
 			pimage->palsize = colors;
diff --git a/src/ft2test.sh b/src/ft2test.sh
index a1b0431..28c6e4c 100755
--- a/src/ft2test.sh
+++ b/src/ft2test.sh
@@ -2,4 +2,4 @@
 # Nano-X applications, press <BREAK> key to exit
 #bin/nano-X -N & bin/nanowm & bin/ft2test & sleep 10000
 #pkill nano
-bin/nano-X -N & bin/nanowm & bin/ft2test & sleep 10000
+bin/nano-X -L -x 810 -y 640 & bin/nanowm & bin/ft2test & sleep 10000
diff --git a/src/include/convblit.h b/src/include/convblit.h
index ddf2c6d..0da68d0 100644
--- a/src/include/convblit.h
+++ b/src/include/convblit.h
@@ -67,20 +67,26 @@ void convblit_copy_mask_mono_byte_msb_bgra_large(PSD psd, PMWBLITPARMS gc);	/* f
 void convblit_copy_mask_mono_byte_lsb_bgra_large(PSD psd, PMWBLITPARMS gc);	/* t1lib non-alias*/
 #endif
 
-/* image_bmp.c*/
 
+/* convblit_frameb.c*/
+/* framebuffer pixel format blits - must handle backwards copy, different rotation code*/
+void frameblit_xxxa8888(PSD psd, PMWBLITPARMS gc);		/* 32bpp*/
+void frameblit_24bpp(PSD psd, PMWBLITPARMS gc);			/* 24bpp*/
+void frameblit_16bpp(PSD psd, PMWBLITPARMS gc);			/* 16bpp*/
+void frameblit_8bpp(PSD psd, PMWBLITPARMS gc);			/* 8bpp*/
+
+/* framebuffer pixel format stretch blits - different rotation code, no backwards copy*/
+void frameblit_stretch_xxxa8888(PSD dstpsd, PMWBLITPARMS gc);	/* 32bpp, alpha in byte 4*/
+void frameblit_stretch_24bpp(PSD psd, PMWBLITPARMS gc);			/* 24 bpp*/
+void frameblit_stretch_16bpp(PSD psd, PMWBLITPARMS gc);			/* 16 bpp*/
+void frameblit_stretch_8bpp(PSD psd, PMWBLITPARMS gc);			/* 8 bpp*/
+
+/* image_bmp.c*/
 /* Conversion blit 24bpp BGR to 24bpp RGB*/
 void convblit_bgr888_rgb888(unsigned char *data, int width, int height, int pitch);
 /* Conversion blit 32bpp BGRX to 32bpp RGBA 255 alpha*/
 void convblit_bgrx8888_rgba8888(unsigned char *data, int width, int height, int pitch);
 
 /* image_tiff.c*/
-
 /* Conversion blit flip y direction 32bpp (upside-down)*/
 void convblit_flipy_8888(PMWBLITPARMS gc);
-
-/* convblit_8888.c*/
-/* framebuffer pixel format blits*/
-void frameblit_copy_8888_8888(PSD psd, PMWBLITPARMS gc);	/* 32bpp*/
-void frameblit_copy_888_888(PSD psd, PMWBLITPARMS gc);		/* 24bpp*/
-void frameblit_copy_16bpp_16bpp(PSD psd, PMWBLITPARMS gc);	/* 16bpp*/
diff --git a/src/include/device.h b/src/include/device.h
index f2ef847..b23e4c4 100644
--- a/src/include/device.h
+++ b/src/include/device.h
@@ -100,13 +100,13 @@ typedef struct {
 	void 	 (*DrawHorzLine)(PSD psd, MWCOORD x1, MWCOORD x2, MWCOORD y, MWPIXELVAL c);
 	void	 (*DrawVertLine)(PSD psd, MWCOORD x, MWCOORD y1, MWCOORD y2, MWPIXELVAL c);
 	void	 (*FillRect)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2, MWCOORD y2,MWPIXELVAL c);
-	void	 (*Blit)(PSD destpsd, MWCOORD destx, MWCOORD desty, MWCOORD w, MWCOORD h,
-				PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
-	void 	 (*StretchBlitEx)(PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, int dest_y_start,
-			MWCOORD width, int height, int x_denominator, int y_denominator,
-			int src_x_fraction, int src_y_fraction,
-			int x_step_fraction, int y_step_fraction, int op);
-	/* new fast blit functions*/
+	/* fallback blit - used only for 1,2,4bpp drivers*/
+	void	(*BlitFallback)(PSD destpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
+							PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
+	/* endian neutral hw pixel format blits*/
+	MWBLITFUNC FrameBlit;
+	MWBLITFUNC FrameStretchBlit;
+	/* fast conversion blits for text and images*/
 	MWBLITFUNC BlitCopyMaskMonoByteMSB;				/* ft non-alias*/
 	MWBLITFUNC BlitCopyMaskMonoByteLSB;				/* t1 non-alias*/
 	MWBLITFUNC BlitCopyMaskMonoWordMSB;				/* core/pcf non-alias*/
@@ -161,12 +161,13 @@ typedef struct _mwscreendevice {
 	void	(*DrawHorzLine)(PSD psd,MWCOORD x1,MWCOORD x2,MWCOORD y, MWPIXELVAL c);
 	void	(*DrawVertLine)(PSD psd,MWCOORD x,MWCOORD y1,MWCOORD y2, MWPIXELVAL c);
 	void	(*FillRect)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2, MWPIXELVAL c);
-	void	(*Blit)(PSD destpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,
-			MWCOORD h,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
-	void 	(*StretchBlitEx) (PSD dstpsd, PSD srcpsd, MWCOORD dest_x_start, MWCOORD dest_y_start,
-			MWCOORD width, MWCOORD height, int x_denominator, int y_denominator,
-			int src_x_fraction, int src_y_fraction, int x_step_fraction, int y_step_fraction, int op);
-	/* new fast blit functions for text and images*/
+	/* fallback blit - used only for 1,2,4bpp drivers*/
+	void	(*BlitFallback)(PSD destpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,MWCOORD h,
+							PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int op);
+	/* endian neutral hw pixel format blits*/
+	MWBLITFUNC FrameBlit;
+	MWBLITFUNC FrameStretchBlit;
+	/* fast conversion blits for text and images*/
 	MWBLITFUNC BlitCopyMaskMonoByteMSB;				/* ft non-alias*/
 	MWBLITFUNC BlitCopyMaskMonoByteLSB;				/* t1 non-alias*/
 	MWBLITFUNC BlitCopyMaskMonoWordMSB;				/* core/pcf non-alias*/
diff --git a/src/include/mwtypes.h b/src/include/mwtypes.h
index f9dfbe3..885d1eb 100644
--- a/src/include/mwtypes.h
+++ b/src/include/mwtypes.h
@@ -106,11 +106,12 @@
 #define MWIF_ALPHABYTE		(MWIF_8BPP | MWIF_ALPHA| MWIF_BYTEDATA)
 
 /* color formats*/
-#define MWIF_BGRA8888		0x00010000L		/* 32bpp BGRA image byte order (old TRUECOLOR8888)*/
-#define MWIF_ARGB8888		0x00020000L		/* 32bpp ARGB image byte order (new)*/
-#define MWIF_RGBA8888		0x00030000L		/* 32bpp RGBA image byte order (old TRUECOLORABGR)*/
-//#define MWIF_ABGR8888		0x00040000L		/* 32bpp ABGR image byte order (new)*/
-//#define MWIF_BGRX8888		0x00050000L		/* 32bpp BGR image order no alpha (new)*/
+#define MWIF_HASALPHA		MWIF_ALPHA		/* value used below in alpha formats*/
+#define MWIF_BGRA8888		0x00010080L		/* 32bpp BGRA image byte order (old TRUECOLOR8888)*/
+#define MWIF_RGBA8888		0x00020080L		/* 32bpp RGBA image byte order (old TRUECOLORABGR)*/
+//#define MWIF_ARGB8888		0x00030080L		/* 32bpp ARGB image byte order (new)*/
+//#define MWIF_ABGR8888		0x00040080L		/* 32bpp ABGR image byte order (new)*/
+//#define MWIF_BGRX8888		0x00050080L		/* 32bpp BGRX image order no alpha (new)*/
 #define MWIF_BGR888			0x00060000L		/* 24bpp BGR image byte order  (old TRUECOLOR888)*/
 #define MWIF_RGB888			0x00070000L		/* 24bpp RGB image byte order  (png no alpha)*/
 #define MWIF_RGB565			0x00080000L		/* 16bpp 5/6/5 RGB packed l.endian (old TRUECOLOR565)*/
@@ -185,7 +186,7 @@
 
 #define MWROP_USE_GC_MODE		255 /* use current GC mode for ROP.  Nano-X CopyArea only*/
 
-#define MWROP_SRCCOPY		MWROP_COPY	/* obsolete*/
+//#define MWROP_SRCCOPY		MWROP_COPY	/* obsolete*/
 //#define MWROP_SRCAND		MWROP_AND	/* obsolete*/
 //#define MWROP_SRCINVERT	MWROP_XOR	/* obsolete*/
 //#define MWROP_BLACKNESS   MWROP_CLEAR	/* obsolete*/
@@ -434,7 +435,7 @@ typedef struct {
 	MWCOORD		width, height;	/* width and height for src and dest*/
 	MWCOORD		dstx, dsty;		/* dest x, y*/
 	MWCOORD		srcx, srcy;		/* source x, y*/
-	int			src_pitch;		/* source row length in bytes*/
+	MWCOORD		src_pitch;		/* source row length in bytes*/
 	MWCOLORVAL	fg_colorval;	/* fg color, MWCOLORVAL 0xAARRGGBB format*/
 	MWCOLORVAL	bg_colorval;
 	uint32_t	fg_pixelval;	/* fg color, hw pixel format*/
@@ -446,9 +447,21 @@ typedef struct {
 	void *		data_out;		/* output image from conversion blits subroutines*/
 	MWCOORD		dst_pitch;		/* dest row length in bytes*/
 
-	/* these item used only in hwfmt blits*/
+	/* this item used only in frame blits*/
 	PSD			srcpsd;			/* src psd, required for srcpsd->virtres*/
 
+	/* these items only used in stretch frame blits*/
+	int			src_x_step;		/* normal steps in source image*/
+	int			src_y_step;
+	int			src_x_step_one;	/* 1-unit steps in source image*/
+	int			src_y_step_one;
+	int			err_x_step;		/* 1-unit error steps in source image*/
+	int			err_y_step;
+	int			err_y;			/* source coordinate error tracking*/
+	int			err_x;
+	int			x_denominator;
+	int			y_denominator;
+
 //	uint32_t	transcolor;		/* trans color for MWROP_SRCTRANSCOPY*/
 //	PSD			alphachan;		/* alpha chan for MWROP_BLENDCHANNEL*/
 } MWBLITPARMS, *PMWBLITPARMS;
@@ -970,11 +983,17 @@ typedef struct {
 #define RED2PIXEL(byte)		RED2PIXEL555(byte)
 #define GREEN2PIXEL(byte)	GREEN2PIXEL555(byte)
 #define BLUE2PIXEL(byte)	BLUE2PIXEL555(byte)
+#define REDMASK(pixel)		((pixel) & 0x7c00)
+#define GREENMASK(pixel)	((pixel) & 0x03e0)
+#define BLUEMASK(pixel)		((pixel) & 0x001f)
 #else
 #define muldiv255_16bpp		muldiv255_rgb565
 #define RED2PIXEL(byte)		RED2PIXEL565(byte)
 #define GREEN2PIXEL(byte)	GREEN2PIXEL565(byte)
 #define BLUE2PIXEL(byte)	BLUE2PIXEL565(byte)
+#define REDMASK(pixel)		((pixel) & 0xf800)
+#define GREENMASK(pixel)	((pixel) & 0x07e0)
+#define BLUEMASK(pixel)		((pixel) & 0x001f)
 #endif
 
 /*
diff --git a/src/nanox/srvevent.c b/src/nanox/srvevent.c
index e5c2e9a..cdd0928 100644
--- a/src/nanox/srvevent.c
+++ b/src/nanox/srvevent.c
@@ -366,7 +366,7 @@ void GsDeliverButtonEvent(GR_EVENT_TYPE type, int buttons, int changebuttons,
 			{
 				tempmask = GR_EVENT_MASK_BUTTON_UP;
 				if (ecp->eventmask & tempmask) {
-					DPRINTF("nano-X: implicit grab on window %d\n", wp->id);
+					//DPRINTF("nano-X: implicit grab on window %d\n", wp->id);
 					grabbuttonwp = wp;
 				}
 			}
@@ -395,7 +395,7 @@ void GsDeliverButtonEvent(GR_EVENT_TYPE type, int buttons, int changebuttons,
 		 */
 		if (grabbuttonwp) {
 			if (buttons == 0) {
-				DPRINTF("nano-X: implicit ungrab on window %d\n", grabbuttonwp->id);
+				//DPRINTF("nano-X: implicit ungrab on window %d\n", grabbuttonwp->id);
 				grabbuttonwp = NULL;
 				GrMoveCursor(cursorx, cursory);
 			}
diff --git a/src/nanox/srvutil.c b/src/nanox/srvutil.c
index 336d32b..adeea10 100644
--- a/src/nanox/srvutil.c
+++ b/src/nanox/srvutil.c
@@ -379,8 +379,7 @@ GsWpDrawBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x,
 		else pixmapx = (wp->width - pm->width) / 2;
 		if(pm->height >= wp->height) pixmapy = 0;
 		else pixmapy = (wp->height - pm->height) / 2;
-	} else { 
-		/* GR_BACKGROUND_TILE (default)*/
+	} else { /* GR_BACKGROUND_TILE (default)*/
 		GsWpTileBackgroundPixmap(wp, pm, x, y, width, height);
 		return;
 	}
@@ -412,13 +411,19 @@ GsWpDrawBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x,
 
 	if(destwidth > 0 && destheight > 0) {
 		if (wp->bgpixmapflags & GR_BACKGROUND_STRETCH) {
+GdFillRect(wp->psd, wp->x+destx, wp->y+desty, wp->x+destx+destwidth, wp->y+desty+destheight);
 			GdStretchBlitEx(wp->psd, destx + wp->x, desty + wp->y,
 				destx + wp->x + destwidth - 0, desty + wp->y + destheight - 0,
 				pm->psd, fromx, fromy,
 				fromx + pm->width - 1, fromy + pm->height - 1,
-				MWROP_COPY);
-		} else GdBlit(wp->psd, destx + wp->x, desty + wp->y, (width < destwidth)?width:destwidth,
-			(height < destheight)?height:destheight, pm->psd, fromx, fromy, MWROP_COPY);
+				MWROP_SRC_OVER);
+		} else {
+			if (width < destwidth) destwidth = width;
+			if (height < destheight) destheight = height;
+GdFillRect(wp->psd, wp->x+destx, wp->y+desty, destwidth, destheight);
+			GdBlit(wp->psd, destx + wp->x, desty + wp->y, destwidth, destheight,
+				pm->psd, fromx, fromy, MWROP_SRC_OVER);
+		}
 	}
 
 	if(wp->bgpixmapflags & (GR_BACKGROUND_TRANS|GR_BACKGROUND_STRETCH))
@@ -429,7 +434,7 @@ GsWpDrawBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x,
 		fillwidth = pixmapx - x;
 		if(fillwidth > width) fillwidth = width;
 		fillheight = height;
-		GdFillRect(wp->psd, wp->x + x, wp->y + y, fillwidth,fillheight);
+		GdFillRect(wp->psd, wp->x + x, wp->y + y, fillwidth, fillheight);
 	}
 	if((x + width) > (pixmapx + pmwidth)) {
 		fillwidth = (x + width) - (pixmapx + pmwidth);
@@ -447,10 +452,8 @@ GsWpDrawBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x,
 		if((x + width) > (pixmapx + pmwidth))
 			fillwidth = pixmapx + pmwidth - destx;
 		else fillwidth = x + width - destx;
-		if((fillwidth > 0) && (fillheight > 0)) {
-			GdFillRect(wp->psd, destx, wp->y + y, fillwidth,
-							fillheight);
-		}
+		if(fillwidth > 0 && fillheight > 0)
+			GdFillRect(wp->psd, destx, wp->y + y, fillwidth, fillheight);
 	}
 	if((y + height) > (pixmapy + pmheight)) {
 		fillheight = (y + height) - (pixmapy + pmheight);
@@ -463,9 +466,8 @@ GsWpDrawBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x,
 		if((x + width) > (pixmapx + pmwidth))
 			fillwidth = pixmapx + pmwidth - destx;
 		else fillwidth = x + width - destx;
-		if((fillwidth > 0) && (fillheight > 0)) {
-			GdFillRect(wp->psd, destx, desty, fillwidth,fillheight);
-		}
+		if(fillwidth > 0 && fillheight > 0)
+			GdFillRect(wp->psd, destx, desty, fillwidth, fillheight);
 	}
 }
 
@@ -531,10 +533,8 @@ GsWpTileBackgroundPixmap(GR_WINDOW *wp, GR_PIXMAP *pm, GR_COORD x, GR_COORD y,
 				cy = wp->y + tiley + fromy;
 			}
 
-			if((cwidth > 0) && (cheight > 0)) {
-				GdBlit(wp->psd, cx, cy, cwidth, cheight,
-					pm->psd, fromx, fromy, MWROP_COPY);
-			}
+			if(cwidth > 0 && cheight > 0)
+				GdBlit(wp->psd, cx, cy, cwidth, cheight, pm->psd, fromx, fromy, MWROP_COPY);
 		}
 	}
 }
@@ -571,9 +571,8 @@ GsWpClearWindow(GR_WINDOW *wp, GR_COORD x, GR_COORD y, GR_SIZE width,
 	 * Now see if the region is really in the window.  If not, then
 	 * do nothing.
 	 */
-	if ((x >= wp->width) || (y >= wp->height) || (width <= 0) ||
-		(height <= 0))
-			return;
+	if (x >= wp->width || y >= wp->height || width <= 0 || height <= 0)
+		return;
 
 	/*
 	 * Draw the background of the window.
@@ -588,12 +587,10 @@ GsWpClearWindow(GR_WINDOW *wp, GR_COORD x, GR_COORD y, GR_SIZE width,
 	if (!(wp->props & GR_WM_PROPS_NOBACKGROUND)) {
 		GdSetMode(GR_MODE_COPY);
 		GdSetForegroundColor(wp->psd, wp->background);
-		if (wp->bgpixmap) {
-			GsWpDrawBackgroundPixmap(wp, wp->bgpixmap, x, y,
-				width, height);
-		} else {
+		if (wp->bgpixmap)
+			GsWpDrawBackgroundPixmap(wp, wp->bgpixmap, x, y, width, height);
+		else
 			GdFillRect(wp->psd, wp->x + x, wp->y + y, width,height);
-		}
 	}
 
 	/*
