diff --git a/src/demos/mwin/mdemo.c b/src/demos/mwin/mdemo.c
index 45a1622..866e8fb 100644
--- a/src/demos/mwin/mdemo.c
+++ b/src/demos/mwin/mdemo.c
@@ -426,10 +426,10 @@ WndProc(HWND hwnd, UINT msg, WPARAM wp,
 		w += 10;
 		GdSetForegroundColor(hdc->psd, RGB(0,255,0));
 		GdArcAngle(hdc->psd, x+w/2, y+h/2, w/2, h/2, pData->startdegrees*64,
-			pData->enddegrees*64, MWPIE);
+			pData->enddegrees*64, MWPIE, 1);
 		GdSetForegroundColor(hdc->psd, RGB(0,0,0));
 		GdArcAngle(hdc->psd, x+w/2, y+h/2, w/2, h/2, pData->startdegrees*64,
-			pData->enddegrees*64, MWARCOUTLINE);
+			pData->enddegrees*64, MWARCOUTLINE, 1);
 		/*GdSetForegroundColor(hdc->psd, RGB(255,255,255)));*/
 		/*GdPoint(hdc->psd, x+w/2, y+h/2);*/
 	}
diff --git a/src/demos/mwin/mdemo.stretch.c b/src/demos/mwin/mdemo.stretch.c
index 524a7bc..2f43659 100644
--- a/src/demos/mwin/mdemo.stretch.c
+++ b/src/demos/mwin/mdemo.stretch.c
@@ -329,10 +329,10 @@ WndProc(HWND hwnd, UINT msg, WPARAM wp,
 		w += 10;
 		GdSetForegroundColor(hdc->psd, RGB(0,255,0));
 		GdArcAngle(hdc->psd, x+w/2, y+h/2, w/2, h/2, startdegrees*64,
-			enddegrees*64, MWPIE);
+			enddegrees*64, MWPIE, 1);
 		GdSetForegroundColor(hdc->psd, RGB(0,0,0));
 		GdArcAngle(hdc->psd, x+w/2, y+h/2, w/2, h/2, startdegrees*64,
-			enddegrees*64, MWARCOUTLINE);
+			enddegrees*64, MWARCOUTLINE, 1);
 		//GdSetForegroundColor(hdc->psd, RGB(255,255,255)));
 		//GdPoint(hdc->psd, x+w/2, y+h/2);
 #endif
diff --git a/src/engine/devarc.c b/src/engine/devarc.c
index 6411ac7..43b5193 100644
--- a/src/engine/devarc.c
+++ b/src/engine/devarc.c
@@ -126,7 +126,7 @@ static short isin[360] = {
  */
 void
 GdArcAngle(PSD psd, MWCOORD x0, MWCOORD y0, MWCOORD rx, MWCOORD ry,
-	MWCOORD angle1, MWCOORD angle2, int type)
+	MWCOORD angle1, MWCOORD angle2, int type, MWCOORD w)
 {
 	int s = angle1 / 64;
 	int e = angle2 / 64;
@@ -171,7 +171,7 @@ GdArcAngle(PSD psd, MWCOORD x0, MWCOORD
 				/* note: doesn't handle patterns... FIXME*/
 				GdFillPoly(psd, 3, pts);
 			} else	/* MWARC*/
-				GdLine(psd, lx, ly, x, y, TRUE);
+				GdLine(psd, lx, ly, x, y, TRUE, w);
 		} else {
 			fx = x;
 			fy = y;
@@ -182,8 +182,8 @@ GdArcAngle(PSD psd, MWCOORD x0, MWCOORD
 
 	if (type & MWOUTLINE) {
 		/* draw two lines from center to arc endpoints*/
-		GdLine(psd, x0, y0, fx, fy, TRUE);
-		GdLine(psd, x0, y0, lx, ly, TRUE);
+		GdLine(psd, x0, y0, fx, fy, TRUE, w);
+		GdLine(psd, x0, y0, lx, ly, TRUE, w);
 	}
 
 	GdFixCursor(psd);
@@ -197,11 +197,15 @@ typedef struct {
 	MWCOORD	rx, ry;		/* radii*/
 	MWCOORD	ax, ay;		/* start point*/
 	MWCOORD	bx, by;		/* end point*/
+	MWCOORD width;
 	int	adir;		/* start pt: 1=bottom half, -1=top half*/
 	int	bdir;		/* end pt:  -1=bottom half,  1=top half*/
 	int	type;		/* MWARC, MWARCOUTLINE, MWPIE, MWELLIPSE etc*/
+	long vse;		/* Used by drawarcline */
 } SLICE;
 
+static void drawthickarc(SLICE *slice);
+
 /*
  * Clip a line segment for arc or pie drawing.
  * Returns 0 if line is clipped or on acceptable side, 1 if it's vertically
@@ -422,6 +426,13 @@ drawarc(SLICE *slice)
 	rx = slice->rx;
 	ry = slice->ry;
 
+	if (slice->width > 1
+	&& slice->type != MWPIE && slice->type != MWELLIPSEFILL) {
+		drawthickarc(slice);
+		return;
+	}
+	/* otherwise the width is ignored */
+
 	xp = 0;
 	yp = ry;
 	Asquared = rx * rx;
@@ -490,6 +501,217 @@ drawarc(SLICE *slice)
 
 }
 
+struct ptrn {
+	MWCOORD x;
+	MWCOORD y;
+	MWBOOL d;
+};
+
+#define VECR(x1, y1, x2, y2) ((x1)*(y2) - (x2)*(y1))
+static unsigned long
+getindex(MWCOORD x, MWCOORD y, struct ptrn *px, unsigned long st,
+	unsigned long cnt)
+{
+	unsigned long i;
+
+	for (i = st; i < cnt; i++)
+		if (VECR(x, y, px[i].x, px[i].y) <= 0)
+			return i;
+	return cnt - 1;
+}
+
+/**
+ * For ellipses, just draws a line.
+ * For arcs, tracks it point by point, putting those between start/end points
+ */
+static void
+drawarcline(SLICE *slice, MWCOORD x1, MWCOORD x2, MWCOORD y, struct ptrn *px,
+	unsigned long *cook, unsigned long cnt)
+{
+	MWCOORD i;
+	unsigned long id;
+	long vsp, vpe;
+
+	if (slice->type == MWELLIPSE && px == NULL) {
+		drawrow(slice->psd, slice->x0 + x1, slice->x0 + x2,
+			slice->y0 + y);
+		drawrow(slice->psd, slice->x0 + x1, slice->x0 + x2,
+			slice->y0 - y);
+		if (x1 == 0)
+			x1++;
+		drawrow(slice->psd, slice->x0 - x2, slice->x0 - x1,
+			slice->y0 + y);
+		drawrow(slice->psd, slice->x0 - x2, slice->x0 - x1,
+			slice->y0 - y);
+		return;
+	}
+
+	if (px != NULL)
+		id = *cook = getindex(x1, y, px, *cook, cnt);
+	/* Will check start/end points and pattern */
+	for (i = x1; i <= x2; i++) {
+		if (px != NULL) {
+			id = getindex(i, y, px, id, cnt);
+			if (!px[id].d)
+				continue;
+		}
+		vsp = VECR(slice->ax, slice->ay, i, y) <= 0;
+		vpe = VECR(i, y, slice->bx, slice->by) <= 0;
+		if ((vsp && vpe) || (!slice->vse && (vsp || vpe)))
+			drawpoint(slice->psd, slice->x0 + i, slice->y0 + y);
+		vsp = VECR(slice->ax, slice->ay, i, -y) <= 0;
+		vpe = VECR(i, -y, slice->bx, slice->by) <= 0;
+		if ((vsp && vpe) || (!slice->vse && (vsp || vpe)))
+			drawpoint(slice->psd, slice->x0 + i, slice->y0 - y);
+		if (i == 0)
+			continue;
+		vsp = VECR(slice->ax, slice->ay, -i, y) <= 0;
+		vpe = VECR(-i, y, slice->bx, slice->by) <= 0;
+		if ((vsp && vpe) || (!slice->vse && (vsp || vpe)))
+			drawpoint(slice->psd, slice->x0 - i, slice->y0 + y);
+		vsp = VECR(slice->ax, slice->ay, -i, -y) <= 0;
+		vpe = VECR(-i, -y, slice->bx, slice->by) <= 0;
+		if ((vsp && vpe) || (!slice->vse && (vsp || vpe)))
+			drawpoint(slice->psd, slice->x0 - i, slice->y0 - y);
+	}
+}
+
+struct cdraw {
+	MWCOORD xp;
+	MWCOORD yp;
+	long A2;
+	long TwoA2;
+	long B2;
+	long TwoB2;
+	long d;
+	long dx;
+	long dy;
+	long da;
+};
+
+static void
+cdr_setup(struct cdraw *c, MWCOORD rx, MWCOORD ry)
+{
+	c->xp = 0;
+	c->yp = ry;
+	c->A2 = rx * rx;
+	c->TwoA2 = 2 * c->A2;
+	c->B2 = ry * ry;
+	c->TwoB2 = 2 * c->B2;
+	c->d = c->B2 - c->A2 * ry + (c->A2 >> 2);
+	c->dx = 0;
+	c->dy = c->TwoA2 * ry;
+	c->da = 0;
+}
+
+#define cdr_willstep(c) ((c)->dx >= (c)->dy || (c)->d > 0)
+
+static void
+cdr_next(struct cdraw *c)
+{
+	if (c->dx < c->dy) {
+		if (c->d > 0) {
+			c->yp--;
+			c->dy -= c->TwoA2;
+			c->d -= c->dy;
+		}
+		c->xp++;
+		c->dx += c->TwoB2;
+		c->d += c->B2 + c->dx;
+		return;
+	}
+	if (!c->da) {
+		/* One-time adjustment */
+		c->da++;
+		c->d += (3L * (c->A2 - c->B2) / 2L - (c->dx + c->dy)) >> 1;
+	}
+	if (c->d < 0) {
+		c->xp++;
+		c->dx += c->TwoB2;
+		c->d += c->dx;
+	}
+	c->yp--;
+	c->dy -= c->TwoA2;
+	c->d += c->A2 - c->dy;
+}
+
+/**
+ * Draw thick arc/ellipse outline. Mostly copies the drawarc, but
+ * wals two paths at once, the inner and the outer.
+ */
+static void
+drawthickarc(SLICE *slice)
+{
+	extern unsigned long gr_dashcount;
+	extern unsigned long gr_dashmask;
+
+	struct ptrn *px;
+	unsigned long dc, bit, cnt, ck;
+	MWCOORD rx, ry;
+	long wi, wo;
+	struct cdraw i, o, c;
+
+	dc = gr_dashcount;
+	gr_dashcount = 0;
+
+	rx = slice->rx;
+	ry = slice->ry;
+	if (dc != 0) {
+		/* Fill the drawing pattern */
+		cdr_setup(&c, rx, ry);
+		px = ALLOCA(sizeof(*px) * (rx + ry));
+		for (bit = cnt = 0; c.yp >= 0; cdr_next(&c), cnt++) {
+			px[cnt].x = c.xp;
+			px[cnt].y = c.yp;
+			px[cnt].d = (gr_dashmask & (1 << bit));
+			bit = (bit + 1) % dc;
+		}
+	}
+	else {
+		px = NULL;
+		cnt = 0;
+	}
+	rx -= slice->width >> 1;
+	ry -= slice->width >> 1;
+	cdr_setup(&i, rx, ry);
+	rx += slice->width - 1;
+	ry += slice->width - 1;
+	cdr_setup(&o, rx, ry);
+
+	if (slice->type & MWARC)
+		slice->vse = VECR(slice->ax,slice->ay,slice->bx,slice->by)<=0;
+
+	ck = 0;
+	while (i.yp >= 0 || o.yp >= 0) {
+		if (o.yp > i.yp) {
+			/* Step only the outer */
+			if (cdr_willstep(&o))
+				drawarcline(slice, 0, o.xp, o.yp,
+					px, &ck, cnt);
+			cdr_next(&o);
+			continue;
+		}
+		wi = cdr_willstep(&i);
+		wo = cdr_willstep(&o);
+
+		if (wi && wo) {
+			/* Draw lines */
+			drawarcline(slice, i.xp, o.xp, o.yp, px, &ck, cnt);
+			cdr_next(&o);
+			cdr_next(&i);
+			continue;
+		}
+
+		if (!wo)
+			cdr_next(&o);
+		if (!wi)
+			cdr_next(&i);
+	}
+	gr_dashcount = dc;
+	if (dc != 0)
+		FREEA(px);
+}
+
 /**
  * Draw an arc or pie using start/end points.
  * Integer only routine.  To specify start/end angles,
@@ -514,7 +736,8 @@ drawarc(SLICE *slice)
  */
 void
 GdArc(PSD psd, MWCOORD x0, MWCOORD y0, MWCOORD rx, MWCOORD ry,
-	MWCOORD ax, MWCOORD ay, MWCOORD bx, MWCOORD by, int type)
+	MWCOORD ax, MWCOORD ay, MWCOORD bx, MWCOORD by, int type,
+	MWCOORD w)
 {
 	MWCOORD	adir, bdir;
 	SLICE	slice;
@@ -545,7 +768,7 @@ GdArc(PSD psd, MWCOORD x0, MWCOORD y0, M
 	if (by == 0) ++by;
 #endif
 	/* swap rightmost edge first */
-	if (bx > ax) {
+	if (bx > ax && (w == 1 || type == MWPIE)) {
 		MWCOORD swap;
 
 		swap = ax;
@@ -562,7 +785,7 @@ GdArc(PSD psd, MWCOORD x0, MWCOORD y0, M
 	}
 
 	/* check for entire area clipped, draw with per-point clipping*/
-	if (GdClipArea(psd, x0-rx, y0-ry, x0+rx, y0+ry) == CLIP_INVISIBLE)
+	if (GdClipArea(psd, x0-rx-w, y0-ry-w, x0+rx+w, y0+ry+w) == CLIP_INVISIBLE)
 		return;
 
 	slice.psd = psd;
@@ -577,13 +800,19 @@ GdArc(PSD psd, MWCOORD x0, MWCOORD y0, M
 	slice.adir = adir;
 	slice.bdir = bdir;
 	slice.type = type;
+	slice.width = w;
 
 	drawarc(&slice);
 
 	if (type & MWOUTLINE) {
 		/* draw two lines from rx,ry to arc endpoints*/
-		GdLine(psd, x0, y0, x0+ax, y0+ay, TRUE);
-		GdLine(psd, x0, y0, x0+bx, y0+by, TRUE);
+		w = w - (w >> 1);
+		ax += w * ax / rx;
+		ay += w * ay / ry;
+		bx += w * bx / rx;
+		by += w * by / ry;
+		GdLine(psd, x0, y0, x0+ax, y0+ay, TRUE, w);
+		GdLine(psd, x0, y0, x0+bx, y0+by, TRUE, w);
 	}
 
 	GdFixCursor(psd);
@@ -602,7 +831,8 @@ GdArc(PSD psd, MWCOORD x0, MWCOORD y0, M
  * @param fill Nonzero for a filled ellipse, zero for an outline.
  */
 void
-GdEllipse(PSD psd, MWCOORD x, MWCOORD y, MWCOORD rx, MWCOORD ry, MWBOOL fill)
+GdEllipse(PSD psd, MWCOORD x, MWCOORD y, MWCOORD rx, MWCOORD ry, MWBOOL fill,
+	MWCOORD w)
 {
 	SLICE	slice;
 
@@ -612,7 +842,7 @@ GdEllipse(PSD psd, MWCOORD x, MWCOORD y,
 	/* Check if the ellipse bounding box is either totally visible
 	 * or totally invisible.  Draw with per-point clipping.
 	 */
-	switch (GdClipArea(psd, x - rx, y - ry, x + rx, y + ry)) {
+	switch (GdClipArea(psd, x-rx-w, y-ry-w, x+rx+w, y+ry+w)) {
 	case CLIP_VISIBLE:
 		/*
 		 * For size considerations, there's no low-level ellipse
@@ -634,6 +864,7 @@ GdEllipse(PSD psd, MWCOORD x, MWCOORD y,
 	slice.rx = rx;
 	slice.ry = ry;
 	slice.type = fill? MWELLIPSEFILL: MWELLIPSE;
+	slice.width = w;
 	/* other elements unused*/
 
 	drawarc(&slice);
@@ -833,7 +1064,7 @@ FLOAT QSIN(FLOAT a)
  */
 void
 GdArcAngle(PSD psd, MWCOORD x0, MWCOORD y0, MWCOORD rx, MWCOORD ry,
-	MWCOORD angle1, MWCOORD angle2, int type)
+	MWCOORD angle1, MWCOORD angle2, int type, MWCOORD w)
 {
 	MWCOORD	ax, ay, bx, by;
 	FLOAT	a, b, c, d;
@@ -855,7 +1086,7 @@ GdArcAngle(PSD psd, MWCOORD x0, MWCOORD
 		return;
 #endif
 	/* call integer routine*/
-	GdArc(psd, x0, y0, rx, ry, ax, ay, bx, by, type);
+	GdArc(psd, x0, y0, rx, ry, ax, ay, bx, by, type, w);
 }
 #endif /* !NEWARCANGLE*/
 
diff --git a/src/engine/devdraw.c b/src/engine/devdraw.c
index faf43d4..c0271d9 100644
--- a/src/engine/devdraw.c
+++ b/src/engine/devdraw.c
@@ -36,6 +36,9 @@ extern int        gr_fillmode;
 /*static*/ void drawrow(PSD psd,MWCOORD x1,MWCOORD x2,MWCOORD y);
 static void drawcol(PSD psd,MWCOORD x,MWCOORD y1,MWCOORD y2);
 
+static void drawrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
+		MWCOORD w);
+
 /**
  * Set the drawing mode for future calls.
  *
@@ -174,9 +177,22 @@ GdSetDash(uint32_t *mask, int *count)
  * @param y Y co-ordinate to draw point.
  */
 void
-GdPoint(PSD psd, MWCOORD x, MWCOORD y)
+GdPoint(PSD psd, MWCOORD x, MWCOORD y, MWCOORD w)
 {
-	if (GdClipPoint(psd, x, y)) {
+	MWCOORD r2;
+
+	r2 = (w * w) >> 2;
+	if (w > 1) {
+		int xi, yi;
+		for (yi = -w + 1; yi < w; yi++)
+			for (xi = -w + 1; xi < w; xi++)
+				if (xi*xi + yi*yi < r2
+				&& GdClipPoint(psd, x + xi, y + yi)) {
+					psd->DrawPixel(psd, x + xi, y + yi, gr_foreground);
+					GdFixCursor(psd);
+				}
+	}
+	else if (GdClipPoint(psd, x, y)) {
 		psd->DrawPixel(psd, x, y, gr_foreground);
 		GdFixCursor(psd);
 	}
@@ -201,7 +217,7 @@ GdPoint(PSD psd, MWCOORD x, MWCOORD y)
  */
 void
 GdLine(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
-       MWBOOL bDrawLastPoint) 
+       MWBOOL bDrawLastPoint, MWCOORD w) 
 {
 	int xdelta;		/* width of rectangle around line */
 	int ydelta;		/* height of rectangle around line */
@@ -209,7 +225,7 @@ GdLine(PSD psd, MWCOORD x1, MWCOORD y1,
 	int yinc;		/* increment for moving y coordinate */
 	int rem;		/* current remainder */
 	unsigned int bit = 0;	/* used for dashed lines */
-	MWCOORD temp;
+	MWCOORD temp, mn, mx;
 
 	/* See if the line is horizontal or vertical. If so, then call
 	 * special routines.
@@ -228,7 +244,10 @@ GdLine(PSD psd, MWCOORD x1, MWCOORD y1,
 		}
 
 		/* call faster line drawing routine */
-		drawrow(psd, x1, x2, y1);
+		mn = y1 - w / 2;
+		mx = mn + w;
+		for (temp = mn; temp < mx; temp++)
+			drawrow(psd, x1, x2, temp);
 		GdFixCursor(psd);
 		return;
 	}
@@ -246,11 +265,19 @@ GdLine(PSD psd, MWCOORD x1, MWCOORD y1,
 		}
 
 		/* call faster line drawing routine */
-		drawcol(psd, x1, y1, y2);
+		mn = x1 - w / 2;
+		mx = mn + w;
+		for (temp = mn; temp < mx; temp++)
+			drawcol(psd, temp, y1, y2);
 		GdFixCursor(psd);
 		return;
 	}
 
+	if (w > 1) {
+		drawrect(psd, x1, y1, x2, y2, w);
+		return;
+	}
+
 	/* See if the line is either totally visible or totally invisible. If
 	 * so, then the line drawing is easy.
 	 */
@@ -444,6 +471,32 @@ drawcol(PSD psd, MWCOORD x,MWCOORD y1,MW
 	}
 }
 
+static void drawrect(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
+		MWCOORD w)
+{
+	int dx=x2-x1, dy=y2-y1;
+	double len = sqrt (dx*dx+dy*dy);
+	double scale = (double)(w+2) / (2*len);
+	double ddx = -scale * (double)dy;
+	double ddy = scale * (double)dx;
+	MWPOINT aPoints[4];
+
+	ddx += (ddx<0)?0.5:-0.5;
+	ddy += (ddy<0)?0.5:-0.5;
+	dx = (int)ddx;
+	dy = (int)ddy;
+
+	aPoints[0].x = x1 + dx;
+	aPoints[0].y = y1 + dy;
+	aPoints[1].x = x1 - dx;
+	aPoints[1].y = y1 - dy;
+	aPoints[2].x = x2 - dx;
+	aPoints[2].y = y2 - dy;
+	aPoints[3].x = x2 + dx;
+	aPoints[3].y = y2 + dy;
+	GdFillPoly (psd, 4, aPoints);
+}
+
 /**
  * Draw a rectangle in the foreground color, applying clipping if necessary.
  * This is careful to not draw points multiple times in case the rectangle
@@ -456,25 +509,50 @@ drawcol(PSD psd, MWCOORD x,MWCOORD y1,MW
  * @param height Height of rectangle.
  */
 void
-GdRect(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height)
+GdRect(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height, MWCOORD w)
 {
 	MWCOORD maxx;
 	MWCOORD maxy;
+	MWCOORD s, e;
+	MWCOORD i, hw, hw2;
 
 	if (width <= 0 || height <= 0)
 		return;
 	maxx = x + width - 1;
 	maxy = y + height - 1;
-	drawrow(psd, x, maxx, y);
-	if (height > 1)
-		drawrow(psd, x, maxx, maxy);
-	if (height < 3)
+	hw = w >> 1;
+	hw2 = w - hw;
+	s = y - hw;
+	e = y + hw2;
+
+	for (i = s; i < e; i++)
+		drawrow(psd, x - hw, maxx + hw2 - 1, i);
+	if (height > 1) {
+		s = maxy - hw;
+		if (s < e)
+			s = e;
+		e = maxy + hw2;
+		for (i = s; i < e; i++)
+			drawrow(psd, x - hw, maxx + hw2 - 1, i);
+	}
+
+	y += hw2;
+	maxy -= hw + 1;
+	if (maxy <= y)
 		return;
-	++y;
-	--maxy;
-	drawcol(psd, x, y, maxy);
-	if (width > 1)
-		drawcol(psd, maxx, y, maxy);
+
+	s = x - hw;
+	e = x + hw2;
+	for (i = s; i < e; i++)
+		drawcol(psd, i, y, maxy);
+	if (width > 1) {
+		s = maxx - hw;
+		if (s < e)
+			s = e;
+		e = maxx + hw2;
+		for (i = s; i < e; i++)
+			drawcol(psd, i, y, maxy);
+	}
 	GdFixCursor(psd);
 }
 
diff --git a/src/engine/devfont.c b/src/engine/devfont.c
index d59a91d..c1715f3 100644
--- a/src/engine/devfont.c
+++ b/src/engine/devfont.c
@@ -539,7 +539,7 @@ gen_drawtext(PMWFONT pfont, PSD psd, MWC
 	}
 
 	if (pfont->fontattr & MWTF_UNDERLINE)
-		GdLine(psd, startx, starty, x, starty, FALSE);
+		GdLine(psd, startx, starty, x, starty, FALSE, 1);
 
 	/* restore background draw state*/
 	gr_usebg = bgstate;
diff --git a/src/engine/devpoly.c b/src/engine/devpoly.c
index a0c3b6a..e5cf46a 100644
--- a/src/engine/devpoly.c
+++ b/src/engine/devpoly.c
@@ -46,7 +46,7 @@ extern int gr_fillmode;
  * @param points The array of points.
  */
 void
-GdPoly(PSD psd, int count, MWPOINT *points)
+GdPoly(PSD psd, int count, MWPOINT *points, MWCOORD w)
 {
   MWCOORD firstx;
   MWCOORD firsty;
@@ -62,7 +62,7 @@ GdPoly(PSD psd, int count, MWPOINT *poin
 	if (didline && (gr_mode == MWROP_XOR))
 		drawpoint(psd, points->x, points->y);
 	/* note: change to drawline*/
-	GdLine(psd, points[0].x, points[0].y, points[1].x, points[1].y, TRUE);
+	GdLine(psd, points[0].x, points[0].y, points[1].x, points[1].y, TRUE, 1);
 	points++;
 	didline = TRUE;
   }
diff --git a/src/engine/font_freetype2.c b/src/engine/font_freetype2.c
index 97ac2a4..69a0d0a 100644
--- a/src/engine/font_freetype2.c
+++ b/src/engine/font_freetype2.c
@@ -1420,7 +1420,7 @@ freetype2_drawtext(PMWFONT pfont, PSD ps
 
 		}
 		if (pf->fontattr & MWTF_UNDERLINE)
-			GdLine(psd, startx, starty, ax, ay, FALSE);
+			GdLine(psd, startx, starty, ax, ay, FALSE, 1);
 	}
 	GdFixCursor(psd);
 }
diff --git a/src/engine/font_t1lib.c b/src/engine/font_t1lib.c
index 2fccb34..1dbb396 100644
--- a/src/engine/font_t1lib.c
+++ b/src/engine/font_t1lib.c
@@ -248,7 +248,7 @@ t1lib_drawtext(PMWFONT pfont, PSD psd, M
 
 		if (pf->fontattr & MWTF_UNDERLINE) {
 			int underliney = y + glyph->metrics.ascent;
-			GdLine(psd, x, underliney, x+width, underliney, FALSE);
+			GdLine(psd, x, underliney, x+width, underliney, FALSE, 1);
 		}
 
 		/* cleanup*/
diff --git a/src/include/device.h b/src/include/device.h
index 7ee51cf..de67398 100644
--- a/src/include/device.h
+++ b/src/include/device.h
@@ -257,9 +257,11 @@ MWPIXELVAL GdFindNearestColor(MWPALENTRY
 int		GdCaptureScreen(PSD psd, char *pathname);	/* debug only*/
 void	GdPrintBitmap(PMWBLITPARMS gc, int SSZ);	/* debug only*/
 void	GdGetScreenInfo(PSD psd,PMWSCREENINFO psi);
-void	GdPoint(PSD psd,MWCOORD x, MWCOORD y);
-void	GdLine(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2, MWBOOL bDrawLastPoint);
-void	GdRect(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
+void	GdPoint(PSD psd,MWCOORD x, MWCOORD y, MWCOORD w);
+void	GdLine(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2, MWBOOL bDrawLastPoint,
+		MWCOORD w);
+void	GdRect(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
+		MWCOORD w);
 void	GdFillRect(PSD psd,MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height);
 MWBOOL	GdColorInPalette(MWCOLORVAL cr,MWPALENTRY *palette,int palsize);
 void	GdMakePaletteConversionTable(PSD psd,MWPALENTRY *palette,int palsize,
@@ -268,7 +270,7 @@ void	GdDrawImage(PSD psd,MWCOORD x, MWCO
 void	GdBitmap(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,const MWIMAGEBITS *imagebits);
 void	GdBitmapByPoint(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,
 			const MWIMAGEBITS *imagebits, int clipresult);
-void	GdPoly(PSD psd,int count, MWPOINT *points);
+void	GdPoly(PSD psd,int count, MWPOINT *points, MWCOORD w);
 void	GdFillPoly(PSD psd,int count, MWPOINT *points);
 void	GdReadArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height,MWPIXELVALHW *pixels);
 void	GdArea(PSD psd,MWCOORD x,MWCOORD y,MWCOORD width,MWCOORD height, void *pixels, int pixtype);
@@ -295,12 +297,13 @@ void	GdStretchBlit(PSD dstpsd, MWCOORD d
 /* devarc.c*/
 /* requires float*/
 void	GdArcAngle(PSD psd, MWCOORD x0, MWCOORD y0, MWCOORD rx, MWCOORD ry,
-		MWCOORD angle1, MWCOORD angle2, int type);
+		MWCOORD angle1, MWCOORD angle2, int type, MWCOORD w);
 /* integer only*/
 void	GdArc(PSD psd, MWCOORD x0, MWCOORD y0, MWCOORD rx, MWCOORD ry,
-		MWCOORD ax, MWCOORD ay, MWCOORD bx, MWCOORD by, int type);
+		MWCOORD ax, MWCOORD ay, MWCOORD bx, MWCOORD by, int type,
+		MWCOORD w);
 void	GdEllipse(PSD psd,MWCOORD x, MWCOORD y, MWCOORD rx, MWCOORD ry,
-		MWBOOL fill);
+		MWBOOL fill, MWCOORD w);
 
 /* devfont.c*/
 void	GdClearFontList(void);
diff --git a/src/include/windows.h b/src/include/windows.h
index df9481e..aad8c6b 100644
--- a/src/include/windows.h
+++ b/src/include/windows.h
@@ -49,6 +49,7 @@ struct hgdiobj {
 typedef struct {
 	MWGDIOBJHDR	hdr;
 	int		style;		/* pen style*/
+	int		width;		/* pen width*/
 	COLORREF	color;		/* pen color*/
 } MWPENOBJ;
 
diff --git a/src/mwin/wingdi.c b/src/mwin/wingdi.c
index 782e995..87588b9 100644
--- a/src/mwin/wingdi.c
+++ b/src/mwin/wingdi.c
@@ -475,7 +475,7 @@ SetPixel(HDC hdc, int x, int y, COLORREF
 
 	/* draw point in passed color*/
 	GdSetForegroundColor(hdc->psd, crColor);
-	GdPoint(hdc->psd, pt.x, pt.y);
+	GdPoint(hdc->psd, pt.x, pt.y, hdc->pen->width);
 	return 0;		/* doesn't return previous color*/
 }
 
@@ -514,7 +514,8 @@ LineTo(HDC hdc, int x, int y)
 	if(hdc->pen->style != PS_NULL) {
 		GdSetForegroundColor(hdc->psd, hdc->pen->color);
 		/* don't draw last point*/
-		GdLine(hdc->psd, beg.x, beg.y, end.x, end.y, FALSE);
+		GdLine(hdc->psd, beg.x, beg.y, end.x, end.y, FALSE,
+			hdc->pen->width);
 	}
 	hdc->pt.x = x;
 	hdc->pt.y = y;
@@ -550,7 +551,8 @@ Polyline(HDC hdc, CONST POINT *lppt, int
 			ClientToScreen(hwnd, &end);
 
 		/* don't draw last point*/
-		GdLine(hdc->psd, beg.x, beg.y, end.x, end.y, FALSE);
+		GdLine(hdc->psd, beg.x, beg.y, end.x, end.y, FALSE,
+			hdc->pen->width);
 
 		beg = end;
 	}
@@ -575,7 +577,8 @@ Rectangle(HDC hdc, int nLeft, int nTop,
 	if(hdc->pen->style != PS_NULL) {
 		GdSetForegroundColor(hdc->psd, hdc->pen->color);
 		GdRect(hdc->psd, rc.left, rc.top,
-			rc.right - rc.left, rc.bottom - rc.top);
+			rc.right - rc.left, rc.bottom - rc.top,
+			hdc->pen->width);
 	}
 
 	/* fill rectangle in current brush color*/
@@ -613,13 +616,15 @@ Ellipse(HDC hdc, int nLeftRect, int nTop
 	if(hdc->brush->style != BS_NULL) {
 		InflateRect(&rc, -1, -1);
 		GdSetForegroundColor(hdc->psd, hdc->brush->color);
-		GdEllipse(hdc->psd, rc.left, rc.top, rx, ry, TRUE);
+		GdEllipse(hdc->psd, rc.left, rc.top, rx, ry, TRUE,
+			hdc->pen->width);
 	}
 
 	/* draw ellipse outline in current pen color*/
 	if(hdc->pen->style != PS_NULL) {
 		GdSetForegroundColor(hdc->psd, hdc->pen->color);
-		GdEllipse(hdc->psd, rc.left, rc.top, rx, ry, FALSE);
+		GdEllipse(hdc->psd, rc.left, rc.top, rx, ry, FALSE,
+			hdc->pen->width);
 	}
 
 	return TRUE;
@@ -653,7 +658,8 @@ dopiearc(HDC hdc, int nLeftRect, int nTo
 	if(hdc->brush->style != BS_NULL && type == MWPIE) {
 		GdSetForegroundColor(hdc->psd, hdc->brush->color);
 		GdArc(hdc->psd, rc.left, rc.top, rx, ry,
-			rc2.left, rc2.top, rc2.right, rc2.bottom, MWPIE);
+			rc2.left, rc2.top, rc2.right, rc2.bottom, MWPIE,
+			hdc->pen->width);
 	}
 
 	/* draw ellipse outline in current pen color*/
@@ -662,7 +668,8 @@ dopiearc(HDC hdc, int nLeftRect, int nTo
 		if(type == MWPIE)
 			type = MWARC;	/* MWARCOUTLINE?*/
 		GdArc(hdc->psd, rc.left, rc.top, rx, ry,
-			rc2.left, rc2.top, rc2.right, rc2.bottom, type);
+			rc2.left, rc2.top, rc2.right, rc2.bottom, type,
+			hdc->pen->width);
 	}
 }
 
@@ -716,7 +723,7 @@ Polygon(HDC hdc, CONST POINT *lpPoints,
 	/* draw polygon outline in current pen color*/
 	if(hdc->pen->style != PS_NULL) {
 		GdSetForegroundColor(hdc->psd, hdc->pen->color);
-		GdPoly(hdc->psd, nCount, pp);
+		GdPoly(hdc->psd, nCount, pp, hdc->pen->width);
 	}
 
 	if(ppAlloc)
@@ -1426,15 +1433,15 @@ static MWBRUSHOBJ OBJ_NULL_BRUSH = {
 };
 
 static MWPENOBJ OBJ_WHITE_PEN = {
-	{OBJ_PEN, TRUE}, PS_SOLID, RGB(255, 255, 255)
+	{OBJ_PEN, TRUE}, PS_SOLID, 1, RGB(255, 255, 255)
 };
 
 static MWPENOBJ OBJ_BLACK_PEN = {
-	{OBJ_PEN, TRUE}, PS_SOLID, RGB(0, 0, 0)
+	{OBJ_PEN, TRUE}, PS_SOLID, 1, RGB(0, 0, 0)
 };
 
 static MWPENOBJ OBJ_NULL_PEN = {
-	{OBJ_PEN, TRUE}, PS_NULL, RGB(0, 0, 0)
+	{OBJ_PEN, TRUE}, PS_NULL, 1, RGB(0, 0, 0)
 };
 
 static MWFONTOBJ OBJ_OEM_FIXED_FONT = {
@@ -1710,6 +1717,7 @@ CreatePen(int nPenStyle, int nWidth, COL
 	hpen->hdr.type = OBJ_PEN;
 	hpen->hdr.stockobj = FALSE;
 	hpen->style = nPenStyle;
+	hpen->width = nWidth;
 	hpen->color = crColor;
 	return (HPEN)hpen;
 }
diff --git a/src/nanox/srvfunc.c b/src/nanox/srvfunc.c
index 843b5c8..29577c0 100644
--- a/src/nanox/srvfunc.c
+++ b/src/nanox/srvfunc.c
@@ -2712,7 +2712,7 @@ GrLine(GR_DRAW_ID id, GR_GC_ID gc, GR_CO
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdLine(dp->psd, dp->x + x1, dp->y + y1, dp->x + x2, dp->y + y2, TRUE);
+		GdLine(dp->psd, dp->x + x1, dp->y + y1, dp->x + x2, dp->y + y2, TRUE, 1);
 		break;
 	}
 
@@ -2736,7 +2736,7 @@ GrRect(GR_DRAW_ID id, GR_GC_ID gc, GR_CO
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdRect(dp->psd, dp->x + x, dp->y + y, width, height);
+		GdRect(dp->psd, dp->x + x, dp->y + y, width, height, 1);
 		break;
 	}
 
@@ -2780,7 +2780,7 @@ GrEllipse(GR_DRAW_ID id, GR_GC_ID gc, GR
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, FALSE);
+		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, FALSE, 1);
 		break;
 	}
 
@@ -2802,7 +2802,7 @@ GrFillEllipse(GR_DRAW_ID id, GR_GC_ID gc
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, TRUE);
+		GdEllipse(dp->psd, dp->x + x, dp->y + y, rx, ry, TRUE, 1);
 		break;
 	}
 
@@ -2825,7 +2825,7 @@ GrArc(GR_DRAW_ID id, GR_GC_ID gc, GR_COO
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdArc(dp->psd, dp->x + x, dp->y + y, rx, ry, ax, ay, bx, by, type);
+		GdArc(dp->psd, dp->x + x, dp->y + y, rx, ry, ax, ay, bx, by, type, 1);
 		break;
 	}
 
@@ -2847,7 +2847,7 @@ GrArcAngle(GR_DRAW_ID id, GR_GC_ID gc, G
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdArcAngle(dp->psd, dp->x + x, dp->y + y, rx, ry, angle1, angle2, type);
+		GdArcAngle(dp->psd, dp->x + x, dp->y + y, rx, ry, angle1, angle2, type, 1);
 		break;
 	}
 
@@ -3255,7 +3255,7 @@ GrPoint(GR_DRAW_ID id, GR_GC_ID gc, GR_C
 	switch (GsPrepareDrawing(id, gc, &dp)) {
 	case GR_DRAW_TYPE_WINDOW:
 	case GR_DRAW_TYPE_PIXMAP:
-		GdPoint(dp->psd, dp->x + x, dp->y + y);
+		GdPoint(dp->psd, dp->x + x, dp->y + y, 1);
 		break;
 	}
 
@@ -3288,7 +3288,7 @@ GrPoints(GR_DRAW_ID id, GR_GC_ID gc, GR_
 
 	pp = pointtable;
 	for (i = count; i-- > 0; pp++)
-		GdPoint(psd, pp->x + dp->x, pp->y + dp->y);
+		GdPoint(psd, pp->x + dp->x, pp->y + dp->y, 1);
 
 	SERVER_UNLOCK();
 }
@@ -3328,7 +3328,7 @@ GrPoly(GR_DRAW_ID id, GR_GC_ID gc, GR_CO
 		pp->y += dp->y;
 	}
 
-	GdPoly(psd, count, pointtable);
+	GdPoly(psd, count, pointtable, 1);
 
 #if NONETWORK   
 	/*
diff --git a/src/nanox/srvutil.c b/src/nanox/srvutil.c
index f65e89e..4b6a353 100644
--- a/src/nanox/srvutil.c
+++ b/src/nanox/srvutil.c
@@ -846,10 +846,10 @@ GsDrawBorder(GR_WINDOW *wp)
 	GdSetFillMode(GR_FILL_SOLID);
 
 	if (bs == 1) {
-		GdLine(wp->psd, lminx, tminy, rminx, tminy, TRUE);
-		GdLine(wp->psd, lminx, bminy, rminx, bminy, TRUE);
-		GdLine(wp->psd, lminx, topy, lminx, boty, TRUE);
-		GdLine(wp->psd, rminx, topy, rminx, boty, TRUE);
+		GdLine(wp->psd, lminx, tminy, rminx, tminy, TRUE, 1);
+		GdLine(wp->psd, lminx, bminy, rminx, bminy, TRUE, 1);
+		GdLine(wp->psd, lminx, topy, lminx, boty, TRUE, 1);
+		GdLine(wp->psd, rminx, topy, rminx, boty, TRUE, 1);
 	} else {
 		GdFillRect(wp->psd, lminx, tminy, width + bs * 2, bs);
 		GdFillRect(wp->psd, lminx, bminy, width + bs * 2, bs);
