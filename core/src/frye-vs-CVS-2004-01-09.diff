Index: CVS-2004-01-09.1/src/nanox/srvutil.c
--- CVS-2004-01-09.1/src/nanox/srvutil.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/c/3_srvutil.c 1.6.2.1 644)
+++ 0.39(w)/src/nanox/srvutil.c Fri, 09 Jan 2004 16:00:20 -0800 aaron (microwin/c/3_srvutil.c 1.6.2.1 644)
@@ -933,8 +933,10 @@
 	GR_GC		*gcp;		/* found graphics context */
 	GR_FONT		*fontp;
 	GR_REGION	*regionp;	/* user clipping region */
-	MWCLIPREGION	*reg;
 	PMWFONT		pf;
+#if DYNAMICREGIONS
+	MWCLIPREGION	*reg;
+#endif
 
 	*retdp = NULL;
 
@@ -1054,6 +1056,8 @@
 		GdSetMode(gcp->mode & GR_MODE_DRAWMASK);
 		GdSetUseBackground(gcp->usebackground);
 		
+		if (gcp->linestyle >= 0 && gcp->linestyle <= MWLINE_MAX)
+			GdSetLineAttributes(gcp->linestyle);
 		GdSetDash(&mask, &count);
 		GdSetFillMode(gcp->fillmode);
 		GdSetTSOffset(gcp->ts_offset.x, gcp->ts_offset.y);
Index: CVS-2004-01-09.1/src/nanox/srvclip1.c
--- CVS-2004-01-09.1/src/nanox/srvclip1.c Fri, 02 Mar 2001 18:36:38 -0800 kaben (microwin/c/7_srvclip1.c 1.2 644)
+++ 0.39(w)/src/nanox/srvclip1.c Mon, 10 Mar 2003 22:25:27 -0800 aaron (microwin/c/7_srvclip1.c 1.3 644)
@@ -43,7 +43,7 @@
 	GR_BOOL		toomany;	/* TRUE if too many clip rects */
 	MWCLIPRECT	cliprects[MAX_CLIPRECTS];	/* clip rectangles */
 
-	if (wp->unmapcount || !wp->output || (wp == clipwp))
+	if (!wp->realized || !wp->output || (wp == clipwp))
 		return;
 
 	clipwp = wp;
@@ -120,7 +120,7 @@
 			sibwp = pwp->children;
 
 		for (; sibwp != wp; sibwp = sibwp->siblings) {
-			if (sibwp->unmapcount || !sibwp->output)
+			if (!sibwp->realized || !sibwp->output)
 				continue;
 
 			bs = sibwp->bordersize;
Index: CVS-2004-01-09.1/src/nanox/srvmain.c
--- CVS-2004-01-09.1/src/nanox/srvmain.c Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/c/15_srvmain.c 1.6.2.2 644)
+++ 0.39(w)/src/nanox/srvmain.c Fri, 09 Jan 2004 16:03:35 -0800 aaron (microwin/c/15_srvmain.c 1.6.2.2 644)
@@ -345,6 +345,7 @@
 void
 GrDelay(GR_TIMEOUT msecs)
 {
+#if !defined(__rtems__)
 #if UNIX
 	struct timeval timeval;
 
@@ -352,6 +353,7 @@
 	timeval.tv_usec = (msecs % 1000) * 1000;
 	select(0, NULL, NULL, NULL, &timeval);
 #endif
+#endif
 }
 
 #if NONETWORK
@@ -465,7 +467,7 @@
 
 }
 
-#elif MSDOS | _MINIX
+#elif MSDOS | _MINIX | FRYEBOX7k
 
 void
 GsSelect(GR_TIMEOUT timeout)
Index: CVS-2004-01-09.1/src/nanox/srvfunc.c
--- CVS-2004-01-09.1/src/nanox/srvfunc.c Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/c/16_srvfunc.c 1.12.2.2 644)
+++ 0.39(w)/src/nanox/srvfunc.c Fri, 09 Jan 2004 16:09:52 -0800 aaron (microwin/c/16_srvfunc.c 1.12.2.2 644)
@@ -11,6 +11,9 @@
 #include <string.h>
 #define MWINCLUDECOLORS
 #include "serv.h"
+#ifdef USE_VIDMALLOC
+#include <vidmalloc.h>
+#endif
 
 static int	nextid = GR_ROOT_WINDOW_ID + 1;
 
@@ -281,7 +284,11 @@
 			psd = pp->psd;
 			/* deallocate pixmap memory*/
 			if (psd->flags & PSF_ADDRMALLOC)
+#ifdef USE_VIDMALLOC
+				vidfree(psd->addr);
+#else
 				free(psd->addr);
+#endif
 
 			/* deallocate mem gc*/
 			psd->FreeMemGC(psd);
@@ -816,7 +823,11 @@
 	}
 
 	if (gcp->stipple.bitmap)
-		free(gcp->stipple.bitmap);
+#ifdef USE_VIDMALLOC
+	    vidfree(gcp->stipple.bitmap);
+#else
+	    free(gcp->stipple.bitmap);
+#endif
 	free(gcp);
 
 	SERVER_UNLOCK();
@@ -1375,7 +1386,7 @@
  * The GC is owned by the current client.
  */
 GR_FONT_ID
-GrCreateFont(GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
+GrCreateFont(const GR_CHAR *name, GR_COORD height, GR_LOGFONT *plogfont)
 {
 	GR_FONT	*fontp;
 
@@ -1822,7 +1833,13 @@
 
 	/* Allocate space for pixel values */
         if (!pixels) {
+#ifdef USE_VIDMALLOC
+		/* it would be faster to use regular malloc and then do
+		 * a blit fill... */
+	        pixels = vidmalloc(size);
+#else
 	        pixels = calloc(size, 1);
+#endif
 		psd->flags |= PSF_ADDRMALLOC;
 	}
 	if (!pixels) {
@@ -1844,11 +1861,14 @@
 
         psd->MapMemGC(psd, width, height, planes, bpp, linelen, size,
 		pixels);
-	
+
         listpp = pp;
-	
+#ifdef USE_VIDMALLOC
+	/* blank it using bitblit */
+	psd->FillRect(psd, 0, 0, width-1, height-1, 0);
+#endif
 	id = pp->id;
-	
+
 	SERVER_UNLOCK();
 	
 	return id;
@@ -2332,20 +2352,24 @@
 		return;
 	}
 
-	/* Build the bitmask (up to 32 bits) */
+	/* Build the bitmask (up to sizeof(unsigned long) * 8 bits) */
 	for (i = 0; i < count; i++) {
 		int b = 0;
 
 		for (; b < dashes[i]; b++) {
 			if (onoff)
 				dmask |= (1 << dcount);
-			if ((++dcount) == 32)
+			if ((++dcount) == sizeof(unsigned long) * 8) {
+				GsError(GR_ERROR_BAD_DASH, gc);
 				break;
+			}
 		}
 
 		onoff = (onoff + 1) % 2;
-		if (dcount == 32)
+		if (dcount == sizeof(unsigned long) * 8) {
+			GsError(GR_ERROR_BAD_DASH, gc);
 			break;
+		}
 	}
 	gcp->dashmask = dmask;
 	gcp->dashcount = dcount;
@@ -2410,7 +2434,11 @@
 	}
 
 	gcp->stipple.bitmap =
+#ifdef USE_VIDMALLOC
+		vidmalloc(GR_BITMAP_SIZE(width, height) * sizeof(GR_BITMAP));
+#else
 		malloc(GR_BITMAP_SIZE(width, height) * sizeof(GR_BITMAP));
+#endif
 	memcpy(gcp->stipple.bitmap, bitmap,
 	       GR_BITMAP_SIZE(width, height) * sizeof(GR_BITMAP));
 
@@ -2838,6 +2866,7 @@
 	return id;
 }
 
+
 /* draw cached image*/
 void
 GrDrawImageToFit(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
@@ -2934,9 +2963,10 @@
 	GR_SIZE width, GR_SIZE height, GR_DRAW_ID srcid,
 	GR_COORD srcx, GR_COORD srcy, unsigned long op)
 {
+#if DYNAMICREGIONS
   	GR_GC		*gcp;
 	GR_BOOL         exposure = GR_TRUE;
-
+#endif
 	GR_DRAWABLE	*dp;
         GR_WINDOW	*swp;
         GR_PIXMAP	*spp = NULL;
Index: CVS-2004-01-09.1/src/nanox/srvevent.c
--- CVS-2004-01-09.1/src/nanox/srvevent.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/c/17_srvevent.c 1.5.2.1 644)
+++ 0.39(w)/src/nanox/srvevent.c Fri, 09 Jan 2004 16:10:46 -0800 aaron (microwin/c/17_srvevent.c 1.5.2.1 644)
@@ -11,6 +11,11 @@
 #include <string.h>
 #include "serv.h"
 
+#if 1
+#define EVENT_BLOCK_MALLOC
+#define EVENT_BLOCKS 16
+#endif
+
 /* readable error strings*/
 char *nxErrorStrings[] = {
 	GR_ERROR_STRINGS
@@ -124,6 +129,49 @@
 	if (elp)
 		eventfree = elp->next;
 	else {
+#ifdef EVENT_BLOCK_MALLOC
+		/* block allocation of server events should help with
+		 * memory fragmentation issues. */
+		int loopy;
+		GR_EVENT_LIST	*elp_free, *prevelp;
+
+		/* allocate EVENT_BLOCKS number of events at one time;
+		 * this event is stitched up and cleaned at the bottom
+		 * of this routine... */
+		elp = (GR_EVENT_LIST *) malloc(
+			sizeof(GR_EVENT_LIST) * EVENT_BLOCKS
+		);
+		DPRINTF("Nano-X: allocating new block of %d events "
+			"starting at %p\n", EVENT_BLOCKS, elp);
+		if (elp == NULL) {
+			oldcurclient = curclient;
+			curclient = client;
+			GsError(GR_ERROR_MALLOC_FAILED, 0);
+			curclient = oldcurclient;
+			return NULL;
+		}
+
+		/* now to add the extra events to the free list. */
+
+		/* skip to the second block of allocated memory */
+		elp_free = elp;
+		elp_free++;
+
+		/* set the free list to the head of the newly-allocated
+		 * free block */
+		eventfree = elp_free;
+
+		/* stitch up the next EVENT_BLOCKS-2 members */
+		for (loopy = 0; loopy < EVENT_BLOCKS-2; loopy++) {
+			prevelp = elp_free;
+			elp_free++;
+			prevelp->next = elp_free;
+		}
+
+		/* the last member points to NULL */
+		prevelp->next = NULL;
+#else
+		/* allocate a single event */
 		elp = (GR_EVENT_LIST *) malloc(sizeof(GR_EVENT_LIST));
 		if (elp == NULL) {
 			oldcurclient = curclient;
@@ -132,6 +180,7 @@
 			curclient = oldcurclient;
 			return NULL;
 		}
+#endif
 	}
 
 	/*
Index: CVS-2004-01-09.1/src/fonts/Makefile
--- CVS-2004-01-09.1/src/fonts/Makefile Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/d/46_Makefile 1.7.2.2 644)
+++ 0.39(w)/src/fonts/Makefile Wed, 28 Jan 2004 18:56:22 -0800 aaron (microwin/d/46_Makefile 1.7.2.2 644)
@@ -16,7 +16,21 @@
 LIBNAME = libmwfonts.a
 #LIBNAMESO = libmwfonts.so
 
-OBJS := $(MW_DIR_OBJ)/fonts/obsolete.o
+# List of bdf fonts to compile
+BDF_FONTS   +=  helvB10
+BDF_FONTS   +=  helvR10
+BDF_FONTS   +=  helvB12
+BDF_FONTS   +=  X5x7
+BDF_FONTS   +=  X6x13
+BDF_FONTS   +=  X6x13B
+BDF_FONTS   +=  vga
+BDF_FONTS   +=  X8x16
+
+BDF_C:=$(BDF_FONTS:%=%.c)
+BDF_OBJS:=$(BDF_FONTS:%=$(MW_DIR_OBJ)/fonts/%.o)
+
+# List of additional fonts to compile
+OBJS     :=  $(BDF_OBJS)
 
 ######################### Makefile.rules section #############################
 
@@ -28,13 +42,10 @@
 
 realclean: clean
 ifeq ($(MW_DIR_OBJ),$(MW_DIR_SRC))
-	$(RM) \
-		$(MW_DIR_OBJ)/fonts/helvB10.c \
-		$(MW_DIR_OBJ)/fonts/helvB12.c \
-		$(MW_DIR_OBJ)/fonts/helvR10.c \
-		$(MW_DIR_OBJ)/fonts/timBI18.c \
-		$(MW_DIR_OBJ)/fonts/X5x7.c \
-		$(MW_DIR_OBJ)/fonts/X6x13.c
+	$(RM) $(OBJS)
 endif
+	$(RM) $(BDF_C)
 
-
+%.c:bdf_fonts/%.bdf
+	@echo "Generating $@ from font file ..."
+	./convbdf -c -o $@ $< || rm $@
Index: CVS-2004-01-09.1/src/Arch.rules
--- CVS-2004-01-09.1/src/Arch.rules Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/f/51_Arch.rules 1.14.2.2 644)
+++ 0.39(w)/src/Arch.rules Fri, 09 Jan 2004 16:01:01 -0800 aaron (microwin/f/51_Arch.rules 1.14.2.2 644)
@@ -160,9 +160,21 @@
 INCLUDEDIRS += -I$(RTEMS_BUILD)/$(RTEMS_BSP)/lib/include \
 -I$(RTEMS_BUILD)/$(RTEMS_BSP)/lib/include/networking \
 -I$(RTEMS_BUILD)/$(RTEMS_BSP)/lib/include/sys
-DEFINES += -DUNIX=1
-CFLAGS += -O4 -Wall -Wno-unused -fasm -g \
--B$(RTEMS_BUILD)/$(RTEMS_BSP)/lib/ -specs bsp_specs -qrtems
+DEFINES += -DUNIX=1 -DCOREFONT_ZEROCOPY=1
+CFLAGS += -O4 -Wall -Wno-unused -fasm -g
+CPPFLAGS += -B$(RTEMS_BUILD)/$(RTEMS_BSP)/lib/ -specs bsp_specs -qrtems
+endif
+
+ifeq ($(ARCH), FRYEBOX7k)
+OPTFLAGS = -fasm -O4 -g
+COMPILER = gcc
+CXX_COMPILER = g++
+DEFINES += -DUNIX -DUSE_VIDMALLOC -DNONETWORK -DFRYEBOX7k
+DEFINES += -DCOREFONT_ZEROCOPY
+TOOLSPREFIX = $(FRYEBOX7kPREFIX)
+BASEDIR = /usr/local/cross/frye7k/lib
+CPPFLAGS += -B$(RTEMS_MAKEFILE_PATH)/lib/ -specs bsp_specs -qrtems
+CFLAGS = -Wall -Werror -mcpu32 -fno-builtin -ffreestanding $(OPTFLAGS)
 endif
 
 ifeq ($(ARCH), ECOS)
Index: CVS-2004-01-09.1/src/Makefile.rules
--- CVS-2004-01-09.1/src/Makefile.rules Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/g/5_Makefile.r 1.9.2.2 644)
+++ 0.39(w)/src/Makefile.rules Wed, 28 Jan 2004 18:59:52 -0800 aaron (microwin/g/5_Makefile.r 1.9.2.2 644)
@@ -15,16 +15,16 @@
 endif
 
 # install directories for headers and libraries
-INSTALL_PREFIX  = /usr
+INSTALL_PREFIX  = /usr/local/cross/frye7k
 INSTALL_OWNER1  = -o root -g root
 INSTALL_OWNER2  = -o root -g bin
-HDRINSTALLDIR = $(INSTALL_PREFIX)/include/microwin
+HDRINSTALLDIR = $(INSTALL_PREFIX)/lib/include/nano-X
 LIBINSTALLDIR = $(INSTALL_PREFIX)/lib
 BININSTALLDIR = $(INSTALL_PREFIX)/bin
 
-INSTALL_DIR   = install -c -m 755 $(INSTALL_OWNER1) -d
-INSTALL_HDR   = install -c -m 644 $(INSTALL_OWNER2)
-INSTALL_LIB   = install -c -m 644 $(INSTALL_OWNER2)
+INSTALL_DIR   = install -c -m 775 -d
+INSTALL_HDR   = $(TOP)/install-if-change -c -m 444
+INSTALL_LIB   = $(TOP)/install-if-change -c -m 444
 INSTALL_BIN   = install -c -m 755 $(INSTALL_OWNER2)
 
 ##############################################################################
@@ -565,7 +565,7 @@
 # time the user runs make.
 #
 define MW_RULE_DEPEND_C
-	$(HOSTCC) -MM $(MAKEDEPCFLAGS) $(DEFINES) $< \
+	$(CC) -MM $(MAKEDEPCFLAGS) $(DEFINES) $< \
 		| sed 's/.*\.o[ :]*/$(subst /,\/,$@) : /g' \
 		> $(basename $@).d \
 		|| (rm $@ $(basename $@).d ; exit 1)
Index: CVS-2004-01-09.1/src/engine/devdraw.c
--- CVS-2004-01-09.1/src/engine/devdraw.c Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/g/6_devdraw.c 1.11.2.2 644)
+++ 0.39(w)/src/engine/devdraw.c Wed, 28 Jan 2004 19:04:29 -0800 aaron (microwin/g/6_devdraw.c 1.11.2.2 644)
@@ -31,6 +31,8 @@
 /* These support drawing dashed lines */
 extern unsigned long gr_dashmask;     /* An actual bitmask of the dash values */
 extern unsigned long gr_dashcount;    /* The number of bits defined in the dashmask */
+extern char       gr_dashindex;       /* current dashlist index */
+extern int        gr_linestyle;       /* current line style */
 
 extern int        gr_fillmode;
 
@@ -39,6 +41,240 @@
 /*static*/ void drawrow(PSD psd,MWCOORD x1,MWCOORD x2,MWCOORD y);
 static void drawcol(PSD psd,MWCOORD x,MWCOORD y1,MWCOORD y2);
 
+/* for kaben's clipping routines */
+enum {
+    T = 0x01,
+    B = 0x02,
+    L = 0x04,
+    R = 0x08
+};
+
+typedef struct {
+    MWPOINT     p;
+    int         c;
+} coded_point_t;
+
+typedef struct {
+    MWPOINT     s;      /* starting point */
+    MWPOINT     e;      /* ending point */
+
+    int         dx;     /* delta x */
+    int         dy;     /* delta y */
+    int         xi;     /* increment x */
+    int         yi;     /* increment y */
+
+    int         r;      /* remainder ?? */
+    int         re;     /* remainder end ?? */
+    coded_point_t cs;   /* conditioned start */
+    coded_point_t ce;   /* conditioned end */
+} conditioned_line_t;
+
+/***
+ *** new clipping code added by kaben.
+ ***
+ *** this is cohen-sutherland clipping of lines to clip-rectangles.
+ *** after studying this algorithm and developing the code, I discovered
+ *** barsky-liang clipping, which could be made to work well with
+ *** polygon clipping regions in microwindows if each edge-member of a
+ *** clip-polygon has a precomputed normal pointing to the outside of
+ *** polygon.
+ ***
+ *** the precomputed normal would be the edge rotated ninety degrees in
+ *** the appropriate direction; the cohen-sutherland coding stuff would
+ *** be removed from the code below; and the
+ *** clip_{start,end}_{major,minor}_{x,y} functions could be reused.
+ ***
+ *** I should rephrase that:  I don't know that barsky-liang would work
+ *** well or easily because I don't have time to try it out; maybe
+ *** sometime down the road I'll try it if someone else doesn't beat me
+ *** to it.
+ ***
+ *** -- k.
+ ***/
+static void clip_start_major_x(conditioned_line_t *l, MWCOORD LR){
+    l->r += l->xi * (LR - l->cs.p.x) * l->dy;
+    l->cs.p.y += l->yi * (l->r / l->dx);
+    l->r %= l->dx;
+    l->cs.p.x = LR;
+}
+    
+static void clip_start_minor_y(conditioned_line_t *l, MWCOORD TB){
+    l->r -= (l->yi * (TB - l->cs.p.y) * l->dx) + (l->dy - 1);
+    l->cs.p.x -= l->xi * (l->r / l->dy);
+    l->r = (l->dy - 1) + (l->r % l->dy);
+    l->cs.p.y = TB;
+}
+
+static void clip_end_major_x(conditioned_line_t *l, MWCOORD LR){
+    l->re += l->xi * (l->ce.p.x - LR) * l->dy;
+    l->ce.p.y -= l->yi * (l->re / l->dx);
+    l->re %= l->dx;
+    l->ce.p.x = LR;
+}
+
+static void clip_end_minor_y(conditioned_line_t *l, MWCOORD TB){
+    if(l->yi == 1){
+        l->re -= (l->ce.p.y - TB) * l->dx;
+        l->ce.p.x -= l->xi * (1 - l->re / l->dy);
+        l->re = l->dy + l->re % l->dy;
+    } else {
+        l->re -= (TB - l->ce.p.y) * l->dx + (l->dy - 1);
+        l->ce.p.x += l->xi * (l->re / l->dy);
+        l->re = (l->dy - 1) + (l->re % l->dy);
+    }
+    l->ce.p.y = TB;
+}   
+
+static void clip_start_major_y(conditioned_line_t *l, MWCOORD TB){
+    l->r += l->yi * (TB - l->cs.p.y) * l->dx;
+    l->cs.p.x += l->xi * (l->r / l->dy);
+    l->r %= l->dy;
+    l->cs.p.y = TB;
+}
+
+static void clip_start_minor_x(conditioned_line_t *l, MWCOORD LR){
+    l->r -= l->xi * (LR - l->cs.p.x) * l->dy + (l->dx - 1);
+    l->cs.p.y -= l->yi * (l->r / l->dx);
+    l->r = (l->dx - 1) + (l->r % l->dx);
+    l->cs.p.x = LR;
+}
+
+static void clip_end_major_y(conditioned_line_t *l, MWCOORD TB){
+    l->re += l->yi * (l->ce.p.y - TB) * l->dx;
+    l->ce.p.x -= l->xi * (l->re / l->dy);
+    l->re %= l->dy;
+    l->ce.p.y = TB;
+}
+
+static void clip_end_minor_x(conditioned_line_t *l, MWCOORD LR){
+    if(l->xi == 1){
+        l->re -= (l->ce.p.x - LR) * l->dy;
+        l->ce.p.y -= l->yi * (1 - l->re / l->dx);
+        l->re = l->dx + l->re % l->dx;
+    } else {
+        l->re -= (LR - l->ce.p.x) * l->dy + (l->dx - 1);
+        l->ce.p.y += l->yi * (l->re / l->dx);
+        l->re = (l->dx - 1) + (l->re % l->dx);
+    }
+    l->ce.p.x = LR;
+}
+
+static void precondition_line(conditioned_line_t *l){
+    l->dx = l->e.x - l->s.x;
+    if (l->dx < 0) {
+        l->dx = -l->dx;
+        l->xi = -1;
+    } else { l->xi = 1; }
+
+    l->dy = l->e.y - l->s.y;
+    if (l->dy < 0) {
+        l->dy = -l->dy;
+        l->yi = -1;
+    } else { l->yi = 1; }
+}
+
+static void init_line(conditioned_line_t *l){
+    l->cs.p = l->s;
+    l->ce.p = l->e;
+
+    if (l->dx >= l->dy) {
+        l->r = l->re = l->dx/2;
+    } else { l->r = l->re = l->dy/2; }
+}
+
+static void code_line(conditioned_line_t *l,
+    MWCOORD left, MWCOORD right, MWCOORD top, MWCOORD bot)
+{
+    l->cs.c = l->ce.c = 0;
+
+    if(l->cs.p.x < left) { l->cs.c |= L; }
+    else if (l->cs.p.x > right) { l->cs.c |= R; }
+
+    if(l->cs.p.y < top) { l->cs.c |= T; }
+    else if (l->cs.p.y > bot) { l->cs.c |= B; }
+
+    if(l->ce.p.x < left) { l->ce.c |= L; }
+    else if (l->ce.p.x > right) { l->ce.c |= R; }
+
+    if(l->ce.p.y < top) { l->ce.c |= T; }
+    else if (l->ce.p.y > bot) { l->ce.c |= B; }
+}
+
+/* dashlist stuff */
+static void GdIncrementDashPhase(int inc) {
+    if (gr_dashmask == 0) return;
+
+    inc%=gr_dashcount;
+    gr_dashindex+=inc;
+    gr_dashindex%=gr_dashcount;
+}
+
+static void clip_line(PSD psd, conditioned_line_t *l,
+    MWCOORD left, MWCOORD right, MWCOORD top, MWCOORD bot,
+    MWBOOL bDrawLastPoint)
+{
+    if (l->dx > l->dy){
+        for(;;){
+            code_line(l, left, right, top, bot);
+            if(!(l->cs.c | l->ce.c)){
+                if (bDrawLastPoint){ l->ce.p.x += l->xi; }
+                GdIncrementDashPhase(l->xi*(l->cs.p.x - l->s.x));
+                psd->Line(
+                    psd,
+                    l->cs.p.x, l->cs.p.y, l->ce.p.x, l->ce.p.y,
+                    l->dx, l->dy, l->xi, l->yi, l->r,
+                    gr_foreground
+                );
+                GdIncrementDashPhase(l->xi*(l->e.x - l->ce.p.x));
+                return;
+            } else if (l->cs.c & l->ce.c){ return; }
+
+            if (l->ce.c){
+                     if (l->ce.c & L) { clip_end_major_x(l, left); }
+                else if (l->ce.c & R) { clip_end_major_x(l, right); }
+                else if (l->ce.c & T) { clip_end_minor_y(l, top); }
+                else if (l->ce.c & B) { clip_end_minor_y(l, bot); }
+            }
+            else {
+                     if (l->cs.c & L) { clip_start_major_x(l, left); }
+                else if (l->cs.c & R) { clip_start_major_x(l, right); }
+                else if (l->cs.c & T) { clip_start_minor_y(l, top); }
+                else if (l->cs.c & B) { clip_start_minor_y(l, bot); }
+            }
+        }
+    } else { /* (l->dx < l->dy) */
+        for(;;){
+            code_line(l, left, right, top, bot);
+            if(!(l->cs.c | l->ce.c)){
+                if (bDrawLastPoint){ l->ce.p.y += l->yi; }
+                GdIncrementDashPhase(l->yi*(l->cs.p.y - l->s.y));
+                psd->Line(
+                    psd,
+                    l->cs.p.x, l->cs.p.y, l->ce.p.x, l->ce.p.y,
+                    l->dx, l->dy, l->xi, l->yi, l->r,
+                    gr_foreground
+                );
+                GdIncrementDashPhase(l->yi*(l->e.y - l->ce.p.y));
+                return;
+            } else if (l->cs.c & l->ce.c){ return; }
+
+            if (l->ce.c){
+                     if (l->ce.c & L) { clip_end_minor_x(l, left); }
+                else if (l->ce.c & R) { clip_end_minor_x(l, right); }
+                else if (l->ce.c & T) { clip_end_major_y(l, top); }
+                else if (l->ce.c & B) { clip_end_major_y(l, bot); }
+            }
+            else {
+                     if (l->cs.c & L) { clip_start_minor_x(l, left); }
+                else if (l->cs.c & R) { clip_start_minor_x(l, right); }
+                else if (l->cs.c & T) { clip_start_major_y(l, top); }
+                else if (l->cs.c & B) { clip_start_major_y(l, bot); }
+            }
+        }
+    }
+}
+/*** end of new line-clipping code added by kaben. */
+
 /**
  * Set the drawing mode for future calls.
  *
@@ -162,11 +398,19 @@
 
 	gr_dashmask = *mask;
 	gr_dashcount = *count;
+	gr_dashindex = 0;
 
 	*mask = oldm;
 	*count = oldc;
 }
 
+/* set the line attribute */
+void
+GdSetLineAttributes(int linestyle)
+{
+	gr_linestyle = linestyle;
+}
+
 /**
  * Draw a point using the current clipping region and foreground color.
  *
@@ -203,32 +447,43 @@
 void
 GdLine(PSD psd, MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
        MWBOOL bDrawLastPoint) 
-{
-	int xdelta;		/* width of rectangle around line */
-	int ydelta;		/* height of rectangle around line */
-	int xinc;		/* increment for moving x coordinate */
-	int yinc;		/* increment for moving y coordinate */
-	int rem;		/* current remainder */
-	unsigned int bit = 0;	/* used for dashed lines */
+{ 
 	MWCOORD temp;
+	conditioned_line_t line;	/* for smart line clipping code */
+#if DYNAMICREGIONS
+#warning dynamic regions untested
+	MWRECT *prc;
+	extern MWCLIPREGION *clipregion;
+#else
+	MWCLIPRECT *prc;
+	extern MWCLIPRECT cliprects[];
+	extern int clipcount;
+#endif
+	int count;
+
+	/* a new line, a new index */
+	gr_dashindex = 0;
 
-	/* See if the line is horizontal or vertical. If so, then call
-	 * special routines.
+	/* See if the line is horizontal or vertical with increasing
+	 * coordinates. If so, then call special routines.
 	 */
 	if (y1 == y2) {
 		/*
 		 * Adjust coordinates if not drawing last point.  Tricky.
+		 * XXX does this still work correctly if going the
+		 * XXX opposite way?
 		 */
-		if (!bDrawLastPoint) {
+		if(!bDrawLastPoint) {
 			if (x1 > x2) {
 				temp = x1;
 				x1 = x2 + 1;
 				x2 = temp;
 			} else
-				--x2;
+			    --x2;
 		}
 
-		/* call faster line drawing routine */
+		/* call faster line drawing routine*/
+
 		drawrow(psd, x1, x2, y1);
 		GdFixCursor(psd);
 		return;
@@ -236,8 +491,10 @@
 	if (x1 == x2) {
 		/*
 		 * Adjust coordinates if not drawing last point.  Tricky.
+		 * XXX does this still work correctly if going the
+		 * XXX opposite way?
 		 */
-		if (!bDrawLastPoint) {
+		if(!bDrawLastPoint) {
 			if (y1 > y2) {
 				temp = y1;
 				y1 = y2 + 1;
@@ -252,94 +509,61 @@
 		return;
 	}
 
+	/* initialize for clipper */
+	line.s.x = x1;
+	line.s.y = y1;
+	line.e.x = x2;
+	line.e.y = y2;
+
+	precondition_line(&line);
+	init_line(&line);
+	if(bDrawLastPoint) {
+		if(line.dx >= line.dy){ line.ce.p.x += line.xi; }
+		else { line.ce.p.y += line.yi; }
+	}
+
 	/* See if the line is either totally visible or totally invisible. If
 	 * so, then the line drawing is easy.
 	 */
-	switch (GdClipArea(psd, x1, y1, x2, y2)) {
+	switch (GdClipArea(psd, line.s.x, line.s.y, line.e.x, line.e.y)) {
 	case CLIP_VISIBLE:
-		/*
-		 * For size considerations, there's no low-level bresenham
-		 * line draw, so we've got to draw all non-vertical
-		 * and non-horizontal lines with per-point
-		 * clipping for the time being
-		 psd->Line(psd, x1, y1, x2, y2, gr_foreground);
-		 GdFixCursor(psd);
-		 return;
-		 */
+		/* use the low-level routine if we've got it available */
+		if (psd->Line != NULL) {
+			psd->Line(psd, line.cs.p.x, line.cs.p.y,
+				line.ce.p.x, line.ce.p.y, line.dx,
+				line.dy, line.xi, line.yi, line.r,
+				gr_foreground);
+			GdFixCursor(psd);
+			return;
+		}
 		break;
 	case CLIP_INVISIBLE:
 		return;
 	}
 
 	/* The line may be partially obscured. Do the draw line algorithm
-	 * checking each point against the clipping regions.
+	 * with smart clipping.
 	 */
-	xdelta = x2 - x1;
-	ydelta = y2 - y1;
-	if (xdelta < 0)
-		xdelta = -xdelta;
-	if (ydelta < 0)
-		ydelta = -ydelta;
-	xinc = (x2 > x1)? 1 : -1;
-	yinc = (y2 > y1)? 1 : -1;
-
-	/* draw first point*/
-	if (GdClipPoint(psd, x1, y1))
-		psd->DrawPixel(psd, x1, y1, gr_foreground);
-
-	if (xdelta >= ydelta) {
-		rem = xdelta / 2;
-		for (;;) {
-			if (!bDrawLastPoint && x1 == x2)
-				break;
-			x1 += xinc;
-			rem += ydelta;
-			if (rem >= xdelta) {
-				rem -= xdelta;
-				y1 += yinc;
-			}
-
-			if (gr_dashcount) {
-				if ((gr_dashmask & (1 << bit)) && GdClipPoint(psd, x1, y1))
-					psd->DrawPixel(psd, x1, y1, gr_foreground);
-
-				bit = (bit + 1) % gr_dashcount;
-			} else {	/* No dashes */
-				if (GdClipPoint(psd, x1, y1))
-					psd->DrawPixel(psd, x1, y1, gr_foreground);
-			}
-
-			if (bDrawLastPoint && x1 == x2)
-				break;
-
-		}
-	} else {
-		rem = ydelta / 2;
-		for (;;) {
-			if (!bDrawLastPoint && y1 == y2)
-				break;
-			y1 += yinc;
-			rem += xdelta;
-			if (rem >= ydelta) {
-				rem -= ydelta;
-				x1 += xinc;
-			}
-
-			/* If we are trying to draw to a dash mask */
-			if (gr_dashcount) {
-				if ((gr_dashmask & (1 << bit)) && GdClipPoint(psd, x1, y1))
-					psd->DrawPixel(psd, x1, y1, gr_foreground);
-
-				bit = (bit + 1) % gr_dashcount;
-			} else {	/* No dashes */
-				if (GdClipPoint(psd, x1, y1))
-					psd->DrawPixel(psd, x1, y1, gr_foreground);
-			}
+#if DYNAMICREGIONS
+#warning dynamic regions are untested with new line clipping code
+	prc = clipregion->rects;
+	count = clipregion->numRects;
+#else
+	prc = cliprects;
+	count = clipcount;
+#endif
 
-			if (bDrawLastPoint && y1 == y2)
-				break;
-		}
+	while (--count >= 0) {
+		init_line(&line);
+#if DYNAMICREGIONS
+		clip_line(psd, &line, prc->left, prc->right, prc->top, prc->bottom, TRUE);
+#else
+		clip_line(psd, &line, prc->x, prc->x + prc->width - 1, prc->y,
+			prc->y + prc->height - 1, TRUE);
+#endif
+		++prc;
 	}
+
 	GdFixCursor(psd);
 }
 
@@ -359,48 +583,45 @@
 {
 	MWCOORD temp;
 
-	/* reverse endpoints if necessary */
+	/* reverse endpoints if necessary*/
 	if (x1 > x2) {
 		temp = x1;
 		x1 = x2;
 		x2 = temp;
 	}
 
-	/* clip to physical device */
+	/* clip to physical device*/
 	if (x1 < 0)
 		x1 = 0;
 	if (x2 >= psd->xvirtres)
 		x2 = psd->xvirtres - 1;
 
-	/* check cursor intersect once for whole line */
+	/* check cursor intersect once for whole line*/
 	GdCheckCursor(psd, x1, y, x2, y);
 
-	/* If aren't trying to draw a dash, then head for the speed */
-
-	if (!gr_dashcount) {
-		while (x1 <= x2) {
-			if (GdClipPoint(psd, x1, y)) {
-				temp = MWMIN(clipmaxx, x2);
-				psd->DrawHorzLine(psd, x1, temp, y, gr_foreground);
-			} else
-				temp = MWMIN(clipmaxx, x2);
-			x1 = temp + 1;
-		}
-	} else {
-		unsigned int p, bit = 0;
-
-		/* We want to draw a dashed line instead */
-		for (p = x1; p <= x2; p++) {
-			if ((gr_dashmask & (1 << bit)) && GdClipPoint(psd, p, y))
-				psd->DrawPixel(psd, p, y, gr_foreground);
-
-			bit = (bit + 1) % gr_dashcount;
+	/* since the low-level code now handles dashlist, this is easy */
+	while (x1 <= x2) {
+		if (GdClipPoint(psd, x1, y)) {
+			/* x1,y is not clipped */
+			temp = MWMIN(clipmaxx, x2);
+			psd->DrawHorzLine(psd, x1, temp, y, gr_foreground);
+		} else {
+			temp = MWMAX(clipmaxx, x1);
+			if (gr_dashcount != 0 && temp != x1)
+				gr_dashindex+=(x1 - clipmaxx);
+		}
+		x1 = temp + 1;
+		if (gr_dashcount != 0) {
+			gr_dashindex++;
+			gr_dashindex%=gr_dashcount;
 		}
 	}
 }
 
 /* Draw a vertical line from y1 to and including y2 in the
  * foreground color, applying clipping if necessary.
+ *
+ * hopefully the clipping checks here aren't redundant.
  */
 static void
 drawcol(PSD psd, MWCOORD x,MWCOORD y1,MWCOORD y2)
@@ -423,25 +644,43 @@
 	/* check cursor intersect once for whole line */
 	GdCheckCursor(psd, x, y1, x, y2);
 
-	if (!gr_dashcount) {
-		while (y1 <= y2) {
-			if (GdClipPoint(psd, x, y1)) {
-				temp = MWMIN(clipmaxy, y2);
-				psd->DrawVertLine(psd, x, y1, temp, gr_foreground);
-			} else
-				temp = MWMIN(clipmaxy, y2);
-			y1 = temp + 1;
-		}
-	} else {
-		unsigned int p, bit = 0;
+	/* check for clipping for whole line */
+	switch (GdClipArea(psd, x, y1, x, y2)) {
+	case CLIP_VISIBLE:
+		/* no clipping */
+		/* my VertLine does dashes.  yay */
+		psd->DrawVertLine(psd, x, y1, y2, gr_foreground);
+		break;
 
-		/* We want to draw a dashed line instead */
-		for (p = y1; p <= y2; p++) {
-			if ((gr_dashmask & (1<<bit)) && GdClipPoint(psd, x, p))
-				psd->DrawPixel(psd, x, p, gr_foreground);
+	case CLIP_INVISIBLE:
+		/* hooray, nothing to do */
+		break;
 
-			bit = (bit + 1) % gr_dashcount;
+	default:
+		/* partially obscured */
+		if (!gr_dashcount) {
+			/* no dashes */
+			while (y1 <= y2) {
+				if (GdClipPoint(psd, x, y1)) {
+					temp = MWMIN(clipmaxy, y2);
+					psd->DrawVertLine(psd, x, y1,
+					    temp, gr_foreground);
+				} else temp = MWMIN(clipmaxy, y2);
+				y1 = temp + 1;
+			}
+		} else {
+			/* dashes
+			 * XXX could probably speed this case up, eh? */
+			int p, bit = 0;
+			for(p = y1; p <= y2; p++) {
+				if (GdClipPoint(psd, x, p)
+				    && (gr_dashmask & (1 << bit)))
+				    psd->DrawPixel(psd, x, p, gr_foreground);
+				bit++;
+				bit%=gr_dashcount;
+			}
 		}
+		break;
 	}
 }
 
@@ -510,6 +749,7 @@
 		return;
 	}
 
+
 	/* See if the rectangle is either totally visible or totally
 	 * invisible. If so, then the rectangle drawing is easy.
 	 */
@@ -564,37 +804,48 @@
 	MWIMAGEBITS bitvalue = 0;	/* bitmap word value */
 	int bitcount;			/* number of bits left in bitmap word */
 
-	if (width <= 0 || height <= 0)
-		return;
+	switch (GdClipArea(psd, x, y, x + width - 1, y + height - 1)) {
+	case CLIP_VISIBLE:
+		/* FIXME think of the speedups if this existed...
+		psd->DrawBitmap(psd, x, y, width, height, imagebits,
+		    gr_foreground);
+		return;
+		*/
+
+		/* "size considerations" be damned.  per-point clipping is
+		 * godawful slow. */
+		if (gr_usebg)
+			psd->FillRect(psd, x, y, x + width - 1,
+			    y + height - 1, gr_background);
 
-	if (gr_usebg)
-		psd->FillRect(psd, x, y, x + width - 1, y + height - 1,
-			gr_background);
+		minx = x;
+		maxx = x + width - 1;
+		bitcount = 0;
+		while (height > 0) {
+			if (bitcount <= 0) {
+				bitcount = MWIMAGE_BITSPERIMAGE;
+				bitvalue = *imagebits++;
+			}
+			/* look, ma, no clipping checks! */
+			if (MWIMAGE_TESTBIT(bitvalue))
+				psd->DrawPixel(psd, x, y, gr_foreground);
+			bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
+			bitcount--;
+			if (x++ == maxx) {
+				x = minx;
+				y++;
+				height--;
+				bitcount = 0;
+			}
+		}
+		GdFixCursor(psd);
+		return;
+		
+		break;
 
-	/* FIXME think of the speedups if this existed...
-	psd->DrawBitmap(psd, x, y, width, height, imagebits, gr_foreground);
-	return;
-	*/
+	case CLIP_INVISIBLE:
+		return;
 
-	minx = x;
-	maxx = x + width - 1;
-	bitcount = 0;
-	while (height > 0) {
-		if (bitcount <= 0) {
-			bitcount = MWIMAGE_BITSPERIMAGE;
-			bitvalue = *imagebits++;
-		}
-		/* draw without clipping*/
-		if (MWIMAGE_TESTBIT(bitvalue))
-			psd->DrawPixel(psd, x, y, gr_foreground);
-		bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
-		bitcount--;
-		if (x++ == maxx) {
-			x = minx;
-			y++;
-			--height;
-			bitcount = 0;
-		}
 	}
 }
 
@@ -641,12 +892,12 @@
 		}
 		if (MWIMAGE_TESTBIT(bitvalue) && GdClipPoint(psd, x, y))
 			psd->DrawPixel(psd, x, y, gr_foreground);
-			bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
-			bitcount--;
+		bitvalue = MWIMAGE_SHIFTBIT(bitvalue);
+		bitcount--;
 		if (x++ == maxx) {
 			x = minx;
 			y++;
-			--height;
+			height--;
 			bitcount = 0;
 		}
 	}
@@ -2116,8 +2367,9 @@
 /*
  * Calculate size and linelen of memory gc.
  * If bpp or planes is 0, use passed psd's bpp/planes.
- * Note: linelen is calculated to be DWORD aligned for speed
- * for bpp <= 8.  Linelen is converted to bytelen for bpp > 8.
+ * Note: linelen is calculated to be DWORD aligned when bpp <= 8, but
+ * really it should be hardware specific.
+ * Linelen is converted to bytelen for bpp > 8.
  */
 int
 GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height, int planes,
@@ -2158,7 +2410,16 @@
 			bytelen = linelen = (linelen+3) & ~3;
 			break;
 		case 8:
+#if 0
+			/* XXX wastes up to 3 pixels worth of space */
 			bytelen = linelen = (width+3) & ~3;
+#elif 1
+			/* XXX 1 pixel's worth of space wasted */
+			bytelen = linelen = (width+1) & ~1;
+#else
+			/* XXX runs into alignment problems */
+			bytelen = linelen = width;
+#endif
 			break;
 		case 16:
 			linelen = width;
Index: CVS-2004-01-09.1/src/engine/devopen.c
--- CVS-2004-01-09.1/src/engine/devopen.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/g/30_devopen.c 1.8.2.1 644)
+++ 0.39(w)/src/engine/devopen.c Fri, 09 Jan 2004 16:01:01 -0800 aaron (microwin/g/30_devopen.c 1.8.2.1 644)
@@ -42,6 +42,8 @@
 
 unsigned long gr_dashmask;     /* An actual bitmask of the dash values */
 unsigned long gr_dashcount;    /* The number of bits defined in the dashmask */
+char       gr_dashindex;       /* where are we in the dashlist */
+int        gr_linestyle;       /* current line style */
 
 int        gr_fillmode;
 MWSTIPPLE  gr_stipple;
@@ -148,6 +150,7 @@
 	/* select first builtin font (usually MWFONT_SYSTEM_VAR)*/
 	GdSetFont(GdCreateFont(psd, NULL, 0, NULL));
 
+	GdSetLineAttributes(MWLINE_SOLID);  /* solid lines */
 	GdSetDash(0, 0);  /* No dashing to start */
 	GdSetStippleBitmap(0,0,0);  /* No stipple to start */
 
Index: CVS-2004-01-09.1/src/drivers/genmem.c
--- CVS-2004-01-09.1/src/drivers/genmem.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/k/13_genmem.c 1.5.2.1 644)
+++ 0.39(w)/src/drivers/genmem.c Fri, 09 Jan 2004 17:18:22 -0800 aaron (microwin/k/13_genmem.c 1.5.2.1 644)
@@ -98,6 +98,7 @@
 	psd->DrawArea 		= subdriver->DrawArea;
 	psd->StretchBlit 	= subdriver->StretchBlit;
 	psd->StretchBlitEx	= subdriver->StretchBlitEx;
+	psd->Line		= subdriver->Line;
 
 	/* call driver init procedure to calc map size and linelen*/
 	if (init && !subdriver->Init(psd))
Index: CVS-2004-01-09.1/src/drivers/genfont.h
--- CVS-2004-01-09.1/src/drivers/genfont.h Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/k/27_genfont.h 1.8.2.1 644)
+++ 0.39(w)/src/drivers/genfont.h Fri, 09 Jan 2004 17:19:23 -0800 aaron (microwin/k/27_genfont.h 1.8.2.1 644)
@@ -8,7 +8,7 @@
  * These routines are screen driver entry points.
  */
 
-#define NUMBER_FONTS	4	/* number of compiled-in fonts*/
+#define NUMBER_FONTS	5	/* number of compiled-in fonts*/
 
 /* entry points*/
 MWBOOL	gen_getfontinfo(PMWFONT pfont, PMWFONTINFO pfontinfo);
Index: CVS-2004-01-09.1/src/drivers/genfont.c
--- CVS-2004-01-09.1/src/drivers/genfont.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/k/30_genfont.c 1.14.2.1 644)
+++ 0.39(w)/src/drivers/genfont.c Fri, 09 Jan 2004 17:22:37 -0800 aaron (microwin/k/30_genfont.c 1.14.2.1 644)
@@ -17,11 +17,18 @@
 #include "genfont.h"
 
 /* compiled in fonts*/
-extern MWCFONT font_winFreeSansSerif11x13;	/* new MWFONT_SYSTEM_VAR (was MWFONT_GUI_VAR)*/
-extern MWCFONT font_X6x13;			/* MWFONT_SYSTEM_FIXED (should be ansi)*/
-/*extern MWCFONT font_winFreeSystem14x16;*/	/* deprecated MWFONT_SYSTEM_VAR*/
-/*extern MWCFONT font_rom8x16;*/		/* deprecated MWFONT_OEM_FIXED*/
-/*extern MWCFONT font_rom8x8, font_X5x7;*/	/* unused*/
+extern MWCFONT
+	font_bdf_fonts_helvB10,
+	font_bdf_fonts_helvR10,
+	font_bdf_fonts_helvB12,
+	font_bdf_fonts_X5x7,
+	font_bdf_fonts_X5x7_alt,
+	font_bdf_fonts_X6x13,
+	font_bdf_fonts_X6x13_alt,
+	font_bdf_fonts_X6x13B,
+	font_bdf_fonts_X6x13B_alt,
+	font_bdf_fonts_X8x16;
+#endif
 
 /* handling routines for MWCOREFONT*/
 static MWFONTPROCS fontprocs = {
@@ -56,12 +63,26 @@
 
 /* first font is default font*/
 MWCOREFONT gen_fonts[NUMBER_FONTS] = {
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR,   &font_winFreeSansSerif11x13},
-	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13},
-	/* deprecated redirections for the time being*/
-	{&fontprocs, 0, 0, 0, "Helvetica",         &font_winFreeSansSerif11x13}, /* redirect*/
-	{&fontprocs, 0, 0, 0, "Terminal",          &font_X6x13}	/* redirect*/
+#if 0
+#if HAVEMSFONTS
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &font_winSystem14x16},
+	{&fontprocs, 0, 0, 0, MWFONT_GUI_VAR, &font_winMSSansSerif11x13},
+	{&fontprocs, 0, 0, 0, MWFONT_OEM_FIXED, &font_winTerminal8x12},
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13}
+#else
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_VAR, &font_winFreeSystem14x16},
+	{&fontprocs, 0, 0, 0, MWFONT_GUI_VAR, &font_winFreeSansSerif11x13},
+	{&fontprocs, 0, 0, 0, MWFONT_OEM_FIXED, &font_rom8x16},
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_X6x13}
+#endif
+#else
+	{&fontprocs, 0, 0, 0, MWFONT_SYSTEM_FIXED, &font_bdf_fonts_X6x13},
+	{&fontprocs, 0, 0, 0, "bdf_fonts_X6x13_alt", &font_bdf_fonts_X6x13_alt},
+	{&fontprocs, 0, 0, 0, "bdf_fonts_X6x13B", &font_bdf_fonts_X6x13B},
+	{&fontprocs, 0, 0, 0, "bdf_fonts_X6x13B_alt", &font_bdf_fonts_X6x13B_alt},
+	{&fontprocs, 0, 0, 0, "bdf_fonts_X8x16", &font_bdf_fonts_X8x16}
 };
+#endif
 
 /*
  * Generalized low level get font info routine.  This
@@ -73,6 +94,7 @@
 	PMWCFONT	pf = ((PMWCOREFONT)pfont)->cfont;
 	int		i;
 
+	pfontinfo->name = pf->name;
 	pfontinfo->maxwidth = pf->maxwidth;
 	pfontinfo->height = pf->height;
 	pfontinfo->baseline = pf->ascent;
@@ -160,6 +182,161 @@
 	PMWCFONT		pf = ((PMWCOREFONT)pfont)->cfont;
 	int 			count, width;
 	const MWIMAGEBITS *	bits;
+
+#if HAVE_BIG5_SUPPORT
+	/* decode chinese big5*/
+	int CH = ((unsigned int)ch) >> 8, CL = ((unsigned int)ch) & 0xFF;
+	if (CH >= 0xA1 && CH <= 0xF9 && ((CL >= 0x40 && CL <= 0x7E) || (CL >= 0xA1 && CL <= 0xFE)) ) 
+	{
+	    int Pos;	/* != ((CH - 0xA1) * 94 + (CL - 0xA1)) * 18; */
+
+	    int i;
+	    extern unsigned char JMT_BIG5_12X12_FONT_BITMAP[];
+
+	    int seq;
+	    {
+		seq=0;
+		/* ladd=loby-(if(loby<127)?64:98) */
+		CL/*c2*/-=(CL/*c2*/<127?64:98);   
+
+		/* hadd=(hiby-164)*157 */
+		if (CH/*c1*/>=0xa4)	/* standard font */
+		{
+			seq=(((CH/*c1*/-164)*157)+CL/*c2*/);
+			if (seq>=5809) seq-=408;
+		}
+
+		/* hadd=(hiby-161)*157 */
+		if (CH/*c1*/<=0xa3)	/* special font */
+			seq=(((CH/*c1*/-161)*157)+CL/*c2*/)+13094;
+	    }
+	    Pos=seq*18;
+
+	    *pwidth = width = 12;
+	    *pheight = 12;
+	    *pbase = 0;
+
+	    for (i = 0; i < 6; i++) {
+		unsigned char *DstBitmap  = ((unsigned char *)retmap) + i * 4;
+		unsigned char *FontBitmap = JMT_BIG5_12X12_FONT_BITMAP +
+			Pos + i * 3;
+		DstBitmap[0] = FontBitmap[1];
+		DstBitmap[1] = FontBitmap[0];
+		DstBitmap[2] = FontBitmap[1] << 4;
+		DstBitmap[3] = FontBitmap[2];
+	    }
+	    return;
+	}
+#endif /* HAVE_BIG5_SUPPORT*/
+
+#if HAVE_GB2312_SUPPORT
+	/* decode chinese gb2312*/
+	int CH = ((unsigned int)ch) >> 8, CL = ((unsigned int)ch) & 0xFF;
+	if (CH >= 0xA1 && CH < 0xF8 && CL >= 0xA1 && CL < 0xFF) {
+	    int Pos = ((CH - 0xA1) * 94 + (CL - 0xA1)) * 18;
+	    int i;
+	    extern unsigned char GUO_GB2312_12X12_FONT_BITMAP[];
+
+	    *pwidth = width = 12;
+	    *pheight = 12;
+	    *pbase = 0;
+
+	    for (i = 0; i < 6; i++) {
+		unsigned char *DstBitmap  = ((unsigned char *)retmap) + i * 4;
+		unsigned char *FontBitmap = GUO_GB2312_12X12_FONT_BITMAP +
+			Pos + i * 3;
+		DstBitmap[0] = FontBitmap[1];
+		DstBitmap[1] = FontBitmap[0];
+		DstBitmap[2] = FontBitmap[1] << 4;
+		DstBitmap[3] = FontBitmap[2];
+	    }
+	    return;
+	}
+#endif /* HAVE_GB2312_SUPPORT*/
+
+#if HAVE_JISX0213_SUPPORT
+	/* decode Japanese JISX0213*/
+	int CH = ((unsigned int)ch) >> 8, CL = ((unsigned int)ch) & 0xFF;
+	/*EUC-JISX0213*/
+	if (CH >= 0xA1 && CH <= 0xFE && CL >= 0xA1 && CL <= 0xFE){
+	int EH = CH - 0xA1;
+	int EL = CL - 0xA1;
+	int pos = EH*94 + EL;
+	int height,i;
+	extern unsigned short JP_JISX0213_12X12_FONT_BITMAP[];
+	unsigned short *FontBitmap = JP_JISX0213_12X12_FONT_BITMAP + pos*12;
+
+	    *pwidth = width = 12;
+	    *pheight = height = 12;
+	    *pbase = 0;
+
+
+	    for (i = 0;i<width;i++)
+		*retmap++ = *FontBitmap++;
+
+	    return;
+	}
+	/*SHIFT-JISX0213*/
+       if ((CH >= 0x81 && CH <= 0x9F) || (CH >= 0xE0 && CH <= 0xEF)){
+	   int EH = 0;
+	   int EL = 0;
+	   int pos = 0;
+	   int height,i;
+	   extern unsigned short JP_JISX0213_12X12_FONT_BITMAP[];
+          unsigned short *FontBitmap;
+	   
+          if (CH >= 0x81 && CH <= 0x9F)
+  		if (CL >= 0x40 && CL <= 0xFC && (CL != 0x7F))
+  		{
+			EH = CH - 0x81;
+			if (CL >= 0x40 && CL <= 0x7E){
+		  	   EL = CL - 0x40;
+			}else if (CL >= 0x80 && CL <= 0xFC){
+			   EL = CL - 0x40 - 1;
+			}   
+			pos = EH*188 + EL;
+ 		}
+	   if (CH >= 0xE0 && CH <= 0xEF)
+	       if (CL >= 0x40 && CL <= 0xFC && (CL != 0x7F))
+	       {
+			EH = CH - 0xE0 + (0x9F - 0x81);
+			if (CL >= 0x40 && CL <= 0x7E){
+		  	   EL = CL - 0x40;
+			}else if (CL >= 0x80 && CL <= 0xFC){
+			   EL = CL - 0x40 - 1;
+			}   
+			pos = EH*188 + EL;		
+		}
+	    *pwidth = width = 12;
+	    *pheight = height = 12;
+	    *pbase = 0;
+
+	    FontBitmap = (unsigned short*)(JP_JISX0213_12X12_FONT_BITMAP + pos*width);
+	    
+	    for (i = 0;i<width;i++)
+		*retmap++ = *FontBitmap++;
+
+	    return;
+       }   
+#endif /*HAVE_JISX0213_SUPPORT*/
+
+#if HAVE_KSC5601_SUPPORT
+	int CH = ((unsigned int)ch) >> 8, CL = ((unsigned int)ch) & 0xFF;
+	int	mc;
+
+	if ( CH>= 0xA1 &&  CH<= 0xFE && (CL >= 0xA1 && CL <= 0xFE))
+	{
+		mc = convert_ksc_to_johab( CH, CL);
+		if ( mc )	
+			get_han_image(mc, retmap );
+
+		/* Fix me */
+		*pwidth = width = 16;
+		*pheight = 16;
+		*pbase = 0;
+		return;
+	}
+#endif
 
 	/* if char not in font, map to first character by default*/
 	if(ch < pf->firstchar || ch >= pf->firstchar+pf->size)
Index: CVS-2004-01-09.1/src/drivers/fblin32.c
--- CVS-2004-01-09.1/src/drivers/fblin32.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/k/34_fblin32.c 1.6.2.1 644)
+++ 0.39(w)/src/drivers/fblin32.c Fri, 09 Jan 2004 16:01:16 -0800 aaron (microwin/k/34_fblin32.c 1.6.2.1 644)
@@ -119,15 +119,15 @@
 linear32_blit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD w, MWCOORD h,
 	PSD srcpsd, MWCOORD srcx, MWCOORD srcy, long op)
 {
-	ADDR8	dst8, src8;
 	ADDR32	dst = dstpsd->addr;
 	ADDR32	src = srcpsd->addr;
 	int	i;
 	int	dlinelen = dstpsd->linelen;
 	int	slinelen = srcpsd->linelen;
+#if ALPHABLEND
+	ADDR8	dst8, src8;
 	int	dlinelen_minus_w4;
 	int	slinelen_minus_w4;
-#if ALPHABLEND
 	unsigned int alpha;
 #endif
 
Index: CVS-2004-01-09.1/src/drivers/fblin8.c
--- CVS-2004-01-09.1/src/drivers/fblin8.c Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/k/48_fblin8.c 1.13.2.1 644)
+++ 0.39(w)/src/drivers/fblin8.c Fri, 09 Jan 2004 17:24:05 -0800 aaron (microwin/k/48_fblin8.c 1.13.2.1 644)
@@ -20,6 +20,7 @@
 #include "fb.h"
 
 #if ALPHABLEND
+#include <malloc.h>
 /*
  * Alpha lookup tables for 256 color palette systems
  * A 5 bit alpha value is used to keep tables smaller.
@@ -295,6 +296,77 @@
 	DRAWOFF;
 }
 
+/* kaben's linedraw */
+static void
+linear8_conditioned_line(PSD psd,
+    MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
+    MWCOORD dx, MWCOORD dy, MWCOORD xi, MWCOORD yi,
+    MWCOORD r, MWPIXELVAL c)
+{
+#if 0
+	/* current line style */
+	extern unsigned int gr_line_style;
+	/* current dash list */
+	extern char *gr_dash_list;
+	/* length of current dash list */
+	extern unsigned int gr_num_dashes;
+	/* current index into dash list */
+	extern unsigned int gr_dash_index;
+	/* current pixel in current dash */
+	extern int gr_dash_pixct;
+#else
+	extern unsigned long gr_dashmask;
+	extern unsigned long gr_dashcount;
+	extern char gr_dashindex;
+	extern int gr_linestyle;
+#endif
+	ADDR8 addr = psd->addr;
+	int linelen = psd->linelen;
+	int dM, dm, adM, adm, M;
+
+	assert (addr != 0);
+	assert (x1 >= 0 && x1 < psd->xres);
+	assert (x2 >= -1 && x2 <= psd->xres);
+	assert (y1 >= 0 && y1 < psd->yres);
+	assert (y2 >= -1 && y2 <= psd->yres);
+	assert (c < psd->ncolors);
+
+	DRAWON;
+	addr += x1 + y1 * linelen;
+
+	if (dx > dy){
+		dM = dy;
+		dm = dx - dM;
+		M = xi * (x2 - x1);
+		adM = xi;
+		adm = adM + yi * linelen;
+	} else {
+		dM = dx;
+		dm = dy - dM;
+		M = yi * (y2 - y1);
+		adM = yi * linelen;
+		adm = adM + xi;
+	}
+
+	if((gr_dashmask == 0) || (gr_linestyle == MWLINE_SOLID)) {
+		/* generic bresenham */
+		while(M--) {
+			*addr = c;
+			if (r >= dm) { r -= dm; addr += adm; }
+			else { r += dM; addr += adM; }
+		}
+	} else while(M--) {
+		/* bresenham with dashmask */
+		if(gr_dashmask & (1 << gr_dashindex)) *addr = c;
+		gr_dashindex++;
+		gr_dashindex%=gr_dashcount;
+		if (r >= dm) { r -= dm; addr += adm; }
+		else { r += dM; addr += adM; }
+	}
+
+	DRAWOFF;
+}
+
 #if ALPHABLEND
 void
 init_alpha_lookup(void)
@@ -848,5 +920,6 @@
 	gen_fillrect,
 	linear8_blit,
 	linear8_drawarea,
-	linear8_stretchblit
+	linear8_stretchblit,
+	linear8_conditioned_line
 };
Index: CVS-2004-01-09.1/src/include/mwtypes.h
--- CVS-2004-01-09.1/src/include/mwtypes.h Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/l/49_mwtypes.h 1.9.2.1 644)
+++ 0.39(w)/src/include/mwtypes.h Fri, 09 Jan 2004 17:25:18 -0800 aaron (microwin/l/49_mwtypes.h 1.9.2.1 644)
@@ -90,6 +90,7 @@
 /* Line modes */
 #define MWLINE_SOLID      0
 #define MWLINE_ONOFF_DASH 1
+#define MWLINE_MAX        1
 
 /* FUTURE: MWLINE_DOUBLE_DASH */
 
@@ -432,6 +433,12 @@
 	 * the sum of the advance widths for the characters 'A' and 'V'.
 	 */
 	MWUCHAR widths[256];
+
+	/**
+	 * Name of the font
+	 */
+	const char *name;
+
 } MWFONTINFO, *PMWFONTINFO;
 
 
Index: CVS-2004-01-09.1/src/include/device.h
--- CVS-2004-01-09.1/src/include/device.h Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/m/18_device.h 1.9.2.2 644)
+++ 0.39(w)/src/include/device.h Wed, 28 Jan 2004 19:09:30 -0800 aaron (microwin/m/18_device.h 1.9.2.2 644)
@@ -12,15 +12,19 @@
 #include "mwsystem.h"
 
 /* Changeable limits and options*/
-#define ALPHABLEND	1			/* =1 to include blending code*/
-#define DYNAMICREGIONS	1			/* =1 to use MWCLIPREGIONS*/
-#define HAVEFLOAT	1			/* =1 incl float, GdArcAngle*/
-#define POLYREGIONS	1			/* =1 includes polygon regions*/
+#define ALPHABLEND	0			/* =1 to include blending code*/
+#define DYNAMICREGIONS	0			/* =1 to use MWCLIPREGIONS*/
+#define HAVEFLOAT	0			/* =1 incl float, GdArcAngle*/
+#define POLYREGIONS	0			/* =1 includes polygon regions*/
 #define ANIMATEPALETTE	0			/* =1 animated palette test*/
 #define FONTMAPPER	0			/* =1 for Morten's font mapper*/
+#if defined(_POSIX_VERSION) && _POSIX_VERSION >= 199309L
 #define USE_ALLOCA	1			/* alloca() is available */
+#else
+#define USE_ALLOCA	0			/* alloca() not available */
+#endif
 #define FASTJPEG	1			/* =1 for temp quick jpeg 8bpp*/
-#define HAVE_MMAP       1       		/* =1 to use mmap if available*/
+#define HAVE_MMAP       0       		/* =1 to use mmap if available*/
 #define TRANSLATE_ESCAPE_SEQUENCES  1		/* =1 to parse fnkeys w/tty driver*/
 
 #if !((DOS_DJGPP) || (__PACIFIC__) || (DOS_TURBOC))
@@ -102,9 +106,9 @@
 	int		ascent;		/* ascent (baseline) height*/
 	int		firstchar;	/* first character in bitmap*/
 	int		size;		/* font size in characters*/
-	MWIMAGEBITS *	bits;		/* 16-bit right-padded bitmap data*/
-	unsigned long *offset;		/* offsets into bitmap data*/
-	unsigned char *	width;		/* character widths or 0 if fixed*/
+	const MWIMAGEBITS *	bits;	/* 16-bit right-padded bitmap data*/
+	const unsigned long *offset;	/* offsets into bitmap data*/
+	const unsigned char *	width;	/* character widths or 0 if fixed*/
 	int		defaultchar;	/* default char (not glyph index)*/
 	long		bits_size;	/* # words of MWIMAGEBITS bits*/
 } MWCFONT, *PMWCFONT;
@@ -308,6 +312,9 @@
 			int x_denominator, int y_denominator,
 			int src_x_fraction, int src_y_fraction,
 			int x_step_fraction, int y_step_fraction, long op);
+	void	 (*Line)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2,
+			MWCOORD dx, MWCOORD dy, MWCOORD xi, MWCOORD yi,
+			MWCOORD r, MWPIXELVAL c);
 } SUBDRIVER, *PSUBDRIVER;
 
 /*
@@ -343,9 +350,11 @@
 			MWPIXELVAL c);
 	PMWCOREFONT builtin_fonts;
 
-	/* *void (*DrawText)(PSD psd,MWCOORD x,MWCOORD y,const MWUCHAR *str,
-			int count, MWPIXELVAL fg, PMWFONT pfont);***/
-
+	void	(*DrawText)(PSD psd,MWCOORD x,MWCOORD y,const MWUCHAR *str,
+			int count, MWPIXELVAL fg, PMWFONT pfont);
+	void	(*Line)(PSD psd,MWCOORD x1,MWCOORD y1,MWCOORD x2,MWCOORD y2,
+			MWCOORD dx, MWCOORD dy, MWCOORD xi, MWCOORD yi,
+			MWCOORD r, MWPIXELVAL c);
 	void	(*Blit)(PSD destpsd,MWCOORD destx,MWCOORD desty,MWCOORD w,
 			MWCOORD h,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,long op);
 	void	(*PreSelect)(PSD psd);
@@ -693,6 +702,7 @@
 MWPIXELVAL GdSetBackgroundPixelVal(PSD psd, MWPIXELVAL bg);
 MWPIXELVAL GdSetForegroundColor(PSD psd, MWCOLORVAL fg);
 MWPIXELVAL GdSetBackgroundColor(PSD psd, MWCOLORVAL bg);
+void	GdSetLineAttributes(int linestyle);
 
 void	GdResetPalette(void);
 void	GdSetPalette(PSD psd,int first, int count, MWPALENTRY *palette);
@@ -919,6 +929,9 @@
 /* error.c*/
 int	GdError(const char *format, ...);
 int	GdErrorNull(const char *format, ...);  /* doesn't print msgs */
+
+/* Frye Electronics goo */
+extern const char _MW_Frye_version[];
 
 #if USE_ALLOCA
 /* alloca() is available, so use it for better performance */
Index: CVS-2004-01-09.1/src/include/nano-X.h
--- CVS-2004-01-09.1/src/include/nano-X.h Fri, 09 Jan 2004 15:45:46 -0800 aaron (microwin/m/19_nano-X.h 1.9.2.2 644)
+++ 0.39(w)/src/include/nano-X.h Fri, 09 Jan 2004 16:01:22 -0800 aaron (microwin/m/19_nano-X.h 1.9.2.2 644)
@@ -108,6 +108,7 @@
 /* Line modes */
 #define GR_LINE_SOLID           MWLINE_SOLID
 #define GR_LINE_ONOFF_DASH      MWLINE_ONOFF_DASH
+#define GR_LINE_MAX		MWLINE_MAX
 
 #define GR_FILL_SOLID           MWFILL_SOLID
 #define GR_FILL_STIPPLE         MWFILL_STIPPLE
@@ -303,6 +304,7 @@
 #define GR_ERROR_BAD_LINE_ATTRIBUTE     14
 #define GR_ERROR_BAD_FILL_MODE          15
 #define GR_ERROR_BAD_REGION_ID		16
+#define GR_ERROR_BAD_DASH		17
 
 /* Event types.
  * Mouse motion is generated for every motion of the mouse, and is used to
@@ -711,7 +713,8 @@
 	"Bad drawing mode gc: %d\n",    \
         "Bad line attribute gc: %d\n",  \
         "Bad fill mode gc: %d\n",       \
-	"Bad region id: %d\n",
+	"Bad region id: %d\n",		\
+	"Bad dash gc: %d\n"
         
 extern char *nxErrorStrings[];
 
@@ -767,7 +770,7 @@
 void		GrGetWindowInfo(GR_WINDOW_ID wid, GR_WINDOW_INFO *infoptr);
 void		GrSetWMProperties(GR_WINDOW_ID wid, GR_WM_PROPERTIES *props);
 void		GrGetWMProperties(GR_WINDOW_ID wid, GR_WM_PROPERTIES *props);
-GR_FONT_ID	GrCreateFont(GR_CHAR *name, GR_COORD height,
+GR_FONT_ID	GrCreateFont(const GR_CHAR *name, GR_COORD height,
 			GR_LOGFONT *plogfont);
 GR_FONT_ID	GrCreateFontFromBuffer(const void *buffer, unsigned length,
 			const char *format, GR_COORD height);
Index: CVS-2004-01-09.1/src/include/swap.h
--- CVS-2004-01-09.1/src/include/swap.h Fri, 23 May 2003 11:55:55 -0700 aaron (microwin/B/15_swap.h 1.1.2.1 644)
+++ 0.39(w)/src/include/swap.h Wed, 28 Jan 2004 18:59:02 -0800 aaron (microwin/B/15_swap.h 1.1.2.1 644)
@@ -136,5 +136,7 @@
  * 2) Just comment out the warning.  If you have performance problems with
  *    BMP files and PCF fonts, you'll need to do (1).
  */
+#if 0
 # warning You might want to define optimized byte swapping macros for this machine - if not, you can safely ignore this warning.
+#endif
 #endif
Changes type from type file to symlink: [FROM: src/engine/devfont.c, TO: 
symlink: src/engine/devfont.c]
