diff -urN microwin/src\demos\demos.bkl microwin-0.90/src\demos\demos.bkl
--- microwin/src\demos\demos.bkl	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\demos\demos.bkl	Mon Aug 30 14:45:28 2010
@@ -0,0 +1,312 @@
+<?xml version="1.0"?>
+<!-- Demos bakefile for nano-X -->
+  <makefile>
+    <requires version="0.2.8"/>
+    <include file="presets/simple.bkl"/>
+	
+    <if cond="PLATFORM_UNIX=='1'">
+      <set var="EXEEXT" overwrite="1">.elf</set>
+    </if>
+    <set var="BUILDDIR">..$(DIRSEP)bin</set>
+
+    <set var="EMBEDFLAG">
+      <if cond="PLATFORM_WIN32=='1'"></if>
+      <if cond="PLATFORM_WIN32=='0'">EMBEDDED</if>
+    </set>
+    
+    <set var="FLOATFLAG">
+      HAVEFLOAT=0
+    </set>
+    
+    /* HOST build (only Win32 for now) */    
+    <set var="HOST">
+      <if cond="PLATFORM_WIN32=='1'">1</if>
+    </set>
+    
+    <set var="RANDFLAG">
+      HAVE_RAND
+    </set>
+
+    <set var="SYSLIB1">
+      <if cond="PLATFORM_WIN32=='1'">user32</if>
+      <if cond="PLATFORM_WIN32=='0'">m</if>
+    </set>
+    <set var="SYSLIB2">
+      <if cond="PLATFORM_WIN32=='1'">gdi32</if>
+      <if cond="PLATFORM_WIN32=='0'">c</if>
+    </set>
+    
+    <if cond="HOST=='1'">
+      <exe id="convbmp" template="simple">
+        <app-type>console</app-type>
+        <sources>../mwin/bmp/convbmp.c</sources>
+      </exe>
+  
+      <exe id="bin2c" template="simple">
+        <app-type>console</app-type>
+        <sources>nanox/bin2c.c</sources>
+      </exe>
+
+      <set var="TUXCHESS_IMAGES">tuxchess$(DIRSEP)images</set>
+      <set var="BIN2C">..$(DIRSEP)..$(DIRSEP)..$(DIRSEP)bin$(DIRSEP)bin2c.exe</set>
+      <action id="gen-tuxchess">
+        <command>
+          cd $(TUXCHESS_IMAGES)
+            $(BIN2C) board.gif > board.c
+            $(BIN2C) w_p.gif w_n.gif w_b.gif w_r.gif w_k.gif w_q.gif > white.c
+            $(BIN2C) b_p.gif b_n.gif b_b.gif b_r.gif b_k.gif b_q.gif > black.c
+          cd ..$(DIRSEP)..
+        </command>
+        <clean-files>
+          $(RM) $(TUXCHESS_IMAGES)$(DIRSEP)board.c
+          $(RM) $(TUXCHESS_IMAGES)$(DIRSEP)white.c
+          $(RM) $(TUXCHESS_IMAGES)$(DIRSEP)black.c
+        </clean-files>
+        <depends>bin2c</depends>
+      </action>
+
+      <set var="MINE_IMAGES">mwin</set>
+      <set var="CONVBMP">..$(DIRSEP)..$(DIRSEP)bin$(DIRSEP)convbmp.exe</set>
+      <action id="gen-mine">
+        <command>
+          cd $(MINE_IMAGES)
+        	$(CONVBMP) -o minebomb.c minebomb.bmp
+            $(CONVBMP) -o minedone.c minedone.bmp
+            $(CONVBMP) -o mineface.c mineface.bmp
+            $(CONVBMP) -o minefacelost.c minefacelost.bmp
+            $(CONVBMP) -o mineflag.c mineflag.bmp
+            $(CONVBMP) -o minehitfalse.c minehitfalse.bmp
+          cd ..
+        </command>
+        <clean-files>
+          $(RM) $(MINE_IMAGES)$(DIRSEP)minebomb.c
+          $(RM) $(MINE_IMAGES)$(DIRSEP)minedone.c
+          $(RM) $(MINE_IMAGES)$(DIRSEP)mineface.c
+          $(RM) $(MINE_IMAGES)$(DIRSEP)minefacelost.c
+          $(RM) $(MINE_IMAGES)$(DIRSEP)mineflag.c
+          $(RM) $(MINE_IMAGES)$(DIRSEP)minehitfalse.c
+        </clean-files>
+        <depends>convbmp</depends>
+      </action>
+      
+      <set var="BIN2C">..$(DIRSEP)..$(DIRSEP)bin$(DIRSEP)bin2c.exe</set>
+      <action id="gen-tux">
+        <command>
+          cd nanox
+            $(BIN2C) tux.gif > tux_gif.c
+          cd ..
+        </command>
+        <clean-files>
+          $(RM) nanox$(DIRSEP)tux_gif.c
+        </clean-files>
+        <depends>bin2c</depends>
+      </action>
+
+      <action id="gen-slider">
+        <is-phony></is-phony>
+        <command>
+          cd nanox
+            $(BIN2C) slidebmp.bmp > slide_bmp.c
+          cd ..
+        </command>
+        <clean-files>
+          $(RM) nanox$(DIRSEP)slide_bmp.c
+        </clean-files>
+        <depends>bin2c</depends>
+        <depends-on-file>nanox$(DIRSEP)slidebmp.bmp</depends-on-file>
+      </action>
+
+      <action id="gen-world">
+        <command>
+          cd nanox
+            $(BIN2C) -w world.map > world_map.c
+          cd ..
+        </command>
+        <clean-files>
+          $(RM) nanox$(DIRSEP)world_map.c
+        </clean-files>
+        <depends>bin2c</depends>
+      </action>
+
+
+      <set var="CONVBMP">..$(DIRSEP)..$(DIRSEP)bin$(DIRSEP)convbmp.exe</set>
+      <set var="MWIN_BMP">..$(DIRSEP)mwin$(DIRSEP)bmp</set>
+      <action id="gen-bmp">
+        <command>
+          cd $(MWIN_BMP)
+            $(CONVBMP) -o car8.c car8.bmp
+            $(CONVBMP) -o penguin.c penguin.bmp
+            $(CONVBMP) -o microwin.c microwin.bmp
+          cd ..$(DIRSEP)..$(DIRSEP)demos
+        </command>
+        <clean-files>
+          $(RM) $(MWIN_BMP)$(DIRSEP)car8.c
+          $(RM) $(MWIN_BMP)$(DIRSEP)penguin.c
+          $(RM) $(MWIN_BMP)$(DIRSEP)microwin.c
+        </clean-files>
+        <depends>bin2c</depends>
+      </action>
+    </if>
+
+    <!-- Make Nano-X demos -->
+    <template id="nanoxapp">
+      <app-type>gui</app-type>
+      <define>$(EMBEDFLAG)</define>
+      <define>$(FLOATFLAG)</define>
+      <define>$(RANDFLAG)</define>
+      <include>../include</include>
+      <lib-path>../lib</lib-path>
+      <sys-lib>nanox</sys-lib>
+      <sys-lib>nxbase</sys-lib>
+      <sys-lib>$(SYSLIB1)</sys-lib>
+      <sys-lib>$(SYSLIB2)</sys-lib>
+    </template>
+    
+    <exe id="arcdemo" template="simple,nanoxapp">
+      <sources>nanox/arcdemo.c</sources>
+    </exe>
+
+    <exe id="bmpdemo" template="simple,nanoxapp">
+      <sources>nanox/bmpdemo.c</sources>
+    </exe>
+
+    <exe id="dashdemo" template="simple,nanoxapp">
+      <sources>nanox/dashdemo.c</sources>
+    </exe>
+
+    <exe id="demo" template="simple,nanoxapp">
+      <sources>nanox/demo.c</sources>
+    </exe>
+
+    <exe id="demo2" template="simple,nanoxapp">
+      <sources>nanox/demo2.c</sources>
+    </exe>
+
+    <exe id="demo5" template="simple,nanoxapp">
+      <sources>nanox/demo5.c</sources>
+    </exe>
+
+    <exe id="fontdemo" template="simple,nanoxapp">
+      <sources>nanox/fontdemo.c</sources>
+    </exe>
+
+    <exe id="landmine" template="simple,nanoxapp">
+      <sources>nanox/landmine.c</sources>
+    </exe>
+	
+    <if cond="HOST=='1'">
+      <exe id="ntetris" template="simple,nanoxapp">
+        <sources>nanox/ntetris.c</sources>
+      </exe>
+      <exe id="nxeyes" template="simple,nanoxapp">
+        <sources>nanox/nxeyes.c</sources>
+      </exe>
+    </if>
+	
+    <exe id="polydemo" template="simple,nanoxapp">
+      <sources>nanox/polydemo.c</sources>
+    </exe>
+
+    <exe id="slider" template="simple,nanoxapp">
+      <sources>nanox/slider.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-slider</objects-depend>
+      </if>
+    </exe>
+
+    <exe id="t1demo" template="simple,nanoxapp">
+      <sources>nanox/t1demo.c</sources>
+    </exe>
+
+    <exe id="tsdemo" template="simple,nanoxapp">
+      <sources>nanox/tsdemo.c</sources>
+    </exe>
+    
+    <if cond="HOST=='1'">
+	    <exe id="tux" template="simple,nanoxapp">
+ 	      <sources>nanox/tux.c</sources>
+ 	      <objects-depend>gen-tux</objects-depend>
+	    </exe>
+	 </if>
+	
+    <exe id="tuxchess" template="simple,nanoxapp">
+      <sources>tuxchess/board.c</sources>
+      <sources>tuxchess/data.c</sources>
+      <sources>tuxchess/eval.c</sources>
+      <sources>tuxchess/images.c</sources>
+      <sources>tuxchess/main.c</sources>
+      <sources>tuxchess/search.c</sources>
+      <headers>demos/tuxchess/data.h</headers>
+      <headers>demos/tuxchess/defs.h</headers>
+      <headers>demos/tuxchess/protos.h</headers>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-tuxchess</objects-depend>
+      </if>
+    </exe>
+
+    <exe id="world" template="simple,nanoxapp">
+      <sources>nanox/world.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-world</objects-depend>
+      </if>
+    </exe>
+	
+    <!-- Make Microwindows demos -->
+    <template id="mwinapp">
+      <app-type>gui</app-type>
+      <define>$(EMBEDFLAG)</define>
+      <define>$(FLOATFLAG)</define>
+      <define>$(RANDFLAG)</define>
+      <include>../include</include>
+      <include>../mwin/include</include>
+      <lib-path>../lib</lib-path>
+      <sys-lib>mwin</sys-lib>
+      <sys-lib>nxbase</sys-lib>
+      <sys-lib>$(SYSLIB1)</sys-lib>
+      <sys-lib>$(SYSLIB2)</sys-lib>
+    </template>
+  
+    <exe id="malpha" template="simple,mwinapp">
+      <sources>mwin/malpha.c</sources>
+      <sources>../mwin/bmp/car8.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-bmp</objects-depend>
+      </if>
+    </exe>
+    	
+    <exe id="mdemo" template="simple,mwinapp">
+      <sources>mwin/mdemo.c</sources>
+      <sources>../mwin/bmp/microwin.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-bmp</objects-depend>
+      </if>
+    </exe>
+		
+    <exe id="mine" template="simple,mwinapp">
+      <sources>mwin/mine.c</sources>
+      <sources>mwin/minebomb.c</sources>
+      <sources>mwin/minedone.c</sources>
+      <sources>mwin/mineface.c</sources>
+      <sources>mwin/minefacelost.c</sources>
+      <sources>mwin/mineflag.c</sources>
+      <sources>mwin/minehitfalse.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-mine</objects-depend>
+      </if>
+    </exe>
+
+    <exe id="mstretch" template="simple,mwinapp">
+      <sources>mwin/mstretch.c</sources>
+      <sources>../mwin/bmp/penguin.c</sources>
+      <if cond="HOST=='1'">
+        <objects-depend>gen-bmp</objects-depend>
+      </if>
+    </exe>
+
+    <exe id="mtest2" template="simple,mwinapp">
+      <sources>mwin/mtest2.c</sources>
+      <lib-path>../lib</lib-path>
+    </exe>
+
+      
+</makefile>
diff -urN microwin/src\demos\mwin\malpha.c microwin-0.90/src\demos\mwin\malpha.c
--- microwin/src\demos\mwin\malpha.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\malpha.c	Mon Aug 30 09:47:52 2010
@@ -11,7 +11,7 @@
 
 extern MWIMAGEHDR image_car8;
 
-#define APPCLASS	"test"
+#define APPCLASS	"malpha"
 
 /* forward decls*/
 LRESULT CALLBACK WndProc(HWND hwnd,UINT uMsg,WPARAM wp,LPARAM lp);
@@ -32,9 +32,7 @@
 	wc.hbrBackground = (HBRUSH)GetStockObject(GRAY_BRUSH);
 	wc.lpszMenuName = NULL;
 	wc.lpszClassName =  APPCLASS;
-	RegisterClass( &wc);
-
-	return 1;
+	return RegisterClass( &wc);
 }
 
 HWND
@@ -133,9 +131,15 @@
 	return( 0);
 }
 
-int WINAPI 
-WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
-	int nShowCmd)
+
+#ifdef WIN32
+int WINAPI MWinMain
+#else
+int WINAPI WinMain
+#endif
+
+	(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
+
 {
 	MSG msg;
 
diff -urN microwin/src\demos\mwin\mdemo.c microwin-0.90/src\demos\mwin\mdemo.c
--- microwin/src\demos\mwin\mdemo.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\mdemo.c	Fri Aug 27 11:06:34 2010
@@ -45,7 +45,7 @@
 #define USEBLIT		0	/* use blit rather than DrawDIB()*/
 #endif
 
-#if RTEMS || ECOS || PSP
+#ifdef HAVE_RAND
 #define  srandom  srand
 #define  random   rand
 #endif
@@ -468,15 +468,23 @@
 	return 0;
 }
 
-int WINAPI 
-WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
-	int nShowCmd)
+
+#ifdef WIN32
+int WINAPI MWinMain
+
+#else
+
+int WINAPI WinMain
+
+#endif
+
+	(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,	int nShowCmd)
 {
 	MSG 	msg;
 	HWND	hwnd;
 	RECT	rc;
 
-	srandom(time(NULL));
+	srandom( GetTickCount() );
 
 	RegisterAppClass();
 	GetWindowRect(GetDesktopWindow(), &rc);
diff -urN microwin/src\demos\mwin\mine.c microwin-0.90/src\demos\mwin\mine.c
--- microwin/src\demos\mwin\mine.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\mine.c	Fri Aug 27 11:05:42 2010
@@ -7,7 +7,7 @@
  */
 extern int mwCurrentButtons;	/* FIXME */
 
-#if RTEMS || __ECOS || PSP
+#ifdef HAVE_RAND
 #define  srandom  srand
 #define  random   rand
 #endif
@@ -724,7 +724,7 @@
               for (i = 0; i < (sg_boxnumx*sg_boxnumy); i++)
                   NoAdr[i].NY = FALSE; 
                    
-              srandom( time(NULL));
+              srandom( GetTickCount() );
               i = 0;
               while( i < bombnum )
                {
@@ -1044,9 +1044,17 @@
     return NULL;
 }
 
-int WINAPI 
-WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
-	int nShowCmd)
+
+#ifdef WIN32
+
+int WINAPI MWinMain
+
+#else
+int WINAPI WinMain
+
+#endif
+
+	(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,	int nShowCmd)
 {
     TestMyWindow (NULL);
     return 0;
diff -urN microwin/src\demos\mwin\mstretch.c microwin-0.90/src\demos\mwin\mstretch.c
--- microwin/src\demos\mwin\mstretch.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\mstretch.c	Mon Aug 30 08:21:40 2010
@@ -68,8 +68,17 @@
 	return 0;
 }
 
-int WINAPI 
-WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
+
+#ifdef WIN32
+int WINAPI MWinMain
+
+#else
+
+int WINAPI WinMain
+
+#endif
+
+	(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
 	int nShowCmd)
 {
 	MSG 	msg;
@@ -77,6 +86,8 @@
 
 	RegisterAppClass();
 	GetWindowRect(GetDesktopWindow(), &rc);
+
+
 
 	/* create penguin windows*/
 	CreateWindowEx(0L, APPCHILD, "", WS_BORDER | WS_VISIBLE,
diff -urN microwin/src\demos\mwin\mterm.c microwin-0.90/src\demos\mwin\mterm.c
--- microwin/src\demos\mwin\mterm.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\mterm.c	Mon Aug 30 08:22:10 2010
@@ -259,7 +259,9 @@
 		CreateAppWindow();
 		return;
 	}
-	fprintf(stderr, "Uncaught signal %d\n", signo);
+
+	DPRINTF("Uncaught signal %d\n", signo);
+
 }
 
 /*
@@ -276,10 +278,13 @@
 	signal(SIGCHLD, ptysignaled);
 	signal(SIGINT, ptysignaled);
 	if ((pid = forkpty(&master, pty_name, NULL, NULL)) == -1) {
-		fprintf(stderr, "No processes\n");
+
+		DPRINTF("No processes\n");
+
 		return -1;
 	}
-fprintf(stderr, "CYGWIN: Opened pty_name %s\n", pty_name);
+    DPRINTF("CYGWIN: Opened pty_name %s\n", pty_name);
+
 	if (!pid) {
 		close(STDIN_FILENO);
 		close(STDOUT_FILENO);
@@ -290,7 +295,7 @@
 		grantpt(master);
 		unlockpt(master);
 		if ((slave = open(pty_name, O_RDWR)) < 0) {
-			fprintf(stderr, "Child: Can't open pty %s\n", pty_name);
+			DPRINTF("Child: Can't open pty %s\n", pty_name);
 			exit(1);
 		}
 		dup2(slave, STDIN_FILENO);
@@ -317,7 +322,7 @@
 	/* opens /dev/ptmx, can't use getpt() as needs nonblocking*/
 	if ((tfd = open("/dev/ptmx", O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0) {
 err:
-		fprintf(stderr, "Can't create pty /dev/ptmx\n");
+		DPRINTF("Can't create pty /dev/ptmx\n");
 		return -1;
 	}
 	signal(SIGCHLD, SIG_DFL);	/* required before grantpt()*/
@@ -327,7 +332,7 @@
 	signal(SIGCHLD, ptysignaled);
 	signal(SIGINT, ptysignaled);
 	if ((pid = fork()) == -1) {
-		fprintf(stderr, "No processes\n");
+		DPRINTF("No processes\n");
 		return -1;
 	}
 	if (!pid) {
@@ -338,7 +343,7 @@
 		
 		setsid();
 		if ((tfd = open(pty_name, O_RDWR)) < 0) {
-			fprintf(stderr, "Child: Can't open pty %s\n", pty_name);
+			DPRINTF("Child: Can't open pty %s\n", pty_name);
 			exit(1);
 		}
 		dup2(tfd, STDIN_FILENO);
@@ -362,19 +367,19 @@
 	char	pty_name[32];
 
 again:
-	sprintf(pty_name, "/dev/ptyp%d", n);
+	DPRINTF(pty_name, "/dev/ptyp%d", n);
 	if ((tfd = open(pty_name, O_RDWR | O_NONBLOCK)) < 0) {
 		if ((errno == EBUSY || errno == EIO) && n < 10) {
 			++n;
 			goto again;
 		}
-		fprintf(stderr, "Can't create pty %s\n", pty_name);
+		DPRINTF("Can't create pty %s\n", pty_name);
 		return -1;
 	}
 	signal(SIGCHLD, ptysignaled);
 	signal(SIGINT, ptysignaled);
 	if ((pid = fork()) == -1) {
-		fprintf(stderr, "No processes\n");
+		DPRINTF("No processes\n");
 		return -1;
 	}
 	if (!pid) {
@@ -386,7 +391,7 @@
 		setsid();
 		pty_name[5] = 't';
 		if ((tfd = open(pty_name, O_RDWR)) < 0) {
-			fprintf(stderr, "Child: Can't open pty %s\n", pty_name);
+			DPRINTF("Child: Can't open pty %s\n", pty_name);
 			exit(1);
 		}
 		dup2(tfd, STDIN_FILENO);
diff -urN microwin/src\demos\mwin\mtest2.c microwin-0.90/src\demos\mwin\mtest2.c
--- microwin/src\demos\mwin\mtest2.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\mtest2.c	Mon Aug 30 08:22:26 2010
@@ -2,9 +2,16 @@
 #include <windows.h>
 
 LRESULT CALLBACK wproc(HWND,UINT,WPARAM,LPARAM);
+#ifdef WIN32
+int WINAPI MWinMain
 
-int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
-                   PSTR szCmdLine, int iCmdShow)
+#else
+
+int WINAPI WinMain
+
+#endif
+
+	(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
 {
         static char szAppName[]="HolaWin";
         HWND hwnd;
@@ -42,8 +49,8 @@
                           szAppName,
                           "Hola",
                           WS_OVERLAPPEDWINDOW | WS_VISIBLE,
-                          CW_USEDEFAULT,
-                          CW_USEDEFAULT,
+                          (r.right - width) >> 1,
+                          (r.bottom - height - 25) >> 1,
                           width,	/* 80, */
                           height,	/* 80, */
                           NULL,
diff -urN microwin/src\demos\mwin\muserfd.c microwin-0.90/src\demos\mwin\muserfd.c
--- microwin/src\demos\mwin\muserfd.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\mwin\muserfd.c	Mon Aug 30 08:24:02 2010
@@ -7,7 +7,7 @@
 #include <sys/types.h>
 #endif
 
-#if RTEMS || __ECOS
+#ifdef HAVE_RAND
 #define  srandom  srand
 #define  random   rand
 #endif
diff -urN microwin/src\demos\nanox\bin2c.c microwin-0.90/src\demos\nanox\bin2c.c
--- microwin/src\demos\nanox\bin2c.c	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\demos\nanox\bin2c.c	Mon Aug 30 08:50:18 2010
@@ -0,0 +1,243 @@
+#include <windows.h>
+#include <stdio.h>
+#include <memory.h>
+#include <stdlib.h>
+
+const char szByteHeader[] = "const unsigned char %s[] =\n{";
+const char szWordHeader[] = "const unsigned short %s[] =\n{";
+const char szLongHeader[] = "const unsigned long %s[] =\n{";
+const char szDefaultTrailer[] = "\n}; /* %s */\n";
+
+const char szSourceHeader[] =
+"/*\n"
+" *  ===== File: %s =====\n"
+" */\n";
+
+#define DEFAULT_WIDTH	16
+#define DEFAULT_HEADER	szByteHeader
+#define DEFAULT_TYPE	1
+
+/*
+ *  ===== OutLine =====
+ *  Output one line of the converted file
+ */
+int OutLine(FILE* finp, FILE* fout, int line, size_t width, int type)
+{
+	size_t col;
+	int b0, b1, b2, b3;
+	long value = 0;
+	const char* format;
+	
+	for (col = 0; col < width; ++col)
+	{
+		switch (type)
+		{
+		case 1:
+		case -1:
+			b0 = fgetc(finp);
+			if (b0 < 0)
+				return -1;
+			value = b0;
+			format = "%3u";
+			break;
+		case 2:
+			b0 = fgetc(finp);
+			if (b0 < 0)
+				return -1;
+			b1 = fgetc(finp);
+			if (b1 < 0)
+				return -1;
+			value = (b1 << 8) | b0;
+			format = "%5u";
+			break;
+		case -2:
+			b0 = fgetc(finp);
+			if (b0 < 0)
+				return -1;
+			b1 = fgetc(finp);
+			if (b1 < 0)
+				return -1;
+			value = (b0 << 8) | b1;
+			format = "%5u";
+			break;
+		case 4:
+			b0 = fgetc(finp);
+			if (b0 < 0)
+				return -1;
+			b1 = fgetc(finp);
+			if (b1 < 0)
+				return -1;
+			b2 = fgetc(finp);
+			if (b2 < 0)
+				return -1;
+			b3 = fgetc(finp);
+			if (b3 < 0)
+				return -1;
+			value = (((((b3 << 8) | b2) << 8) | b1) << 8) | b0;
+			format = "%10u";
+			break;
+		case -4:
+			b0 = fgetc(finp);
+			if (b0 < 0)
+				return -1;
+			b1 = fgetc(finp);
+			if (b1 < 0)
+				return -1;
+			b2 = fgetc(finp);
+			if (b2 < 0)
+				return -1;
+			b3 = fgetc(finp);
+			if (b3 < 0)
+				return -1;
+			value = (((((b0 << 8) | b1) << 8) | b2) << 8) | b3;
+			format = "%10u";
+			break;
+		}
+		/* Output separator between items */
+		if (col == 0)
+		{
+			if (line == 0)
+				fprintf(fout, "\n    ");
+			else
+				fprintf(fout, ",\n    ");
+		}
+		else
+		{
+			fputc(',', fout);
+		}
+		fprintf(fout, format, value);
+	}
+	return 0;
+}
+
+/*   Get (optional) decimal numeric argument */
+int get_num(const char* p, int value)
+{
+	char ch = *p++;
+	if (isdigit(ch))
+	{
+		value = 0;
+		do
+		{
+			value = value * 10 + (ch - '0');
+			ch = *p++;
+		}
+		while (isdigit(ch));
+	}
+	return value;
+}
+
+void BuildFileName(char* szFileName, const char* szInpFile)
+{
+	char* pszDot;
+
+	/* Copy input file name */
+	strcpy(szFileName, szInpFile);
+	/* Overwrite '.'s with '_'s */
+	while ((pszDot = strchr(szFileName, '.')) != NULL)
+	{
+        *pszDot = '_';
+	}
+}
+
+/*
+ *  Simple "C" program to generate initialized "C" structures
+ *      usage: bin2c input output
+ */
+
+int main(int argc, char* argv[])
+{	
+	int result = 0;
+    fprintf(stderr, "bin2c v1.00 (17-Aug-2010)\n");
+
+    if (argc < 2)
+    {
+        fprintf(stderr, "usage: bin2hex [-bwlBWL] {inpfiles}\n");
+    }
+    else
+    {
+        FILE* fout = stdout;
+        FILE* finp = NULL;
+        const char* pszHeader = DEFAULT_HEADER;
+        const char* pszTrailer = szDefaultTrailer;
+        int width = DEFAULT_WIDTH;
+        int type = DEFAULT_TYPE;
+		TCHAR szBaseName[_MAX_PATH];
+		TCHAR szFileName[_MAX_PATH];
+		int line;
+		int arg;
+		for (arg = 1; arg < argc; ++arg)
+		{
+			const char* parm = argv[arg];
+
+			if (parm[0]== '-')
+			{
+				switch (parm[1])
+				{
+				case 'b':
+				case 'B':
+					width = get_num(parm+2, 16);
+					type = 1;
+					pszHeader = szByteHeader;
+					break;
+				case 'w':
+					type = 2;
+					width = get_num(parm + 2, 8);
+					pszHeader = szWordHeader;
+					break;
+				case 'W':
+					type = -2;
+					width = get_num(parm + 2, 8);
+					pszHeader = szWordHeader;
+					break;
+				case 'l':
+					type = 4;
+					width = get_num(parm + 2, 8);
+					pszHeader = szLongHeader;
+					break;
+				case 'L':
+					type = -4;
+					width = get_num(parm + 2, 8);
+					pszHeader = szLongHeader;
+					break;
+				default:
+					fprintf(stderr, "Invalid option!");
+					exit(-1);
+				}
+			}
+			else if (finp == NULL || arg < argc)
+			{
+				/* Open input file */
+				finp = fopen(parm, "rb");
+				if (finp == NULL)
+				{
+					fprintf(stderr, "Error opening %s\n", parm);
+					exit(-1);
+				}
+				/* Build base name */
+				BuildFileName(szBaseName, parm);
+
+				sprintf(szFileName, "%s.c", szBaseName);
+
+				/* Output file header */
+				fprintf(fout, szSourceHeader, szFileName, szBaseName);
+
+				/* Output file header */
+				fprintf(fout, pszHeader, szBaseName, szBaseName);
+				line = 0;        
+				do
+        			/* nothing */;
+				while (OutLine(finp, fout, line++, width, type) >= 0);
+
+				/* Output file header */
+				fprintf(fout, pszTrailer, szBaseName);
+
+				fclose(finp);
+			}
+		} /* for (arg) */
+            
+		/* Close input and output files */
+		fclose(finp);
+    }
+    return result;
+}
diff -urN microwin/src\demos\nanox\dashdemo.c microwin-0.90/src\demos\nanox\dashdemo.c
--- microwin/src\demos\nanox\dashdemo.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\nanox\dashdemo.c	Mon Aug 30 08:50:18 2010
@@ -46,7 +46,7 @@
 	int COLS, ROWS;
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "Cannot open graphics\n");
+		DPRINTF("Cannot open graphics\n");
 		exit(1);
 	}
 
diff -urN microwin/src\demos\nanox\demo.c microwin-0.90/src\demos\nanox\demo.c
--- microwin/src\demos\nanox\demo.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\nanox\demo.c	Mon Aug 30 08:50:18 2010
@@ -66,8 +66,8 @@
 	GR_BITMAP	bitmap2fg[7];	/* bitmaps for second cursor */
 	GR_BITMAP	bitmap2bg[7];
 
-	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+	if (GrOpen() < 0) {
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 
@@ -475,6 +475,6 @@
 void
 errorcatcher(GR_EVENT *ep)
 {
-	printf("nxclient: Error (%s) ", ep->error.name);
-	printf(nxErrorStrings[ep->error.code], ep->error.id);
+	DPRINTF("nxclient: Error (%s) ", ep->error.name);
+	DPRINTF(nxErrorStrings[ep->error.code], ep->error.id);
 }
diff -urN microwin/src\demos\nanox\demo2.c microwin-0.90/src\demos\nanox\demo2.c
--- microwin/src\demos\nanox\demo2.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\nanox\demo2.c	Mon Aug 30 08:50:18 2010
@@ -16,7 +16,7 @@
 	GR_FONT_ID	font;
 
 	if (GrOpen() < 0) {
-		printf("Can't open graphics\n");
+		DPRINTF("Can't open graphics\n");
 		exit(1);
 	}
 
@@ -67,14 +67,14 @@
 			exit(0);
 			break;
 		case GR_EVENT_TYPE_ERROR:
-			printf("\7demo2: Error (%s) ", event.error.name);
-			printf(nxErrorStrings[event.error.code],event.error.id);
+			DPRINTF("\7demo2: Error (%s) ", event.error.name);
+			DPRINTF(nxErrorStrings[event.error.code],event.error.id);
 			break;
 #if 1
 		case GR_EVENT_TYPE_BUTTON_DOWN:
 			GrUnmapWindow(w);
 			GrFlush();
-			sleep(1);
+			GdSleep(1);
 			GrMapWindow(w);
 			break;
 #endif
@@ -89,12 +89,12 @@
 #if 0
 		case GR_EVENT_TYPE_KEY_DOWN:
 			kev = (GR_EVENT_KEYSTROKE *)&event;
-			printf("DOWN %d (%04x) %04x\n",
+			DPRINTF("DOWN %d (%04x) %04x\n",
 				kev->ch, kev->ch, kev->modifiers);
 			break;
 		case GR_EVENT_TYPE_KEY_UP:
 			kev = (GR_EVENT_KEYSTROKE *)&event;
-			printf("UP %d (%04x) %04x\n",
+			DPRINTF("UP %d (%04x) %04x\n",
 				kev->ch, kev->ch, kev->modifiers);
 			break;
 #endif
diff -urN microwin/src\demos\nanox\demo4.c microwin-0.90/src\demos\nanox\demo4.c
--- microwin/src\demos\nanox\demo4.c	Thu Aug 26 19:41:18 2010
+++ microwin-0.90/src\demos\nanox\demo4.c	Mon Aug 30 08:50:18 2010
@@ -31,7 +31,7 @@
 	GR_EVENT	event;		/* current event */
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
diff -urN microwin/src\demos\nanox\demo5.c microwin-0.90/src\demos\nanox\demo5.c
--- microwin/src\demos\nanox\demo5.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\demo5.c	Mon Aug 30 08:50:18 2010
@@ -61,7 +61,7 @@
 	GR_BITMAP	bitmap2bg[7];
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
diff -urN microwin/src\demos\nanox\demo6.c microwin-0.90/src\demos\nanox\demo6.c
--- microwin/src\demos\nanox\demo6.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\demo6.c	Mon Aug 30 08:50:18 2010
@@ -33,7 +33,7 @@
 
 static void errorhandler(GR_EVENT *ep)
 {
-	printf("Error (%s) code %d id %d", ep->error.name, 
+	DPRINTF("Error (%s) code %d id %d", ep->error.name, 
 		ep->error.code, ep->error.id);
 	exit(1);
 }
@@ -44,24 +44,26 @@
 	GR_EVENT event;
 	FILE *infile;
 	int i, o;
-	unsigned char *p;
+	unsigned char *p;
+	char* filename;
 
-	if(argc != 2) {
-		printf("Usage: demo6 <filename.ppm>\n");
-		exit(1);
-	}
-
-	if(!(infile = fopen(argv[1], "r"))) {
-		printf("Couldn't open \"%s\" for reading: %s\n", argv[1],
+	if(argc != 2)
+		filename = "mwlogo.ppm";
+	else
+		filename = argv[1];
+
+#if HAVE_FILEIO
+	if(!(infile = fopen(filename, "rb"))) {
+		DPRINTF("Couldn't open \"%s\" for reading: %s\n", argv[1],
 						strerror(errno));
 		exit(2);
-	}
+	}
 
 	/* Read magic number (P6 = colour, binary encoded PPM file) */
 	if(!fgets(line, 256, infile)) goto truncated;
 	if(line[0] != 'P' || line[1] != '6') {
-		printf("Unsupported PPM type or not a PPM file.\n");
-		printf("Please supply a valid P6 format file (colour, with "
+		DPRINTF("Unsupported PPM type or not a PPM file.\n");
+		DPRINTF("Please supply a valid P6 format file (colour, with "
 			"binary encoding).\n");
 	}
 
@@ -77,7 +79,7 @@
 	if(!fgets(line, 256, infile)) goto truncated;
 	sscanf(line, "%i", &i);
 	if(i != 255) {
-		printf("Truecolour mode only is supported\n");
+		DPRINTF("Truecolour mode only is supported\n");
 		exit(4);
 	}
 
@@ -88,7 +90,7 @@
 
 	/* Allocate the space to store the data whilst it's being loaded */
 	if(!(data = malloc(o))) {
-		printf("Not enough memory to load image\n");
+		DPRINTF("Not enough memory to load image\n");
 		exit(5);
 	}
 
@@ -103,12 +105,13 @@
 
 	/* We don't need the input file anymore so close it */
 	fclose(infile);
+#endif
 
 	/* Register the error handler */
 	GrSetErrorHandler(errorhandler);
 
 	if(GrOpen() < 0) {
-		printf("Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		exit(6);
 	}
 
@@ -160,6 +163,6 @@
 	return 0;
 
 truncated:
-	printf("Error: File appears to be truncated\n");
+	DPRINTF("Error: File appears to be truncated\n");
 	exit(3);
 }
diff -urN microwin/src\demos\nanox\ft2test.c microwin-0.90/src\demos\nanox\ft2test.c
--- microwin/src\demos\nanox\ft2test.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\ft2test.c	Mon Aug 30 08:50:18 2010
@@ -62,7 +62,7 @@
 	GrGetScreenInfo(&sinfo);
 
 	if(!(iid = GrLoadImageFromFile(IMAGE, 0))) {
-		fprintf(stderr, "Failed to load image file \"%s\"\n", IMAGE);
+		DPRINTF("Failed to load image file \"%s\"\n", IMAGE);
 		return;
 	}
 	GrGetImageInfo(iid, &image_info);
@@ -113,7 +113,7 @@
 	int quit = 0;
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
diff -urN microwin/src\demos\nanox\ftdemo.c microwin-0.90/src\demos\nanox\ftdemo.c
--- microwin/src\demos\nanox\ftdemo.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\ftdemo.c	Mon Aug 30 08:50:18 2010
@@ -50,7 +50,7 @@
   GR_WINDOW_ID window;
 
   if (GrOpen() < 0) {
-	fprintf(stderr, "cannot open graphics\n");
+	DPRINTF("cannot open graphics\n");
 	exit(1);
   }
 
@@ -63,7 +63,7 @@
 		GR_EVENT_MASK_CLOSE_REQ | GR_EVENT_MASK_EXPOSURE);
 
   if ((file = fopen("bin/ftdemo.txt", "r")) == NULL) {
-	printf("Can't open text file\n");
+	DPRINTF("Can't open text file\n");
 	return (-1);
   }
 
diff -urN microwin/src\demos\nanox\getselection.c microwin-0.90/src\demos\nanox\getselection.c
--- microwin/src\demos\nanox\getselection.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\getselection.c	Mon Aug 30 08:50:18 2010
@@ -16,32 +16,32 @@
 {
 	GR_EVENT_CLIENT_DATA *ev = &event->clientdata;
 
-	fprintf(stderr, "Got client data packet with serial number %ld for window %d from window %d\n",
+	DPRINTF("Got client data packet with serial number %ld for window %d from window %d\n",
 		ev->serial, ev->wid, ev->rid);
 
 	if(!(data = realloc(data, bytes_received + ev->datalen + 1))) {
-		fprintf(stderr, "Out of memory\n");
+		DPRINTF("Out of memory\n");
 		exit(7);
 	}
 	memcpy(data + bytes_received, ev->data, ev->datalen);
 
-	fprintf(stderr, "Got client data packet with serial number %ld for window %d from window %d\n",
+	DPRINTF("Got client data packet with serial number %ld for window %d from window %d\n",
 		ev->serial, ev->wid, ev->rid);
 
-	fprintf(stderr, "Already received %ld bytes, this packet is %ld bytes, total data length is %ld bytes so ",
+	DPRINTF("Already received %ld bytes, this packet is %ld bytes, total data length is %ld bytes so ",
 		bytes_received, ev->datalen, ev->len);
 
 	bytes_received += ev->datalen;
 	if(bytes_received == ev->len) {
 		data[ev->len] = 0;
-		fprintf(stderr, "we have received all of the data now.\n");
-		fprintf(stderr, "The data in the packet is:\n%s\n", data);
+		DPRINTF("we have received all of the data now.\n");
+		DPRINTF("The data in the packet is:\n%s\n", data);
 		return 1;
 	}
 	else if(bytes_received < ev->len) {
-		fprintf(stderr, "this is not the last data packet.\n");
+		DPRINTF("this is not the last data packet.\n");
 		return 0;
-	} else fprintf(stderr, "we have received too much data (shouldn't happen)\n");
+	} else DPRINTF("we have received too much data (shouldn't happen)\n");
 
 	return 1;
 }
@@ -54,23 +54,23 @@
 	int n = 0, mimetype = -1;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
 	sid = GrGetSelectionOwner(&typelist);
 	if(!sid) {
-		fprintf(stderr, "Clipboard is empty\n");
+		DPRINTF("Clipboard is empty\n");
 		return 2;
 	}
 
 	if(!typelist) {
-		fprintf(stderr, "GrGetSelectionOwner() returned an empty type list for window %d\n", sid);
+		DPRINTF("GrGetSelectionOwner() returned an empty type list for window %d\n", sid);
 		return 3;
 	}
 
-	fprintf(stderr, "Window %d owns the selection\n", sid);
-	fprintf(stderr, "It claims to be able to supply data in the following types:\n%s\n", typelist);
+	DPRINTF("Window %d owns the selection\n", sid);
+	DPRINTF("It claims to be able to supply data in the following types:\n%s\n", typelist);
 
 	p = strtok(typelist, " ");
 	do {
@@ -82,17 +82,17 @@
 	} while((p = strtok(NULL, " ")));
 
 	if(mimetype == -1) {
-		fprintf(stderr, "Type text/plain is not available\n");
+		DPRINTF("Type text/plain is not available\n");
 		return 4;
 	}
 
 	free(typelist);
 
-	fprintf(stderr, "Type text/plain is available, requesting data\n");
+	DPRINTF("Type text/plain is available, requesting data\n");
 
 	wid = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, 1, 1, 0, 0, 0);
 	if(!wid) {
-		fprintf(stderr, "Couldn't get a window\n");
+		DPRINTF("Couldn't get a window\n");
 		return 5;
 	}
 
@@ -112,14 +112,14 @@
 					return 0;
 				break;
 			case GR_EVENT_TYPE_TIMEOUT:
-				fprintf(stderr, "Timed out waiting for data\n");
+				DPRINTF("Timed out waiting for data\n");
 				return 6;
 			default:
 				break;
 		}
 	}
 
-	fprintf(stderr, "getselection: normal exit\n");
+	DPRINTF("getselection: normal exit\n");
 	GrClose();
 	return 0;
 }
diff -urN microwin/src\demos\nanox\ipcclient.c microwin-0.90/src\demos\nanox\ipcclient.c
--- microwin/src\demos\nanox\ipcclient.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\ipcclient.c	Mon Aug 30 08:50:18 2010
@@ -37,13 +37,13 @@
 	GR_WINDOW_ID wid, serverid;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
 	wid = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, 1, 1, 0, 0, 0);
 	if(!wid) {
-		fprintf(stderr, "Couldn't get a window\n");
+		DPRINTF("Couldn't get a window\n");
 		GrClose();
 		return 1;
 	}
@@ -53,11 +53,11 @@
 	if(GrGetWindowProperty(GR_ROOT_WINDOW_ID, "demo_ipc_server", &data)
 			!= sizeof(serverid)) {
 		if(!data) {
-			fprintf(stderr, "Couldn't find server ID\n");
+			DPRINTF("Couldn't find server ID\n");
 			GrClose();
 			return 1;
 		} else {
-			fprintf(stderr, "Server ID property is wrong size\n");
+			DPRINTF("Server ID property is wrong size\n");
 			free(data);
 			GrClose();
 			return 1;
@@ -81,7 +81,7 @@
 				handle_packet(&event);
 				break;
 			default:
-				fprintf(stderr, "Got unknown event %d\n",
+				DPRINTF("Got unknown event %d\n",
 						event.type);
 				break;
 		}
diff -urN microwin/src\demos\nanox\ipcserver.c microwin-0.90/src\demos\nanox\ipcserver.c
--- microwin/src\demos\nanox\ipcserver.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\ipcserver.c	Mon Aug 30 08:50:18 2010
@@ -29,13 +29,13 @@
 	GR_WINDOW_ID wid;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
 	wid = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, 1, 1, 0, 0, 0);
 	if(!wid) {
-		fprintf(stderr, "Couldn't get a window\n");
+		DPRINTF("Couldn't get a window\n");
 		GrClose();
 		return 1;
 	}
@@ -54,7 +54,7 @@
 				handle_packet(wid, &event);
 				break;
 			default:
-				fprintf(stderr, "Got unknown event %d\n",
+				DPRINTF("Got unknown event %d\n",
 						event.type);
 				break;
 		}
diff -urN microwin/src\demos\nanox\landmine.c microwin-0.90/src\demos\nanox\landmine.c
--- microwin/src\demos\nanox\landmine.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\landmine.c	Mon Aug 30 08:50:18 2010
@@ -302,8 +302,10 @@
 static void movetopos(POS newpos);
 static void togglecell(POS pos);
 static void findindex(void);
-static void readgame(char *name);
+#if HAVE_FILEIO
+static int readgame(char *name);
 static GR_BOOL writegame(char *name);
+#endif
 static void gameover(void);
 static void handleevent(GR_EVENT *ep);
 static void doexposure(GR_EVENT_EXPOSURE *ep);
@@ -333,7 +335,7 @@
 		switch (argv[0][1]) {
 			case 'm':
 				if (argc <= 0) {
-					fprintf(stderr, "Missing mine count\n");
+					DPRINTF("Missing mine count\n");
 					exit(1);
 				}
 				argc--;
@@ -344,7 +346,7 @@
 
 			case 's':
 				if (argc <= 0) {
-					fprintf(stderr, "Missing size\n");
+					DPRINTF("Missing size\n");
 					exit(1);
 				}
 				argc--;
@@ -354,7 +356,7 @@
 				break;
 
 			default:
-				fprintf(stderr, "Unknown option \"-%c\"\n",
+				DPRINTF("Unknown option \"-%c\"\n",
 					argv[0][1]);
 				exit(1);
 		}
@@ -364,13 +366,19 @@
 	if (argc > 0)
 		savefile = *argv;
 
-	srand(time(0));
-
-	readgame(savefile);
-
+	srand(GsGetTickCount());
+#if HAVE_FILEIO
+	if (readgame(savefile) < 0)
+#endif
+	{
+		magic = MAGIC;
+		size = SIZE;
+		mines = (size * size * MINEPERCENT) / 100;
+		playing = GR_FALSE;
+	}
 	if (setsize) {
 		if ((newsize < MINSIZE) || (newsize > MAXSIZE)) {
-			fprintf(stderr, "Illegal board size\n");
+			DPRINTF("Illegal board size\n");
 			exit(1);
 		}
 		if (newsize != size) {
@@ -388,7 +396,7 @@
 
 	if (setmines) {
 		if ((newmines <= 0) || ((newmines > (size * size) / 2))) {
-			fprintf(stderr, "Illegal number of mines\n");
+			DPRINTF("Illegal number of mines\n");
 			exit(1);
 		}
 		if (newmines != mines) {
@@ -410,7 +418,7 @@
 	 */
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "Cannot open graphics\n");
+		DPRINTF("Cannot open graphics\n");
 		exit(1);
 	}
 
@@ -533,6 +541,11 @@
 	GrMapWindow(savewid);
 	GrMapWindow(newgamewid);
 
+
+
+	GsRedrawScreen();
+
+
 	if (!playing)
 		newgame();
 
@@ -618,8 +631,10 @@
 	if (bp->wid == quitwid) {
 		GrFillRect(quitwid, xorgc, 0, 0, BUTTONWIDTH, BUTTONHEIGHT);
 		GrFlush();
+#if HAVE_FILEIO
 		if (savefile)
 			writegame(savefile);
+#endif
 		GrClose();
 		exit(0);
 	}
@@ -627,12 +642,14 @@
 	if (bp->wid == savewid) {
 		GrFillRect(savewid, xorgc, 0, 0, BUTTONWIDTH, BUTTONHEIGHT);
 		GrFlush();
+#if HAVE_FILEIO
 		if (savefile == NULL)
 			savefile = SAVEFILE;
 		if (writegame(savefile))
 			write(1, "\007", 1);
 		else
 			delay();
+#endif
 		GrFillRect(savewid, xorgc, 0, 0, BUTTONWIDTH, BUTTONHEIGHT);
 	}
 
@@ -1253,16 +1270,17 @@
 			return;
 		}
 	}
-	fprintf(stderr, "Too many parameters in save file\n");
+	DPRINTF("Too many parameters in save file\n");
 	exit(1);
 }
 
+#if HAVE_FILEIO
 
 /*
  * Read in a saved game if available, otherwise start from scratch.
  * Exits if an error is encountered.
  */
-static void
+static int
 readgame(char *name)
 {
 	int	fd;
@@ -1271,25 +1289,20 @@
 	if (name)
 		fd = open(name, 0);
 
-	if (fd < 0) {
-		magic = MAGIC;
-		size = SIZE;
-		mines = (size * size * MINEPERCENT) / 100;
-		playing = GR_FALSE;
-		return;
-	}
+	if (fd >= 0) {
 
-	if (read(fd, &st, sizeof(st)) != sizeof(st))
-		magic = 0;
-	close(fd);
+		if (read(fd, &st, sizeof(st)) != sizeof(st))
+			magic = 0;
+		close(fd);
 
-	if ((magic != MAGIC) || (size > MAXSIZE)) {
-		fprintf(stderr, "Save file format is incorrect\n");
-		exit(1);
+		if ((magic != MAGIC) || (size > MAXSIZE)) {
+			DPRINTF("Save file format is incorrect\n");
+			exit(1);
+		}
 	}
+	return fd;
 }
 
-
 /*
  * Write the current game to a file.
  * Returns nonzero on an error.
@@ -1313,5 +1326,7 @@
 	close(fd);
 	return GR_FALSE;
 }
+
+#endif
 
 /* END CODE */
diff -urN microwin/src\demos\nanox\launcher.c microwin-0.90/src\demos\nanox\launcher.c
--- microwin/src\demos\nanox\launcher.c	Thu Aug 26 19:41:20 2010
+++ microwin-0.90/src\demos\nanox\launcher.c	Mon Aug 30 08:50:18 2010
@@ -90,7 +90,7 @@
 	void *ret;
 
 	if(!(ret = malloc(size))) {
-		fprintf(stderr, "Out of memory\n");
+		DPRINTF("Out of memory\n");
 		exit(1);
 	}
 
@@ -99,7 +99,7 @@
 
 void usage(void)
 {
-	fprintf(stderr, "Usage: launcher <config-file>\n");
+	DPRINTF("Usage: launcher <config-file>\n");
 	exit(3);
 }
 
@@ -127,7 +127,7 @@
 
 	while(isspace(*p)) p++;
 	if(!*p) {
-		fprintf(stderr, "Premature end of line on line %d of config "
+		DPRINTF("Premature end of line on line %d of config "
 				"file\n", lineno);
 		return 0;
 	}
@@ -160,7 +160,7 @@
 		*p++ = 0;
 		if(!(prog->argv[n] = strdup(pp))) goto nomem;
 		if(++n == (MAX_ARGUMENTS - 1)) {
-			fprintf(stderr, "Too many arguments on line "
+			DPRINTF("Too many arguments on line "
 				"%d of the config file\n", lineno);
 			break; 
 		}
@@ -169,7 +169,7 @@
 	return prog;
 
 nomem:
-	fprintf(stderr, "Out of memory parsing line %d of the config "
+	DPRINTF("Out of memory parsing line %d of the config "
 			"file\n", lineno);
 	return 0;
 }
@@ -181,7 +181,7 @@
 
 	while(isspace(*p)) p++;
 	if(!*p) {
-		fprintf(stderr, "Premature end of line on line %d of config "
+		DPRINTF("Premature end of line on line %d of config "
 				"file\n", lineno);
 		return;
 	}
@@ -202,7 +202,7 @@
 	else if(!strcmp(pp, "BROWN")) props.background = GR_COLOR_BROWN;
 	else if(!strcmp(pp, "GRAY")) props.background = GR_COLOR_GRAY;
 	else {
-		fprintf(stderr, "Invalid colour \"%s\" on line %d of config "
+		DPRINTF("Invalid colour \"%s\" on line %d of config "
 							"file\n", pp, lineno);
 		return;
 	}
@@ -321,13 +321,13 @@
 		}
 		if(!new_litem->iconid) {
 			if(!(new_litem->iconid = GrLoadImageFromFile(icon, 0))){
-				fprintf(stderr, "Couldn't load icon \"%s\"\n",
+				DPRINTF("Couldn't load icon \"%s\"\n",
 									icon);
 			} else {
 				GrGetImageInfo(new_litem->iconid, &imageinfo);
 				if((imageinfo.width != ICON_WIDTH) ||
 					(imageinfo.height != ICON_HEIGHT)) {
-					fprintf(stderr, "Icon \"%s\" is the "
+					DPRINTF("Icon \"%s\" is the "
 					"wrong size (%dx%d instead of %dx%d)"
 					"\n", icon, imageinfo.width,
 					imageinfo.height, ICON_WIDTH,
@@ -355,11 +355,11 @@
 	return;
 
 nomem:
-	fprintf(stderr, "Out of memory\n");
+	DPRINTF("Out of memory\n");
 	exit(1);
 
 premature:
-	fprintf(stderr, "Premature end of line on line %d of config file\n",
+	DPRINTF("Premature end of line on line %d of config file\n",
 								lineno);
 }
 
@@ -370,7 +370,7 @@
 	char *buf = my_malloc(256);
 
 	if(!(fp = fopen(state->config_file, "r"))) {
-		fprintf(stderr, "Couldn't open config file \"%s\"\n",
+		DPRINTF("Couldn't open config file \"%s\"\n",
 							state->config_file);
 		exit(2);
 	}
@@ -395,7 +395,7 @@
 	else state->curssitem = state->ssitems;
 	
 	if(!state->numlitems) {
-		fprintf(stderr, "No valid launcher items in config file\n");
+		DPRINTF("No valid launcher items in config file\n");
 		exit(5);
 	}
 }
@@ -430,7 +430,7 @@
 		i = i->next;
 	}
 
-	fprintf(stderr, "Got exposure event for unknown window %d\n",
+	DPRINTF("Got exposure event for unknown window %d\n",
 							event->wid);
 }
 
@@ -441,7 +441,7 @@
 	if((pid = fork()) == -1) perror("Couldn't fork");
 	else if(!pid) {
 		if(execvp(prog->command, prog->argv) == -1)
-			fprintf(stderr, "Couldn't start \"%s\": %s\n",
+			DPRINTF("Couldn't start \"%s\": %s\n",
 					prog->command, strerror(errno));
 		exit(7);
 	}
@@ -464,7 +464,7 @@
 		i = i->next;
 	}
 
-	fprintf(stderr, "Got mouse event for unknown window %d\n", event->wid);
+	DPRINTF("Got mouse event for unknown window %d\n", event->wid);
 }
 
 void choose_random_screensaver(lstate *state)
@@ -510,7 +510,7 @@
 	}
 
 	if(!state->ssitems) {
-		fprintf(stderr, "Got screensaver activate event with no "
+		DPRINTF("Got screensaver activate event with no "
 				"screensavers defined\n");
 		return;
 	}
@@ -553,7 +553,7 @@
 		case GR_EVENT_TYPE_NONE:
 			break;
 		default:
-			fprintf(stderr, "Got unknown event type %d\n",
+			DPRINTF("Got unknown event type %d\n",
 							state->event.type);
 			break;
 	}
@@ -590,7 +590,7 @@
 	litem *i;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		exit(4);
 	}
 
@@ -632,13 +632,13 @@
 	if(state->window_background_image) {
 		if(!(back_image = GrLoadImageFromFile(
 					state->window_background_image, 0))) {
-			fprintf(stderr, "Couldn't load background image\n");
+			DPRINTF("Couldn't load background image\n");
 		} else {
 			GrGetImageInfo(back_image, &imageinfo);
 			if(!(state->background_pixmap = GrNewPixmap(
 							imageinfo.width,
 						imageinfo.height, NULL))) {
-				fprintf(stderr, "Couldn't allocate pixmap "	
+				DPRINTF("Couldn't allocate pixmap "	
 						"for background image\n");
 			} else {
 				GrDrawImageToFit(state->background_pixmap,
@@ -692,7 +692,7 @@
 	return;
 
 toomany:
-	fprintf(stderr, "Too many items to fit on screen\n");
+	DPRINTF("Too many items to fit on screen\n");
 	exit(6);
 }
 
diff -urN microwin/src\demos\nanox\move.c microwin-0.90/src\demos\nanox\move.c
--- microwin/src\demos\nanox\move.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\move.c	Mon Aug 30 08:50:18 2010
@@ -101,7 +101,7 @@
       GrClose();
       exit(0);
     default:
-      fprintf(stderr, "%d\n", event.type);
+      DPRINTF("%d\n", event.type);
     }
   }
   GrClose();
diff -urN microwin/src\demos\nanox\npanel.c microwin-0.90/src\demos\nanox\npanel.c
--- microwin/src\demos\nanox\npanel.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\npanel.c	Mon Aug 30 08:50:18 2010
@@ -113,7 +113,7 @@
 	for(act = Apps; act->app_id[0] != '\0'; act++, num_apps++);
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
diff -urN microwin/src\demos\nanox\nsaver.c microwin-0.90/src\demos\nanox\nsaver.c
--- microwin/src\demos\nanox\nsaver.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\nsaver.c	Mon Aug 30 08:50:18 2010
@@ -41,14 +41,17 @@
 
 #include <nano-X.h>
 #include <nxcolors.h>
-#include "nsaver.h"
+#include "nsaver.h"
+
+#define M_PI	3.14159265
+#define M_PI_2	(M_PI*2)
 
 void *my_malloc(size_t size)
 {
 	void *ret;
 
 	if(!(ret = malloc(size))) {
-		fprintf(stderr, "Out of memory\n");
+		DPRINTF("Out of memory\n");
 		exit(1);
 	}
 
@@ -1143,7 +1146,7 @@
 	GR_BITMAP cursor = 0;
 
 	if(!GrOpen()) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 3;
 	}
 
@@ -1242,7 +1245,7 @@
 	GR_EVENT_SCREENSAVER *event = &state->event.screensaver;
 
 	if(event->activate != GR_FALSE) {
-		fprintf(stderr, "Got a non-deactivate screensaver event\n");
+		DPRINTF("Got a non-deactivate screensaver event\n");
 		return 0;
 	}
 
@@ -1269,7 +1272,7 @@
 		case GR_EVENT_TYPE_FOCUS_OUT:
 			return 0;
 		default:
-			fprintf(stderr, "Got unknown event type %d\n",
+			DPRINTF("Got unknown event type %d\n",
 							state->event.type);
 			break;
 	}
@@ -1285,7 +1288,7 @@
 	if(argc == 2) {
 		state->saver = atoi(argv[1]) - 1;
 		if((state->saver) < 0 || (state->saver >= NUM_SAVERS)) {
-			fprintf(stderr, "Invalid saver number \"%s\"\n",
+			DPRINTF("Invalid saver number \"%s\"\n",
 								argv[1]);
 			return 2;
 		}
diff -urN microwin/src\demos\nanox\nterm.c microwin-0.90/src\demos\nanox\nterm.c
--- microwin/src\demos\nanox\nterm.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\nterm.c	Mon Aug 30 08:50:18 2010
@@ -54,7 +54,7 @@
 	GR_BITMAP	bitmap1bg[7];
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
@@ -180,7 +180,7 @@
 			n++;
 			goto again;
 		}
-		fprintf(stderr, "Can't create pty %s\n", pty_name);
+		DPRINTF("Can't create pty %s\n", pty_name);
 		return -1;
 	}
 	signal(SIGCHLD, sigchild);
@@ -191,7 +191,7 @@
 #define fork() vfork()
 #endif
 	if ((pid = fork()) == -1) {
-		fprintf(stderr, "No processes\n");
+		DPRINTF("No processes\n");
 		return -1;
 	}
 	if (!pid) {
@@ -203,7 +203,7 @@
 		setsid();
 		pty_name[5] = 't';
 		if ((tfdSlave = open(pty_name, O_RDWR)) < 0) {
-			fprintf(stderr, "Child: Can't open pty %s\n", pty_name);
+			DPRINTF("Child: Can't open pty %s\n", pty_name);
 			exit(1);
 		}
 		dup2(tfdSlave, STDIN_FILENO);
diff -urN microwin/src\demos\nanox\ntetris.c microwin-0.90/src\demos\nanox\ntetris.c
--- microwin/src\demos\nanox\ntetris.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\ntetris.c	Mon Aug 30 08:50:18 2010
@@ -87,7 +87,7 @@
 
 #include "ntetris.h"
 
-#if RTEMS || __ECOS
+#ifdef HAVE_RAND
 #define  srandom  srand
 #define  random   rand
 #endif
@@ -97,9 +97,10 @@
 	void *ret;
 
 	if(!(ret = malloc(size))) {
-		fprintf(stderr, "Out of memory\n");
+		DPRINTF("Out of memory\n");
 		exit(1);
-	}
+	}
+	memset(ret, 0, size);
 
 	return ret;
 }
@@ -109,7 +110,16 @@
 {
 	usleep(ms * 1000);
 }
-#else
+#elif defined(WIN32)
+
+void __stdcall Sleep(unsigned long msec);
+
+void msleep(long ms)
+{
+	Sleep(ms);
+}
+#else
+
 void msleep(long ms)
 {
 	struct timespec req, rem;
@@ -147,7 +157,7 @@
 	fclose(f);
 
 	if(i != 1) {
-		fprintf(stderr, "Couldn't read high score file\n");
+		DPRINTF("Couldn't read high score file\n");
 		n = 0;
 	}
 
@@ -677,7 +687,7 @@
 		case GR_EVENT_TYPE_TIMEOUT:
 			break;
 		default:
-			fprintf(stderr, "Unhandled event type %d\n",
+			DPRINTF("Unhandled event type %d\n",
 							state->event.type);
 			break;
 	}
@@ -728,7 +738,7 @@
 	GR_COORD x = MAIN_WINDOW_X_POSITION;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		exit(1);
 	}
 
@@ -867,7 +877,7 @@
 	state->level = 0;
 	state->running_buttons_mapped = 0;
 
-	srandom(time(0));
+	srandom( GsGetTickCount() );
 
 	choose_new_shape(state);
 	new_game(state);
@@ -899,7 +909,7 @@
 	m = ((state->timeout.tv_usec - t.tv_usec) / 1000);
 	ret = (unsigned long)((1000 * s) + m);
 /*
-	fprintf(stderr, "t.tv_sec = %ld, t.tv_usec = %ld, timeout.tv_sec = "
+	DPRINTF("t.tv_sec = %ld, t.tv_usec = %ld, timeout.tv_sec = "
 		"%ld, timeout.tv_usec = %ld, s = %ld, m = %ld, ret = %ld\n",
 		t.tv_sec, t.tv_usec, state->timeout.tv_sec,	
 		state->timeout.tv_usec, s, m, ret);
@@ -967,7 +977,7 @@
 int main(int argc, char *argv[])
 {
 	nstate *state = my_malloc(sizeof(nstate));
-
+
 	init_game(state);
 	main_game_loop(state);
 
diff -urN microwin/src\demos\nanox\nxcal.c microwin-0.90/src\demos\nanox\nxcal.c
--- microwin/src\demos\nanox\nxcal.c	Thu Aug 26 19:41:22 2010
+++ microwin-0.90/src\demos\nanox\nxcal.c	Mon Aug 30 08:50:18 2010
@@ -301,7 +301,7 @@
 	datafile[0] = 0;
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
diff -urN microwin/src\demos\nanox\nxclock.c microwin-0.90/src\demos\nanox\nxclock.c
--- microwin/src\demos\nanox\nxclock.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\nxclock.c	Mon Aug 30 08:50:18 2010
@@ -59,7 +59,7 @@
 	GR_BITMAP	bitmap1bg[7];
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
@@ -226,14 +226,21 @@
 void
 do_clock(void)
 {
-	struct timeval tv;
-	struct timezone tz;
+	struct timeval tv;
+#ifdef HAVE_TIMEZONE
+	struct timezone tz;
+#endif
 	struct tm * tp;
 	time_t now;
 	int minutes, hour, sec;
-
+
+#ifdef HAVE_TIMEZONE
 	gettimeofday(&tv, &tz);
-	now = tv.tv_sec - (60 * tz.tz_minuteswest);
+	now = tv.tv_sec - (60 * tz.tz_minuteswest);
+#else
+	gettimeofday(&tv);
+	now = tv.tv_sec;
+#endif
 	if (now == then) {
 		return;
 	}
diff -urN microwin/src\demos\nanox\nxev.c microwin-0.90/src\demos\nanox\nxev.c
--- microwin/src\demos\nanox\nxev.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\nxev.c	Mon Aug 30 08:50:18 2010
@@ -96,7 +96,7 @@
 	GR_EVENT	event;		/* current event */
 	
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 	
@@ -166,31 +166,31 @@
 	for (;;) {
 		GrGetNextEvent(&event);
 
-		printf("%s (0x%x)\n", \
+		DPRINTF("%s (0x%x)\n", \
 		       lookupEvent(event.type), event.type);
 		
 		switch(event.type) {
 		  case GR_EVENT_TYPE_EXPOSURE:
 			{
-			  printf("\twid = %d\n", event.exposure.wid);
-			  printf("\t(X, Y) = (%d, %d)\n", \
+			  DPRINTF("\twid = %d\n", event.exposure.wid);
+			  DPRINTF("\t(X, Y) = (%d, %d)\n", \
 			         event.exposure.x, event.exposure.y);
-			  printf("\twidth = %d, height = %d\n", \
+			  DPRINTF("\twidth = %d, height = %d\n", \
 			  	 event.exposure.width, event.exposure.height);
 			}
 			break;
 		  case GR_EVENT_TYPE_BUTTON_DOWN:
 		  case GR_EVENT_TYPE_BUTTON_UP:
 			{
-			  printf("\twid = %d\n", event.button.wid);
-			  printf("\tsub-window id = %d\n", event.button.subwid);
-			  printf("\troot window (X, Y) coordinates = (%d, %d)\n", \
+			  DPRINTF("\twid = %d\n", event.button.wid);
+			  DPRINTF("\tsub-window id = %d\n", event.button.subwid);
+			  DPRINTF("\troot window (X, Y) coordinates = (%d, %d)\n", \
 			         event.button.rootx, event.button.rooty);
-			  printf("\t(X, Y) = (%d, %d)\n", \
+			  DPRINTF("\t(X, Y) = (%d, %d)\n", \
 				 event.button.x, event.button.y);
-			  printf("\tbuttons: %04X, ", event.button.buttons);
-			  printf("changed buttons: %04X\n", event.button.changebuttons);
-			  printf("\tmodifiers: %04X\n", event.button.modifiers);
+			  DPRINTF("\tbuttons: %04X, ", event.button.buttons);
+			  DPRINTF("changed buttons: %04X\n", event.button.changebuttons);
+			  DPRINTF("\tmodifiers: %04X\n", event.button.modifiers);
 			}
 			break;
 		  case GR_EVENT_TYPE_MOUSE_ENTER:
@@ -198,49 +198,49 @@
 		  case GR_EVENT_TYPE_MOUSE_MOTION:
 		  case GR_EVENT_TYPE_MOUSE_POSITION:
 			{
-			  printf("\twid = %d\n", event.mouse.wid);
-			  printf("\tsub-window id = %d\n", event.mouse.subwid);
-			  printf("\troot window (X, Y) coordinates = (%d, %d)\n", \
+			  DPRINTF("\twid = %d\n", event.mouse.wid);
+			  DPRINTF("\tsub-window id = %d\n", event.mouse.subwid);
+			  DPRINTF("\troot window (X, Y) coordinates = (%d, %d)\n", \
 			         event.mouse.rootx, event.mouse.rooty);
-			  printf("\t(X, Y) = (%d, %d)\n", \
+			  DPRINTF("\t(X, Y) = (%d, %d)\n", \
 				 event.mouse.x, event.mouse.y);
-			  printf("\tbuttons: %04X\n", event.mouse.buttons);
-			  printf("\tmodifiers: %04X\n", event.mouse.modifiers);
+			  DPRINTF("\tbuttons: %04X\n", event.mouse.buttons);
+			  DPRINTF("\tmodifiers: %04X\n", event.mouse.modifiers);
 			}
 			break;
 		  case GR_EVENT_TYPE_KEY_DOWN:
 		  case GR_EVENT_TYPE_KEY_UP:
 			{
-			  printf("\twid = %d\n", event.keystroke.wid);
-			  printf("\tsub-window id = %d\n", event.keystroke.subwid);
-			  printf("\troot window (X, Y) coordinates = (%d, %d)\n", \
+			  DPRINTF("\twid = %d\n", event.keystroke.wid);
+			  DPRINTF("\tsub-window id = %d\n", event.keystroke.subwid);
+			  DPRINTF("\troot window (X, Y) coordinates = (%d, %d)\n", \
 			         event.keystroke.rootx, event.keystroke.rooty);
-			  printf("\t(X, Y) = (%d, %d)\n", \
+			  DPRINTF("\t(X, Y) = (%d, %d)\n", \
 				 event.keystroke.x, event.keystroke.y);
-			  printf("\tbuttons: %04X\n", event.keystroke.buttons);
-			  printf("\tmodifiers: %04X\n", event.keystroke.modifiers);
-			  printf("\tUnicode-16 keyvalue: %d, ASCII: %d\n", \
+			  DPRINTF("\tbuttons: %04X\n", event.keystroke.buttons);
+			  DPRINTF("\tmodifiers: %04X\n", event.keystroke.modifiers);
+			  DPRINTF("\tUnicode-16 keyvalue: %d, ASCII: %d\n", \
 				 (int)event.keystroke.ch, event.keystroke.ch);
-			  printf("\tscancode: %02X\n",
+			  DPRINTF("\tscancode: %02X\n",
 				(int)event.keystroke.scancode);
 			}
 			break;
 		  case GR_EVENT_TYPE_FOCUS_IN:
-			printf("\twid = %d\n", event.general.wid);
-			printf("\told focus = %d\n", event.general.otherid);
+			DPRINTF("\twid = %d\n", event.general.wid);
+			DPRINTF("\told focus = %d\n", event.general.otherid);
 			break;
 		  case GR_EVENT_TYPE_FOCUS_OUT:
-			printf("\twid = %d\n", event.general.wid);
-			printf("\tnew focus = %d\n", event.general.otherid);
+			DPRINTF("\twid = %d\n", event.general.wid);
+			DPRINTF("\tnew focus = %d\n", event.general.otherid);
 			break;
 		  case GR_EVENT_TYPE_UPDATE:
 		  case GR_EVENT_TYPE_CHLD_UPDATE:
 			{
-			  printf("\twid = %d\n", event.update.wid);
-			  printf("\tsub-window id = %d\n", event.update.subwid);
-			  printf("\t(X, Y) = (%d, %d)\n", \
+			  DPRINTF("\twid = %d\n", event.update.wid);
+			  DPRINTF("\tsub-window id = %d\n", event.update.subwid);
+			  DPRINTF("\t(X, Y) = (%d, %d)\n", \
 				 event.update.x, event.update.y);
-			  printf("\twidth = %d, height = %d\n", \
+			  DPRINTF("\twidth = %d, height = %d\n", \
 			  	 event.update.width, event.update.height);
 			  {
 				  GR_UPDATE_TYPE u = event.update.utype;
@@ -250,13 +250,13 @@
 					  "<unknown>": \
 					  update_types[u].name;
 
-			  	  printf("\tupdate_type: %s (%d)\n",
+			  	  DPRINTF("\tupdate_type: %s (%d)\n",
 					  p, u);
 			  }
 			}
 			break;
 		  case GR_EVENT_TYPE_TIMEOUT:
-		  	printf("\ttimeout?\n");
+		  	DPRINTF("\ttimeout?\n");
 			break;
 		  case GR_EVENT_TYPE_CLOSE_REQ:
 			GrClose();
diff -urN microwin/src\demos\nanox\nxeyes.c microwin-0.90/src\demos\nanox\nxeyes.c
--- microwin/src\demos\nanox\nxeyes.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\nxeyes.c	Mon Aug 30 08:50:18 2010
@@ -287,12 +287,12 @@
 	nxeyes_state *state;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 1;
 	}
 
 	if(!(state = init())) {
-		fprintf(stderr, "Couldn't allocate state structure\n");
+		DPRINTF("Couldn't allocate state structure\n");
 		return 1;
 	}
 
diff -urN microwin/src\demos\nanox\nxlsclients.c microwin-0.90/src\demos\nanox\nxlsclients.c
--- microwin/src\demos\nanox\nxlsclients.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\nxlsclients.c	Mon Aug 30 08:50:18 2010
@@ -115,7 +115,7 @@
 	GR_WINDOW_INFO info;
 
         if (GrOpen() < 0) {
-                fprintf(stderr, "nxlsclients: cannot open graphics\n");
+                DPRINTF((stderr, "nxlsclients: cannot open graphics\n");
                 exit(1);
         }
 
diff -urN microwin/src\demos\nanox\oneshot.c microwin-0.90/src\demos\nanox\oneshot.c
--- microwin/src\demos\nanox\oneshot.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\oneshot.c	Mon Aug 30 08:50:18 2010
@@ -76,7 +76,7 @@
 	GR_WM_PROPERTIES props;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF((stderr, "Couldn't connect to Nano-X server\n");
 		return -1;
 	}
 
@@ -121,7 +121,7 @@
 			timeout();
 			break;
 		default:
-			fprintf(stderr, "Got unknown event %d\n", ev->type);
+			DPRINTF((stderr, "Got unknown event %d\n", ev->type);
 			break;
 	}
 	return 0;
diff -urN microwin/src\demos\nanox\periodic.c microwin-0.90/src\demos\nanox\periodic.c
--- microwin/src\demos\nanox\periodic.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\periodic.c	Mon Aug 30 08:50:18 2010
@@ -70,7 +70,7 @@
 	GR_WM_PROPERTIES props;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF((stderr, "Couldn't connect to Nano-X server\n");
 		return -1;
 	}
 
@@ -113,7 +113,7 @@
 			timeout();
 			break;
 		default:
-			fprintf(stderr, "Got unknown event %d\n", ev->type);
+			DPRINTF((stderr, "Got unknown event %d\n", ev->type);
 			break;
 	}
 	return 0;
diff -urN microwin/src\demos\nanox\polydemo.c microwin-0.90/src\demos\nanox\polydemo.c
--- microwin/src\demos\nanox\polydemo.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\polydemo.c	Mon Aug 30 08:50:18 2010
@@ -145,7 +145,7 @@
 	GR_WINDOW_ID w;
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 
diff -urN microwin/src\demos\nanox\pressure.c microwin-0.90/src\demos\nanox\pressure.c
--- microwin/src\demos\nanox\pressure.c	Thu Aug 26 19:41:24 2010
+++ microwin-0.90/src\demos\nanox\pressure.c	Mon Aug 30 08:50:18 2010
@@ -69,14 +69,14 @@
 
 	if(argc > 1) {
 		if(argc != 3) {
-			fprintf(stderr, "Usage: %s min_pressure max_pressure\n",
+			DPRINTF("Usage: %s min_pressure max_pressure\n",
 					argv[0]);
 			return -1;
 		}
 		minz = atoi(argv[1]);
 		maxz = atoi(argv[2]);
 		if(minz == 0 || maxz == 0 || minz >= maxz) {
-			fprintf(stderr, "Invalid calibration parameters\n");
+			DPRINTF("Invalid calibration parameters\n");
 			return -1;
 		}
 		min_z = minz;
@@ -84,7 +84,7 @@
 	}
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return -1;
 	}
 
@@ -162,7 +162,7 @@
 		case GR_EVENT_TYPE_BUTTON_UP:
 			break;
 		default:
-			fprintf(stderr, "Got unknown event %d\n", ev->type);
+			DPRINTF("Got unknown event %d\n", ev->type);
 			break;
 	}
 	return 0;
diff -urN microwin/src\demos\nanox\rgndemo.c microwin-0.90/src\demos\nanox\rgndemo.c
--- microwin/src\demos\nanox\rgndemo.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\rgndemo.c	Mon Aug 30 08:50:18 2010
@@ -148,7 +148,7 @@
 	GR_EVENT event;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to the Nano-X server\n");
+		DPRINTF("Couldn't connect to the Nano-X server\n");
 		return 1;
 	}
 
diff -urN microwin/src\demos\nanox\setportrait.c microwin-0.90/src\demos\nanox\setportrait.c
--- microwin/src\demos\nanox\setportrait.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\setportrait.c	Mon Aug 30 08:50:18 2010
@@ -11,7 +11,7 @@
 
 static void usage(void)
 {
-	fprintf(stderr, "Usage: setportrait <none|left|right|down>\n");
+	DPRINTF("Usage: setportrait <none|left|right|down>\n");
 	exit(-1);
 }
 
@@ -28,7 +28,7 @@
 	else usage();
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return -1;
 	}
 
diff -urN microwin/src\demos\nanox\setselection.c microwin-0.90/src\demos\nanox\setselection.c
--- microwin/src\demos\nanox\setselection.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\setselection.c	Mon Aug 30 08:50:18 2010
@@ -21,12 +21,12 @@
 	GR_EVENT_SELECTION_CHANGED *sc;
 
 	if(argc != 2) {
-		fprintf(stderr, "Usage: setselection <text file>\n");
+		DPRINTF("Usage: setselection <text file>\n");
 		return 1;
 	}
 
 	if(!(fp = fopen(argv[1], "r"))) {
-		fprintf(stderr, "Couldn't open text file\n");
+		DPRINTF("Couldn't open text file\n");
 		return 2;
 	}
 
@@ -34,23 +34,23 @@
 		data_len += ret;
 		buf_size = data_len + 65536;
 		if(!(buf = realloc(buf, buf_size))) {
-			fprintf(stderr, "Out of memory\n");
+			DPRINTF("Out of memory\n");
 			return 3;
 		}
 	} while((ret = fread(buf + data_len, 1, 65536, fp)) > 0);
 	if(ret < 0) {
-		fprintf(stderr, "Failed to read text file sucessfully\n");
+		DPRINTF("Failed to read text file sucessfully\n");
 		return 2;
 	}
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 4;
 	}
 
 	wid = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, 1, 1, 0, 0, 0);
 	if(!wid) {
-		fprintf(stderr, "Couldn't get a window\n");
+		DPRINTF("Couldn't get a window\n");
 		return 5;
 	}
 
@@ -63,23 +63,23 @@
 		switch(event.type) {
 			case GR_EVENT_TYPE_CLIENT_DATA_REQ:
 				req = &event.clientdatareq;
-				fprintf(stderr, "Got request with serial number %ld from window %d for mime type %d\n",
+				DPRINTF("Got request with serial number %ld from window %d for mime type %d\n",
 					req->serial, req->rid, req->mimetype);
 				GrSendClientData(wid, req->rid, req->serial, data_len, data_len, buf);
 				break;
 			case GR_EVENT_TYPE_SELECTION_CHANGED:
 				sc = &event.selectionchanged;
 				if(sc->new_owner != wid) {
-					fprintf(stderr, "Lost selection to window %d\n", sc->new_owner);
+					DPRINTF("Lost selection to window %d\n", sc->new_owner);
 					return 0;
 				}
 			default:
-				fprintf(stderr, "event %d recieved\n", event.type);
+				DPRINTF("event %d recieved\n", event.type);
 				break;
 		}
 	}
 
-	fprintf(stderr, "setselection: normal exit\n");
+	DPRINTF("setselection: normal exit\n");
 	GrClose();
 	return 0;
 }
diff -urN microwin/src\demos\nanox\slider.c microwin-0.90/src\demos\nanox\slider.c
--- microwin/src\demos\nanox\slider.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\slider.c	Mon Aug 30 14:17:56 2010
@@ -13,7 +13,7 @@
 #define MWINCLUDECOLORS
 #include "nano-X.h"
 
-#if RTEMS || __ECOS
+#ifdef HAVE_RAND
 #define  srandom  srand
 #define  random   rand
 #endif
@@ -46,12 +46,18 @@
 static	void	RandomiseTiles();
 static	void	MoveTile();
 static	void	DrawTile();
+#undef HAVE_FILEIO
+#define HAVE_FILEIO	0
+#if !HAVE_FILEIO
+#include "slide_bmp.c"
+#endif
 
 int
 main(int argc,char **argv)
 {
+	char* filename;
 	if (GrOpen() < 0) {
-		fprintf(stderr, "cannot open graphics\n");
+		DPRINTF("cannot open graphics\n");
 		exit(1);
 	}
 		
@@ -63,19 +69,24 @@
 
 	if(argc != 2)
 		/* No image specified, use numered tiles */
-		using_image = 0;
-	else {
-		/* need to find out image size.... */
- 		image_addr = malloc(4 * (WIDTH_IN_TILES * tile_width) *
-			(HEIGHT_IN_TILES * tile_height) );
-
- 		image = GrNewPixmap((WIDTH_IN_TILES * tile_width),
- 			(HEIGHT_IN_TILES * tile_height), image_addr);
- 
-		GrDrawImageFromFile(image, gc1, 0, 0,
-			GR_IMAGE_MAX_SIZE, GR_IMAGE_MAX_SIZE, argv[1], 0);
-	}
+		filename = "slidebmp.bmp";
+	else
+		filename = argv[1];
+	/* need to find out image size.... */
+ 	image_addr = malloc(4 * (WIDTH_IN_TILES * tile_width) *
+		(HEIGHT_IN_TILES * tile_height) );
+
+ 	image = GrNewPixmap((WIDTH_IN_TILES * tile_width),
+ 		(HEIGHT_IN_TILES * tile_height), image_addr);
+#if HAVE_FILEIO
+	GrDrawImageFromFile(image, gc1, 0, 0,
+		GR_IMAGE_MAX_SIZE, GR_IMAGE_MAX_SIZE, filename, 0);
+#else
+	GrDrawImageFromBuffer(image, gc1, 0, 0, 
+		GR_IMAGE_MAX_SIZE, GR_IMAGE_MAX_SIZE, &slidebmp_bmp, sizeof(slidebmp_bmp), 0);
 #endif
+
+#endif /* USE_IMAGE */
 	
 	/* calculate size of tile area */
  	calc_width = 10 + (WIDTH_IN_TILES * tile_width);
@@ -85,7 +96,7 @@
 	if (calc_width < 240) calc_width=240;
 	if (calc_height < 320) calc_height=320;
 #endif
-	master = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, calc_width, calc_height, 1, RED, WHITE);
+	master = GrNewWindow(GR_ROOT_WINDOW_ID, 100, 50, calc_width, calc_height, 1, RED, WHITE);
  	buttons = GrNewWindow((GR_WINDOW_ID) master, 5, 5, (calc_width - 5), 35, 1, RED, RED);
 
 	tiles = GrNewWindow((GR_WINDOW_ID) master, (calc_width/2) - (WIDTH_IN_TILES * tile_width /2),
@@ -97,7 +108,7 @@
 	GrMapWindow(tiles);
 
  	/* set random seed */
- 	srandom((int) getpid());
+ 	srandom( GsGetTickCount() );
 
 	RandomiseTiles();
 	
@@ -258,7 +269,6 @@
 			value[xpos][ypos] = 1 + xpos + (WIDTH_IN_TILES * ypos);
 		}
 	}
-return;
 	/* position of 'hole' */
 	xpos = WIDTH_IN_TILES - 1;
 	ypos = HEIGHT_IN_TILES - 1;
diff -urN microwin/src\demos\nanox\snap_jpg.c microwin-0.90/src\demos\nanox\snap_jpg.c
--- microwin/src\demos\nanox\snap_jpg.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\snap_jpg.c	Mon Aug 30 08:50:18 2010
@@ -36,7 +36,7 @@
 
 	fp = fopen(file, "wb");
 	if (!fp) {
-		fprintf(stderr, "Bad file name (error [%s])\n",
+		fprintf(sterr, "Bad file name (error [%s])\n",
 			strerror(errno));
 		return (-1);
 	}
diff -urN microwin/src\demos\nanox\t1demo.c microwin-0.90/src\demos\nanox\t1demo.c
--- microwin/src\demos\nanox\t1demo.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\t1demo.c	Mon Aug 30 08:50:18 2010
@@ -11,12 +11,17 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#if UNIX | DOS_DJGPP
+#if HAVE_TIME
 #include <time.h>
 #endif
 #define MWINCLUDECOLORS
 #include "nano-X.h"
 
+#if HAVE_RAND
+#define  srandom  srand
+#define  random   rand
+#endif
+
 #define CLIP_POLYGON	0	/* =1 for polygonal region test */
 #define HZKBIG5		1	/* =1 for big5 encoding test with HZKFONT*/
 
@@ -81,7 +86,7 @@
 #define FONT5 ""
 #endif
 
-#define RAND(max)	((int) (((float)(max)) * rand() / (RAND_MAX + 1.0)))
+#define RAND(max)	((int) (((float)(max)) * random() / (RAND_MAX + 1.0)))
 
 static char *names[5] = { FONT1, FONT2, FONT3, FONT4, FONT5 };
 
@@ -122,7 +127,9 @@
 #endif
 	GrSetGCRegion(gc, regionid);
 
-	srand(time(0));
+#if HAVE_TIME
+	srandom( GsGetTickCount() );
+#endif
 	while (1) {
 		GR_EVENT event;
 
diff -urN microwin/src\demos\nanox\tsdemo.c microwin-0.90/src\demos\nanox\tsdemo.c
--- microwin/src\demos\nanox\tsdemo.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\tsdemo.c	Mon Aug 30 08:50:18 2010
@@ -129,6 +129,7 @@
 	GrDestroyGC(gc);
 }
 
+#if HAVE_FILEIO
 void
 load_pixmap(void)
 {
@@ -140,6 +141,8 @@
 	GrDestroyGC(gc);
 }
 
+#endif
+
 int
 main(int argc, char **argv)
 {
@@ -151,7 +154,9 @@
 	COLS = 480;
 	ROWS = 300;
 
+#if HAVE_FILEIO
 	load_pixmap();
+#endif
 
 	g_main = GrNewWindowEx(GR_WM_PROPS_APPWINDOW, "tsdemo",
 		    GR_ROOT_WINDOW_ID, 100, 50, COLS - 120, ROWS - 60, GRAY);
diff -urN microwin/src\demos\nanox\tux.c microwin-0.90/src\demos\nanox\tux.c
--- microwin/src\demos\nanox\tux.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\tux.c	Mon Aug 30 08:50:18 2010
@@ -38,7 +38,13 @@
 #include <nxcolors.h>
 #include "tuxmask.h"
 
-#define DEFAULT_TUX_FILE "bin/tux.gif"
+#if !HAVE_FILEIO
+
+#include "tux_gif.c"
+
+#endif
+
+#define DEFAULT_TUX_FILE "tux.gif"
 
 static int button_down = 0, x = 0, y = 0;
 
@@ -55,15 +61,19 @@
 	int x, y;
 
 	if(GrOpen() < 0) {
-		fprintf(stderr, "Couldn't connect to Nano-X server\n");
+		DPRINTF("Couldn't connect to Nano-X server\n");
 		return 0;
 	}
 	GrGetScreenInfo(&sinfo);
 
+#if HAVE_FILEIO
 	if(!(iid = GrLoadImageFromFile(tuxfile, 0))) {
-		fprintf(stderr, "Failed to load image file \"%s\"\n", tuxfile);
+		DPRINTF("Failed to load image file \"%s\"\n", tuxfile);
 		return 0;
 	}
+#else
+	iid = GrLoadImageFromBuffer(tux_gif, sizeof(tux_gif), 0);
+#endif
 	GrGetImageInfo(iid, &iif);
 	pid = GrNewPixmap(iif.width, iif.height, NULL);
 	gc = GrNewGC();
diff -urN microwin/src\demos\nanox\world.c microwin-0.90/src\demos\nanox\world.c
--- microwin/src\demos\nanox\world.c	Thu Aug 26 19:41:26 2010
+++ microwin-0.90/src\demos\nanox\world.c	Mon Aug 30 08:50:18 2010
@@ -20,20 +20,29 @@
 #include <sys/types.h>
 #include <fcntl.h>
 #endif
+
+#ifdef USE_FILEIO
 
-#if LINUX || DOS_DJGPP || defined(__CYGWIN__)
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
+
+#ifndef O_BINARY
+#define O_BINARY 	0
+#endif
+
+#else
+
+#include "world_map.c"
+
 #endif
 
-#ifndef O_BINARY
-#define O_BINARY 	0
-#endif
 
 #if DOS_DJGPP || __ECOS
 #define	MAPFILE	"/world.map"
+#elif defined(WIN32)
+#define	MAPFILE	"world.map"
 #else
 #define	MAPFILE	"demos/nanox/world.map"		/* was /usr/lib*/
 #endif
@@ -175,7 +184,7 @@
 	GR_WM_PROPERTIES props;
 
 	if (GrOpen() < 0) {
-		fprintf(stderr, "Cannot open graphics\n");
+		DPRINTF("Cannot open graphics\n");
 		exit(1);
 	}
 
@@ -409,6 +418,7 @@
 			exit(0);
 
 		case 't':		/* redraw total map */
+		case 'T':
 			Longitude = ITOF(0);
 			Latitude = ITOF(0);
 			setzoom(ITOF(1));
@@ -537,7 +547,6 @@
 load(char *fn)
 {
 	register DBPOINT	*pp;
-	DBPOINT		*pend;
 	FLOAT		x, y, LonPrv, LatPrv;
 	long		oldlong = 0L;
 	GR_COORD	xnew, ynew;
@@ -547,96 +556,174 @@
 	GR_BOOL		newseg = GR_FALSE;
 	GR_COLOR	oldcolor;
 	GR_COLOR	newcolor;
-	int		n;
-	int		fh;
-	DBPOINT		p[PCount];
-
+
 	LonPrv = ITOF(0);
 	LatPrv = ITOF(0);
 	oldcolor = -1;
 	is_out = GR_FALSE;
 	was_out = GR_FALSE;
 
-	fh = open(fn, O_BINARY | O_RDONLY);
-	if (fh < 0) {
-		GrClose();
-		fprintf(stderr, "Cannot open %s\n", fn);
-		exit(1);
-	}
-
-	while ((n = read(fh, p, PCount * POINTSize)) > 0) {
-		for (pp = p,pend = p + n/POINTSize; pp < pend; pp++)
-		{
-			DBPOINT_CONVERT(pp);
-			/* do displacement */
-			x = ITOF(pp->Lon) - Longitude;
-			y = ITOF(pp->Lat) - Latitude;
-
-			/* wrap around for East-West */
-			if (x < -HSPAN)
-				x += WSPAN;
-			if (x > HSPAN)
-				x -= WSPAN;
-
-			if (pp->Code > 5) {
-				newcolor = code_colors[pp->Code / 1000];
-				if (newcolor != oldcolor) {
-					oldcolor = newcolor;
-					GrSetGCForeground(mapgc, oldcolor);
-				}
-				newseg = GR_TRUE;
-			}
-
-			if (oldcolor == BLACK)
-				goto go_on;
-
-			/* ignore points outside magnified area */
-			if ((x < -longradius || x > longradius ||
-				y < -latradius || y > latradius))
-			{
-				is_out = 1;
-				if (was_out) {		/* out to out */
+#if USE_FILEIO
+	{
+		int	fh = open(fn, O_BINARY);
+		if (fh >= 0) {
+			DBPOINT		p[PCount];
+			DBPOINT		*pend;
+			int		n;
+
+			while ((n = read(fh, p, PCount * POINTSize)) > 0) {
+				for (pp = p,pend = p + n/POINTSize; pp < pend; pp++)
+				{
+					DBPOINT_CONVERT(pp);
+					/* do displacement */
+					x = ITOF(pp->Lon) - Longitude;
+					y = ITOF(pp->Lat) - Latitude;
+
+					/* wrap around for East-West */
+					if (x < -HSPAN)
+						x += WSPAN;
+					if (x > HSPAN)
+						x -= WSPAN;
+
+					if (pp->Code > 5) {
+						newcolor = code_colors[pp->Code / 1000];
+						if (newcolor != oldcolor) {
+							oldcolor = newcolor;
+							GrSetGCForeground(mapgc, oldcolor);
+						}
+						newseg = GR_TRUE;
+					}
+
+					if (oldcolor == BLACK)
+						goto go_on;
+
+					/* ignore points outside magnified area */
+					if ((x < -longradius || x > longradius ||
+						y < -latradius || y > latradius))
+					{
+						is_out = 1;
+						if (was_out) {		/* out to out */
+							LonPrv = x;
+							LatPrv = y;
+							goto go_on;
+						}
+
+						/* in to out */
+						xold = mapxorig + FTOI(FFMUL(LonPrv, X_Scale)) / 60;
+						yold = mapyorig - FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
+					} else {			/* out to in */
+						is_out = 0;
+						if (was_out) {
+							xold = mapxorig +
+								FTOI(FFMUL(LonPrv, X_Scale)) / 60;
+							yold = mapyorig -
+								FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
+						}
+						/* in to in */
+					}
 					LonPrv = x;
 					LatPrv = y;
-					goto go_on;
-				}
 
-				/* in to out */
-				xold = mapxorig + FTOI(FFMUL(LonPrv, X_Scale)) / 60;
-				yold = mapyorig - FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
-			} else {			/* out to in */
-				is_out = 0;
-				if (was_out) {
-					xold = mapxorig +
-						FTOI(FFMUL(LonPrv, X_Scale)) / 60;
-					yold = mapyorig -
-						FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
+					/* scale points w/in area to interlace screen */
+					xnew = mapxorig + FTOI(FFMUL(x, X_Scale)) / 60;
+					ynew = mapyorig - FTOI(FFMUL(y, Y_Scale)) / 60;
+
+					/* if new segment, move to place */
+					if (newseg || ABS(oldlong - pp->Lon) > 180*60) {
+						xold = xnew;
+						yold = ynew;
+					}
+					oldlong = pp->Lon;
+
+					GrLine(mapwid, mapgc, xold, yold, xnew, ynew);
+					xold = xnew;
+					yold = ynew;
+go_on:
+					was_out = is_out;
+					newseg = GR_FALSE;
 				}
-				/* in to in */
 			}
-			LonPrv = x;
-			LatPrv = y;
-
-			/* scale points w/in area to interlace screen */
-			xnew = mapxorig + FTOI(FFMUL(x, X_Scale)) / 60;
-			ynew = mapyorig - FTOI(FFMUL(y, Y_Scale)) / 60;
-
-			/* if new segment, move to place */
-			if (newseg || ABS(oldlong - pp->Lon) > 180*60) {
-				xold = xnew;
-				yold = ynew;
-			}
-			oldlong = pp->Lon;
-
-			GrLine(mapwid, mapgc, xold, yold, xnew, ynew);
-			xold = xnew;
-			yold = ynew;
-go_on:
-			was_out = is_out;
-			newseg = GR_FALSE;
-		}
-	}
-	close(fh);
+			close(fh);
+		}
+	}
+#else
+	{
+		unsigned int pcount = sizeof(world_map)/sizeof(DBPOINT);
+		unsigned int u;
+
+		for (u = 0; u < pcount; ++u)
+		{
+			pp = (DBPOINT*) &world_map[u * 3];
+			DBPOINT_CONVERT(pp);
+			/* do displacement */
+			x = ITOF(pp->Lon) - Longitude;
+			y = ITOF(pp->Lat) - Latitude;
+
+			/* wrap around for East-West */
+			if (x < -HSPAN)
+				x += WSPAN;
+			if (x > HSPAN)
+				x -= WSPAN;
+
+			if (pp->Code > 5) {
+				newcolor = code_colors[pp->Code / 1000];
+				if (newcolor != oldcolor) {
+					oldcolor = newcolor;
+					GrSetGCForeground(mapgc, oldcolor);
+				}
+				newseg = GR_TRUE;
+			}
+
+			if (oldcolor == BLACK)
+				goto go_on;
+
+			/* ignore points outside magnified area */
+			if ((x < -longradius || x > longradius ||
+				y < -latradius || y > latradius))
+			{
+				is_out = 1;
+				if (was_out) {		/* out to out */
+					LonPrv = x;
+					LatPrv = y;
+					goto go_on;
+				}
+
+				/* in to out */
+				xold = mapxorig + FTOI(FFMUL(LonPrv, X_Scale)) / 60;
+				yold = mapyorig - FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
+			} else {			/* out to in */
+				is_out = 0;
+				if (was_out) {
+					xold = mapxorig +
+						FTOI(FFMUL(LonPrv, X_Scale)) / 60;
+					yold = mapyorig -
+						FTOI(FFMUL(LatPrv, Y_Scale)) / 60;
+				}
+				/* in to in */
+			}
+			LonPrv = x;
+			LatPrv = y;
+
+			/* scale points w/in area to interlace screen */
+			xnew = mapxorig + FTOI(FFMUL(x, X_Scale)) / 60;
+			ynew = mapyorig - FTOI(FFMUL(y, Y_Scale)) / 60;
+
+			/* if new segment, move to place */
+			if (newseg || ABS(oldlong - pp->Lon) > 180*60) {
+				xold = xnew;
+				yold = ynew;
+			}
+			oldlong = pp->Lon;
+
+			GrLine(mapwid, mapgc, xold, yold, xnew, ynew);
+			xold = xnew;
+			yold = ynew;
+	go_on:
+			was_out = is_out;
+			newseg = GR_FALSE;
+		}
+	}
+#endif
 }
 
 /* END CODE */
diff -urN microwin/src\demos\tuxchess\images.c microwin-0.90/src\demos\tuxchess\images.c
--- microwin/src\demos\tuxchess\images.c	Thu Aug 26 19:41:34 2010
+++ microwin-0.90/src\demos\tuxchess\images.c	Mon Aug 30 08:49:42 2010
@@ -3,7 +3,13 @@
 #include <string.h>
 #include "nano-X.h"
 
-#define IMAGE_PATH "demos/tuxchess/images"
+#if HAVE_FILEIO
+	#define IMAGE_PATH "demos/tuxchess/images/"
+#else
+	#include "images/board.c"
+	#include "images/white.c"
+	#include "images/black.c"
+#endif
 
 extern GR_IMAGE_ID     board_image_id;
 extern GR_IMAGE_INFO   board_info;
@@ -56,150 +62,185 @@
 extern GR_IMAGE_ID     b_k_image_id;   /* black king */
 extern GR_IMAGE_INFO   b_k_info;
 extern int b_k_w,b_k_h;
-                 
+
+#define GIF_FILE(i)		i, sizeof(i)
                                                 
 int load_images(void)
 {
+#if HAVE_FILEIO
 	char buf[128];
-
-	sprintf(buf,"%s/board.gif",IMAGE_PATH);
-        if (!(board_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load board image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(board_image_id, &board_info);
-        board_w = board_info.width;
-        board_h = board_info.height;
- 
-	/* ****************/
-	sprintf(buf,"%s/w_p.gif",IMAGE_PATH);
-        if (!(w_p_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white pawn image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_p_image_id, &w_p_info);
-        w_p_w = w_p_info.width;
-        w_p_h = w_p_info.height;
- 
-	/* ****************/
-	sprintf(buf,"%s/w_n.gif",IMAGE_PATH);
-        if (!(w_n_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white knight image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_n_image_id, &w_n_info);
-        w_n_w = w_n_info.width;
-        w_n_h = w_n_info.height;
-
- 
-	/* ****************/
-	sprintf(buf,"%s/w_b.gif",IMAGE_PATH);
-        if (!(w_b_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white bishop image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_b_image_id, &w_b_info);
-        w_b_w = w_b_info.width;
-        w_b_h = w_b_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/w_r.gif",IMAGE_PATH);
-        if (!(w_r_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white rook image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_r_image_id, &w_r_info);
-        w_r_w = w_r_info.width;
-        w_r_h = w_r_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/w_k.gif",IMAGE_PATH);
-        if (!(w_k_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white king image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_k_image_id, &w_k_info);
-        w_k_w = w_k_info.width;
-        w_k_h = w_k_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/w_q.gif",IMAGE_PATH);
-        if (!(w_q_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load white queen image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(w_q_image_id, &w_q_info);
-        w_q_w = w_q_info.width;
-        w_q_h = w_q_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/b_p.gif",IMAGE_PATH);
-        if (!(b_p_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black pawn image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_p_image_id, &b_p_info);
-        b_p_w = b_p_info.width;
-        b_p_h = b_p_info.height;
- 
-	/* ****************/
-	sprintf(buf,"%s/b_n.gif",IMAGE_PATH);
-        if (!(b_n_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black knight image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_n_image_id, &b_n_info);
-        b_n_w = b_n_info.width;
-        b_n_h = b_n_info.height;
-
- 
-	/* ****************/
-	sprintf(buf,"%s/b_b.gif",IMAGE_PATH);
-        if (!(b_b_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black bishop image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_b_image_id, &b_b_info);
-        b_b_w = b_b_info.width;
-        b_b_h = b_b_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/b_r.gif",IMAGE_PATH);
-        if (!(b_r_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black rook image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_r_image_id, &b_r_info);
-        b_r_w = b_r_info.width;
-        b_r_h = b_r_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/b_k.gif",IMAGE_PATH);
-        if (!(b_k_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black king image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_k_image_id, &b_k_info);
-        b_k_w = b_k_info.width;
-        b_k_h = b_k_info.height;
- 
- 
-	/* ****************/
-	sprintf(buf,"%s/b_q.gif",IMAGE_PATH);
-        if (!(b_q_image_id = GrLoadImageFromFile(buf, 0))) {
-                fprintf(stderr, "Can't load black queen image file\n");
-                exit(-1);
-        }
-        GrGetImageInfo(b_q_image_id, &b_q_info);
-        b_q_w = b_q_info.width;
-        b_q_h = b_q_info.height;
- 
+	
+	sprintf(buf,"%sboard.gif",IMAGE_PATH);
+	if (!(board_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load board image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_p.gif",IMAGE_PATH);
+	if (!(w_p_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white pawn image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_n.gif",IMAGE_PATH);
+	if (!(w_n_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white knight image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_b.gif",IMAGE_PATH);
+	if (!(w_b_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white bishop image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_r.gif",IMAGE_PATH);
+	if (!(w_r_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white rook image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_k.gif",IMAGE_PATH);
+	if (!(w_k_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white king image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sw_q.gif",IMAGE_PATH);
+	if (!(w_q_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load white queen image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_p.gif",IMAGE_PATH);
+	if (!(b_p_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black pawn image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_n.gif",IMAGE_PATH);
+	if (!(b_n_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black knight image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_b.gif",IMAGE_PATH);
+	if (!(b_b_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black bishop image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_r.gif",IMAGE_PATH);
+	if (!(b_r_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black rook image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_k.gif",IMAGE_PATH);
+	if (!(b_k_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black king image file\n");
+		exit(-1);
+	}
+	/* ****************/
+	sprintf(buf,"%sb_q.gif",IMAGE_PATH);
+	if (!(b_q_image_id = GrLoadImageFromFile(buf, 0))) {
+		DPRINTF("Can't load black queen image file\n");
+		exit(-1);
+	}
+#else
+	if (!(board_image_id = GrLoadImageFromBuffer(GIF_FILE(board_gif), 0))) {
+		DPRINTF("Can't load board image file\n");
+		exit(-1);
+	}
+	if (!(w_p_image_id = GrLoadImageFromBuffer(GIF_FILE(w_p_gif), 0))) {
+		DPRINTF("Can't load white pawn image file\n");
+		exit(-1);
+	}
+	if (!(w_n_image_id = GrLoadImageFromBuffer(GIF_FILE(w_n_gif), 0))) {
+		DPRINTF("Can't load white knight image file\n");
+		exit(-1);
+	}
+	if (!(w_b_image_id = GrLoadImageFromBuffer(GIF_FILE(w_b_gif), 0))) {
+		DPRINTF("Can't load white bishop image file\n");
+		exit(-1);
+		
+	}
+	if (!(w_r_image_id = GrLoadImageFromBuffer(GIF_FILE(w_r_gif), 0))) {
+		DPRINTF("Can't load white rook image file\n");
+		exit(-1);
+	}
+	if (!(w_k_image_id = GrLoadImageFromBuffer(GIF_FILE(w_k_gif), 0))) {
+		DPRINTF("Can't load white king image file\n");
+		exit(-1);
+	}
+	if (!(w_q_image_id = GrLoadImageFromBuffer(GIF_FILE(w_q_gif), 0))) {
+		DPRINTF("Can't load white queen image file\n");
+		exit(-1);
+	}
+	if (!(b_p_image_id = GrLoadImageFromBuffer(GIF_FILE(b_p_gif), 0))) {
+		DPRINTF("Can't load black pawn image file\n");
+		exit(-1);
+	}
+	if (!(b_n_image_id = GrLoadImageFromBuffer(GIF_FILE(b_n_gif), 0))) {
+		DPRINTF("Can't load black knight image file\n");
+		exit(-1);
+	}
+	if (!(b_b_image_id = GrLoadImageFromBuffer(GIF_FILE(b_b_gif), 0))) {
+		DPRINTF("Can't load black bishop image file\n");
+		exit(-1);
+	}
+	if (!(b_r_image_id = GrLoadImageFromBuffer(GIF_FILE(b_r_gif), 0))) {
+		DPRINTF("Can't load black rook image file\n");
+		exit(-1);
+	}
+	if (!(b_k_image_id = GrLoadImageFromBuffer(GIF_FILE(b_k_gif), 0))) {
+		DPRINTF("Can't load black king image file\n");
+		exit(-1);
+	}
+	if (!(b_q_image_id = GrLoadImageFromBuffer(GIF_FILE(b_q_gif), 0))) {
+		DPRINTF("Can't load black queen image file\n");
+		exit(-1);
+	}
+#endif
+	GrGetImageInfo(board_image_id, &board_info);
+	board_w = board_info.width;
+	board_h = board_info.height;
+	GrGetImageInfo(w_p_image_id, &w_p_info);
+	w_p_w = w_p_info.width;
+	w_p_h = w_p_info.height;
+	GrGetImageInfo(w_n_image_id, &w_n_info);
+	w_n_w = w_n_info.width;
+	w_n_h = w_n_info.height;
+	GrGetImageInfo(w_b_image_id, &w_b_info);
+	w_b_w = w_b_info.width;
+	w_b_h = w_b_info.height;
+	GrGetImageInfo(w_r_image_id, &w_r_info);
+	w_r_w = w_r_info.width;
+	w_r_h = w_r_info.height;
+	GrGetImageInfo(w_k_image_id, &w_k_info);
+	w_k_w = w_k_info.width;
+	w_k_h = w_k_info.height;
+	GrGetImageInfo(w_q_image_id, &w_q_info);
+	w_q_w = w_q_info.width;
+	w_q_h = w_q_info.height;
+	GrGetImageInfo(b_p_image_id, &b_p_info);
+	b_p_w = b_p_info.width;
+	b_p_h = b_p_info.height;
+	GrGetImageInfo(b_n_image_id, &b_n_info);
+	b_n_w = b_n_info.width;
+	b_n_h = b_n_info.height;
+	GrGetImageInfo(b_b_image_id, &b_b_info);
+	b_b_w = b_b_info.width;
+	b_b_h = b_b_info.height;
+	GrGetImageInfo(b_r_image_id, &b_r_info);
+	b_r_w = b_r_info.width;
+	b_r_h = b_r_info.height;
+	GrGetImageInfo(b_k_image_id, &b_k_info);
+	b_k_w = b_k_info.width;
+	b_k_h = b_k_info.height;
+	GrGetImageInfo(b_q_image_id, &b_q_info);
+	b_q_w = b_q_info.width;
+	b_q_h = b_q_info.height;
 	return(0);
 }
 
diff -urN microwin/src\demos\tuxchess\main.c microwin-0.90/src\demos\tuxchess\main.c
--- microwin/src\demos\tuxchess\main.c	Thu Aug 26 19:41:36 2010
+++ microwin-0.90/src\demos\tuxchess\main.c	Mon Aug 30 08:36:00 2010
@@ -7,11 +7,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#if RTEMS
-#include <time.h>
-#else
-#include <sys/timeb.h>
-#endif
 #include "defs.h"
 #include "data.h"
 #include "protos.h"
@@ -33,25 +28,30 @@
         short yoffset;
         short height;
         struct keycolumn columns[9];
-};
+};
+
+#define SQSIZE	49
+
+#define SX(x)	((x)*SQSIZE)		/* Square X */
+#define SY(y)	((y)*SQSIZE)		/* Square Y */
 
 struct keyrow keyrows[8] = {
-        {0, 49, 
-         {{0,0}, {49,1}, {98,2}, {147,3}, {196,4}, {245,5}, {294,6}, {343,7}, {999,-1}}},
-        {49, 49, 
-         {{0,8}, {49,9}, {98,10}, {147,11}, {196,12}, {245,13}, {294,14}, {343,15}, {999,-1}}},
-        {98, 49, 
-         {{0,16}, {49,17}, {98,18}, {147,19}, {196,20}, {245,21}, {294,22}, {343,23}, {999,-1}} },
-        {147, 49, 
-         {{0,24}, {49,25}, {98,26}, {147,27}, {196,28}, {245,29}, {294,30}, {343,31}, {999,-1}}},
-        {196, 49, 
-         {{0,32}, {49,33}, {98,34}, {147,35}, {196,36}, {245,37}, {294,38}, {343,39}, {999,-1}}},
-        {245, 49, 
-         {{0,40}, {49,41}, {98,42}, {147,43}, {196,44}, {245,45}, {294,46}, {343,47}, {999,-1}}},
-        {294, 49, 
-         {{0,48}, {49,49}, {98,50}, {147,51}, {196,52}, {245,53}, {294,54}, {343,55}, {999,-1}}},
-        {343, 49, 
-         {{0,56}, {49,57}, {98,58}, {147,59}, {196,60}, {245,61}, {294,62}, {343,63}, {999,-1}}}
+        {SY(0), SY(1), 
+         {{SX(0),0}, {SX(1),1}, {SX(2),2}, {SX(3),3}, {SX(4),4}, {SX(5),5}, {SX(6),6}, {SX(7),7}, {999,-1}}},
+        {SY(1), SY(1), 
+         {{SX(0),8}, {SX(1),9}, {SX(2),10}, {SX(3),11}, {SX(4),12}, {SX(5),13}, {SX(6),14}, {SX(7),15}, {999,-1}}},
+        {SY(2), SY(1), 
+         {{SX(0),16}, {SX(1),17}, {SX(2),18}, {SX(3),19}, {SX(4),20}, {SX(5),21}, {SX(6),22}, {SX(7),23}, {999,-1}} },
+        {SY(3), SY(1), 
+         {{SX(0),24}, {SX(1),25}, {SX(2),26}, {SX(3),27}, {SX(4),28}, {SX(5),29}, {SX(6),30}, {SX(7),31}, {999,-1}}},
+        {SY(4), SY(1), 
+         {{SX(0),32}, {SX(1),33}, {SX(2),34}, {SX(3),35}, {SX(4),36}, {SX(5),37}, {SX(6),38}, {SX(7),39}, {999,-1}}},
+        {SY(5), SY(1), 
+         {{SX(0),40}, {SX(1),41}, {SX(2),42}, {SX(3),43}, {SX(4),44}, {SX(5),45}, {SX(6),46}, {SX(7),47}, {999,-1}}},
+        {SY(6), SY(1), 
+         {{SX(0),48}, {SX(1),49}, {SX(2),50}, {SX(3),51}, {SX(4),52}, {SX(5),53}, {SX(6),54}, {SX(7),55}, {999,-1}}},
+        {SY(7), SY(1), 
+         {{SX(0),56}, {SX(1),57}, {SX(2),58}, {SX(3),59}, {SX(4),60}, {SX(5),61}, {SX(6),62}, {SX(7),63}, {999,-1}}}
 };
 
 static char *board_position[SCANCODES] = {
@@ -133,28 +133,6 @@
 BOOL ftime_ok = FALSE;  /* does ftime return milliseconds? */
 
 /* ***********************************************************/
-/* get_ms() returns the milliseconds elapsed since midnight,
-   January 1, 1970.
-*/
-int get_ms(void)
-{
-#if RTEMS
-	struct timespec tp;
-
-	clock_gettime( CLOCK_REALTIME, &tp );
-	ftime_ok = TRUE;
-	return (tp.tv_sec * 1000) + (tp.tv_nsec / 1000000);
-#else
-	struct timeb timebuffer;
-	ftime(&timebuffer);
-	if (timebuffer.millitm != 0)
-		ftime_ok = TRUE;
-	return (timebuffer.time * 1000) + timebuffer.millitm;
-#endif
-}
-
- 
-/* ***********************************************************/
 static void gprintf(char s[])
 {
 	static char lasttext[128];
@@ -219,7 +197,7 @@
 		    y < keyrows[row].yoffset+keyrows[row].height) {
                         for (column = 0; column < 8; column++) {
                                 if (keyrows[row].columns[column].xoffset == 999) {
-                                        fprintf(stderr, "off end of row\n");
+                                        DPRINTF("off end of row\n");
                                         return;
                                 }
                                 if (x < keyrows[row].columns[column + 1].xoffset) {
@@ -230,32 +208,34 @@
                         }
                 }
         }
-        fprintf(stderr, "off bottom\n");
-}
+        DPRINTF("off bottom\n");
+}
 
-
-/* ***********************************************************/
+/* ***********************************************************/
+#define XOFF	50
+#define YOFF	20
+
 int main(int argc, char* argv[])
 {
         GR_EVENT event;
 	GR_WM_PROPERTIES props;
 
-	int computer_side;
+	int computer_side;
 	char s[256];
 	int i;
 	BOOL found;
 	char temp[50];	
 
         if (GrOpen() < 0) {
-                fprintf(stderr, "tuxchess: cannot open graphics\n");
+                DPRINTF("tuxchess: cannot open graphics\n");
                 exit(1);
         }
 
 	load_images();
 
-        master = GrNewWindow(GR_ROOT_WINDOW_ID, 0, 0, BM_WIDTH, BM_HEIGHT, 0, WHITE, WHITE);
-        board = GrNewWindow((GR_WINDOW_ID) master, 0, 0, 394, 394, 0, WHITE, WHITE);
-        text = GrNewWindow((GR_WINDOW_ID) master, 0, 393, 394, 20, 0, WHITE, BLACK); 
+        master = GrNewWindow(GR_ROOT_WINDOW_ID, XOFF, YOFF, BM_WIDTH, BM_HEIGHT, 0, WHITE, BLACK);
+        board = GrNewWindow((GR_WINDOW_ID) master, 0, 0, BM_WIDTH, BM_WIDTH, 0, WHITE, BLACK);
+        text = GrNewWindow((GR_WINDOW_ID) master, 0, BM_WIDTH-1, BM_WIDTH, 20, 0, WHITE, BLACK); 
 
         GrSelectEvents(master, GR_EVENT_MASK_CLOSE_REQ | GR_EVENT_MASK_EXPOSURE | GR_EVENT_MASK_BUTTON_DOWN);
 
@@ -275,35 +255,43 @@
 	gen();
 	max_time = 1 << 25;
 	max_depth = 4;
-
-	if (argc > 1)
-		computer_side = side;	/* computer plays white */
+
+	if (argc > 1)
+	{
+		computer_side = side;	/* computer plays white */
+	}
 	else
 	{
 		computer_side = EMPTY;	/* human plays white */
 		gprintf("Make a move...");
-	}
-
+	}
         for (;;) 
-	{
-
-		if (side == computer_side) 
+	{
+#if EMBEDDED
+		computer_side = side;
+		GsSelect(1);
+#endif
+		if (side == computer_side) 
 		{
 			/* think about the move and make it */
 			think(0);
 			if (!pv[0][0].u) {
 				gprintf("No legal moves");
-				computer_side = EMPTY;
+				computer_side = EMPTY;
+#if EMBEDDED
+				print_result();
+#endif
 				continue;
 			}
 			
-			sprintf(temp,"Computer's move: %s\n", move_str(pv[0][0].b));
+			sprintf(temp,"%s's move: %s\n", (side == DARK) ? "Black" : "White", move_str(pv[0][0].b));
 			gprintf(temp);
 			makemove(pv[0][0].b);
 			ply = 0;
 			gen();
 			print_board();
-			print_result();
+			print_result();
+
 			continue;
 		}
 		
@@ -321,7 +309,7 @@
 			case GR_EVENT_TYPE_BUTTON_DOWN:
 				mouse_hit(event.button.x, event.button.y);
 				break;
-		}
+		}
 
 		if (to != 999)
 		{
diff -urN microwin/src\demos\tuxchess\search.c microwin-0.90/src\demos\tuxchess\search.c
--- microwin/src\demos\tuxchess\search.c	Thu Aug 26 19:41:36 2010
+++ microwin-0.90/src\demos\tuxchess\search.c	Mon Aug 30 08:36:14 2010
@@ -41,29 +41,32 @@
 		return;
 	}
 
-	start_time = get_ms();
+	start_time = GsGetTickCount();
 	stop_time = start_time + max_time;
 
 	ply = 0;
 	nodes = 0;
 	memset(pv, 0, sizeof(pv));
 	memset(history, 0, sizeof(history));
+#ifdef _DEBUG
 	if (output == 1)
 		printf("ply      nodes  score  pv\n");
+#endif
 	for (i = 1; i <= max_depth; ++i) {
 		follow_pv = TRUE;
 		x = search(-10000, 10000, i);
+#ifdef _DEBUG
 		if (output == 1)
 			printf("%3d  %9d  %5d ", i, nodes, x);
 		else if (output == 2)
 			printf("%d %d %d %d",
-					i, x, (get_ms() - start_time) / 10, nodes);
+					i, x, (GsGetTickCount() - start_time) / 10, nodes);
 		if (output) {
 			for (j = 0; j < pv_length[0]; ++j)
 				printf(" %s", move_str(pv[0][j].b));
 			printf("\n");
-			fflush(stdout);
 		}
+#endif
 		if (x > 9000 || x < -9000)
 			break;
 	}
@@ -300,7 +303,7 @@
 {
 	/* is the engine's time up? if so, longjmp back to the
 	   beginning of think() */
-	if (get_ms() >= stop_time) {
+	if (GsGetTickCount() >= stop_time) {
 		stop_search = TRUE;
 		longjmp(env, 0);
 	}
diff -urN microwin/src\drivers\dynacal.c microwin-0.90/src\drivers\dynacal.c
--- microwin/src\drivers\dynacal.c	Thu Aug 26 19:41:40 2010
+++ microwin-0.90/src\drivers\dynacal.c	Wed Aug 25 14:29:36 2010
@@ -109,7 +109,7 @@
 	state = 1;
       }
       else 
-	fprintf(stderr, "Non start byte recieved (%2.2x)\n", c);
+	DPRINTF("Non start byte recieved (%2.2x)\n", c);
       
       break;
 
@@ -119,7 +119,7 @@
 	state = 2;
       }
       else {
-	fprintf(stderr, "Got a start byte in the middle of the packet\n");
+	DPRINTF("Got a start byte in the middle of the packet\n");
 	data[0] = (unsigned char) c;
 
 	state = 0;
@@ -134,7 +134,7 @@
 	return(1);
       }
       else {
-	fprintf(stderr, "Got a start byte in the middle of the packet\n");
+	DPRINTF("Got a start byte in the middle of the packet\n");
 	data[0] = (unsigned char) c;
 
 	state = 0;
@@ -256,7 +256,7 @@
   /* Open up the graphics */
 
   if (GrOpen() == -1) {
-    fprintf(stderr, "Error!  Unable to open the graphics engine\n");
+    DPRINTF("Error!  Unable to open the graphics engine\n");
     return(-1);
   }
 
@@ -264,7 +264,7 @@
 
   serialFd = calInitSerial("/dev/ttyS1");
   if (serialFd == -1) {
-    fprintf(stderr, "Error!  Unable to open the touchscreen device\n");
+    DPRINTF("Error!  Unable to open the touchscreen device\n");
     return(-1);
   }
 
@@ -340,7 +340,7 @@
     }
   }
   else {
-    fprintf(stderr, "Error - Unable to read the touchscreen\n");
+    DPRINTF("Error - Unable to read the touchscreen\n");
   }
 
   /* Close everything down */
diff -urN microwin/src\drivers\fb.h microwin-0.90/src\drivers\fb.h
--- microwin/src\drivers\fb.h	Thu Aug 26 19:41:40 2010
+++ microwin-0.90/src\drivers\fb.h	Wed Aug 25 14:29:38 2010
@@ -570,9 +570,9 @@
 void set_portrait_subdriver(PSD psd);
 
 /* fbportrait_xxx.c*/
-extern SUBDRIVER fbportrait_left;
-extern SUBDRIVER fbportrait_right;
-extern SUBDRIVER fbportrait_down;
+SUBDRIVER fbportrait_left;
+SUBDRIVER fbportrait_right;
+SUBDRIVER fbportrait_down;
 
 void fbportrait_left_drawpixel(PSD psd,MWCOORD x, MWCOORD y, MWPIXELVAL c);
 MWPIXELVAL fbportrait_left_readpixel(PSD psd, MWCOORD x, MWCOORD y);
diff -urN microwin/src\drivers\genmem.c microwin-0.90/src\drivers\genmem.c
--- microwin/src\drivers\genmem.c	Thu Aug 26 19:41:42 2010
+++ microwin-0.90/src\drivers\genmem.c	Wed Aug 25 14:29:36 2010
@@ -64,6 +64,8 @@
 	mempsd->addr = addr;
 }
 
+
+
 /* 
  * Initialize memory device with passed parms,
  * select suitable framebuffer subdriver,
@@ -74,6 +76,9 @@
  * then blitted using swapped x,y coords for speed with
  * no rotation required.
  */
+
+extern SUBDRIVER fblinear8;
+
 MWBOOL
 gen_mapmemgc(PSD mempsd,MWCOORD w,MWCOORD h,int planes,int bpp,int linelen,
 	int data_format,int pitch,int size,void *addr)
@@ -84,16 +89,21 @@
 	gen_initmemgc(mempsd, w, h, planes, bpp, data_format, linelen, pitch, size, addr);
 
 	/* select and init hw compatible framebuffer subdriver for pixmap drawing*/
+#ifdef GENMEM_LINEAR8
+	subdriver = &fblinear8;
+#else
 	subdriver = select_fb_subdriver(mempsd);
+#endif
 	if(!subdriver || !subdriver->Init(mempsd))
 		return 0;
 
 	/* pixmap portrait subdriver will callback fb drivers, not screen drivers*/
 	mempsd->orgsubdriver = subdriver;
 
+#ifndef GENMEM_LINEAR8
 	/* assign portrait subdriver or regular fb driver for pixmap drawing*/
 	set_portrait_subdriver(mempsd);
-
+#endif
 	return 1;
 }
 
@@ -107,6 +117,8 @@
 	free(mempsd);
 }
 
+#ifndef GENMEM_LINEAR8
+
 void
 gen_setportrait(PSD psd, int portraitmode)
 {
@@ -126,6 +138,8 @@
 	/* assign portrait subdriver or original driver*/
 	set_portrait_subdriver(psd);
 }
+
+#endif
 
 void
 gen_fillrect(PSD psd,MWCOORD x1, MWCOORD y1, MWCOORD x2, MWCOORD y2,
diff -urN microwin/src\drivers\hbf.c microwin-0.90/src\drivers\hbf.c
--- microwin/src\drivers\hbf.c	Thu Aug 26 19:41:42 2010
+++ microwin-0.90/src\drivers\hbf.c	Wed Aug 25 14:27:44 2010
@@ -66,6 +66,7 @@
 /*
  * Messy file system issues
  */
+#if HAVE_FILEIO
 
 #ifdef unix
 #define	PATH_DELIMITER ':'
@@ -1484,3 +1485,5 @@
 {
 	return &(hbf->hbf_font_bbox);
 }
+
+#endif
diff -urN microwin/src\drivers\kbd_mosync.c microwin-0.90/src\drivers\kbd_mosync.c
--- microwin/src\drivers\kbd_mosync.c	Thu Aug 26 19:41:42 2010
+++ microwin-0.90/src\drivers\kbd_mosync.c	Wed Dec 31 16:00:00 1969
@@ -1,117 +0,0 @@
-/*
- * Microwindows keyboard driver for MoSync
- *
- * Copyright (c) 2010 DI (FH) Ludwig Ertl / CSP GmbH
- *
- */
-#include <ma.h>
-#include "device.h"
-
-extern MAEvent g_event;
-
-static MWKEY MapKey (int key);
-static int  MOS_Open(KBDDEVICE *pkd);
-static void MOS_Close(void);
-static void MOS_GetModifierInfo(MWKEYMOD *modifiers, MWKEYMOD *curmodifiers);
-static int  MOS_Read(MWKEY *kbuf, MWKEYMOD *modifiers, MWSCANCODE *scancode);
-
-KBDDEVICE kbddev = {
-	MOS_Open,
-	MOS_Close,
-	MOS_GetModifierInfo,
-	MOS_Read,
-	NULL
-};
-
-static int
-MOS_Open(KBDDEVICE * pkd)
-{
-	return 0;
-}
-
-static void
-MOS_Close(void)
-{
-}
-
-static void
-MOS_GetModifierInfo(MWKEYMOD * modifiers, MWKEYMOD * curmodifiers)
-{
-	if (modifiers)
-		*modifiers = 0;	/* no modifiers available */
-	if (curmodifiers)
-		*curmodifiers = 0;
-}
-
-// 0	-	No key pressed
-// 1	-	Key down
-// 2	-	Key released
-static int
-MOS_Read(MWKEY * kbuf, MWKEYMOD * modifiers, MWSCANCODE * scancode)
-{
-	*modifiers = 0;
-
-	switch (g_event.type)
-	{
-	case EVENT_TYPE_KEY_PRESSED:
-		*kbuf = MapKey(g_event.key);
-		*scancode = g_event.nativeKey;
-		return 1;
-	case EVENT_TYPE_KEY_RELEASED:
-		*kbuf = MapKey(g_event.key);
-		*scancode = g_event.nativeKey;
-		return 2;
-	}
-
-	return 0;
-}
-
-#define MAP_KEY(key) case MAK_##key: return MWKEY_##key;
-
-static MWKEY MapKey (int key)
-{
-	switch (key)
-	{
-	MAP_KEY(LEFT);
-	MAP_KEY(RIGHT);
-	MAP_KEY(UP);
-	MAP_KEY(DOWN);
-	MAP_KEY(INSERT);
-	MAP_KEY(DELETE);
-	MAP_KEY(HOME);
-	MAP_KEY(END);
-	MAP_KEY(PAGEUP);
-	MAP_KEY(PAGEDOWN);
-	MAP_KEY(KP0);
-	MAP_KEY(KP1);
-	MAP_KEY(KP2);
-	MAP_KEY(KP3);
-	MAP_KEY(KP4);
-	MAP_KEY(KP5);
-	MAP_KEY(KP6);
-	MAP_KEY(KP7);
-	MAP_KEY(KP8);
-	MAP_KEY(KP9);
-	MAP_KEY(KP_PERIOD);
-	MAP_KEY(KP_DIVIDE);
-	MAP_KEY(KP_MULTIPLY);
-	MAP_KEY(KP_MINUS);
-	MAP_KEY(KP_PLUS);
-	MAP_KEY(KP_ENTER);
-	MAP_KEY(KP_EQUALS);
-	MAP_KEY(LSHIFT);
-	MAP_KEY(RSHIFT);
-	MAP_KEY(LCTRL);
-	MAP_KEY(RCTRL);
-	MAP_KEY(LALT);
-	MAP_KEY(RALT);
-	MAP_KEY(MENU);
-	case MAK_CLEAR: return MWKEY_BACKSPACE;
-	case MAK_FIRE: return MWKEY_ACCEPT;
-	case MAK_SOFTLEFT: return MWKEY_LMETA;
-	case MAK_SOFTRIGHT: return MWKEY_RMETA;
-	default: return key;
-	}
-	return MWKEY_UNKNOWN;
-}
-
diff -urN microwin/src\drivers\kbd_pipe.c microwin-0.90/src\drivers\kbd_pipe.c
--- microwin/src\drivers\kbd_pipe.c	Thu Aug 26 19:41:42 2010
+++ microwin-0.90/src\drivers\kbd_pipe.c	Wed Aug 25 14:27:44 2010
@@ -118,6 +118,8 @@
 	if(*buf == 0x1b)
 	      return -2;      /* special case ESC*/
 #if _SOFT_DEBUG
+
+#error hello
     	EPRINTF("kbd_soft.c: soft_Read(): read '%c', cc = %d\n", 
 	        buf[0], cc); 
 	fflush(NULL);
diff -urN microwin/src\drivers\kbd_win32.c microwin-0.90/src\drivers\kbd_win32.c
--- microwin/src\drivers\kbd_win32.c	Thu Aug 26 19:41:42 2010
+++ microwin-0.90/src\drivers\kbd_win32.c	Mon Aug 30 09:11:24 2010
@@ -7,36 +7,38 @@
 #include <string.h>
 #include <stdio.h>
 #include "device.h"
-#include <windows.h>
 
-static int  NUL_Open(KBDDEVICE *pkd);
-static void NUL_Close(void);
-static void NUL_GetModifierInfo(MWKEYMOD *modifiers, MWKEYMOD *curmodifiers);
-static int  NUL_Read(MWKEY *buf, MWKEYMOD *modifiers, MWSCANCODE *scancode);
-static int  NUL_Poll(void);
+static int  KBD_Open(KBDDEVICE *pkd);
+static void KBD_Close(void);
+static void KBD_GetModifierInfo(MWKEYMOD *modifiers, MWKEYMOD *curmodifiers);
+static int  KBD_Read(MWKEY *buf, MWKEYMOD *modifiers, MWSCANCODE *scancode);
+static int  KBD_Poll(void);
+
+extern unsigned int g_scancode;
+extern unsigned int g_modifier;
 
 KBDDEVICE kbddev = {
-	NUL_Open,
-	NUL_Close,
-	NUL_GetModifierInfo,
-	NUL_Read,
-	NUL_Poll
+	KBD_Open,
+	KBD_Close,
+	KBD_GetModifierInfo,
+	KBD_Read,
+	KBD_Poll
 };
 
 /*
  * Poll for keyboard events
  */
 static int
-NUL_Poll(void)
+KBD_Poll(void)
 {
-	return 0;
+	return 1; /* Used by MINIX only */
 }
 
 /*
  * Open the keyboard.
  */
 static int
-NUL_Open(KBDDEVICE *pkd)
+KBD_Open(KBDDEVICE *pkd)
 {
 	return 0;
 }
@@ -45,7 +47,7 @@
  * Close the keyboard.
  */
 static void
-NUL_Close(void)
+KBD_Close(void)
 {
 	
 }
@@ -54,10 +56,12 @@
  * Return the possible modifiers for the keyboard.
  */
 static  void
-NUL_GetModifierInfo(MWKEYMOD *modifiers, MWKEYMOD *curmodifiers)
+KBD_GetModifierInfo(MWKEYMOD *modifiers, MWKEYMOD *curmodifiers)
 {
 	if (modifiers)
-		*modifiers = 0;		/* no modifiers available */
+	{
+		*modifiers = g_modifier;
+	}
 	if (curmodifiers)
 		*curmodifiers = 0;
 }
@@ -69,7 +73,15 @@
  * This is a non-blocking call.
  */
 static int
-NUL_Read(MWKEY *mwkey, MWKEYMOD *modifiers, MWSCANCODE *scancode)
+KBD_Read(MWKEY *mwkey, MWKEYMOD *modifiers, MWSCANCODE *scancode)
 {
+	if (g_scancode)
+	{
+		*mwkey = g_scancode;
+		*scancode = g_scancode;
+		*modifiers = g_modifier;
+		g_scancode = 0;
+		return (g_modifier & 0x80000000) ? 1 : 2;
+	}
 	return 0;
 }
diff -urN microwin/src\drivers\mou_mosync.c microwin-0.90/src\drivers\mou_mosync.c
--- microwin/src\drivers\mou_mosync.c	Thu Aug 26 19:41:44 2010
+++ microwin-0.90/src\drivers\mou_mosync.c	Wed Dec 31 16:00:00 1969
@@ -1,67 +0,0 @@
-/*
- * Mosync touchscreen mousedriver
- *
- * Copyright (c) 2010 DI (FH) Ludwig Ertl / CSP GmbH
- */
-
-#include <ma.h>
-#include "device.h"
-
-extern MAEvent g_event;
-extern SCREENDEVICE scrdev;
-
-static int MOS_Open(MOUSEDEVICE *pmd)
-{
-	GdHideCursor(&scrdev);
-	return 0;
-}
-
-static void MOS_Close(void)
-{
-}
-
-static int MOS_GetButtonInfo(void)
-{
-	/* get "mouse" buttons supported */
-	return MWBUTTON_L;
-}
-
-static void MOS_GetDefaultAccel(int *pscale,int *pthresh)
-{
-	*pscale = 3;
-	*pthresh = 5;
-}
-
-static int MOS_Read(MWCOORD *px, MWCOORD *py, MWCOORD *pz, int *pb)
-{
-	switch (g_event.type)
-	{
-	case EVENT_TYPE_POINTER_PRESSED:
-	case EVENT_TYPE_POINTER_DRAGGED:
-		*pb = MWBUTTON_L;
-		break;
-	case EVENT_TYPE_POINTER_RELEASED:
-		*pb = 0;
-		break;
-	default:
-		return 0;
-	}
-	*px = g_event.point.x;
-	*py = g_event.point.y;
-
-	//*pz = event.pressure;
-
-	if(!*pb)
-		return 3;
-	return 2;
-}
-
-MOUSEDEVICE mousedev = {
-	MOS_Open,
-	MOS_Close,
-	MOS_GetButtonInfo,
-	MOS_GetDefaultAccel,
-	MOS_Read,
-	NULL,
-	MOUSE_RAW   /* Input filter flags */
-};
diff -urN microwin/src\drivers\mou_win32.c microwin-0.90/src\drivers\mou_win32.c
--- microwin/src\drivers\mou_win32.c	Thu Aug 26 19:41:44 2010
+++ microwin-0.90/src\drivers\mou_win32.c	Fri Aug 27 13:57:10 2010
@@ -5,55 +5,125 @@
  */
 #include <stdio.h>
 #include "device.h"
-#include <windows.h>
-#include <windowsx.h>
 
 #define	SCALE		3	/* default scaling factor for acceleration */
 #define	THRESH		5	/* default threshhold for acceleration */
 
-MSG *winMouseMsg = NULL;
-
-static int  	NUL_Open(MOUSEDEVICE *pmd);
-static void 	NUL_Close(void);
-static int  	NUL_GetButtonInfo(void);
-static void	NUL_GetDefaultAccel(int *pscale,int *pthresh);
-static int  	NUL_Read(MWCOORD *dx, MWCOORD *dy, MWCOORD *dz, int *bp);
-static int  	NUL_Poll(void);
+#define MK_LBUTTON      0x0001
+#define MK_RBUTTON      0x0002
+#define MK_SHIFT        0x0004
+#define MK_CONTROL      0x0008
+#define MK_MBUTTON      0x0010
+
+static int  	MOU_Open(MOUSEDEVICE *pmd);
+static void 	MOU_Close(void);
+static int  	MOU_GetButtonInfo(void);
+static void	MOU_GetDefaultAccel(int *pscale,int *pthresh);
+static int  	MOU_Read(MWCOORD *dx, MWCOORD *dy, MWCOORD *dz, int *bp);
+static int  	MOU_Poll(void);
 
 MOUSEDEVICE mousedev = {
-	NUL_Open,
-	NUL_Close,
-	NUL_GetButtonInfo,
-	NUL_GetDefaultAccel,
-	NUL_Read,
-	NUL_Poll,
+	MOU_Open,
+	MOU_Close,
+	MOU_GetButtonInfo,
+	MOU_GetDefaultAccel,
+	MOU_Read,
+	MOU_Poll,
     MOUSE_NORMAL	/* flags*/
 };
 
+#ifdef WIN32
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <windowsx.h>
+
+static MSG winMouseMsg;
+
 /*
  * Poll for events
  */
+extern HWND winRootWindow;
+
+/* Copied from nano-X */
+#define	GR_EVENT_TYPE_KEY_DOWN		8
+#define	GR_EVENT_TYPE_KEY_UP		9
+
+extern unsigned int g_scancode;
+extern unsigned int g_modifier;
 
 static int
-NUL_Poll(void)
+MOU_Poll(void)
 {
+	MSG msg;
+	if (winRootWindow != NULL)
+	{
+		if (PeekMessage(&msg, winRootWindow, 0, 0, PM_REMOVE))
+		{
+			switch (msg.message)
+			{
+			case WM_KEYDOWN:
+			case WM_SYSKEYDOWN:
+				g_scancode = msg.wParam;
+				g_modifier = msg.lParam;
+				break;
+			case WM_KEYUP:
+			case WM_SYSKEYUP:
+				g_scancode = msg.wParam;
+				g_modifier = msg.lParam;
+				break;
+			case WM_MOUSEMOVE:
+			case WM_LBUTTONDOWN:
+			case WM_LBUTTONUP:
+			case WM_LBUTTONDBLCLK:
+			case WM_MBUTTONDOWN:
+			case WM_MBUTTONUP:
+			case WM_MBUTTONDBLCLK:
+			case WM_RBUTTONDOWN:
+			case WM_RBUTTONUP:
+			case WM_RBUTTONDBLCLK:
+				winMouseMsg = msg;
+				break;
+			}
+
+			TranslateMessage(&msg);
+			DispatchMessage(&msg);
+		}
+	}
+	/* Return mouse status */
+	if (winMouseMsg.message)
+		return 1;
 	return 0;
 }
 
+#else
+
+static int
+MOU_Poll(void)
+{
+#if WIN32
+	if (winMouseMsg.msg)
+		return 1;
+#endif
+	return 0;
+}
+
+#endif
+
 /*
  * Open up the mouse device.
  */
 static int
-NUL_Open(MOUSEDEVICE *pmd)
+MOU_Open(MOUSEDEVICE *pmd)
 {
-	return -2;	/* no mouse*/
+	return 1;
 }
 
 /*
  * Close the mouse device.
  */
 static void
-NUL_Close(void)
+MOU_Close(void)
 {
 }
 
@@ -61,7 +131,7 @@
  * Get mouse buttons supported
  */
 static int
-NUL_GetButtonInfo(void)
+MOU_GetButtonInfo(void)
 {
 	return MWBUTTON_L | MWBUTTON_M | MWBUTTON_R;
 }
@@ -70,7 +140,7 @@
  * Get default mouse acceleration settings
  */
 static void
-NUL_GetDefaultAccel(int *pscale,int *pthresh)
+MOU_GetDefaultAccel(int *pscale,int *pthresh)
 {
 	*pscale = SCALE;
 	*pthresh = THRESH;
@@ -85,27 +155,32 @@
  */
 
 static int
-NUL_Read(MWCOORD *dx, MWCOORD *dy, MWCOORD *dz, int *bp)
+MOU_Read(MWCOORD *dx, MWCOORD *dy, MWCOORD *dz, int *bp)
 {
-    if (winMouseMsg)
-    {
-        *dx = GET_X_LPARAM(winMouseMsg->lParam);
-        *dy = GET_Y_LPARAM(winMouseMsg->lParam);
-        *dz = 0;
-        *bp = 0;
-        if (winMouseMsg->wParam & MK_LBUTTON)
-        {
-            *bp |= MWBUTTON_L;
-        }
-        if (winMouseMsg->wParam & MK_MBUTTON)
-        {
-            *bp |= MWBUTTON_M;
-        }
-        if (winMouseMsg->wParam & MK_RBUTTON)
-        {
-            *bp |= MWBUTTON_R;
-        }
-        return 2;
-    }
+#ifdef WIN32
+	UINT button = 0;
+
+	if (winMouseMsg.message)
+	{
+		*dx = GET_X_LPARAM(winMouseMsg.lParam);
+		*dy = GET_Y_LPARAM(winMouseMsg.lParam);
+		*dz = 0;
+		if (winMouseMsg.wParam & MK_LBUTTON)
+		{
+			button |= MWBUTTON_L;
+		}
+		if (winMouseMsg.wParam & MK_MBUTTON)
+		{
+			button |= MWBUTTON_M;
+		}
+		if (winMouseMsg.wParam & MK_RBUTTON)
+		{
+			button |= MWBUTTON_R;
+		}
+		*bp = button;
+		winMouseMsg.message = 0;
+		return 2;
+	}
+#endif
     return 0;
 }
diff -urN microwin/src\drivers\osglue.c microwin-0.90/src\drivers\osglue.c
--- microwin/src\drivers\osglue.c	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\drivers\osglue.c	Thu Aug 26 19:33:00 2010
@@ -0,0 +1,441 @@
+#if defined(WIN32)
+
+#include <assert.h>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include "nano-X.h"
+
+extern void* GetFrameBuffer();
+
+#ifdef STUB_STRING_FUNC
+
+size_t strlen(const char* s)
+{
+	register int len = 0;
+	while (*s++)
+		++len;
+	return len;
+}
+
+void* memcpy(void* dst, const void* src, size_t count)
+{
+	char* s = dst;
+	const char* t = src;
+	while (count)
+	{
+		*s++ = *t++;
+		--count;;
+	}
+	return dst;
+}
+
+char* strcat(char*dst, const char* src)
+{
+	return strcpy(dst + strlen(dst), src);
+}
+
+char* strcpy(char* dst, const char* src)
+{
+	while ((*dst++ = *src++) != '\0')
+		/* nothing */;
+	return dst;
+}
+
+
+void *memset(void* buf, int value, size_t count)
+{
+	register char* p = buf;
+	while (count)
+	{
+		*p++ = value;
+		--count;
+	}
+	return buf;
+}
+
+#endif
+
+#ifdef STUB_FILE_FUNC
+
+int isatty() {return 0;}
+void _fstat() {}
+void _read() {}
+void _write() {}
+void _lseek() {}
+void _close() {}
+
+#endif
+
+HWND winRootWindow = NULL;
+const char szAppName[] = "NanoX";
+
+#define ZOOM		0
+#define ID_TIMER	1000
+
+LPBYTE pFrameBuffer = NULL;
+UINT g_scancode = 0;
+UINT g_modifier = 0;
+
+typedef struct bmi_256
+{
+    BITMAPINFO bmi;
+    RGBQUAD pad[255];
+} BMI_256;
+
+static BMI_256 bmiPalette;
+
+/* Copied from wingdi.h */
+
+#define DIB_RGB_COLORS      0 /* color table in RGBs */
+
+#if 0
+void
+HandleKeyMessage(MSG *msg, GR_EVENT_TYPE keyType)
+{
+	int keystatus = -1;
+	MWKEY mwkey = msg->wParam; // virtual-key code
+	MWKEYMOD modifiers = 0;
+	unsigned char scanCode;
+	int repeat, extended, context, previous;
+
+	repeat = msg->lParam & 0xffff;
+	scanCode = (msg->lParam >> 16) & 0xff;
+	previous = msg->lParam & 0x40000000L;
+	context = msg->lParam & 0x20000000L;
+	extended = msg->lParam & 0x1000000L;
+	if (extended) {
+	}
+	GsDeliverKeyboardEvent(0, keyType, mwkey, modifiers, scanCode);
+}
+
+#endif
+
+#ifdef _DEBUG
+
+const BITMAPFILEHEADER bfFileHeader =
+{
+	/* bfType */      'B' + ('M' << 8),
+	/* bfSize */      sizeof(BITMAPFILEHEADER) + sizeof(BMI_256) + SCREEN_HEIGHT * SCREEN_WIDTH,
+	/* bfReserved1 */ 0L,
+	/* bfReserved2 */ 0L,
+	/* bfOffBits */   sizeof(BITMAPFILEHEADER) + sizeof(BMI_256)
+};
+
+void CaptureScreen(void)
+{
+	FILE* fp = fopen("nanoxcap.bmp", "wb");
+	if (fp != NULL)
+	{
+		int row;
+		/* Write out BITMAPFILEHEADER */
+		fwrite(&bfFileHeader, 1, sizeof(bfFileHeader), fp);
+		/* Write out BITMAPINFO + PALETTE */
+		bmiPalette.bmi.bmiHeader.biHeight = SCREEN_HEIGHT;
+		fwrite(&bmiPalette, 1, sizeof(bmiPalette), fp);
+		bmiPalette.bmi.bmiHeader.biHeight = 1;
+		/* Write out bitmap data (upsdie down) */
+		for (row = SCREEN_HEIGHT; row; --row)
+			fwrite((BYTE*) GetFrameBuffer() + (row - 1) * SCREEN_WIDTH, 1, SCREEN_WIDTH, fp);
+		fclose(fp);
+	}
+}
+
+#endif
+
+LRESULT CALLBACK
+myWindowProc(HWND hWnd,	UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+	BOOL ret;
+	HDC dc;
+	PAINTSTRUCT ps;
+	int y;
+
+	switch (uMsg) {
+	case WM_CREATE:
+		break;
+	case WM_MOUSEMOVE:
+	case WM_LBUTTONDOWN:
+	case WM_LBUTTONUP: 
+	case WM_LBUTTONDBLCLK:
+	case WM_MBUTTONDOWN:
+	case WM_MBUTTONUP:
+	case WM_MBUTTONDBLCLK:
+	case WM_RBUTTONDOWN:
+	case WM_RBUTTONUP:
+	case WM_RBUTTONDBLCLK:
+		break;
+	case WM_SYSKEYDOWN:
+	case WM_KEYDOWN:
+	case WM_SYSKEYUP:
+	case WM_KEYUP:
+		g_scancode = wParam;
+		g_modifier = lParam;
+		break;
+	case WM_CHAR:
+	case WM_DEADCHAR:
+	case WM_SYSCHAR:
+	case WM_SYSDEADCHAR:
+		break;
+	case WM_TIMER:
+		InvalidateRect(hWnd, NULL, FALSE);
+		break;
+	case WM_PAINT:
+		dc = BeginPaint(hWnd, &ps);
+		if (pFrameBuffer)
+		{
+			// Fill in BITMAPINFO
+			for (y = 0; y < SCREEN_HEIGHT; ++y)
+			{
+				// Paint one scan line
+				ret = StretchDIBits(dc, 0, (y << ZOOM), SCREEN_WIDTH << ZOOM, 1 << ZOOM,
+					0, /*ySrc*/0, SCREEN_WIDTH, /*nSrcHeight*/ 1,
+					&pFrameBuffer[SCREEN_WIDTH * y], &bmiPalette.bmi, DIB_RGB_COLORS, SRCCOPY);
+			}
+			assert(ret!=FALSE);
+		}
+		EndPaint(hWnd, &ps);
+		break;
+	case WM_CLOSE:
+#ifdef _DEBUG
+		CaptureScreen();
+#endif
+		GrClose();		/* When main window is closed shutdown Nano-X server */
+		break;
+	case WM_DESTROY:
+		KillTimer(hWnd, ID_TIMER);
+		PostQuitMessage(0);
+		break;
+	case WM_NCDESTROY:
+		winRootWindow = NULL;
+		break;
+	case WM_SETCURSOR:
+		/* Hide cursor in client area: Nano-X draws cursor! */
+		if (LOWORD(lParam) == HTCLIENT)
+			SetCursor(NULL);
+		else
+			SetCursor(LoadCursor(NULL, IDC_ARROW));
+		break;
+	default:
+		return DefWindowProc(hWnd, uMsg, wParam, lParam);
+	}
+	return 0;	
+}
+
+void* GetFrameBuffer()
+{
+	if (pFrameBuffer == NULL)
+	{
+		/* Only do this once */
+		HINSTANCE hInstance = GetModuleHandle(NULL);
+		WNDCLASS wc;
+				
+		wc.style           = CS_HREDRAW | CS_VREDRAW; // | CS_OWNDC;
+		wc.lpfnWndProc     = (WNDPROC)myWindowProc;
+		wc.cbClsExtra      = 0;
+		wc.cbWndExtra      = 0;
+		wc.hInstance       = hInstance;
+		wc.hIcon           = LoadIconA(NULL, IDI_APPLICATION);
+		wc.hCursor         = NULL;// LoadCursorA(NULL, IDC_ARROW);
+		wc.hbrBackground   = GetStockObject(WHITE_BRUSH);
+		wc.lpszMenuName    = NULL;
+		wc.lpszClassName   = szAppName;
+		RegisterClassA(&wc);
+
+		/* setup bitmap palette info */
+		memset(&bmiPalette.bmi, 0, sizeof(BITMAPINFO));
+		bmiPalette.bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+		bmiPalette.bmi.bmiHeader.biWidth = SCREEN_WIDTH;
+		bmiPalette.bmi.bmiHeader.biHeight = 1;
+		bmiPalette.bmi.bmiHeader.biPlanes = 1;
+		bmiPalette.bmi.bmiHeader.biBitCount = 8;
+		bmiPalette.bmi.bmiHeader.biCompression = BI_RGB;
+	
+		winRootWindow = CreateWindowExA(0, szAppName, szAppName, WS_OVERLAPPED|WS_MINIMIZEBOX|WS_CAPTION|WS_SYSMENU, 0, 0, 
+				SCREEN_WIDTH << ZOOM, SCREEN_HEIGHT << ZOOM, 0, 0, hInstance, NULL);
+		if (winRootWindow)
+		{
+			ShowWindow(winRootWindow, SW_SHOW);
+			UpdateWindow(winRootWindow);
+			SetTimer(winRootWindow, ID_TIMER, 100, NULL);
+		}
+		pFrameBuffer = malloc(SCREEN_WIDTH * SCREEN_HEIGHT);
+	}
+	return pFrameBuffer;
+}
+
+void SetSystemPalette(int i, COLORREF rgb)
+{
+	if (i >= 0 && i < 256)
+	{
+		RGBQUAD* pRGB = &bmiPalette.bmi.bmiColors[i];
+
+		pRGB->rgbRed = GetRValue(rgb);
+		pRGB->rgbGreen = GetGValue(rgb);
+		pRGB->rgbBlue = GetBValue(rgb);
+	}
+}
+
+void GdSleep(DWORD ms)
+{
+	Sleep(ms);
+}
+
+int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, char* lpCmdLine, int nShowCmd)
+{
+	int argc = (*lpCmdLine == '\0') ? 1 : 2;
+	const char* argv[2];
+	argv[0] = "";
+	argv[1] = lpCmdLine;
+	return main(argc, argv);
+}
+
+#elif defined(_MICO32)
+
+#include <stdlib.h>
+#include <sys/time.h>
+
+typedef unsigned long COLORREF;
+
+unsigned int g_modifier;
+unsigned int g_scancode;
+
+typedef enum
+{
+    /* Video mode control */                                                                             
+    VIDEO_RAMP          = 0x0004,         /* [R/W] 1=Video Ramp, 0=Normal FPA data */                    
+    VIDEO_FREEZE        = 0x0020,         /* [R/W] 1=Frozen, 0=Live Image */                             
+} VIDEO_MODE_BITS;
+
+#define video_mode          (*(volatile unsigned long*) 0xF0000004)
+#define video_cycles        (*(volatile unsigned long*) 0xF0000010)
+#define watch_dog           (*(volatile unsigned long*) 0xF000001C)
+#define dma_base_addr       ((volatile void**)          0xF0000040)
+
+#define   COLOR_LUT_BASE     0xF0008000L           /* Color Look up table */
+
+#define HEAP_END			((char*) 0x23E00000)
+#define VIDEO_BUFF			((char*) 0x23F00000)
+
+#define color_lut           ((unsigned long*) COLOR_LUT_BASE)
+
+void* GetFrameBuffer()
+{
+	/* Turn on Freeze bit in video mode register */
+	video_mode = VIDEO_FREEZE;
+	
+	dma_base_addr[1] = dma_base_addr[2] = dma_base_addr[3] = HEAP_END;
+	dma_base_addr[11] = dma_base_addr[12] = VIDEO_BUFF;
+	
+	/* Return default address of Tau video buffer */
+	return VIDEO_BUFF;
+}
+
+
+/* Windows Byte Order 00bbggrr */
+void SetSystemPalette(int i, COLORREF rgb)
+{
+	/* Write Tau Byte Order aarrggbb */
+	color_lut[i] = ((rgb & 0xFF) << 16) | (rgb & 0x00FF00) | ((rgb >> 16) & 0xFF);
+}
+
+void GdSleep(long msec)
+{
+	unsigned long now = video_cycles;
+	do
+	{
+		watch_dog = 0x5555;
+		watch_dog = 0xAAAA;
+	}
+	while (video_cycles - now < msec * 73000);
+}
+
+#include <errno.h>
+extern char _end;
+
+/*
+ * sbrk -- changes heap size size. Get nbytes more
+ *         RAM. We just increment a pointer in what's
+ *         left of memory on the board.
+ */
+caddr_t
+_sbrk(nbytes)
+     int nbytes;
+{
+  static caddr_t heap_ptr = NULL;
+  caddr_t        base;
+
+  if (heap_ptr == NULL) {
+    heap_ptr = (caddr_t)&_end;
+  }
+
+  if ((HEAP_END - heap_ptr) >= 0) {
+    base = heap_ptr;
+    heap_ptr += nbytes;
+    return (base);
+  } else {
+    errno = ENOMEM;
+    return ((caddr_t)-1);
+  }
+}
+
+int atexit( void (*func )( void ) )
+{
+    return 0;
+}
+
+void exit( int status )
+{
+	watch_dog = 0xDEAD;
+}
+
+#if 1
+
+int isatty() {return 0;}
+void _fstat() {}
+void _read() {}
+void _write() {}
+void _lseek() {}
+void _close() {}
+
+#endif
+
+void breakpoint_handler(void)
+{
+}
+
+void instruction_bus_error_handler(void)
+{
+}
+
+void watchpoint_handler(void)
+{
+}
+
+void data_bus_error_handler(void)
+{
+}
+
+void divide_by_zero_handler(void)
+{
+}
+
+int gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+	tv->tv_sec = 0;
+	tv->tv_usec = 0;
+}
+
+#endif /* WIN32 */
+
+typedef unsigned char SCREEN[SCREEN_HEIGHT][SCREEN_WIDTH];
+
+void FillScreen(int color)
+{
+	int row;
+	SCREEN* pScreen = (SCREEN*) GetFrameBuffer();
+	
+	for (row = 0; row < SCREEN_HEIGHT; ++row)
+	{
+		memset(&(*pScreen)[row][0], color, SCREEN_WIDTH);
+	}
+}
diff -urN microwin/src\drivers\scr_fb8.c microwin-0.90/src\drivers\scr_fb8.c
--- microwin/src\drivers\scr_fb8.c	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\drivers\scr_fb8.c	Thu Aug 19 19:08:16 2010
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Microwindows Screen Driver for 8-bit framebuffers
+ *
+ * Portions used from Ben Pfaff's BOGL <pfaffben@debian.org>
+ *
+ * Modified for eCos by
+ *   Gary Thomas <gthomas@redhat.com>
+ *   Richard Panton <richard.panton@3glab.org>
+ * 
+ * Note: modify select_fb_driver() to add new framebuffer subdrivers
+ */
+#include <fcntl.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "device.h"
+#include "genfont.h"
+#include "genmem.h"
+#include "nano-X.h"
+#include "fb.h"
+
+#ifdef WIN32
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+extern HWND winRootWindow;
+
+#else
+
+typedef unsigned char BYTE;
+typedef unsigned long COLORREF;
+
+/* Windows Byte Order 00bbggrr */
+#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((COLORREF)((BYTE)(g))<<8))|(((COLORREF)(BYTE)(b))<<16)))
+
+#endif
+
+extern void SetSystemPalette(int index, COLORREF rgb);
+extern unsigned char* GetFrameBuffer();
+
+static PSD  fb_open(PSD psd);
+static void fb_close(PSD psd);
+static void fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette);
+static void gen_getscreeninfo(PSD psd,PMWSCREENINFO psi);
+
+SCREENDEVICE	scrdev = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
+	fb_open,
+	fb_close,
+	gen_getscreeninfo,
+	fb_setpalette,
+	NULL,			/* DrawPixel subdriver*/
+	NULL,			/* ReadPixel subdriver*/
+	NULL,			/* DrawHorzLine subdriver*/
+	NULL,			/* DrawVertLine subdriver*/
+	NULL,			/* FillRect subdriver*/
+	gen_fonts,
+	NULL,			/* Blit subdriver*/
+	NULL,			/* PreSelect*/
+	NULL,			/* DrawArea subdriver*/
+	NULL,			/* SetIOPermissions*/
+	gen_allocatememgc,
+	gen_mapmemgc,
+	gen_freememgc
+};
+
+/* static variables*/
+static int status;		/* 0=never inited, 1=once inited, 2=inited. */
+#if PORTRAIT
+int gr_portraitmode = PORTRAIT;	/* =1 portrait left, =2 portrait right*/
+#endif
+
+extern SUBDRIVER fblinear8;
+
+/* init framebuffer*/
+static PSD
+fb_open(PSD psd)
+{
+    PSUBDRIVER subdriver;
+
+    psd->xres = psd->xvirtres = SCREEN_WIDTH;
+    psd->yres = psd->yvirtres = SCREEN_HEIGHT;
+#if PORTRAIT
+    /* automatic portrait mode if y resolution is greater than x res*/
+    /* * commented out, PORTRAIT_MODE=[R,L] used for compile time option***/
+    /* *if(psd->yres > psd->xres)
+        gr_portraitmode = 1;***/
+#endif
+    /* set planes from fb type*/
+    if (1 /*type == FB_TYPE_PACKED_PIXELS*/)
+        psd->planes = 1;   /* FIXME */
+    else psd->planes = 0;	/* force error later*/
+
+	psd->data_format = 0;			// FIXME
+    /* set pixel format*/
+    psd->pixtype = MWPF_PALETTE;
+    psd->bpp = 8;
+    psd->ncolors = (psd->bpp >= 24)? (1 << 24): (1 << psd->bpp);
+
+    /* set linelen to byte length, possibly converted later*/
+    psd->linelen = SCREEN_WIDTH;
+    psd->size = 0;		/* force subdriver init of size*/
+
+    psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
+
+#if PORTRAIT
+    /* determine whether to run in portrait mode*/
+    if(1 /*gr_portraitmode*/) {
+        psd->flags |= PSF_PORTRAIT;
+
+        /* swap x, y*/
+        psd->xvirtres = psd->yres;
+        psd->yvirtres = psd->xres;
+    }
+#endif
+
+    /* select a framebuffer subdriver based on planes and bpp*/
+    subdriver = &fblinear8;
+
+    /*
+     * set and initialize subdriver into screen driver
+     * psd->size is calculated by subdriver init
+     */
+    if(!set_subdriver(psd, subdriver, TRUE)) {
+        DPRINTF("Driver initialize failed\n", psd->bpp);
+        goto fail;
+    }
+
+#if PORTRAIT
+    if(psd->flags & PSF_PORTRAIT) {
+        /* remember original subdriver*/
+        _subdriver = subdriver;
+
+        /* assign portrait subdriver which calls original subdriver*/
+        set_subdriver(psd, &fbportrait, FALSE);
+    }
+#endif
+    /* mmap framebuffer into this address space*/
+    psd->addr = GetFrameBuffer();
+    if(psd->addr == NULL || psd->addr == (unsigned char *)-1) {
+//        DPRINTF("Error mmaping %s: %m\n", env);
+        goto fail;
+    }
+    status = 2;
+    return psd;	/* success*/
+
+ fail:
+    return NULL;
+}
+
+/* close framebuffer*/
+static void
+fb_close(PSD psd)
+{
+#ifdef WIN32
+	if (winRootWindow)
+		SendMessage(winRootWindow, WM_DESTROY, 0, 0);
+#endif
+}
+
+static int fade = 100;
+
+/* convert Microwindows palette to framebuffer format and set it*/
+static void
+fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette)
+{
+	int 	i;
+
+	if (count > 256)
+		count = 256;
+
+	/* convert palette to framebuffer format*/
+	if (palette)
+	{
+		for(i=0; i < count; i++) {
+			MWPALENTRY* p = &palette[i];
+
+			/* grayscale computation:
+			 * red[i] = green[i] = blue[i] =
+			 *	(p->r * 77 + p->g * 151 + p->b * 28);
+			 */
+			BYTE red = (p->r * fade / 100);
+			BYTE grn = (p->g * fade / 100);
+			BYTE blu = (p->b * fade / 100);
+			SetSystemPalette(i, RGB(red, grn, blu));
+		}
+	}
+}
+
+/* experimental palette animation*/
+void
+setfadelevel(PSD psd, int f)
+{
+}
+
+static void
+gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
+{
+    psi->rows = psd->yvirtres;
+    psi->cols = psd->xvirtres;
+    psi->planes = psd->planes;
+    psi->bpp = psd->bpp;
+	psi->data_format = psd->data_format;
+    psi->ncolors = psd->ncolors;
+    psi->pixtype = psd->pixtype;
+    psi->fonts = NUMBER_FONTS;
+
+    psi->ydpcm = 27;
+    psi->xdpcm = 27;
+}
diff -urN microwin/src\drivers\scr_mosync.c microwin-0.90/src\drivers\scr_mosync.c
--- microwin/src\drivers\scr_mosync.c	Thu Aug 26 19:41:48 2010
+++ microwin-0.90/src\drivers\scr_mosync.c	Wed Dec 31 16:00:00 1969
@@ -1,196 +0,0 @@
-/*
- * Copyright (c) 1999, 2000, 2001, 2002, 2007 Greg Haerr <greg@censoft.com>
- * Portions Copyright (c) 2002 Koninklijke Philips Electronics
- * moSync framebuffer adaptions (c) 2010 Ludwig Ertl / CSP GmbH
- *
- * Microwindows Screen Driver for moSync framebuffer
- *
- * Portions used from Ben Pfaff's BOGL <pfaffben@debian.org>
- *
- * Note: modify select_fb_driver() to add new framebuffer subdrivers
- */
-#include <ma.h>
-#include <assert.h>
-#include <fcntl.h>
-#include <limits.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "device.h"
-#include "genfont.h"
-#include "genmem.h"
-#include "fb.h"
-
-static PSD  fb_open(PSD psd);
-static void fb_close(PSD psd);
-static void fb_setportrait(PSD psd, int portraitmode);
-static void fb_setpalette(PSD psd,int first, int count, MWPALENTRY *palette);
-static void gen_getscreeninfo(PSD psd,PMWSCREENINFO psi);
-
-SCREENDEVICE	scrdev = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL,
-	fb_open,
-	fb_close,
-	gen_getscreeninfo,
-	NULL,			/* Palette not supported by moSync framebuffer */
-	NULL,			/* DrawPixel subdriver*/
-	NULL,			/* ReadPixel subdriver*/
-	NULL,			/* DrawHorzLine subdriver*/
-	NULL,			/* DrawVertLine subdriver*/
-	NULL,			/* FillRect subdriver*/
-	gen_fonts,
-	NULL,			/* Blit subdriver*/
-	NULL,			/* PreSelect*/
-	NULL,			/* DrawArea subdriver*/
-	NULL,			/* SetIOPermissions*/
-	gen_allocatememgc,
-	gen_mapmemgc,
-	gen_freememgc,
-	//NULL,			/* StretchBlit subdriver - deprecated*/
-	gen_setportrait,	/* SetPortrait*/
-	0,				/* int portrait */
-	NULL,			/* orgsubdriver */
-	NULL			/* StretchBlitEx subdriver*/
-};
-
-/* static variables*/
-static int status;		/* 0=never inited, 1=once inited, 2=inited. */
-static MAFrameBufferInfo fbinfo;
-
-extern SUBDRIVER fbportrait_left, fbportrait_right, fbportrait_down;
-static PSUBDRIVER pdrivers[4] = { /* portrait mode subdrivers*/
-	NULL, &fbportrait_left, &fbportrait_right, &fbportrait_down
-};
-
-/* init framebuffer*/
-static PSD
-fb_open(PSD psd)
-{
-	PSUBDRIVER subdriver;
-	int iRet;
-
-	assert(status < 2);
-
-	/* setup screen device from framebuffer info*/
-	maFrameBufferGetInfo(&fbinfo);
-
-	psd->portrait = MWPORTRAIT_NONE;
-	psd->xres = psd->xvirtres = fbinfo.width;
-	psd->yres = psd->yvirtres = fbinfo.height;
-	psd->planes = 1;
-	psd->bpp = fbinfo.bitsPerPixel;
-	psd->ncolors = (psd->bpp >= 24)? (1 << 24): (1 << psd->bpp);
-	psd->linelen = fbinfo.width;
-	psd->pitch = fbinfo.pitch;
-	psd->size = fbinfo.sizeInBytes;		/* force subdriver init of size*/
-	psd->flags = PSF_SCREEN | PSF_HAVEBLIT;
-
-	/* set pixel format*/
-	switch(psd->bpp) {
-	case 8:
-		psd->pixtype = MWPF_TRUECOLOR332;
-		break;
-	case 16:
-		if (fbinfo.greenBits == 5)
-			psd->pixtype = MWPF_TRUECOLOR555;
-		else
-			psd->pixtype = MWPF_TRUECOLOR565;
-		break;
-	case 18:
-	case 24:
-		psd->pixtype = MWPF_TRUECOLOR888;
-		break;
-	case 32:
-		psd->pixtype = MWPF_TRUECOLOR0888;
-		break;
-	default:
-		EPRINTF(
-		"Unsupported %ld color (%d bpp) truecolor framebuffer\n",
-			psd->ncolors, psd->bpp);
-		return NULL;
-	}
-
-	/* select a framebuffer subdriver based on planes and bpp*/
-	subdriver = select_fb_subdriver(psd);
-	if (!subdriver) {
-		EPRINTF("No driver for screen bpp %d\n", psd->bpp);
-		return NULL;
-	}
-
-	/*
-	 * set and initialize subdriver into screen driver
-	 * psd->size is calculated by subdriver init
-	 */
-	if(!set_subdriver(psd, subdriver, TRUE)) {
-		EPRINTF("Driver initialize failed bpp %d\n", psd->bpp);
-		return NULL;
-	}
-
-	/* remember original subdriver for portrait mode switching*/
-	pdrivers[0] = psd->orgsubdriver = subdriver;
-
-	/* allocate framebuffer (uses lots of memory!) */
-	if (!(psd->addr = calloc (1, psd->size))) {
-		EPRINTF("Out of memory allocating Framebuffer of %d bytes\n",
-			psd->size);
-		return NULL;
-	}
-
-	if ((iRet = maFrameBufferInit(psd->addr))<=0) {
-		EPRINTF("Error %d initializing framebuffer\n", iRet);
-		return NULL;
-	}
-
-	status = 2;
-	return psd;	/* success*/
-}
-
-/* close framebuffer*/
-static void
-fb_close(PSD psd)
-{
-	/* if not opened, return*/
-	if(status != 2)
-		return;
-	status = 1;
-
-	/* unmap framebuffer*/
-	maFrameBufferClose();
-	free (psd->addr);
-}
-
-static void
-gen_getscreeninfo(PSD psd,PMWSCREENINFO psi)
-{
-	psi->rows = psd->yvirtres;
-	psi->cols = psd->xvirtres;
-	psi->planes = psd->planes;
-	psi->bpp = psd->bpp;
-	psi->ncolors = psd->ncolors;
-	psi->fonts = NUMBER_FONTS;
-	psi->portrait = psd->portrait;
-	psi->data_format = psd->data_format;
-	psi->fbdriver = TRUE;	/* running fb driver, can direct map*/
-
-	psi->pixtype = psd->pixtype;
-	psi->rmask = fbinfo.redMask;
-	psi->gmask = fbinfo.greenMask;
-	psi->bmask = fbinfo.blueMask;
-
-	if(psd->yvirtres > 480) {
-		/* SVGA 800x600*/
-		psi->xdpcm = 33;	/* assumes screen width of 24 cm*/
-		psi->ydpcm = 33;	/* assumes screen height of 18 cm*/
-	} else if(psd->yvirtres > 350) {
-		/* VGA 640x480*/
-		psi->xdpcm = 27;	/* assumes screen width of 24 cm*/
-		psi->ydpcm = 27;	/* assumes screen height of 18 cm*/
-        } else if(psd->yvirtres <= 240) {
-		/* half VGA 640x240 */
-		psi->xdpcm = 14;        /* assumes screen width of 24 cm*/
-		psi->ydpcm =  5;
-	} else {
-		/* EGA 640x350*/
-		psi->xdpcm = 27;	/* assumes screen width of 24 cm*/
-		psi->ydpcm = 19;	/* assumes screen height of 18 cm*/
-	}
-}
diff -urN microwin/src\engine\devblit.c microwin-0.90/src\engine\devblit.c
--- microwin/src\engine\devblit.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devblit.c	Mon Aug 30 09:14:28 2010
@@ -287,7 +287,7 @@
 		break;
 
 	default:
-		EPRINTF("GdConversionBlit: unsupported data format 0x%x\n", parms->data_format);
+		DPRINTF("GdConversionBlit: unsupported data format 0x%x\n", parms->data_format);
 		return;
 	}
 
@@ -683,7 +683,7 @@
 			if (sw > 0 && sh > 0) {
 				sx = srcx + (px1-dstx) * srcw / dstw;
 				sy = srcy + (py1-dsty) * srch / dsth;
-/*printf("P %d,%d,%d,%d   %d,%d\n", sx, sy, sw, sh, g_row_inc, g_col_inc);*/
+/*DPRINTF("P %d,%d,%d,%d   %d,%d\n", sx, sy, sw, sh, g_row_inc, g_col_inc);*/
 
 				/* check cursor in dest and src regions*/
 				GdCheckCursor(dstpsd, px1, py1, px2-1, py2-1);
@@ -803,7 +803,7 @@
 	}
 
 	if (!dstpsd->StretchBlitEx) {
-		EPRINTF("GdStretchBlitEx NOT SUPPORTED on this target\n");
+		DPRINTF("GdStretchBlitEx NOT SUPPORTED on this target\n");
 		return;
 	}
 
diff -urN microwin/src\engine\devdraw.c microwin-0.90/src\engine\devdraw.c
--- microwin/src\engine\devdraw.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devdraw.c	Mon Aug 30 09:14:38 2010
@@ -732,7 +732,8 @@
 
 	if (pimage->data_format)
 		DPRINTF("GdDrawImage: no convblit, using DrawImageInternal fallback\n");
-	else DPRINTF("GdDrawImage: image not RGBA/RGB format, using slow GdDrawImageInternal\n");
+	else
+		DPRINTF("GdDrawImage: image not RGBA/RGB format, using slow GdDrawImageInternal\n");
 
 	GdDrawImageInternal(psd, x, y, pimage);			/* old pixel-by-pixel drawing*/
 	return;
diff -urN microwin/src\engine\devfont.c microwin-0.90/src\engine\devfont.c
--- microwin/src\engine\devfont.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devfont.c	Mon Aug 30 09:15:06 2010
@@ -22,9 +22,11 @@
 #include "intl.h"
 
 #if (UNIX | DOS_DJGPP)
-#define strcmpi	strcasecmp
+	#define strcmpi	strcasecmp
 #endif
 
+#define IABS(x)				((x) < 0 ? -(x) : (x))
+
 //#define DEBUG_TEXT_SHAPING
 
 /**
@@ -135,7 +137,8 @@
 		if (plogfont->lfUnderline)
 			fontattr = MWTF_UNDERLINE;
 	}
-	height = abs(height);
+	if (height < 0)
+		height = -height;
 
 	/* check builtin fonts first for speed*/
  	if (!height && (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_BUILTIN)) {
@@ -158,7 +161,7 @@
 		 * height will always be returned.
 		 */
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("builtin-createfont: %s,%d not found\n",
+			DPRINTF("builtin-createfont: %s,%d not found\n",
 				fontname, height);
   	}
 
@@ -186,7 +189,7 @@
 			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("fnt_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("fnt_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
@@ -198,14 +201,14 @@
 			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("pcf_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("pcf_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
 #if HAVE_FREETYPE_2_SUPPORT
  	if (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_FREETYPE) {
 		/* FIXME auto antialias for height > 14 for kaffe*/
-		if (plogfont && abs(plogfont->lfHeight) > FFMINAA_HEIGHT && plogfont->lfQuality)
+		if (plogfont && IABS(plogfont->lfHeight) > FFMINAA_HEIGHT && plogfont->lfQuality)
 				fontattr |= MWTF_ANTIALIAS;
 
 		pfont = (PMWFONT)freetype2_createfont(fontname, height, width, fontattr);
@@ -216,7 +219,7 @@
 			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("freetype2_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("freetype2_createfont: %s,%d not found\n", fontname, height);
   	}
 #endif
 
@@ -226,7 +229,7 @@
 		if(pfont)
 			return pfont;
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("t1lib_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("t1lib_createfont: %s,%d not found\n", fontname, height);
   	}
 #endif
 
@@ -236,7 +239,7 @@
 		if(pfont)		
 			return pfont;
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("hzk_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("hzk_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
@@ -248,13 +251,13 @@
 			return pfont;
 		}
 		if (fontclass != MWLF_CLASS_ANY)
-			EPRINTF("eucjp_createfont: %s,%d not found\n", fontname, height);
+			DPRINTF("eucjp_createfont: %s,%d not found\n", fontname, height);
 	}
 #endif
 
 	if (fontclass == MWLF_CLASS_ANY) {
-		EPRINTF("createfont: %s,%d not found\n", fontname, height);
-		EPRINTF("  (tried "
+		DPRINTF("createfont: %s,%d not found\n", fontname, height);
+		DPRINTF("  (tried "
 			"builtin_createfont"
 #if HAVE_FNT_SUPPORT
 			", fnt_createfont"
@@ -284,24 +287,24 @@
  	if (height != 0 && (fontclass == MWLF_CLASS_ANY || fontclass == MWLF_CLASS_BUILTIN)) {
 		/* find builtin font closest in height*/
 		fontno = 0;
-		height = abs(height);
+		height = IABS(height);
 		fontht = MAX_MWCOORD;
 		for(i = 0; i < scrinfo.fonts; ++i) {
 			pfont = (PMWFONT)&pf[i];
 			GdGetFontInfo(pfont, &fontinfo);
-			if(fontht > abs(height-fontinfo.height)) { 
+			if(fontht > IABS(height-fontinfo.height)) { 
 				fontno = i;
-				fontht = abs(height-fontinfo.height);
+				fontht = IABS(height-fontinfo.height);
 			}
 		}
 		pf[fontno].fontsize = pf[fontno].cfont->height;
 		pf[fontno].fontattr = fontattr;
-		EPRINTF("createfont: height given, using builtin font %s (%d) as fallback\n", pf[fontno].name, fontno);
+		DPRINTF("createfont: height given, using builtin font %s (%d) as fallback\n", pf[fontno].name, fontno);
 		return (PMWFONT)&pf[fontno];
 	}
 
 	/* no font found: don't load any font and return 0*/
-	EPRINTF("createfont: no height given, fallback search impossible, returning NULL\n");
+	DPRINTF("createfont: no height given, fallback search impossible, returning NULL\n");
 	return 0;
 }
 
@@ -436,7 +439,7 @@
 	}
 
 	/* use strlen for char count when ascii or dbcs*/
-	if(cc == -1 && (flags & MWTF_PACKMASK) == MWTF_ASCII)
+	if(cc == -1 || (flags & MWTF_PACKMASK) == MWTF_ASCII)
 		cc = strlen((char *)str);
 
 	/* convert encoding if required*/
@@ -849,7 +852,7 @@
 	PMWFONT pfont = NULL;
 
 #if HAVE_FREETYPE_2_SUPPORT
-	/* EPRINTF("Nano-X: Font magic = '%c%c%c%c' @ GdCreateFontFromBuffer\n",
+	/* DPRINTF("Nano-X: Font magic = '%c%c%c%c' @ GdCreateFontFromBuffer\n",
 	 * (char) buffer[0], (char) buffer[1], (char) buffer[2], (char) buffer[3]);
 	 */
 
@@ -860,7 +863,7 @@
 	 */
 	pfont = (PMWFONT)freetype2_createfontfrombuffer(buffer, length, height, width);
 	if (!pfont)
-		EPRINTF("GdCreateFontFromBuffer: create failed.\n");
+		DPRINTF("GdCreateFontFromBuffer: create failed.\n");
 #endif
 	return pfont;
 }
@@ -1061,10 +1064,10 @@
 	unsigned short uc16;
 	const char *last = str+sz;
 
-	printf ( "UTF-8 dump:\n" );
+	DPRINTF( "UTF-8 dump:\n" );
 	while ( str < last ) {
 		for ( i=0, n=utf8_len_map[(unsigned char)str[0]]; i < n; i++ )
-			printf ( "%02X", (unsigned char)str[i] );
+			DPRINTF( "%02X", (unsigned char)str[i] );
 		utf8_to_utf16 ( str, n, &uc16 );
 		printf ( ": %04X\n", uc16 );
 		str += n;
diff -urN microwin/src\engine\devimage.c microwin-0.90/src\engine\devimage.c
--- microwin/src\engine\devimage.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devimage.c	Mon Aug 30 09:15:38 2010
@@ -57,7 +57,7 @@
  * Buffered input functions to replace stdio functions
  */
 void
-GdImageBufferInit(buffer_t *buffer, void *startdata, int size)
+GdImageBufferInit(buffer_t *buffer, const void *startdata, int size)
 {
 	buffer->start = startdata;
 	buffer->size = size;
@@ -136,7 +136,7 @@
  * @param flags If nonzero, JPEG images will be loaded as grayscale.  Yuck!
  */
 int
-GdLoadImageFromBuffer(PSD psd, void *buffer, int size, int flags)
+GdLoadImageFromBuffer(PSD psd, const void *buffer, int size, int flags)
 {
 	buffer_t src;
 
@@ -160,7 +160,7 @@
  */
 void
 GdDrawImageFromBuffer(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width,
-	MWCOORD height, void *buffer, int size, int flags)
+	MWCOORD height, const void *buffer, int size, int flags)
 {
 	int id;
 	buffer_t src;
@@ -174,7 +174,8 @@
 	}
 }
 
-#if defined(HAVE_FILEIO)
+#if HAVE_FILEIO
+
 /**
  * Draw an image from a file.
  *
@@ -211,34 +212,39 @@
 int
 GdLoadImageFromFile(PSD psd, char *path, int flags)
 {
-	int fd, id;
+	int fd, id, bytes;
 	struct stat s;
 	void *buffer = 0;
 	buffer_t src;
-  
+#if defined(O_BINARY)
+	fd = open(path, O_RDONLY | O_BINARY);
+#else
 	fd = open(path, O_RDONLY);
+#endif
 	if (fd < 0 || fstat(fd, &s) < 0) {
-		EPRINTF("GdLoadImageFromFile: can't open image: %s\n", path);
+		DPRINTF("GdLoadImageFromFile: can't open image: %s\n", path);
 		return 0;
 	}
 
 #if HAVE_MMAP
 	buffer = mmap(0, s.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
 	if (!buffer) {
-		EPRINTF("GdLoadImageFromFile: Couldn't map image %s\n", path);
+		DPRINTF("GdLoadImageFromFile: Couldn't map image %s\n", path);
 		close(fd);
 		return 0;
 	}
 #else
 	buffer = malloc(s.st_size);
 	if (!buffer) {
-		EPRINTF("GdLoadImageFromFile: Couldn't malloc image %s\n", path);
+		DPRINTF("GdLoadImageFromFile: Couldn't malloc image %s\n", path);
 		close(fd);
 		return 0;
 	}
 
-	if (read(fd, buffer, s.st_size) != s.st_size) {
-		EPRINTF("GdLoadImageFromFile: Couldn't load image %s\n", path);
+	bytes = read(fd, buffer, s.st_size);
+	if (bytes != s.st_size)
+	{
+		DPRINTF("GdLoadImageFromFile: Couldn't load image %s\n", path);
 		close(fd);
 		return 0;
 	}
@@ -312,7 +318,7 @@
 #endif
 
 	if (loadOK == 0) {
-		EPRINTF("GdLoadImageFromFile: unknown image type\n");
+		DPRINTF("GdLoadImageFromFile: unknown image type\n");
 		goto err;		/* image loading error*/
 	}
 	if (loadOK != 1)
@@ -398,7 +404,7 @@
 		image2.palette = pimage->palette;	/* already allocated*/
 		image2.transcolor = pimage->transcolor;
 		if( (image2.imagebits = malloc(image2.pitch*height)) == NULL) {
-			EPRINTF("GdDrawImageToFit: no memory\n");
+			DPRINTF("GdDrawImageToFit: no memory\n");
 			return;
 		}
 
@@ -470,7 +476,7 @@
 		image2.palette = pimage->palette;	/* already allocated*/
 		image2.transcolor = pimage->transcolor;
 		if( (image2.imagebits = malloc(image2.pitch*height)) == NULL) {
-			EPRINTF("GdDrawImageToFit: no memory\n");
+			DPRINTF("GdDrawImageToFit: no memory\n");
 			return;
 		}
 
diff -urN microwin/src\engine\devimage_stretch.c microwin-0.90/src\engine\devimage_stretch.c
--- microwin/src\engine\devimage_stretch.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devimage_stretch.c	Mon Aug 30 09:15:54 2010
@@ -91,7 +91,7 @@
 	MWCLIPRECT full_dst;
 
 	if ( src->bytesperpixel != dst->bytesperpixel ) {
-		EPRINTF("GdStretchImage: bytesperpixel mismatch\n");
+		DPRINTF("GdStretchImage: bytesperpixel mismatch\n");
 		return;
 	}
 
@@ -100,7 +100,7 @@
 		if ( (srcrect->x < 0) || (srcrect->y < 0) ||
 		     ((srcrect->x+srcrect->width) > src->width) ||
 		     ((srcrect->y+srcrect->height) > src->height) ) {
-			EPRINTF("GdStretchImage: invalid source rect\n");
+			DPRINTF("GdStretchImage: invalid source rect\n");
 			return;
 		}
 	} else {
@@ -117,7 +117,7 @@
 		if ( (dstrect->x < 0) || (dstrect->y < 0) ||
 		     ((dstrect->x+dstrect->width) > dst->width) ||
 		     ((dstrect->y+dstrect->height) > dst->height) ) {
-			EPRINTF("GdStretchImage: invalid dest rect\n");
+			DPRINTF("GdStretchImage: invalid dest rect\n");
 			return;
 		}
 	} else {
diff -urN microwin/src\engine\devopen.c microwin-0.90/src\engine\devopen.c
--- microwin/src\engine\devopen.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devopen.c	Mon Aug 30 09:16:28 2010
@@ -167,6 +167,7 @@
 void 
 GdCloseScreen(PSD psd)
 {
+	assert(psd != NULL);
 	psd->Close(psd);
 }
 
@@ -228,7 +229,7 @@
 	int	i;
 
 	/* no palette management needed if running truecolor*/
-	if(psd->pixtype != MWPF_PALETTE)
+	if(psd->pixtype != MWPF_PALETTE || palette == NULL)
 		return;
 
 	/* bounds check against # of device color entries*/
@@ -323,6 +324,8 @@
 	return GdFindNearestColor(gr_palette, (int)gr_ncolors, c);
 }
 
+#define IABS(x)			((x) < 0 ? -(x) : (x))
+
 /**
  * Search a palette to find the nearest color requested.
  * Uses a weighted squares comparison.
@@ -350,7 +353,7 @@
 		B = rgb->b - b;
 #if 1
 		/* speedy linear distance method*/
-		sq = abs(R) + abs(G) + abs(B);
+		sq = IABS(R) + IABS(G) + IABS(B);
 #else
 		/* slower distance-cubed with luminance adjustment*/
 		/* gray is .30R + .59G + .11B*/
@@ -504,7 +507,7 @@
 int
 GdCaptureScreen(char *path)
 {
-#if defined(HAVE_FILEIO) && !__ECOS
+#if HAVE_FILEIO && !__ECOS
 	int	ifd, i, j;
 	FILE *	ofp;
 	int	cx, cy, extra, bpp, bytespp, ncolors, sizecolortable;
diff -urN microwin/src\engine\devpoly.c microwin-0.90/src\engine\devpoly.c
--- microwin/src\engine\devpoly.c	Thu Aug 26 19:41:52 2010
+++ microwin-0.90/src\engine\devpoly.c	Mon Aug 30 09:17:18 2010
@@ -24,9 +24,9 @@
  */
 
 /* set polygon fill routine*/
-#define EDGEPOLYFILL	1	/* edge table, malloc, qsort*/
+#define EDGEPOLYFILL	0	/* edge table, malloc, qsort*/
 #define X11POLYFILL	0	/* X11-derived polygon fill*/
-#define BASICPOLYFILL	0	/* very basic, small polygon fill*/
+#define BASICPOLYFILL	1	/* very basic, small polygon fill*/
 
 /* extern definitions*/
 void drawpoint(PSD psd,MWCOORD x, MWCOORD y);
@@ -542,6 +542,7 @@
 typedef struct {
 	int     x1, y1, x2, y2;
 #if HAVEFLOAT
+#error using float
 	double  x, m;
 #else
 	int     cx, fn, mn, d;
diff -urN microwin/src\engine\devtimer.c microwin-0.90/src\engine\devtimer.c
--- microwin/src\engine\devtimer.c	Thu Aug 26 19:41:54 2010
+++ microwin-0.90/src\engine\devtimer.c	Mon Aug 30 09:18:40 2010
@@ -59,11 +59,25 @@
 #if MW_FEATURE_TIMERS
 
 static MWTIMER *timerlist = NULL;
+
 static struct timeval mainloop_timeout;
 static struct timeval current_time;
 
 static void calculate_timeval(struct timeval *tv, MWTIMEOUT to); 
 static signed long time_to_expiry(struct timeval *t);
+
+#ifdef _MSC_VER
+
+unsigned long __stdcall GetTickCount();
+
+void gettimeofday(struct timeval *tv, void* p)
+{
+	long msec = GetTickCount();
+	tv->tv_sec = msec / 1000;
+	tv->tv_usec = (msec % 1000) * 1000;
+}
+
+#endif
 
 /**
  * Create a new one-shot timer.
diff -urN microwin/src\engine\font_freetype2.c microwin-0.90/src\engine\font_freetype2.c
--- microwin/src\engine\font_freetype2.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\font_freetype2.c	Mon Aug 30 09:21:24 2010
@@ -385,7 +385,7 @@
 
 	if (err != FT_Err_Ok) {
 		freetype2_library = NULL;
-		EPRINTF("Error 0x%x initializing FreeType 2\n", err);
+		DPRINTF("Error 0x%x initializing FreeType 2\n", err);
 		return 0;
 	}
 #if HAVE_FREETYPE_2_CACHE
@@ -396,7 +396,7 @@
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
-		EPRINTF("Error 0x%x initializing FreeType 2 cache system\n", err);
+		DPRINTF("Error 0x%x initializing FreeType 2 cache system\n", err);
 		return 0;
 	}
 
@@ -407,7 +407,7 @@
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
-		EPRINTF("Error 0x%x initializing FreeType 2 sbit cache system\n", err);
+		DPRINTF("Error 0x%x initializing FreeType 2 sbit cache system\n", err);
 		return 0;
 	}
 #if HAVE_FREETYPE_2_CMAP_CACHE
@@ -419,7 +419,7 @@
 		freetype2_cache_manager = NULL;
 		FT_Done_FreeType(freetype2_library);
 		freetype2_library = NULL;
-		EPRINTF("Error 0x%x initializing FreeType 2 cmap cache system\n", err);
+		DPRINTF("Error 0x%x initializing FreeType 2 cmap cache system\n", err);
 		return 0;
 	}
 #endif
@@ -642,7 +642,7 @@
 	if (filename) {
 		error = FT_New_Face(freetype2_library, filename, 0, &pf->face);
 		if (error != FT_Err_Ok) {
-			//EPRINTF("freetype2_createfont_internal: Can't load font from file '%s', error 0x%x\n",
+			//DPRINTF("freetype2_createfont_internal: Can't load font from file '%s', error 0x%x\n",
 			        //filename, error);
 			goto out;
 		}
@@ -650,14 +650,14 @@
 		error = FT_New_Memory_Face(freetype2_library,
 		    faceid->data.buffer.data, faceid->data.buffer.length, 0, &pf->face);
 		if (error != FT_Err_Ok) {
-			EPRINTF("freetype2_createfont_internal: Can't load font from memory, error 0x%x\n", error);
+			DPRINTF("freetype2_createfont_internal: Can't load font from memory, error 0x%x\n", error);
 			goto out;
 		}
 	}
 
 	error = FT_Select_Charmap(pf->face, ft_encoding_unicode);
 	if (error != FT_Err_Ok) {
-		EPRINTF("freetype2_createfont_internal: No unicode map table, error 0x%x\n", error);
+		DPRINTF("freetype2_createfont_internal: No unicode map table, error 0x%x\n", error);
 		goto out;
 	}
 #endif
@@ -687,7 +687,7 @@
 	pf->imagedesc.height = pf->font.pix_height;
 #endif
 	if (error != FT_Err_Ok) {
-		//EPRINTF("freetype2_createfont_internal: error 0x%x trying to load font.\n", error);
+		//DPRINTF("freetype2_createfont_internal: error 0x%x trying to load font.\n", error);
 		free(pf);
 		return NULL;
 	}
@@ -1065,7 +1065,7 @@
 	pf->imagedesc.height = pf->font.pix_height;
 #endif
 	if (error) {
-		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
+		DPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		return FALSE;
 	}
 #else
@@ -1174,7 +1174,7 @@
 	pf->imagedesc.height = pf->font.pix_height;
 #endif
 	if (error) {
-		EPRINTF("Freetype2 error 0x%x getting font for drawtext.\n", error);
+		DPRINTF("Freetype2 error 0x%x getting font for drawtext.\n", error);
 		return;
 	}
 #else
@@ -1461,7 +1461,7 @@
 	pf->imagedesc.height = pf->font.pix_height;
 #endif
 	if (error) {
-		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
+		DPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		*pwidth = 0;
 		*pheight = 0;
 		*pbase = 0;
@@ -1602,7 +1602,7 @@
 	pf->imagedesc.height = pf->font.pix_height;
 #endif
 	if (error) {
-		EPRINTF("Freetype2 error 0x%x getting font info.\n", error);
+		DPRINTF("Freetype2 error 0x%x getting font info.\n", error);
 		*pwidth = 0;
 		*pheight = 0;
 		*pbase = 0;
diff -urN microwin/src\engine\font_pcf.c microwin-0.90/src\engine\font_pcf.c
--- microwin/src\engine\font_pcf.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\font_pcf.c	Mon Aug 30 09:22:06 2010
@@ -66,7 +66,7 @@
 #define FREAD(file, buffer, size)   gzread(file, buffer, size)
 #define FSEEK(file, offset, whence) gzseek(file, offset, whence)
 #define FCLOSE(file)                gzclose(file)
-#else
+#else if HAVE_FILEIO
 #define FILEP  FILE *
 #define FOPEN(path, mode)           fopen(path, mode)
 #define FREAD(file, buffer, size)   fread(buffer, 1, size, file)
diff -urN microwin/src\engine\font_pcf.org microwin-0.90/src\engine\font_pcf.org
--- microwin/src\engine\font_pcf.org	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\engine\font_pcf.org	Sat Jan 09 15:33:16 2010
@@ -0,0 +1,696 @@
+/* 
+ * PCF font engine for Microwindows
+ * Copyright (c) 2002, 2003 Greg Haerr <greg@censoft.com>
+ * Copyright (c) 2001, 2002 by Century Embedded Technologies
+ *
+ * Supports dynamically loading .pcf and pcf.gz X11 fonts
+ *
+ * Written by Jordan Crouse
+ * Bugfixed by Greg Haerr
+ *
+ * 28.01.2003:
+ *   Patch for big-endian-machines by Klaus Fuerth <Fuerth.ELK@gmx.de>
+ */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "swap.h"
+#include "device.h"
+#include "devfont.h"
+#include "../drivers/genfont.h"
+
+extern MWPIXELVAL gr_background;
+extern MWBOOL gr_usebg;
+
+/* The user hase the option including ZLIB and being able to    */
+/* directly read compressed .pcf files, or to omit it and save  */
+/* space.  The following defines make life much easier          */
+#if HAVE_PCFGZ_SUPPORT
+#include <zlib.h>
+#define FILEP gzFile
+#define FOPEN(path, mode)           gzopen(path, mode)
+#define FREAD(file, buffer, size)   gzread(file, buffer, size)
+#define FSEEK(file, offset, whence) gzseek(file, offset, whence)
+#define FCLOSE(file)                gzclose(file)
+#else
+#define FILEP  FILE *
+#define FOPEN(path, mode)           fopen(path, mode)
+#define FREAD(file, buffer, size)   fread(buffer, 1, size, file)
+#define FSEEK(file, offset, whence) fseek(file, offset, whence)
+#define FCLOSE(file)                fclose(file)
+#endif
+
+/* Handling routines for PCF fonts, use MWCOREFONT structure */
+static void pcf_unloadfont(PMWFONT font);
+
+/* these procs used when font ASCII indexed*/
+static MWFONTPROCS pcf_fontprocs = {
+	MWTF_ASCII,
+	gen_getfontinfo,
+	gen_gettextsize,
+	gen_gettextbits,
+	pcf_unloadfont,
+	corefont_drawtext,
+	NULL,			/* setfontsize */
+	NULL,			/* setfontrotation */
+	NULL,			/* setfontattr */
+};
+
+/* these procs used when font requires UC16 index*/
+static MWFONTPROCS pcf_fontprocs16 = {
+	MWTF_UC16,		/* routines expect unicode 16 */
+	gen_getfontinfo,
+	gen16_gettextsize,
+	gen_gettextbits,
+	pcf_unloadfont,
+	gen16_drawtext,
+	NULL,			/* setfontsize */
+	NULL,			/* setfontrotation */
+	NULL,			/* setfontattr */
+	NULL,			/* duplicate not yet implemented */
+};
+
+/* These are maintained statically for ease FIXME*/
+static struct toc_entry *toc;
+static unsigned long toc_size;
+
+/* Various definitions from the Free86 PCF code */
+#define PCF_FILE_VERSION	(('p'<<24)|('c'<<16)|('f'<<8)|1)
+#define PCF_PROPERTIES		(1 << 0)
+#define PCF_ACCELERATORS	(1 << 1)
+#define PCF_METRICS		(1 << 2)
+#define PCF_BITMAPS		(1 << 3)
+#define PCF_INK_METRICS		(1 << 4)
+#define PCF_BDF_ENCODINGS	(1 << 5)
+#define PCF_SWIDTHS		(1 << 6)
+#define PCF_GLYPH_NAMES		(1 << 7)
+#define PCF_BDF_ACCELERATORS	(1 << 8)
+#define PCF_FORMAT_MASK		0xFFFFFF00
+#define PCF_DEFAULT_FORMAT	0x00000000
+
+#define PCF_GLYPH_PAD_MASK	(3<<0)
+#define PCF_BYTE_MASK		(1<<2)
+#define PCF_BIT_MASK		(1<<3)
+#define PCF_SCAN_UNIT_MASK	(3<<4)
+#define GLYPHPADOPTIONS		4
+
+#define PCF_LSB_FIRST		0
+#define PCF_MSB_FIRST		1
+
+/* A few structures that define the various fields within the file */
+struct toc_entry {
+	int type;
+	int format;
+	int size;
+	int offset;
+};
+
+struct prop_entry {
+	unsigned int name;
+	unsigned char is_string;
+	unsigned int value;
+};
+
+struct string_table {
+	unsigned char *name;
+	unsigned char *value;
+};
+
+struct metric_entry {
+	short leftBearing;
+	short rightBearing;
+	short width;
+	short ascent;
+	short descent;
+	short attributes;
+};
+
+struct encoding_entry {
+	unsigned short min_byte2;	/* min_char or min_byte2 */
+	unsigned short max_byte2;	/* max_char or max_byte2 */
+	unsigned short min_byte1;	/* min_byte1 (hi order) */
+	unsigned short max_byte1;	/* max_byte1 (hi order) */
+	unsigned short defaultchar;
+	unsigned long count;		/* count of map entries */
+	unsigned short *map;		/* font index -> glyph index */
+};
+
+/* This is used to quickly reverse the bits in a field */
+static unsigned char _reverse_byte[0x100] = {
+	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+/*
+ *	Invert bit order within each BYTE of an array.
+ */
+static void
+bit_order_invert(unsigned char *buf, int nbytes)
+{
+	for (; --nbytes >= 0; buf++)
+		*buf = _reverse_byte[*buf];
+}
+
+/*
+ *	Invert byte order within each 16-bits of an array.
+ */
+void
+two_byte_swap(unsigned char *buf, int nbytes)
+{
+	unsigned char c;
+
+	for (; nbytes > 0; nbytes -= 2, buf += 2) {
+		c = buf[0];
+		buf[0] = buf[1];
+		buf[1] = c;
+	}
+}
+
+/*
+ *	Invert byte order within each 32-bits of an array.
+ */
+void
+four_byte_swap(unsigned char *buf, int nbytes)
+{
+	unsigned char c;
+
+	for (; nbytes > 0; nbytes -= 4, buf += 4) {
+		c = buf[0];
+		buf[0] = buf[3];
+		buf[3] = c;
+		c = buf[1];
+		buf[1] = buf[2];
+		buf[2] = c;
+	}
+}
+
+/* read an 8 bit byte*/
+static unsigned short
+readINT8(FILEP file)
+{
+	unsigned char b;
+
+	FREAD(file, &b, sizeof(b));
+	return b;
+}
+
+/* read a 16-bit integer LSB16 format*/
+static unsigned short
+readLSB16(FILEP file)
+{
+	unsigned short s;
+
+	FREAD(file, &s, sizeof(s));
+	return wswap(s);
+}
+
+/* read a 32-bit integer LSB32 format*/
+static unsigned long
+readLSB32(FILEP file)
+{
+	unsigned long n;
+
+	FREAD(file, &n, sizeof(n));
+	return dwswap(n);
+}
+
+/* Get the offset of the given field */
+static int
+pcf_get_offset(int item)
+{
+	int i;
+
+	for (i = 0; i < toc_size; i++)
+		if (item == toc[i].type)
+			return toc[i].offset;
+	return -1;
+}
+
+#if LATER
+/* Read the properties from the file */
+static int
+pcf_readprops(FILEP file, struct prop_entry **prop,
+	      struct string_table **strings)
+{
+	long offset;
+	unsigned long format;
+	unsigned long num_props;
+	unsigned long ssize;
+	unsigned long i;
+	struct string_table *s;
+	struct prop_entry *p;
+
+	unsigned char *string_buffer, *spos;
+
+	if ((offset = pcf_get_offset(PCF_PROPERTIES)) == -1)
+		return (-1);
+	FSEEK(file, offset, SEEK_SET);
+
+	format = readLSB32(file);
+	num_props = readLSB32(file);
+
+	p = *prop = (struct prop_entry *) malloc(num_props *
+					     sizeof(struct prop_entry));
+
+	for (i = 0; i < num_props; i++) {
+		p[i].name = readLSB32(file);
+		p[i].is_string = readINT8(file);
+		p[i].value = readLSB32(file);
+	}
+
+	/* Pad to 32 bit multiples */
+	if (num_props & 3)
+		FSEEK(file, 4 - (num_props & 3), SEEK_CUR);
+
+
+	/* Read the entire set of strings into memory */
+	ssize = readLSB32(file);
+	spos = string_buffer = (unsigned char *) ALLOCA(ssize);
+	FREAD(file, string_buffer, ssize);
+
+	/* Allocate the group of strings */
+	s = *strings = (struct string_table *) ALLOCA(num_props *
+					       sizeof(struct string_table));
+
+	for (i = 0; i < num_props; i++) {
+		s[i].name = (unsigned char *) strdup(spos);
+		spos += strlen(s[i].name) + 1;
+
+		if (p[i].is_string) {
+			s[i].value = (unsigned char *) strdup(spos);
+			spos += strlen(s[i].value) + 1;
+		} else
+			s[i].value = 0;
+	}
+
+	FREEA(string_buffer);
+	return num_props;
+}
+#endif
+
+/* Read the actual bitmaps into memory */
+static int
+pcf_readbitmaps(FILEP file, unsigned char **bits, int *bits_size,
+	unsigned long **offsets)
+{
+	long offset;
+	unsigned long format;
+	unsigned long num_glyphs;
+	unsigned long pad;
+	unsigned int i;
+	int endian;
+	unsigned long *o;
+	unsigned char *b;
+	unsigned long bmsize[GLYPHPADOPTIONS];
+
+	if ((offset = pcf_get_offset(PCF_BITMAPS)) == -1)
+		return -1;
+	FSEEK(file, offset, SEEK_SET);
+
+	format = readLSB32(file);
+	endian = (format & PCF_BIT_MASK)? PCF_LSB_FIRST: PCF_MSB_FIRST;
+
+	num_glyphs = readLSB32(file);
+
+	o = *offsets = (unsigned long *)malloc(num_glyphs * sizeof(unsigned long));
+	for (i=0; i < num_glyphs; ++i)
+		o[i] = readLSB32(file);
+
+	for (i=0; i < GLYPHPADOPTIONS; ++i)
+		bmsize[i] = readLSB32(file);
+
+	pad = format & PCF_GLYPH_PAD_MASK;
+	*bits_size = bmsize[pad]? bmsize[pad] : 1;
+
+	/* alloc and read bitmap data*/
+	b = *bits = (unsigned char *) malloc(*bits_size);
+	FREAD(file, b, *bits_size);
+
+	/* convert bitmaps*/
+	bit_order_invert(b, *bits_size);
+#if MW_CPU_BIG_ENDIAN
+	if (endian == PCF_LSB_FIRST)
+		two_byte_swap(b, *bits_size);
+#else
+	if (endian == PCF_MSB_FIRST)
+		two_byte_swap(b, *bits_size);
+#endif
+	return num_glyphs;
+}
+
+/* read character metric data*/
+static int
+pcf_readmetrics(FILE * file, struct metric_entry **metrics)
+{
+	long i, size, offset;
+	unsigned long format;
+	struct metric_entry *m;
+
+	if ((offset = pcf_get_offset(PCF_METRICS)) == -1)
+		return -1;
+	FSEEK(file, offset, SEEK_SET);
+
+	format = readLSB32(file);
+
+	if ((format & PCF_FORMAT_MASK) == PCF_DEFAULT_FORMAT) {
+		size = readLSB32(file);		/* 32 bits - Number of metrics*/
+
+		m = *metrics = (struct metric_entry *) malloc(size *
+			sizeof(struct metric_entry));
+
+		for (i=0; i < size; i++) {
+			m[i].leftBearing = readLSB16(file);
+			m[i].rightBearing = readLSB16(file);
+			m[i].width = readLSB16(file);
+			m[i].ascent = readLSB16(file);
+			m[i].descent = readLSB16(file);
+			m[i].attributes = readLSB16(file);
+		}
+	} else {
+		size = readLSB16(file);		/* 16 bits - Number of metrics*/
+
+		m = *metrics = (struct metric_entry *) malloc(size *
+			sizeof(struct metric_entry));
+
+		for (i = 0; i < size; i++) {
+			m[i].leftBearing = readINT8(file) - 0x80;
+			m[i].rightBearing = readINT8(file) - 0x80;
+			m[i].width = readINT8(file) - 0x80;
+			m[i].ascent = readINT8(file) - 0x80;
+			m[i].descent = readINT8(file) - 0x80;
+		}
+	}
+	return size;
+}
+
+/* read encoding table*/
+static int
+pcf_read_encoding(FILE * file, struct encoding_entry **encoding)
+{
+	long offset, n;
+	unsigned long format;
+	struct encoding_entry *e;
+
+	if ((offset = pcf_get_offset(PCF_BDF_ENCODINGS)) == -1)
+		return -1;
+	FSEEK(file, offset, SEEK_SET);
+
+	format = readLSB32(file);
+
+	e = *encoding = (struct encoding_entry *)
+		malloc(sizeof(struct encoding_entry));
+	e->min_byte2 = readLSB16(file);
+	e->max_byte2 = readLSB16(file);
+	e->min_byte1 = readLSB16(file);
+	e->max_byte1 = readLSB16(file);
+	e->defaultchar = readLSB16(file);
+	e->count = (e->max_byte2 - e->min_byte2 + 1) *
+		(e->max_byte1 - e->min_byte1 + 1);
+	e->map = (unsigned short *) malloc(e->count * sizeof(unsigned short));
+	DPRINTF("def char %d (%x)\n", e->defaultchar, e->defaultchar);
+
+	for (n = 0; n < e->count; ++n) {
+		e->map[n] = readLSB16(file);
+		/*DPRINTF("ncode %x (%c) %x\n", n, n, e->map[n]);*/
+	}
+	DPRINTF("size %d byte1 %d,%d byte2 %d,%d\n", e->count,
+		e->min_byte1, e->max_byte1, e->min_byte2, e->max_byte2);
+	return e->count;
+}
+
+static int
+pcf_read_toc(FILE * file, struct toc_entry **toc, unsigned long *size)
+{
+	long i;
+	unsigned long version;
+	struct toc_entry *t;
+
+	FSEEK(file, 0, SEEK_SET);
+
+	/* Verify the version */
+	version = readLSB32(file);
+	if (version != PCF_FILE_VERSION)
+		return -1;
+
+	*size = readLSB32(file);
+	t = *toc = (struct toc_entry *) calloc(sizeof(struct toc_entry), *size);
+	if (!t)
+		return -1;
+
+	/* Read in the entire table of contents */
+	for (i=0; i<*size; ++i) {
+		t[i].type = readLSB32(file);
+		t[i].format = readLSB32(file);
+		t[i].size = readLSB32(file);
+		t[i].offset = readLSB32(file);
+	}
+
+	return 0;
+}
+
+PMWCOREFONT
+pcf_createfont(const char *name, MWCOORD height, int attr)
+{
+	FILE *file = 0;
+	MWCOREFONT *pf = 0;
+	int offset;
+	int i;
+	int count;
+	int bsize;
+	int bwidth;
+	int err = 0;
+	struct metric_entry *metrics = 0;
+	struct encoding_entry *encoding = 0;
+	MWIMAGEBITS *output;
+	unsigned char *glyphs = 0;
+	unsigned long *glyphs_offsets = 0;
+	int max_width = 0, max_descent = 0, max_ascent = 0, max_height = 0;
+	int glyph_count;
+	unsigned long *goffset = NULL;
+	unsigned char *gwidth = NULL;
+	int uc16;
+	char fname[256];
+
+	/* Try to open the file */
+	file = FOPEN(name, "rb");
+	if (!file) {
+		strcpy(fname, PCF_FONT_DIR "/");
+		strcpy(fname + sizeof(PCF_FONT_DIR), name);
+		file = FOPEN(fname, "rb");
+	}
+	if (!file)
+		return NULL;
+
+	if (!(pf = (MWCOREFONT *) malloc(sizeof(MWCOREFONT)))) {
+		err = -1;
+		goto leave_func;
+	}
+
+	if (!(pf->cfont = (PMWCFONT) calloc(sizeof(MWCFONT), 1))) {
+		err = -1;
+		goto leave_func;
+	}
+
+
+	/* Read the table of contents */
+	if (pcf_read_toc(file, &toc, &toc_size) == -1) {
+		err = -1;
+		goto leave_func;
+	}
+
+	/* Now, read in the bitmaps */
+	glyph_count = pcf_readbitmaps(file, &glyphs, &bsize, &glyphs_offsets);
+	DPRINTF("glyph_count = %d (%x)\n", glyph_count, glyph_count);
+
+	if (glyph_count == -1) {
+		err = -1;
+		goto leave_func;
+	}
+
+	if (pcf_read_encoding(file, &encoding) == -1) {
+		err = -1;
+		goto leave_func;
+	}
+
+	pf->cfont->firstchar = encoding->min_byte2 * (encoding->min_byte1 + 1);
+
+	/* Read in the metrics */
+	count = pcf_readmetrics(file, &metrics);
+
+	/* Calculate various maximum values */
+	for (i = 0; i < count; i++) {
+		if (metrics[i].width > max_width)
+			max_width = metrics[i].width;
+		if (metrics[i].ascent > max_ascent)
+			max_ascent = metrics[i].ascent;
+		if (metrics[i].descent > max_descent)
+			max_descent = metrics[i].descent;
+	}
+	max_height = max_ascent + max_descent;
+
+	pf->cfont->maxwidth = max_width;
+	pf->cfont->height = max_height;
+	pf->cfont->ascent = max_ascent;
+
+	/* Allocate enough room to hold all of the bits and the offsets */
+	bwidth = (max_width + 15) / 16;
+
+	pf->cfont->bits = (MWIMAGEBITS *) calloc((max_height *
+		(sizeof(MWIMAGEBITS) * bwidth)), glyph_count);
+	goffset = (unsigned long *) malloc(glyph_count *
+		sizeof(unsigned long));
+	gwidth = (unsigned char *) malloc(glyph_count * sizeof(unsigned char));
+
+	output = (MWIMAGEBITS *) pf->cfont->bits;
+	offset = 0;
+
+	/* copy and convert from packed BDF format to MWCFONT format*/
+	for (i = 0; i < glyph_count; i++) {
+		int h, w;
+		int y = max_height;
+		unsigned long *ptr =
+			(unsigned long *) (glyphs + glyphs_offsets[i]);
+
+		/* # words image width*/
+		int lwidth = (metrics[i].width + 15) / 16;
+
+		/* # words image width, corrected for bounding box problem*/
+		int xwidth = (metrics[i].rightBearing - metrics[i].leftBearing + 15) / 16;
+
+		gwidth[i] = (unsigned char) metrics[i].width;
+		goffset[i] = offset;
+
+		offset += (lwidth * max_height);
+
+		for (h = 0; h < (max_ascent - metrics[i].ascent); h++) {
+			for (w = 0; w < lwidth; w++)
+				*output++ = 0;
+			y--;
+		}
+
+		for (h = 0; h < (metrics[i].ascent + metrics[i].descent); h++) {
+				unsigned short *val = (unsigned short *) ptr;
+				int            bearing, carry_shift;
+				unsigned short carry = 0;
+
+				/* leftBearing correction*/
+				bearing = metrics[i].leftBearing;
+				if (bearing < 0)	/* negative bearing not handled yet*/
+					bearing = 0;
+				carry_shift = 16 - bearing;
+         
+				for (w = 0; w < lwidth; w++) {
+					*output++ = (val[w] >> bearing) | carry;
+					carry = val[w] << carry_shift;
+				}
+				ptr += (xwidth + 1) / 2;
+				y--;
+		}
+
+		for (; y > 0; y--)
+			for (w = 0; w < lwidth; w++)
+				*output++ = 0;
+	}
+
+	/* reorder offsets and width according to encoding map */
+	pf->cfont->offset = (unsigned long *) malloc(encoding->count *
+		sizeof(unsigned long));
+	pf->cfont->width = (unsigned char *) malloc(encoding->count *
+		 sizeof(unsigned char));
+	for (i = 0; i < encoding->count; ++i) {
+		unsigned short n = encoding->map[i];
+		if (n == 0xffff)	/* map non-existent chars to default char */
+			n = encoding->map[encoding->defaultchar];
+		((unsigned long *)pf->cfont->offset)[i] = goffset[n];
+		((unsigned char *)pf->cfont->width)[i] = gwidth[n];
+	}
+	pf->cfont->size = encoding->count;
+
+	uc16 = pf->cfont->firstchar > 255 || 
+		(pf->cfont->firstchar + pf->cfont->size) > 255;
+	pf->fontprocs = uc16? &pcf_fontprocs16: &pcf_fontprocs;
+	pf->fontsize = pf->fontrotation = pf->fontattr = 0;
+	pf->name = "PCF";
+
+leave_func:
+	if (goffset)
+		free(goffset);
+	if (gwidth)
+		free(gwidth);
+	if (encoding) {
+		if (encoding->map)
+			free(encoding->map);
+		free(encoding);
+	}
+	if (metrics)
+		free(metrics);
+	if (glyphs)
+		free(glyphs);
+	if (glyphs_offsets)
+		free(glyphs_offsets);
+
+	if (toc)
+		free(toc);
+	toc = 0;
+	toc_size = 0;
+
+	if (file)
+		FCLOSE(file);
+
+	if (err == 0 && pf)
+		return pf;
+
+	pcf_unloadfont((PMWFONT)pf);
+	return 0;
+}
+
+void
+pcf_unloadfont(PMWFONT font)
+{
+	PMWCOREFONT pf = (PMWCOREFONT) font;
+	PMWCFONT    pfc = pf->cfont;
+
+	if (pfc) {
+		if (pfc->width)
+			free((char *)pf->cfont->width);
+		if (pfc->offset)
+			free((char *)pf->cfont->offset);
+		if (pfc->bits)
+			free((char *)pf->cfont->bits);
+
+		free(pf->cfont);
+	}
+
+	free(font);
+}
diff -urN microwin/src\engine\image_bmp.c microwin-0.90/src\engine\image_bmp.c
--- microwin/src\engine\image_bmp.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_bmp.c	Mon Aug 30 09:23:34 2010
@@ -214,7 +214,7 @@
 			pimage->palsize = 1 << pimage->bpp;
 		compression = bmpi.BiCompression;
 	}
-printf("bmp bpp %d\n", pimage->bpp);
+DPRINTF("bmp bpp %d\n", pimage->bpp);
 	pimage->compression = MWIMAGE_RGB;	/* right side up, BGR order will be converted to RGB*/
 	pimage->data_format = 0;		/* force GdDrawImage for now*/
 	pimage->planes = 1;
@@ -229,7 +229,7 @@
 	case 32:
 		break;
 	default:
-		EPRINTF("GdDecodeBMP: image bpp not 1, 4, 8, 16, 24 or 32\n");
+		DPRINTF("GdDecodeBMP: image bpp not 1, 4, 8, 16, 24 or 32\n");
 		return 2;	/* image loading error*/
 	}
 
@@ -269,9 +269,9 @@
 		/* else it's 5/6/5 format, no flag required*/
 	}
 
-//	printf("BMP format %d bpp", pimage->bpp);
+//	DPRINTF("BMP format %d bpp", pimage->bpp);
 //	if (pimage->compression & MWIMAGE_555) printf(" 5/5/5");
-//	printf("\n");
+//	DPRINTF("\n");
 
 	/* decode image data*/
 	GdImageBufferSeekTo(src, bmpf.bfOffBits);
@@ -303,7 +303,7 @@
 	return 1;		/* bmp image ok*/
 	
 err:
-	EPRINTF("GdDecodeBMP: image loading error\n");
+	DPRINTF("GdDecodeBMP: image loading error\n");
 	if(pimage->imagebits)
 		free(pimage->imagebits);
 	if(pimage->palette)
diff -urN microwin/src\engine\image_gif.c microwin-0.90/src\engine\image_gif.c
--- microwin/src\engine\image_gif.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_gif.c	Mon Aug 30 09:23:40 2010
@@ -115,7 +115,7 @@
     version[3] = '\0';
 
     if (strcmp(version, "87a") != 0 && strcmp(version, "89a") != 0) {
-	EPRINTF("GdDecodeGIF: GIF version number not 87a or 89a\n");
+	DPRINTF("GdDecodeGIF: GIF version number not 87a or 89a\n");
         return 2;		/* image loading error*/
     }
     Gif89.transparent = MWNOCOLOR;
@@ -124,7 +124,7 @@
     Gif89.disposal = 0;
 
     if (!ReadOK(src, buf, 7)) {
-	EPRINTF("GdDecodeGIF: bad screen descriptor\n");
+	DPRINTF("GdDecodeGIF: bad screen descriptor\n");
         return 2;		/* image loading error*/
     }
     GifScreen.Width = LM_to_uint(buf[0], buf[1]);
@@ -137,25 +137,25 @@
     if (BitSet(buf[4], LOCALCOLORMAP)) {	/* Global Colormap */
 	if (ReadColorMap(src, GifScreen.BitPixel, GifScreen.ColorMap,
 			 &GifScreen.GrayScale)) {
-	    EPRINTF("GdDecodeGIF: bad global colormap\n");
+	    DPRINTF("GdDecodeGIF: bad global colormap\n");
             return 2;		/* image loading error*/
 	}
     }
 
     do {
 	if (!ReadOK(src, &c, 1)) {
-	    EPRINTF("GdDecodeGIF: EOF on image data\n");
+	    DPRINTF("GdDecodeGIF: EOF on image data\n");
             goto done;
 	}
 	if (c == ';') {		/* GIF terminator */
 	    if (imageCount < imageNumber) {
-		EPRINTF("GdDecodeGIF: no image %d of %d\n", imageNumber,imageCount);
+		DPRINTF("GdDecodeGIF: no image %d of %d\n", imageNumber,imageCount);
                 goto done;
 	    }
 	}
 	if (c == '!') {		/* Extension */
 	    if (!ReadOK(src, &c, 1)) {
-		EPRINTF("GdDecodeGIF: EOF on extension function code\n");
+		DPRINTF("GdDecodeGIF: EOF on extension function code\n");
                 goto done;
 	    }
 	    DoExtension(src, c);
@@ -167,7 +167,7 @@
 	++imageCount;
 
 	if (!ReadOK(src, buf, 9)) {
-	    EPRINTF("GdDecodeGIF: bad image size\n");
+	    DPRINTF("GdDecodeGIF: bad image size\n");
             goto done;
 	}
 	useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);
@@ -176,7 +176,7 @@
 
 	if (!useGlobalColormap) {
 	    if (ReadColorMap(src, bitPixel, localColorMap, &grayScale)) {
-		EPRINTF("GdDecodeGIF: bad local colormap\n");
+		DPRINTF("GdDecodeGIF: bad local colormap\n");
                 goto done;
 	    }
 	    ok = ReadImage(src, pimage, LM_to_uint(buf[4], buf[5]),
@@ -303,7 +303,7 @@
     if ((curbit + code_size) >= lastbit) {
 	if (done) {
 	    if (curbit >= lastbit)
-		EPRINTF("GdDecodeGIF: bad decode\n");
+		DPRINTF("GdDecodeGIF: bad decode\n");
 	    return -1;
 	}
 	buf[0] = buf[last_byte - 2];
@@ -395,7 +395,7 @@
 
 	    if (count != 0) {
 		/*
-		 * EPRINTF("missing EOD in data stream (common occurence)");
+		 * DPRINTF("missing EOD in data stream (common occurence)");
 		 */
 	    }
 	    return -2;
@@ -409,7 +409,7 @@
 	while (code >= clear_code) {
 	    *sp++ = table[1][code];
 	    if (code == table[0][code])
-		EPRINTF("GdDecodeGIF: circular table entry\n");
+		DPRINTF("GdDecodeGIF: circular table entry\n");
 	    code = table[0][code];
 	}
 
@@ -446,11 +446,11 @@
      *	Initialize the compression routines
      */
     if (!ReadOK(src, &c, 1)) {
-	EPRINTF("GdDecodeGIF: EOF on image data\n");
+	DPRINTF("GdDecodeGIF: EOF on image data\n");
 	return 0;
     }
     if (LWZReadByte(src, TRUE, c) < 0) {
-	EPRINTF("GdDecodeGIF: error reading image\n");
+	DPRINTF("GdDecodeGIF: error reading image\n");
 	return 0;
     }
 
diff -urN microwin/src\engine\image_jpeg.c microwin-0.90/src\engine\image_jpeg.c
--- microwin/src\engine\image_jpeg.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_jpeg.c	Mon Aug 30 09:23:46 2010
@@ -192,7 +192,7 @@
 		pimage->data_format = MWIF_RGB888;
 	else pimage->data_format = 0;		/* force GdDrawImage for now*/
 	pimage->compression = MWIMAGE_RGB;	/* RGB not BGR order*/
-printf("jpeg bpp %d\n", pimage->bpp);
+DPRINTF("jpeg bpp %d\n", pimage->bpp);
 	GdComputeImagePitch(pimage->bpp, pimage->width, &pimage->pitch, &pimage->bytesperpixel);
 	pimage->palsize = (pimage->bpp == 8)? 256: 0;
 	pimage->imagebits = malloc(pimage->pitch * pimage->height);
diff -urN microwin/src\engine\image_png.c microwin-0.90/src\engine\image_png.c
--- microwin/src\engine\image_png.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_png.c	Mon Aug 30 09:23:52 2010
@@ -147,7 +147,7 @@
 	else if (channels == 3)
 		pimage->data_format = MWIF_RGB888;
 	else pimage->data_format = 0;		/* will use slow GdDrawImage*/
-printf("png %dbpp\n", channels*8);
+DPRINTF("png %dbpp\n", channels*8);
 
 	if (alpha_present)
 		pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
@@ -173,7 +173,7 @@
 	return 1;
 
 nomem:
-	EPRINTF("GdDecodePNG: Out of memory\n");
+	DPRINTF("GdDecodePNG: Out of memory\n");
 	return 2;
 }
 #endif /* MW_FEATURE_IMAGES && defined(HAVE_PNG_SUPPORT)*/
diff -urN microwin/src\engine\image_pnm.c microwin-0.90/src\engine\image_pnm.c
--- microwin/src\engine\image_pnm.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_pnm.c	Mon Aug 30 09:23:58 2010
@@ -65,7 +65,7 @@
 				pimage->bpp = 1;
 				gothdrs = 1;
 				if(!(pimage->palette = malloc( sizeof(MWPALENTRY) * 2))) {
-					EPRINTF("Out of memory\n");
+					DPRINTF("Out of memory\n");
 					return 2;
 				}
 				pimage->palsize = 2;
@@ -87,7 +87,7 @@
 					break;
 				pimage->bpp = 24;
 				if(i > 255) {
-					EPRINTF("GdDecodePNM: PPM files must be 24bpp\n");
+					DPRINTF("GdDecodePNM: PPM files must be 24bpp\n");
 					return 2;
 				}
 				for(scale = 7, n = 2; scale; scale--, n *= 2)
@@ -100,7 +100,7 @@
 	}
 
 	if(!gothdrs) {
-		EPRINTF("GdDecodePNM: bad image headers\n");
+		DPRINTF("GdDecodePNM: bad image headers\n");
 		if(pimage->palette)
 			free(pimage->palette);
 		return 2;
@@ -113,7 +113,7 @@
 		pimage->data_format = MWIF_RGB888;
 	else pimage->data_format = 0;		/* force GdDrawImage for now*/
 	if(!(pimage->imagebits = malloc(pimage->pitch * pimage->height))) {
-		EPRINTF("GdDecodePNM: couldn't allocate memory for image\n");
+		DPRINTF("GdDecodePNM: couldn't allocate memory for image\n");
 		if(pimage->palette)
 			free(pimage->palette);
 		return 2;
@@ -202,7 +202,7 @@
 	}
 
 baddata:
-	EPRINTF("GdDecodePNM: bad image data\n");
+	DPRINTF("GdDecodePNM: bad image data\n");
 	free(pimage->imagebits);
 	if(pimage->palette)
 		free(pimage->palette);
diff -urN microwin/src\engine\image_tiff.c microwin-0.90/src\engine\image_tiff.c
--- microwin/src\engine\image_tiff.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_tiff.c	Mon Aug 30 09:24:02 2010
@@ -103,7 +103,7 @@
 	return 1;
 
 err:
-	EPRINTF("GdDecodeTIFF: image loading error\n");
+	DPRINTF("GdDecodeTIFF: image loading error\n");
 	if (tif)
 		TIFFClose(tif);
 	if(parms.data)
diff -urN microwin/src\engine\image_xpm.c microwin-0.90/src\engine\image_xpm.c
--- microwin/src\engine\image_xpm.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\image_xpm.c	Mon Aug 30 09:24:08 2010
@@ -159,7 +159,7 @@
 				pimage->bpp = 32;
 				pimage->compression = MWIMAGE_RGB | MWIMAGE_ALPHA_CHANNEL;
 				pimage->data_format = MWIF_RGBA8888;
-printf("xpm 32bpp ARGB8888\n");
+DPRINTF("xpm 32bpp ARGB8888\n");
 			}
 
 			pimage->palsize = colors;
@@ -176,7 +176,7 @@
 				pimage->palette = malloc(256 * sizeof(MWPALENTRY));
 
 			if (!colorheap) {
-				EPRINTF("GdDecodeXPM: No mem for palette\n");
+				DPRINTF("GdDecodeXPM: No mem for palette\n");
 				return -1;
 			}
 
diff -urN microwin/src\engine\selfont.c microwin-0.90/src\engine\selfont.c
--- microwin/src\engine\selfont.c	Thu Aug 26 19:41:56 2010
+++ microwin-0.90/src\engine\selfont.c	Wed Aug 25 14:43:00 2010
@@ -585,7 +585,7 @@
 
 	memcpy(&font->lf,lf,sizeof(*lf));
 
-	printf("Adding font: '%s' '%s' '%s' '%s'\n",font->foundry,
+	DPRINTF("Adding font: '%s' '%s' '%s' '%s'\n",font->foundry,
 	       font->family,font->fontname,font->lf.lfFaceName);
 
 	font->next = 0;
@@ -681,7 +681,7 @@
 	MWLF_Clear(&lf);
 
 	if ( argc != 6 ) {
-		fprintf(stderr,"Bad font description %s:%d\n",file,line);
+		DPRINTF("Bad font description %s:%d\n",file,line);
 		return 1;
 	}
 
@@ -717,7 +717,7 @@
 			}
 		}
 
-		fprintf(stderr,"No such font attribute '%s' in %s:%d\n",
+		DPRINTF("No such font attribute '%s' in %s:%d\n",
 			tmp,file,line);
 		return 1;
 
@@ -771,7 +771,7 @@
 	int argc, s, rc, t, line;
 
 	if ( (cf = fopen(file,"r")) == 0 ) {
-		fprintf(stderr,"Unable to read config file '%s'\n",file);
+		DRPINTF("Unable to read config file '%s'\n",file);
 		return -1;
 	}
 
@@ -796,7 +796,7 @@
 				while ( *p != '\0' && *p != '\"' )
 					p++;
 				if ( *p == '\0' ) {
-					fprintf(stderr,"Unbalanced quotes in %s:%d\n",
+					DPRINTF("Unbalanced quotes in %s:%d\n",
 						file,line);
 					break;
 				}
diff -urN microwin/src\include\device.h microwin-0.90/src\include\device.h
--- microwin/src\include\device.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\device.h	Mon Aug 30 09:26:10 2010
@@ -20,7 +20,7 @@
 /* the fontmapper is obsolete, according to Greg */
 #define FONTMAPPER	0			/* =1 for Morten's font mapper*/
 #define FASTJPEG	0			/* =1 for temp quick jpeg 8bpp*/
-#if RTEMS || __ECOS || PSP
+#if RTEMS || __ECOS || PSP || WIN32 || !defined(HAVE_FILEIO)
 #define HAVE_MMAP       0
 #else
 #define HAVE_MMAP       1       /* =1 to use mmap if available*/
@@ -347,13 +347,13 @@
 void	GdCopyArea(PSD psd,MWCOORD srcx,MWCOORD srcy,MWCOORD width,
 		MWCOORD height, MWCOORD destx, MWCOORD desty);
 void	GdBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD width,
-		MWCOORD height,PSD srcpsd,MWCOORD srcx,MWCOORD srcy,int rop);
+		MWCOORD height,PSD srcpsd,MWCOORD srcx,MWCOORD srcy, int32_t rop);
 /***void	GdStretchBlit(PSD dstpsd, MWCOORD dstx, MWCOORD dsty, MWCOORD dstw,
 		MWCOORD dsth, PSD srcpsd, MWCOORD srcx, MWCOORD srcy,
 		MWCOORD srcw, MWCOORD srch, int rop);***/
 void	GdStretchBlitEx(PSD dstpsd, MWCOORD d1_x, MWCOORD d1_y, MWCOORD d2_x,
 		MWCOORD d2_y, PSD srcpsd, MWCOORD s1_x, MWCOORD s1_y,
-		MWCOORD s2_x, MWCOORD s2_y, int rop);
+		MWCOORD s2_x, MWCOORD s2_y, int32_t rop);
 int	GdCalcMemGCAlloc(PSD psd, unsigned int width, unsigned int height,
 		int planes, int bpp, int *size, int *linelen, int *pitch);
 void	drawbitmap(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width, MWCOORD height,
@@ -473,9 +473,9 @@
 
 /* devimage.c */
 #if MW_FEATURE_IMAGES
-int	GdLoadImageFromBuffer(PSD psd, void *buffer, int size, int flags);
+int	GdLoadImageFromBuffer(PSD psd, const void *buffer, int size, int flags);
 void	GdDrawImageFromBuffer(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width,
-		 MWCOORD height, void *buffer, int size, int flags);
+		 MWCOORD height, const void *buffer, int size, int flags);
 void	GdDrawImageFromFile(PSD psd, MWCOORD x, MWCOORD y, MWCOORD width,
 		MWCOORD height, char *path, int flags);
 int	GdLoadImageFromFile(PSD psd, char *path, int flags);
@@ -491,11 +491,11 @@
 
 /* Buffered input functions to replace stdio functions*/
 typedef struct {  /* structure for reading images from buffer   */
-	unsigned char *start;	/* The pointer to the beginning of the buffer */
+	const unsigned char *start;	/* The pointer to the beginning of the buffer */
 	unsigned long offset;	/* The current offset within the buffer       */
 	unsigned long size;	/* The total size of the buffer               */
 } buffer_t;
-void	GdImageBufferInit(buffer_t *buffer, void *startdata, int size);
+void	GdImageBufferInit(buffer_t *buffer, const void *startdata, int size);
 void	GdImageBufferSeekTo(buffer_t *buffer, unsigned long offset);
 int	GdImageBufferRead(buffer_t *buffer, void *dest, unsigned long size);
 int	GdImageBufferGetChar(buffer_t *buffer);
diff -urN microwin/src\include\lock.h microwin-0.90/src\include\lock.h
--- microwin/src\include\lock.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\lock.h	Mon Aug 30 09:26:56 2010
@@ -9,6 +9,9 @@
  * This is necessary since routines nest calls on
  * LOCK(&nxGlobalLock). (nanox/client.c and nanox/nxproto.c)
  */
+#ifndef __LOCK_H__
+#define __LOCK_H__
+
 #if THREADSAFE
 #define THREADSAFE_LINUX	1	/* use linux threadsafe routines*/
 #endif
@@ -81,3 +84,5 @@
 #define LOCK(m)
 #define UNLOCK(m)
 #endif /* !THREADSAFE*/
+
+#endif /* __LOCK_H__ */
diff -urN microwin/src\include\mwindef.h microwin-0.90/src\include\mwindef.h
--- microwin/src\include\mwindef.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\include\mwindef.h	Wed Aug 25 14:35:56 2010
@@ -0,0 +1,184 @@
+/* windef.h*/
+/*
+ * Copyright (c) 1999 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 API base type definitions
+ */
+
+#define _WINDEF_H
+
+
+#ifdef VXWORKS
+/* Don't include the internal Tornado header file <ntcontext.h>, **
+** as the definitions in it conflict with these definitions.     */
+#define __INCntcontexth
+/* Bring in the core VxWorks definitions as they could conflict **
+** with the ones below if they are brought in later.            */
+#include <vxWorks.h>
+#endif
+
+
+#ifndef NULL
+#define NULL    ((void *)0)
+#endif
+
+#ifndef FALSE
+#define FALSE               0
+#endif
+
+#ifndef TRUE
+#define TRUE                1
+#endif
+
+#ifndef NOMINMAX
+#ifndef max
+#define max(a,b)            (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef min
+#define min(a,b)            (((a) < (b)) ? (a) : (b))
+#endif
+#endif  /* NOMINMAX */
+
+#define CALLBACK
+#ifndef WINAPI
+#define WINAPI
+#endif
+#define WINAPIV
+#define APIENTRY    	WINAPI
+#define APIPRIVATE
+#define PASCAL
+
+#define FAR
+#define NEAR
+#define CONST		const
+#define CDECL
+
+#define VOID void
+typedef void *PVOID;
+typedef char CHAR;
+typedef short SHORT;
+typedef long LONG;
+typedef SHORT *PSHORT;  
+typedef LONG *PLONG;    
+
+#ifndef VXWORKS
+typedef unsigned char 		UCHAR;
+typedef unsigned short 		USHORT;
+typedef uint32_t		ULONG;
+#ifndef __ITRON_TYPES_h_ /* FIXME RTEMS hack*/
+typedef unsigned int		UINT;
+#endif
+
+#ifndef __ITRON_TYPES_h_
+#ifndef COMMON_H	 /* MiniGUI hack*/
+typedef int			BOOL;
+#endif
+#endif
+
+#endif /* !VXWORKS*/
+
+typedef ULONG *			PULONG;
+typedef USHORT *		PUSHORT;
+typedef UCHAR *			PUCHAR;
+typedef char *			PSZ;
+#ifndef __ITRON_TYPES_h_
+typedef int                 	INT;
+#endif
+typedef unsigned int        	*PUINT;
+
+typedef uint32_t       DWORD;
+typedef unsigned char       BYTE;
+typedef unsigned short      WORD;
+
+typedef float               FLOAT;
+typedef FLOAT               *PFLOAT;
+typedef BOOL NEAR           *PBOOL;
+typedef BOOL FAR            *LPBOOL;
+typedef BYTE NEAR           *PBYTE;
+typedef BYTE FAR            *LPBYTE;
+typedef int NEAR            *PINT;
+typedef int FAR             *LPINT;
+typedef WORD NEAR           *PWORD;
+typedef WORD FAR            *LPWORD;
+typedef long FAR            *LPLONG;
+typedef DWORD NEAR          *PDWORD;
+typedef DWORD FAR           *LPDWORD;
+typedef void FAR            *LPVOID;
+typedef CONST void FAR      *LPCVOID;
+
+typedef unsigned short WCHAR;
+typedef WCHAR *PWCHAR;
+typedef WCHAR *LPWCH, *PWCH;
+typedef CONST WCHAR *LPCWCH, *PCWCH;
+typedef WCHAR *NWPSTR;
+typedef WCHAR *LPWSTR, *PWSTR;
+typedef CONST WCHAR *LPCWSTR, *PCWSTR;
+
+typedef CHAR *PCHAR;
+typedef CHAR *LPCH, *PCH;
+typedef CONST CHAR *LPCCH, *PCCH;
+typedef CHAR *NPSTR;
+typedef CHAR *LPSTR, *PSTR;
+typedef CONST CHAR *LPCSTR, *PCSTR;
+typedef char TCHAR, *PTCHAR;
+typedef unsigned char TBYTE , *PTBYTE ;
+typedef LPSTR LPTCH, PTCH;
+typedef LPSTR PTSTR, LPTSTR;
+typedef LPCSTR LPCTSTR;
+
+#define __TEXT(quote) quote
+#define TEXT(quote) __TEXT(quote)
+
+typedef int (FAR WINAPI *FARPROC)();
+typedef int (NEAR WINAPI *NEARPROC)();
+typedef int (WINAPI *PROC)();
+
+typedef UINT WPARAM;
+typedef LONG LPARAM;
+typedef LONG LRESULT;
+typedef LONG HRESULT;
+
+#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
+#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
+#define LOWORD(l)           ((WORD)(l))
+#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
+#define LOBYTE(w)           ((BYTE)(w))
+#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))
+
+#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
+
+typedef DWORD   COLORREF;
+typedef DWORD   *LPCOLORREF;
+
+/* handle typedef*/
+typedef PVOID HANDLE;
+
+typedef HANDLE *PHANDLE;
+typedef HANDLE NEAR         *SPHANDLE;
+typedef HANDLE FAR          *LPHANDLE;
+typedef HANDLE              HGLOBAL;
+typedef HANDLE              HLOCAL;
+typedef HANDLE              GLOBALHANDLE;
+typedef HANDLE              LOCALHANDLE;
+
+typedef WORD                ATOM;
+
+typedef struct hwnd *	HWND;
+typedef struct hdc *	HDC;
+typedef struct hcursor *HCURSOR;
+typedef struct hgdiobj *HGDIOBJ;
+typedef struct hgdiobj *HBRUSH;
+typedef struct hgdiobj *HPEN;
+typedef struct hgdiobj *HFONT;
+typedef struct hgdiobj *HBITMAP;
+typedef struct hgdiobj *HRGN;
+typedef struct hgdiobj *HPALETTE;
+typedef HANDLE		HICON;
+typedef HANDLE		HINSTANCE;
+typedef HANDLE		HMODULE;
+typedef HANDLE		HMENU;
+
+/* moved to winuser.h for resource compiler*/
+/*typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);*/
+
diff -urN microwin/src\include\mwindows.h microwin-0.90/src\include\mwindows.h
--- microwin/src\include\mwindows.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\include\mwindows.h	Wed Aug 25 14:35:56 2010
@@ -0,0 +1,167 @@
+#ifndef __WINDOWS_H__
+#define __WINDOWS_H__
+
+/* windows.h*/
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Microwindows Win32 API master public header file
+ * Modifications:
+ *  Date        Author                  Description
+ *  2004/12/07  Gabriele Brugnoni       added lpfnWndProc param on wnd struct, so
+ *                                      SetWindowLong(GWL_WNDPROC) may works on multiple wnd.
+ *  2010/04/23	Ludwig Ertl				Added support for window Props
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mwtypes.h"
+#include "windef.h"
+#include "wingdi.h"
+#include "winfont.h"
+#include "winkbd.h"
+#include "winuser.h"	/* now includes winctl.h for resource compiler*/
+#include "winres.h"
+#include "windlg.h"
+
+
+/* external routines*/
+int WINAPI 	WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
+    			LPSTR lpCmdLine, int nShowCmd);
+
+int		MwUserInit(int ac, char **av);
+
+/* Internal Microwindows non-win32 definitions*/
+
+/* GDI Objects*/
+
+typedef struct {			/* GDI object hdr*/
+	int		type;		/* OBJ_xxx type*/
+	BOOL		stockobj;	/* TRUE if stock (unallocated) object*/
+} MWGDIOBJHDR;
+
+/* gdiobj*/
+struct hgdiobj {
+	MWGDIOBJHDR	hdr;		/* all gdi object start with this hdr*/
+	/* additional data...*/		/* allocated per object type*/
+};
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		style;		/* pen style*/
+	COLORREF	color;		/* pen color*/
+} MWPENOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		style;		/* brush style*/
+	COLORREF	color;		/* brush color*/
+} MWBRUSHOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	PMWFONT		pfont;		/* allocated font*/
+	char		name[32];	/* font name (stock objects only)*/
+} MWFONTOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		width;		/* width*/
+	int		height;		/* height*/
+	int		planes;		/* # planes*/
+	int		bpp;		/* bits per pixel*/
+	int		data_format;/* MWIF_ image data format*/
+	int		linelen;	/* bytes per line (to be deprecated)*/
+	int		pitch;		/* bytes per line*/
+	int		size;		/* allocated size in bytes*/
+	char 		bits[1];	/* beginning of bitmap*/
+} MWBITMAPOBJ;
+
+typedef struct {
+	MWGDIOBJHDR   	hdr;
+	MWCLIPREGION  *	rgn;		/* clip region*/
+} MWRGNOBJ;
+
+/* device context*/
+struct hdc {
+	struct _mwscreendevice *psd;	/* screen or memory device*/
+	HWND		hwnd;		/* associated window*/
+	DWORD		flags;		/* clipping flags*/
+	int		bkmode;		/* background mode*/
+	UINT		textalign;	/* text alignment flags*/
+	MWCOLORVAL	bkcolor;	/* text background color*/
+	MWCOLORVAL	textcolor;	/* text color*/
+	MWBRUSHOBJ *	brush;		/* current brush*/
+	MWPENOBJ *	pen;		/* current pen*/
+	MWFONTOBJ *	font;		/* current font*/
+	MWBITMAPOBJ *	bitmap;		/* current bitmap (mem dc's only)*/
+	MWRGNOBJ *	region;		/* user specified clip region*/
+	int		drawmode;	/* rop2 drawing mode */
+	POINT		pt;		/* current pen pos in client coords*/
+};
+
+/* cursor*/
+struct hcursor {
+	int		usecount;	/* use counter */
+	MWCURSOR	cursor;		/* software cursor definition*/
+};
+
+/* built-in scrollbars*/
+typedef struct {
+	int		minPos;        /* min value of scroll range.*/
+	int		maxPos;        /* max value of scroll range.*/
+	int		curPos;        /* current scroll pos.*/
+	int     trackPos;      /* current scroll box track position */
+	int		pageStep;      /* steps per page.*/
+	int		barStart;      /* start pixel of bar.*/
+	int		barLen;        /* length of bar.*/
+	int		status;        /* status of scroll bar.*/
+	RECT		rc;	       /* screen coordinates position*/
+} MWSCROLLBARINFO, *PMWSCROLLBARINFO;
+
+/* window*/
+struct hwnd {
+	RECT		winrect;	/* window rect in screen coords*/
+	RECT		clirect;	/* client rect in screen coords*/
+	RECT		restorerc;	/* restore rect from maximized*/
+	DWORD		style;		/* window style*/
+	DWORD		exstyle;	/* window extended style*/
+	PWNDCLASS	pClass;		/* window class*/
+	WNDPROC     	lpfnWndProc;	/* default window procedure (initialized from pClass) */
+	struct hwnd	*parent;	/* z-order parent window */
+	struct hwnd	*owner;		/* owner window*/
+	struct hwnd	*children;	/* first child window */
+	struct hwnd	*siblings;	/* next sibling window */
+	struct hwnd	*next;		/* next window in complete list */
+	struct hcursor	*cursor;	/* cursor for this window */
+	struct hdc *	owndc;		/* owndc if CS_OWNDC*/
+	int		unmapcount;	/* count of reasons not really mapped */
+	int		id;		/* window id */
+	LPTSTR		szTitle;	/* window title*/
+	int		gotPaintMsg;	/* window had WM_PAINT PostMessage*/
+	int		paintSerial;	/* experimental serial # for alphblend*/
+	int		paintNC;	/* experimental NC paint handling*/
+	int		nEraseBkGnd;	/* for InvalidateXX erase bkgnd flag */
+	HBRUSH		paintBrush;	/* brush created to paint some controls */
+	HPEN		paintPen;	/* pen created to paint some controls */
+	MWCLIPREGION *	update;		/* update region in screen coords*/
+	DWORD		userdata;	/* setwindowlong user data*/
+	DWORD		userdata2;	/* additional user data (will remove)*/
+	MWLISTHEAD  	props;		/* windows property list */
+	MWSCROLLBARINFO	hscroll;	/* NC scrollbars*/
+	MWSCROLLBARINFO	vscroll;
+	HINSTANCE	hInstance;	/* hInstance */
+	int		nextrabytes;	/* # window extra bytes*/
+	char		extrabytes[1];	/* window extra bytes - must be last*/
+};
+
+/* misc apis - will move to another header file*/
+DWORD WINAPI	GetTickCount(VOID);
+VOID WINAPI	Sleep(DWORD dwMilliseconds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WINDOWS_H__ */
diff -urN microwin/src\include\mwindowsx.h microwin-0.90/src\include\mwindowsx.h
--- microwin/src\include\mwindowsx.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\include\mwindowsx.h	Wed Aug 25 14:35:56 2010
@@ -0,0 +1,63 @@
+#ifndef __WINDOWSX_H__
+#define __WINDOWSX_H__
+
+#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
+#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
+
+#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)
+#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
+    (void)(fn)((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))
+
+#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (LPCREATESTRUCT)(lParam)) ? 0L : (LRESULT)-1L)
+#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
+    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0L, (LPARAM)(LPCREATESTRUCT)(lpCreateStruct))
+
+#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
+    ((fn)(hwnd), 0L)
+#define FORWARD_WM_DESTROY(hwnd, fn) \
+    (void)(fn)((hwnd), WM_DESTROY, 0L, 0L)
+
+#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
+    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
+#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
+   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)
+
+#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+
+#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (HWND)(wParam)), 0L)
+#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
+    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)
+
+#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (HWND)(wParam)), 0L)
+#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
+    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)
+
+#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
+#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
+    (void)(fn)((hwnd), WM_SETTEXT, 0L, (LPARAM)(LPCTSTR)(lpszText))
+
+#define HANDLE_MSG(hwnd, message, fn)    \
+    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))
+
+#endif /* __WINDOWSX_H__ */
diff -urN microwin/src\include\mwingdi.h microwin-0.90/src\include\mwingdi.h
--- microwin/src\include\mwingdi.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\include\mwingdi.h	Wed Aug 25 14:35:56 2010
@@ -0,0 +1,447 @@
+/* wingdi.h*/
+/*
+ * Copyright (c) 1999,2000,2001,2005 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 GDI structures and API
+ */
+
+#ifndef __WINGDI_H__
+#define __WINGDI_H__
+
+/* portable coordinate definition*/
+typedef MWCOORD	GDICOORD;
+
+/* inherit RECT and POINT from mwtypes.h*/
+typedef MWRECT	RECT;
+typedef MWPOINT	POINT;
+
+#if 0000
+typedef struct  tagRECT {
+    GDICOORD left;
+    GDICOORD top;
+    GDICOORD right;
+    GDICOORD bottom;
+} RECT;
+
+typedef struct  tagPOINT {
+    GDICOORD x;
+    GDICOORD y;
+} POINT; 
+#endif
+
+typedef RECT NEAR *PRECT, FAR *LPRECT;
+
+typedef POINT NEAR *PPOINT, FAR *LPPOINT;
+
+typedef struct  tagSIZE {
+    GDICOORD cx;
+    GDICOORD cy;
+} SIZE, NEAR *PSIZE, FAR *LPSIZE;
+
+typedef struct tagRGBQUAD {
+  BYTE rgbBlue;
+  BYTE rgbGreen;
+  BYTE rgbRed;
+  BYTE rgbReserved;
+} RGBQUAD;
+
+typedef struct tagBITMAPINFOHEADER {
+  DWORD biSize;
+  LONG  biWidth;
+  LONG  biHeight;
+  WORD  biPlanes;
+  WORD  biBitCount;
+  DWORD biCompression;
+  DWORD biSizeImage;
+  LONG  biXPelsPerMeter;
+  LONG  biYPelsPerMeter;
+  DWORD biClrUsed;
+  DWORD biClrImportant;
+} BITMAPINFOHEADER, *PBITMAPINFOHEADER;
+
+typedef struct tagBITMAPINFO {
+  BITMAPINFOHEADER bmiHeader;
+  RGBQUAD          bmiColors[1];
+} BITMAPINFO, *PBITMAPINFO;
+
+/* GetDCEx flags*/
+#define DCX_WINDOW           0x00000001L
+#define DCX_CACHE            0x00000002L
+#define DCX_NORESETATTRS     0x00000004L
+#define DCX_CLIPCHILDREN     0x00000008L
+#define DCX_CLIPSIBLINGS     0x00000010L
+#define DCX_PARENTCLIP       0x00000020L
+#define DCX_EXCLUDERGN       0x00000040L
+#define DCX_INTERSECTRGN     0x00000080L
+#define DCX_EXCLUDEUPDATE    0x00000100L
+#define DCX_INTERSECTUPDATE  0x00000200L
+#define DCX_LOCKWINDOWUPDATE 0x00000400L
+#define DCX_VALIDATE         0x00200000L
+#define DCX_DEFAULTCLIP      0x80000000L	/* microwin only*/
+
+HDC WINAPI	GetDCEx(HWND hwnd,HRGN hrgnClip,DWORD flags);
+HDC WINAPI	GetDC(HWND hWnd);
+HDC WINAPI 	GetWindowDC(HWND hWnd);
+int WINAPI 	ReleaseDC(HWND hWnd, HDC hDC);
+BOOL WINAPI	DeleteDC(HDC hdc);
+
+typedef struct tagPAINTSTRUCT {
+    HDC         hdc;
+    BOOL        fErase;			/* indicates bkgnd needs erasing*/
+    RECT        rcPaint;		/* nyi*/
+    BOOL        fRestore;		/* nyi*/
+    BOOL        fIncUpdate;		/* nyi*/
+    BYTE        rgbReserved[32];
+} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, FAR *LPPAINTSTRUCT;
+
+HDC WINAPI 	BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
+BOOL WINAPI 	EndPaint(HWND hWnd, CONST PAINTSTRUCT *lpPaint);
+
+typedef HANDLE HDWP;
+
+HDWP BeginDeferWindowPos(int nNumWindows);
+HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter,
+		int x, int y, int cx, int cy, UINT uFlags);
+BOOL EndDeferWindowPos(HDWP hWinPosInfo);
+
+
+#define RGB(r,g,b)	    MWRGB(r,g,b)
+#define GetRValue(rgb)      ((BYTE)(rgb))
+#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
+#define GetBValue(rgb)      ((BYTE)((rgb)>>16))
+
+/* Background Modes */
+#define TRANSPARENT	1
+#define OPAQUE		2
+
+/* Text Alignment*/
+#define TA_NOUPDATECP                0
+#define TA_UPDATECP                  1
+
+#define TA_LEFT                      0
+#define TA_RIGHT                     2
+#define TA_CENTER                    6
+
+#define TA_TOP                       0
+#define TA_BOTTOM                    8
+#define TA_BASELINE                  24
+#define TA_RTLREADING                256
+#define TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
+
+COLORREF WINAPI	SetTextColor(HDC, COLORREF);
+COLORREF WINAPI GetTextColor(HDC hdc);
+COLORREF WINAPI	SetBkColor(HDC, COLORREF);
+int WINAPI 	SetBkMode(HDC, int);
+UINT WINAPI     SetTextAlign(HDC hdc, UINT fMode);
+UINT WINAPI		GetTextAlign(HDC hdc);
+
+/* Binary raster ops*/
+#define R2_BLACK            (MWROP_CLEAR+1)		/*  0       */
+#define R2_NOTMERGEPEN      (MWROP_NOR+1)		/* DPon     */
+#define R2_MASKNOTPEN       (MWROP_ANDINVERTED+1)	/* DPna     */
+#define R2_NOTCOPYPEN       (MWROP_COPYINVERTED+1)	/* Pn       */
+#define R2_MASKPENNOT       (MWROP_ANDREVERSE+1)	/* PDna     */
+#define R2_NOT              (MWROP_INVERT+1)		/* Dn       */
+#define R2_XORPEN           (MWROP_XOR+1)		/* DPx      */
+#define R2_NOTMASKPEN       (MWROP_NAND+1)		/* DPan     */
+#define R2_MASKPEN          (MWROP_AND+1)		/* DPa      */
+#define R2_NOTXORPEN        (MWROP_EQUIV+1)		/* DPxn     */
+#define R2_NOP              (MWROP_NOOP+1)		/* D        */
+#define R2_MERGENOTPEN      (MWROP_ORINVERTED+1)	/* DPno     */
+#define R2_COPYPEN          (MWROP_COPY+1)		/* P        */
+#define R2_MERGEPENNOT      (MWROP_ORREVERSE+1)	/* PDno     */
+#define R2_MERGEPEN         (MWROP_OR+1)		/* DPo      */
+#define R2_WHITE            (MWROP_SET+1)		/*  1       */
+#define R2_LAST             16
+
+int WINAPI	SetROP2(HDC hdc, int fnDrawMode);
+
+#define GDI_ERROR	(0xFFFFFFFFL)
+#define CLR_INVALID     0xFFFFFFFF
+
+COLORREF WINAPI GetPixel(HDC hdc, int x, int y);
+COLORREF WINAPI	SetPixel(HDC hdc, int x, int y, COLORREF crColor);
+BOOL WINAPI 	MoveToEx(HDC hdc, int x, int y, LPPOINT lpPoint);
+BOOL WINAPI 	LineTo(HDC hdc, int x, int y);
+BOOL WINAPI	Polyline(HDC hdc, CONST POINT *lppt, int cPoints);
+BOOL WINAPI	PolyPolygon(HDC hdc, CONST POINT *lpPoints, LPINT lpPolyCounts,
+			int nCount);
+BOOL WINAPI	Rectangle(HDC hdc, int nLeft, int nTop, int nRight,int nBottom);
+BOOL WINAPI	Ellipse(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect);
+BOOL WINAPI	Arc(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect, int nXStartArc, int nYStartArc,
+			int nXEndArc, int nYEndArc);
+BOOL WINAPI	Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect, int nXRadial1, int nYRadial1,
+			int nXRadial2, int nYRadial2);
+BOOL WINAPI	Polygon(HDC hdc, CONST POINT *lpPoints, int nCount);
+int WINAPI	FillRect(HDC hDC, CONST RECT *lprc, HBRUSH hbr);
+BOOL WINAPI	DrawFocusRect(HDC hdc, LPRECT prect);
+
+/* ExTextOut options*/
+#define ETO_OPAQUE	0x0002
+#define ETO_CLIPPED	0x0004		/* nyi*/
+
+BOOL WINAPI	TextOut(HDC hdc, int x, int y, LPCSTR lpszString, int cbString);
+BOOL WINAPI	TextOutW(HDC hdc, int x, int y, LPCWSTR lpszString, int cbString);
+BOOL WINAPI	ExtTextOut(HDC hdc, int x, int y, UINT fuOptions,
+			CONST RECT *lprc, LPCSTR lpszString, UINT cbCount,
+			CONST INT *lpDx);
+BOOL WINAPI	ExtTextOutW(HDC hdc, int x, int y, UINT fuOptions,
+			CONST RECT *lprc, LPCWSTR lpszString, UINT cbCount,
+			CONST INT *lpDx);
+LONG WINAPI TabbedTextOut ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
+            int ntabs, LPINT lpTabStops, int nTabOrigin );
+DWORD WINAPI GetTabbedTextExtent ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
+            int ntabs, LPINT lpTabStops );
+
+/* DrawText options*/
+#define DT_TOP              0x00000000
+#define DT_LEFT             0x00000000
+#define DT_CENTER           0x00000001
+#define DT_RIGHT            0x00000002
+#define DT_VCENTER          0x00000004
+#define DT_BOTTOM           0x00000008
+#define DT_WORDBREAK        0x00000010
+#define DT_SINGLELINE       0x00000020
+#define DT_EXPANDTABS       0x00000040
+#define DT_TABSTOP          0x00000080
+#define DT_NOCLIP           0x00000100
+#define DT_EXTERNALLEADING  0x00000200
+#define DT_CALCRECT         0x00000400
+#define DT_NOPREFIX         0x00000800
+#define DT_INTERNAL         0x00001000
+#define DT_EDITCONTROL      0x00002000
+#define DT_PATH_ELLIPSIS    0x00004000
+#define DT_END_ELLIPSIS     0x00008000
+#define DT_MODIFYSTRING     0x00010000
+#define DT_RTLREADING       0x00020000
+#define DT_WORD_ELLIPSIS    0x00040000
+
+int WINAPI	DrawTextA(HDC hdc, LPCSTR lpString, int nCount, LPRECT lpRect,
+			UINT uFormat);
+int WINAPI	DrawTextW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect,
+			UINT uFormat);
+#define DrawText DrawTextA
+
+BOOL WINAPI	DrawDIB(HDC hdc,int x, int y,PMWIMAGEHDR pimage); /* microwin*/
+
+/* GetSysColor, FillRect colors*/
+#define COLOR_SCROLLBAR         0
+#define COLOR_BACKGROUND        1
+#define COLOR_ACTIVECAPTION     2
+#define COLOR_INACTIVECAPTION   3
+#define COLOR_MENU              4
+#define COLOR_WINDOW            5
+#define COLOR_WINDOWFRAME       6
+#define COLOR_MENUTEXT          7
+#define COLOR_WINDOWTEXT        8
+#define COLOR_CAPTIONTEXT       9
+#define COLOR_ACTIVEBORDER      10
+#define COLOR_INACTIVEBORDER    11
+#define COLOR_APPWORKSPACE      12
+#define COLOR_HIGHLIGHT         13
+#define COLOR_HIGHLIGHTTEXT     14
+#define COLOR_BTNFACE           15
+#define COLOR_BTNSHADOW         16
+#define COLOR_GRAYTEXT          17
+#define COLOR_BTNTEXT           18
+#define COLOR_INACTIVECAPTIONTEXT 19
+#define COLOR_BTNHIGHLIGHT      20
+#define COLOR_3DDKSHADOW        21
+#define COLOR_3DLIGHT           22
+#define COLOR_INFOTEXT          23
+#define COLOR_INFOBK            24
+#define COLOR_DESKTOP           COLOR_BACKGROUND
+#define COLOR_3DFACE            COLOR_BTNFACE
+#define COLOR_3DSHADOW          COLOR_BTNSHADOW
+#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
+#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
+#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
+#define COLOR_ALTERNATEBUTTONFACE	25
+#define COLOR_HOTLIGHT                  26
+#define COLOR_GRADIENTACTIVECAPTION     27
+#define COLOR_GRADIENTINACTIVECAPTION   28
+
+DWORD WINAPI	GetSysColor(int nIndex);
+COLORREF WINAPI	SetSysColor(int nIndex, COLORREF crColor);/* Microwindows only*/
+
+/* Stock Logical Objects */
+#define WHITE_BRUSH         0
+#define LTGRAY_BRUSH        1
+#define GRAY_BRUSH          2
+#define DKGRAY_BRUSH        3
+#define BLACK_BRUSH         4
+#define NULL_BRUSH          5
+#define HOLLOW_BRUSH        NULL_BRUSH
+#define WHITE_PEN           6
+#define BLACK_PEN           7
+#define NULL_PEN            8
+#define OEM_FIXED_FONT      10
+#define ANSI_FIXED_FONT     11
+#define ANSI_VAR_FONT       12
+#define SYSTEM_FONT         13
+#define DEVICE_DEFAULT_FONT 14
+#define DEFAULT_PALETTE     15
+#define SYSTEM_FIXED_FONT   16
+#define DEFAULT_GUI_FONT    17
+#define DC_BRUSH            18
+#define DC_PEN              19
+#define STOCK_LAST          19
+
+/* Object types*/
+#define OBJ_PEN             1
+#define OBJ_BRUSH           2
+#define OBJ_DC              3
+#define OBJ_METADC          4
+#define OBJ_PAL             5
+#define OBJ_FONT            6
+#define OBJ_BITMAP          7
+#define OBJ_REGION          8
+#define OBJ_METAFILE        9
+#define OBJ_MEMDC           10
+#define OBJ_EXTPEN          11
+#define OBJ_ENHMETADC       12
+#define OBJ_ENHMETAFILE     13
+
+HGDIOBJ WINAPI	GetStockObject(int nObject);
+HGDIOBJ WINAPI	SelectObject(HDC hdc, HGDIOBJ hObject);
+BOOL WINAPI	DeleteObject(HGDIOBJ hObject);
+int WINAPI	SelectClipRgn(HDC hdc, HRGN hrgn);
+int WINAPI	ExtSelectClipRgn(HDC hdc, HRGN hrgn, int fnMode);
+int WINAPI	GetUpdateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
+BOOL WINAPI	GetUpdateRect(HWND hwnd, LPRECT lpRect, BOOL bErase);
+
+/* Brush Styles */
+#define BS_SOLID            0
+#define BS_NULL             1
+#define BS_HOLLOW           BS_NULL
+
+HBRUSH WINAPI	CreateSolidBrush(COLORREF crColor);
+
+/* Pen Styles */
+#define PS_SOLID            0
+#define PS_NULL             5
+
+HPEN WINAPI	CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
+
+HBITMAP WINAPI	CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight);
+HDC WINAPI	CreateCompatibleDC(HDC hdc);
+
+/* BitBlit raster opcodes*/
+#define SRCCOPY         (DWORD)MWROP_COPY	  /* source                   */
+#define SRCPAINT        (DWORD)MWROP_OR		  /* source OR dest           */
+#define SRCAND          (DWORD)MWROP_AND	  /* source AND dest          */
+#define SRCINVERT       (DWORD)MWROP_XOR	  /* source XOR dest          */
+#define SRCERASE        (DWORD)MWROP_ANDREVERSE	  /* source AND (NOT dest )   */
+#define NOTSRCCOPY      (DWORD)MWROP_COPYINVERTED /* (NOT source)             */
+#define NOTSRCERASE     (DWORD)MWROP_NOR	  /* (NOT src) AND (NOT dest) */
+#define MERGEPAINT      (DWORD)MWROP_ORINVERTED   /* (NOT source) OR dest     */
+#define DSTINVERT       (DWORD)MWROP_INVERT	  /* (NOT dest)               */
+#define BLACKNESS       (DWORD)MWROP_CLEAR	  /* BLACK                    */
+#define WHITENESS       (DWORD)MWROP_SET	  /* WHITE                    */
+#if 0
+#define MERGECOPY       (DWORD)0x00C000CA /* (source AND pattern)     */
+#define PATCOPY         (DWORD)0x00F00021 /* pattern                  */
+#define PATPAINT        (DWORD)0x00FB0A09 /* DPSnoo                   */
+#define PATINVERT       (DWORD)0x005A0049 /* pattern XOR dest         */
+#endif
+
+BOOL WINAPI	BitBlt(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,
+			HDC hdcSrc,int nXSrc,int nYSrc,DWORD dwRop);
+BOOL WINAPI	StretchBlt(HDC hdcDest,int nXOriginDest,int nYOriginDest,
+			int nWidthDest,int nHeightDest,HDC hdcSrc,
+			int nXOriginSrc,int nYOriginSrc,int nWidthSrc,
+			int nHeightSrc, DWORD dwRop);
+
+/* Palette entry flags*/
+#define PC_RESERVED	0x01
+#define PC_EXPLICIT	0x02
+#define PC_NOCOLLAPSE	0x04
+
+typedef struct tagPALETTEENTRY {
+	BYTE	peRed;
+	BYTE	peGreen;
+	BYTE	peBlue;
+	BYTE	peFlags;
+} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;
+
+UINT WINAPI	GetSystemPaletteEntries(HDC hdc,UINT iStartIndex,UINT nEntries,
+			LPPALETTEENTRY lppe);
+
+/* GetDeviceCaps parameters*/
+#define HORZRES       8     /* Horizontal width in pixels               */
+#define VERTRES       10    /* Vertical height in pixels                */
+#define BITSPIXEL     12    /* Number of bits per pixel                 */
+#define PLANES        14    /* Number of planes                         */
+#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
+#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */
+#define SIZEPALETTE  104    /* Number of entries in physical palette    */
+
+//int WINAPI	GetDeviceCaps(HDC hdc, int nIndex);
+
+/* Region flags*/
+#define ERRORREGION		MWREGION_ERROR
+#define NULLREGION		MWREGION_NULL
+#define SIMPLEREGION		MWREGION_SIMPLE
+#define COMPLEXREGION		MWREGION_COMPLEX
+/* kluge for VxWorks*/
+#ifdef ERROR
+#undef ERROR
+#endif
+#define ERROR			ERRORREGION
+#define RGN_ERROR		ERRORREGION
+
+/* CombineRgn() Styles */
+#define RGN_AND             1
+#define RGN_OR              2
+#define RGN_XOR             3
+#define RGN_DIFF            4
+#define RGN_COPY            5
+#define RGN_MIN             RGN_AND
+#define RGN_MAX             RGN_COPY
+
+/* GetRegionData/ExtCreateRegion */
+#define RDH_RECTANGLES  1
+typedef struct _RGNDATAHEADER {
+    DWORD   dwSize;
+    DWORD   iType;
+    DWORD   nCount;
+    DWORD   nRgnSize;
+    RECT    rcBound;
+} RGNDATAHEADER, *PRGNDATAHEADER;
+
+typedef struct _RGNDATA {
+    RGNDATAHEADER   rdh;
+    char            Buffer[1];
+} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
+
+/* Region entry points*/
+INT  WINAPI OffsetRgn(HRGN hrgn, INT x, INT y );
+INT  WINAPI GetRgnBox(HRGN hrgn, LPRECT rect );
+HRGN WINAPI CreateRectRgn(INT left, INT top, INT right, INT bottom);
+HRGN WINAPI CreateRectRgnIndirect(const RECT* rect );
+VOID WINAPI SetRectRgn(HRGN hrgn, INT left, INT top, INT right, INT bottom );
+HRGN WINAPI CreateRoundRectRgn(INT left, INT top, INT right, INT bottom,
+		INT ellipse_width, INT ellipse_height );
+HRGN WINAPI CreateEllipticRgn(INT left, INT top, INT right, INT bottom );
+HRGN WINAPI CreateEllipticRgnIndirect(const RECT *rect );
+HRGN WINAPI CreatePolygonRgn(const POINT *points, INT count, INT mode);
+DWORD WINAPI GetRegionData(HRGN hrgn, DWORD count, LPRGNDATA rgndata);
+BOOL WINAPI PtInRegion(HRGN hrgn, INT x, INT y );
+BOOL WINAPI RectInRegion(HRGN hrgn, const RECT *rect );
+BOOL WINAPI EqualRgn(HRGN hrgn1, HRGN hrgn2 );
+INT  WINAPI CombineRgn(HRGN hDest, HRGN hSrc1, HRGN hSrc2, INT mode);
+BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
+
+/* Rect entry points*/
+BOOL WINAPI IntersectRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+BOOL WINAPI UnionRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+BOOL WINAPI EqualRect(const RECT* rect1, const RECT* rect2 );
+BOOL WINAPI SubtractRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+
+/* GDI math stuff */
+int WINAPI MulDiv(int nMultiplicand, int nMultiplier, int nDivisor);
+
+#endif /*  __WINGDI_H__ */
diff -urN microwin/src\include\mwinuser.h microwin-0.90/src\include\mwinuser.h
--- microwin/src\include\mwinuser.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\include\mwinuser.h	Wed Aug 25 14:35:56 2010
@@ -0,0 +1,712 @@
+/* winuser.h*/
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 USER structures and API
+ */
+#include "winctl.h"	/* required compatibility for resource compiler*/
+
+/* moved from windef.h for resource compiler*/
+typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
+typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
+
+/* win api*/
+LRESULT WINAPI 	DefWindowProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam);
+
+/* Class styles*/
+#define CS_VREDRAW          0x0001
+#define CS_HREDRAW          0x0002
+#define CS_DBLCLKS          0x0008
+#define CS_OWNDC            0x0020
+#define CS_CLASSDC          0x0040
+#define CS_PARENTDC         0x0080
+#define CS_NOCLOSE          0x0200
+#define CS_SAVEBITS         0x0800
+#define CS_BYTEALIGNCLIENT  0x1000
+#define CS_BYTEALIGNWINDOW  0x2000
+#define CS_GLOBALCLASS      0x4000
+
+typedef struct tagWNDCLASSA {
+    MWLIST	link;			/* microwin*/
+    UINT        style;
+    WNDPROC     lpfnWndProc;
+    int         cbClsExtra;		/* nyi*/
+    int         cbWndExtra;
+    HINSTANCE   hInstance;		/* nyi*/
+    HICON       hIcon;			/* nyi*/
+    HCURSOR     hCursor;		/* nyi*/
+    HBRUSH      hbrBackground;
+    LPCSTR      lpszMenuName;		/* nyi*/
+    LPCSTR      lpszClassName;
+    CHAR	szClassName[40];	/* microwin*/
+} WNDCLASS, *PWNDCLASS, NEAR *NPWNDCLASS, FAR *LPWNDCLASS;
+
+ATOM WINAPI	RegisterClass(CONST WNDCLASS *lpWndClass);
+BOOL WINAPI UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance);
+
+/*
+ * Message structure
+ */
+typedef struct tagMSG {
+    MWLIST	link;			/* microwin*/
+    HWND        hwnd;
+    UINT        message;
+    WPARAM      wParam;
+    LPARAM      lParam;
+    DWORD       time;
+    POINT       pt;
+} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;
+
+#define POINTSTOPOINT(pt, pts)                          \
+        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
+          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }
+
+#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
+#define MAKEWPARAM(l, h)      (WPARAM)MAKELONG(l, h)
+#define MAKELPARAM(l, h)      (LPARAM)MAKELONG(l, h)
+#define MAKELRESULT(l, h)     (LRESULT)MAKELONG(l, h)
+
+/* window messages*/
+#define WM_NULL                         0x0000
+#define WM_CREATE                       0x0001
+#define WM_DESTROY                      0x0002
+#define WM_NCDESTROY			WM_DESTROY
+#define WM_MOVE                         0x0003
+#define WM_SIZE                         0x0005
+#define WM_ACTIVATE                     0x0006
+#define WM_SETFOCUS                     0x0007
+#define WM_KILLFOCUS                    0x0008
+#define WM_ENABLE                       0x000A
+#define WM_SETREDRAW					0x000B
+#define WM_SETTEXT                      0x000C
+#define WM_GETTEXT                      0x000D
+#define WM_GETTEXTLENGTH                0x000E
+#define WM_PAINT                        0x000F
+#define WM_CLOSE                        0x0010
+#define WM_QUIT                         0x0012
+#define WM_ERASEBKGND                   0x0014
+#define WM_SHOWWINDOW                   0x0018
+#define WM_CTLCOLOR                     0x0019
+#define WM_NEXTDLGCTL                   0x0028
+#define WM_DRAWITEM                     0x002B
+#define WM_MEASUREITEM                  0x002C
+#define WM_DELETEITEM 					0x002D
+#define WM_VKEYTOITEM					0x002E
+#define WM_CHARTOITEM					0x002F
+#define WM_SETFONT          		0x0030
+#define WM_GETFONT      		0x0031
+#define WM_COMPAREITEM					0x0039
+#define WM_WINDOWPOSCHANGED             0x0047
+#define WM_NCCALCSIZE                   0x0083
+#define WM_NCHITTEST                    0x0084
+#define WM_NCPAINT                      0x0085
+#define WM_GETDLGCODE                   0x0087
+#define WM_NCMOUSEMOVE                  0x00A0
+#define WM_NCLBUTTONDOWN                0x00A1
+#define WM_NCLBUTTONUP                  0x00A2
+#define WM_NCLBUTTONDBLCLK              0x00A3
+#define WM_NCRBUTTONDOWN                0x00A4
+#define WM_NCRBUTTONUP                  0x00A5
+#define WM_NCRBUTTONDBLCLK              0x00A6
+#define WM_KEYFIRST                     0x0100
+#define WM_KEYDOWN                      0x0100
+#define WM_KEYUP                        0x0101
+#define WM_CHAR                         0x0102
+#define WM_DEADCHAR                     0x0103	/* notimp*/
+#define WM_SYSKEYDOWN                   0x0104	/* nyi*/
+#define WM_SYSKEYUP                     0x0105	/* nyi*/
+#define WM_SYSCHAR                      0x0106
+#define WM_SYSDEADCHAR                  0x0107	/* notimp*/
+#define WM_KEYLAST                      0x0108
+#define WM_INITDIALOG	                0x0110
+#define WM_COMMAND                      0x0111
+#define WM_SYSCOMMAND                   0x0112
+#define WM_TIMER                        0x0113
+#define WM_HSCROLL                      0x0114
+#define WM_VSCROLL                      0x0115
+
+#define WM_ENTERIDLE                    0x0121
+
+#define WM_CTLCOLORMSGBOX               0x0132
+#define WM_CTLCOLOREDIT                 0x0133
+#define WM_CTLCOLORLISTBOX              0x0134
+#define WM_CTLCOLORBTN                  0x0135
+#define WM_CTLCOLORDLG                  0x0136
+#define WM_CTLCOLORSCROLLBAR            0x0137
+#define WM_CTLCOLORSTATIC               0x0138
+
+#define WM_MOUSEFIRST                   0x0200
+#define WM_MOUSEMOVE                    0x0200
+#define WM_LBUTTONDOWN                  0x0201
+#define WM_LBUTTONUP                    0x0202
+#define WM_LBUTTONDBLCLK                0x0203
+#define WM_RBUTTONDOWN                  0x0204
+#define WM_RBUTTONUP                    0x0205
+#define WM_RBUTTONDBLCLK                0x0206
+#define WM_MBUTTONDOWN                  0x0207
+#define WM_MBUTTONUP                    0x0208
+#define WM_MBUTTONDBLCLK                0x0209
+#define WM_MOUSEWHEEL                   0x020A
+#define WM_MOUSELAST                    0x020A
+
+#define WM_CARET_CREATE    		0x03E0 /* Microwindows only*/
+#define WM_CARET_DESTROY   		0x03E1 /* Microwindows only*/
+#define WM_CARET_BLINK      		0x03E2 /* Microwindows only*/
+#define WM_FDINPUT                      0x03F0 /* Microwindows only*/
+#define WM_FDOUTPUT                     0x03F1 /* Microwindows only*/
+#define WM_FDEXCEPT                     0x03F2 /* Microwindows only*/
+#define WM_USER                         0x0400
+
+/*
+ * System Menu Command Values
+ */
+#define SC_SIZE         0xF000
+#define SC_MOVE         0xF010
+#define SC_MINIMIZE     0xF020
+#define SC_MAXIMIZE     0xF030
+#define SC_NEXTWINDOW   0xF040
+#define SC_PREVWINDOW   0xF050
+#define SC_CLOSE        0xF060
+#define SC_VSCROLL      0xF070
+#define SC_HSCROLL      0xF080
+#define SC_MOUSEMENU    0xF090
+#define SC_KEYMENU      0xF100
+#define SC_ARRANGE      0xF110
+#define SC_RESTORE      0xF120
+#define SC_TASKLIST     0xF130
+#define SC_SCREENSAVE   0xF140
+#define SC_HOTKEY       0xF150
+
+/* WM_ACTIVATE state values*/
+#define WA_INACTIVE     0
+#define WA_ACTIVE       1
+#define WA_CLICKACTIVE  2
+
+/* WM_NCHITTEST codes*/
+#define HTERROR             (-2)
+#define HTTRANSPARENT       (-1)
+#define HTNOWHERE           0
+#define HTCLIENT            1
+#define HTCAPTION           2
+#define HTSYSMENU           3
+#define HTGROWBOX           4
+#define HTSIZE              HTGROWBOX
+#define HTMENU              5
+#define HTHSCROLL           6
+#define HTVSCROLL           7
+#define HTMINBUTTON         8
+#define HTMAXBUTTON         9
+#define HTLEFT              10
+#define HTRIGHT             11
+#define HTTOP               12
+#define HTTOPLEFT           13
+#define HTTOPRIGHT          14
+#define HTBOTTOM            15
+#define HTBOTTOMLEFT        16
+#define HTBOTTOMRIGHT       17
+#define HTBORDER            18
+#define HTREDUCE            HTMINBUTTON
+#define HTZOOM              HTMAXBUTTON
+#define HTSIZEFIRST         HTLEFT
+#define HTSIZELAST          HTBOTTOMRIGHT
+#define HTOBJECT            19
+#define HTCLOSE             20
+#define HTHELP              21
+
+/* WM_SIZE wparam values*/
+#define SIZE_RESTORED       0
+#define SIZE_MINIMIZED      1
+#define SIZE_MAXIMIZED      2
+#define SIZE_MAXSHOW        3
+#define SIZE_MAXHIDE        4
+
+LRESULT WINAPI  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hwnd, UINT Msg,
+			WPARAM wParam, LPARAM lParam);
+LRESULT WINAPI	SendMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
+BOOL WINAPI	PostMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
+BOOL WINAPI	PostThreadMessage(DWORD dwThreadId, UINT Msg, WPARAM wParam,
+			LPARAM lParam);
+VOID WINAPI	PostQuitMessage(int nExitCode);
+
+/* PeekMessage options*/
+#define PM_NOREMOVE		0x0000
+#define PM_REMOVE		0x0001
+#define PM_NOYIELD		0x0002
+
+BOOL WINAPI	PeekMessage(LPMSG lpMsg, HWND hwnd, UINT uMsgFilterMin,
+			UINT uMsgFilterMax, UINT wRemoveMsg);
+BOOL WINAPI 	GetMessage(LPMSG lpMsg,HWND hwnd,UINT wMsgFilterMin,
+			UINT wMsgFilterMax);
+BOOL WINAPI 	TranslateMessage(CONST MSG *lpMsg);
+LONG WINAPI	DispatchMessage(CONST MSG *lpMsg);
+
+/* note: the following struct is in reverse order from the
+ * microsoft version since WINAPI is cdecl in this implementation
+ */
+typedef struct tagCREATESTRUCT {
+    DWORD       dwExStyle;
+    LPCSTR      lpszClass;
+    LPCSTR      lpszName;
+    LONG        style;
+    int         x;
+    int         y;
+    int         cx;
+    int         cy;
+    HWND        hwndParent;
+    HMENU       hMenu;
+    HINSTANCE   hInstance;
+    LPVOID      lpCreateParams;
+} CREATESTRUCT, *LPCREATESTRUCT;
+
+typedef struct tagCOMPAREITEMSTRUCT {
+	UINT	CtlType;
+	UINT	CtlID;
+	HWND	hwndItem;
+	UINT	itemID1;
+	DWORD	itemData1;
+	UINT	itemID2;
+	DWORD	itemData2;
+	DWORD	dwLocaleId;
+} COMPAREITEMSTRUCT,*LPCOMPAREITEMSTRUCT;
+
+typedef struct tagDELETEITEMSTRUCT {
+	UINT CtlType;
+	UINT CtlID;
+	UINT itemID;
+	HWND hwndItem;
+	UINT itemData;
+} DELETEITEMSTRUCT,*PDELETEITEMSTRUCT,*LPDELETEITEMSTRUCT;
+
+/*
+ * Window Styles
+ */
+#define WS_OVERLAPPED       0x00000000L
+#define WS_POPUP            0x80000000L
+#define WS_CHILD            0x40000000L
+#define WS_MINIMIZE         0x20000000L
+#define WS_VISIBLE          0x10000000L
+#define WS_DISABLED         0x08000000L
+#define WS_CLIPSIBLINGS     0x04000000L
+#define WS_CLIPCHILDREN     0x02000000L
+#define WS_MAXIMIZE         0x01000000L
+#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
+#define WS_BORDER           0x00800000L
+#define WS_DLGFRAME         0x00400000L
+#define WS_VSCROLL          0x00200000L
+#define WS_HSCROLL          0x00100000L
+#define WS_SYSMENU          0x00080000L
+#define WS_THICKFRAME       0x00040000L
+#define WS_GROUP            0x00020000L
+#define WS_TABSTOP          0x00010000L
+
+#define WS_MINIMIZEBOX      0x00020000L
+#define WS_MAXIMIZEBOX      0x00010000L
+
+#define WS_TILED            WS_OVERLAPPED
+#define WS_ICONIC           WS_MINIMIZE
+#define WS_SIZEBOX          WS_THICKFRAME
+#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW
+
+/*
+ * Common Window Styles
+ */
+#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
+                             WS_CAPTION        | \
+                             WS_SYSMENU        | \
+                             WS_THICKFRAME     | \
+                             WS_MINIMIZEBOX    | \
+                             WS_MAXIMIZEBOX)
+
+#define WS_POPUPWINDOW      (WS_POPUP          | \
+                             WS_BORDER         | \
+                             WS_SYSMENU)
+
+#define WS_CHILDWINDOW      (WS_CHILD)
+
+/*
+ * Extended Window Styles
+ */
+#define WS_EX_DLGMODALFRAME     0x00000001L
+#define WS_EX_NOPARENTNOTIFY    0x00000004L
+#define WS_EX_TOPMOST           0x00000008L
+#define WS_EX_ACCEPTFILES       0x00000010L
+#define WS_EX_TRANSPARENT       0x00000020L
+#define WS_EX_MDICHILD          0x00000040L
+#define WS_EX_TOOLWINDOW        0x00000080L
+#define WS_EX_WINDOWEDGE        0x00000100L
+#define WS_EX_CLIENTEDGE        0x00000200L
+#define WS_EX_CONTEXTHELP       0x00000400L
+
+#define WS_EX_RIGHT             0x00001000L
+#define WS_EX_LEFT              0x00000000L
+#define WS_EX_RTLREADING        0x00002000L
+#define WS_EX_LTRREADING        0x00000000L
+#define WS_EX_LEFTSCROLLBAR     0x00004000L
+#define WS_EX_RIGHTSCROLLBAR    0x00000000L
+
+#define WS_EX_CONTROLPARENT     0x00010000L
+#define WS_EX_STATICEDGE        0x00020000L
+#define WS_EX_APPWINDOW         0x00040000L
+#define WS_EX_LAYERED		0x00080000L
+
+#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
+#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
+
+#define CW_USEDEFAULT       ((int)0x80000000)
+
+#define HWND_DESKTOP        ((HWND)0)
+
+#define CreateWindow(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)\
+		CreateWindowEx(0L, lpClassName, lpWindowName, dwStyle, x, y,\
+		nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)
+
+HWND WINAPI	CreateWindowEx(DWORD dwExStyle, LPCSTR lpClassName,
+    			LPCSTR lpWindowName, DWORD dwStyle, int X, int Y,
+			int nWidth, int nHeight, HWND hwndParent, HMENU hMenu,
+			HINSTANCE hInstance, LPVOID lpParam);
+BOOL WINAPI 	DestroyWindow(HWND hwnd);
+BOOL WINAPI	IsWindow(HWND hwnd);
+#define IsWindowVisible(hwnd)	((BOOL)((hwnd)->unmapcount == 0))
+
+/*
+ * ShowWindow() Commands
+ */
+#define SW_HIDE             0
+#define SW_SHOWNORMAL       1
+#define SW_NORMAL           1
+#define SW_SHOWMINIMIZED    2
+#define SW_SHOWMAXIMIZED    3
+#define SW_MAXIMIZE         3
+#define SW_SHOWNOACTIVATE   4
+#define SW_SHOW             5
+#define SW_MINIMIZE         6
+#define SW_SHOWMINNOACTIVE  7
+#define SW_SHOWNA           8
+#define SW_RESTORE          9
+#define SW_SHOWDEFAULT      10
+#define SW_FORCEMINIMIZE    11
+#define SW_MAX              11
+
+BOOL WINAPI 	ShowWindow(HWND hwnd, int nCmdShow);
+BOOL WINAPI	InvalidateRect(HWND hwnd, CONST RECT *lpRect, BOOL bErase);
+BOOL WINAPI	InvalidateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
+BOOL WINAPI	ValidateRect(HWND hwnd, CONST RECT *lprc);
+BOOL WINAPI	ValidateRgn(HWND hwnd, HRGN hrgn);
+BOOL WINAPI	UpdateWindow(HWND hwnd);
+
+BOOL WINAPI	SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey,
+			BYTE bAlpha, DWORD dwFlags);
+#define LWA_COLORKEY	0x00000001
+#define LWA_ALPHA	0x00000002
+
+HWND WINAPI	GetFocus(VOID);
+HWND WINAPI	SetFocus(HWND hwnd);
+BOOL WINAPI	SetForegroundWindow(HWND hwnd);
+HWND WINAPI	SetActiveWindow(HWND hwnd);
+HWND WINAPI	GetActiveWindow(VOID);
+BOOL WINAPI	BringWindowToTop(HWND hwnd);
+HWND WINAPI	GetDesktopWindow(VOID);
+HWND WINAPI	GetParent(HWND hwnd);
+BOOL WINAPI	EnableWindow(HWND hwnd, BOOL bEnable);
+#define IsWindowEnabled(hwnd)	((BOOL)(((hwnd)->style&WS_DISABLED) == 0))
+
+BOOL WINAPI	AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu,
+			DWORD dwExStyle);
+BOOL WINAPI	GetClientRect(HWND hwnd, LPRECT lpRect);
+BOOL WINAPI	GetWindowRect(HWND hwnd, LPRECT lpRect);
+
+BOOL WINAPI 	ClientToScreen(HWND hwnd, LPPOINT lpPoint);
+BOOL WINAPI 	ScreenToClient(HWND hwnd, LPPOINT lpPoint);
+int  WINAPI	MapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lpPoints,
+			UINT cPoints);
+
+BOOL WINAPI	SetRect(LPRECT lprc,int xLeft,int yTop,int xRight,int yBottom);
+BOOL WINAPI	SetRectEmpty(LPRECT lprc);
+BOOL WINAPI	CopyRect(LPRECT lprcDst, CONST RECT *lprcSrc);
+BOOL WINAPI	IsRectEmpty(CONST RECT *lprc);
+BOOL WINAPI	InflateRect(LPRECT lprc, int dx, int dy);
+BOOL WINAPI	OffsetRect(LPRECT lprc, int dx, int dy);
+/* The bcc compiler doesn't work passing structs by value, so we have this*/
+#if ELKS
+#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, *(long *)&(pt))
+#else
+#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, pt)
+#endif
+BOOL WINAPI	MwPTINRECT(CONST RECT *lprc, POINT pt);
+
+/*
+ * Window field offsets for GetWindowLong()
+ */
+#define GWL_WNDPROC         (-4)
+#define GWL_HINSTANCE       (-6)
+#define GWL_HWNDPARENT      (-8)
+#define GWL_STYLE           (-16)
+#define GWL_EXSTYLE         (-20)
+#define GWL_USERDATA        (-21)
+#define GWL_ID              (-12)
+
+/*
+ * Class field offsets for GetClassLong()
+ */
+#define GCL_MENUNAME        (-8)
+#define GCL_HBRBACKGROUND   (-10)
+#define GCL_HCURSOR         (-12)
+#define GCL_HICON           (-14)
+#define GCL_HMODULE         (-16)
+#define GCL_CBWNDEXTRA      (-18)
+#define GCL_CBCLSEXTRA      (-20)
+#define GCL_WNDPROC         (-24)
+#define GCL_STYLE           (-26)
+#define GCW_ATOM            (-32)
+#define GCL_HICONSM         (-34)
+
+LONG WINAPI	GetWindowLong(HWND hwnd, int nIndex);
+LONG WINAPI	SetWindowLong(HWND hwnd, int nIndex, LONG lNewLong);
+WORD WINAPI	GetWindowWord(HWND hwnd, int nIndex);
+WORD WINAPI	SetWindowWord(HWND hwnd, int nIndex, WORD wNewWord);
+BOOL WINAPI SetProp(HWND hWnd, LPCSTR lpString, HANDLE hData);
+HANDLE WINAPI GetProp(HWND hWnd, LPCSTR lpString);
+HANDLE WINAPI RemoveProp(HWND hWnd, LPCSTR lpString);
+
+#define GetDlgCtrlID(hwnd)	((int)(hwnd)->id)
+DWORD WINAPI	GetClassLong(HWND hwnd, int nIndex);
+int WINAPI	GetWindowTextLength(HWND hwnd);
+int WINAPI	GetWindowText(HWND hwnd, LPSTR lpString, int nMaxCount);
+BOOL WINAPI	SetWindowText(HWND hwnd, LPCSTR lpString);
+
+BOOL WINAPI 	MoveWindow(HWND hwnd, int x, int y, int nWidth, int nHeight,
+    			BOOL bRepaint);
+
+/* SetWindowPos Flags*/
+#define SWP_NOSIZE          0x0001
+#define SWP_NOMOVE          0x0002
+#define SWP_NOZORDER        0x0004
+#define SWP_NOREDRAW        0x0008
+#define SWP_NOACTIVATE      0x0010	/* nyi*/
+#define SWP_FRAMECHANGED    0x0020	/* nyi*/
+#define SWP_SHOWWINDOW      0x0040
+#define SWP_HIDEWINDOW      0x0080
+#define SWP_NOCOPYBITS      0x0100	/* nyi*/
+#define SWP_NOOWNERZORDER   0x0200	/* nyi*/
+#define SWP_NOSENDCHANGING  0x0400	/* nyi*/
+#define SWP_DRAWFRAME       SWP_FRAMECHANGED
+#define SWP_NOREPOSITION    SWP_NOOWNERZORDER
+#define SWP_DEFERERASE      0x2000	/* nyi*/
+#define SWP_ASYNCWINDOWPOS  0x4000	/* nyi*/
+
+#define HWND_TOP        ((HWND)0)	/* nyi*/
+#define HWND_BOTTOM     ((HWND)1)	/* nyi*/
+#define HWND_TOPMOST    ((HWND)-1)	/* nyi*/
+#define HWND_NOTOPMOST  ((HWND)-2)	/* nyi*/
+
+/* WM_WINDOWPOSCHANGED message*/
+typedef struct tagWINDOWPOS {
+	HWND    hwnd;
+	HWND    hwndInsertAfter;
+	int     x;
+	int     y;
+	int     cx;
+	int     cy;
+	UINT    flags;
+} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;
+
+BOOL WINAPI	SetWindowPos(HWND hwnd, HWND hwndInsertAfter, int x, int y,
+			int cx, int cy, UINT fuFlags);
+
+typedef struct tagWINDOWPLACEMENT {
+    UINT  length;
+    UINT  flags;
+    UINT  showCmd;
+    POINT ptMinPosition;
+    POINT ptMaxPosition;
+    RECT  rcNormalPosition;
+} WINDOWPLACEMENT;
+typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
+BOOL SetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
+BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
+
+BOOL WINAPI	GetCursorPos(LPPOINT lpPoint);
+HWND WINAPI	GetCapture(VOID);
+HWND WINAPI	SetCapture(HWND hwnd);
+BOOL WINAPI	ReleaseCapture(VOID);
+
+#define GW_HWNDNEXT 2
+#define GW_HWNDPREV 3
+#define GW_CHILD 5
+#define GW_HWNDFIRST 0
+#define GW_HWNDLAST 1
+#define GW_OWNER 4
+
+HWND GetWindow(HWND hWnd,  UINT uCmd);
+HWND GetMenu (HWND hWnd);
+HWND GetForegroundWindow(VOID);
+HWND WindowFromPoint(POINT pt);
+
+/*
+ * WM_NCCALCSIZE parameter structure
+ */
+typedef struct tagNCCALCSIZE_PARAMS {
+    RECT       rgrc[3];
+    /*PWINDOWPOS lppos;*/		/* removed for microwin*/
+} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
+
+typedef FARPROC TIMERPROC;
+
+UINT WINAPI	SetTimer(HWND hwnd, UINT idTimer, UINT uTimeout,
+			TIMERPROC lpTimerFunc);
+BOOL WINAPI	KillTimer(HWND hwnd, UINT idTimer);
+UINT		MwGetNextTimeoutValue(void);
+void		MwHandleTimers(void);
+
+/* GetSystemMetrics indices*/
+#define SM_CXSCREEN             0
+#define SM_CYSCREEN             1
+#define SM_CXVSCROLL            2
+#define SM_CYHSCROLL            3
+#define SM_CYCAPTION            4
+#define SM_CXBORDER             5
+#define SM_CYBORDER             6
+#define SM_CXDLGFRAME           7
+#define SM_CYDLGFRAME           8
+#define SM_CXFIXEDFRAME		SM_CXDLGFRAME
+#define SM_CYFIXEDFRAME		SM_CYDLGFRAME
+#define SM_CYMENU               15
+#define SM_CYVSCROLL            20
+#define SM_CXHSCROLL            21
+#define SM_CXFRAME              32
+#define SM_CYFRAME              33
+#define SM_CXSIZEFRAME		SM_CXFRAME
+#define SM_CYSIZEFRAME		SM_CYFRAME
+
+int WINAPI	GetSystemMetrics(int nIndex);
+
+#define SPI_SETWORKAREA            47
+#define SPI_GETWORKAREA            48
+
+BOOL WINAPI SystemParametersInfo (UINT uiAction,  UINT uiParam, PVOID pvParam, UINT fWinIni);
+
+HWND WINAPI	GetDlgItem(HWND hDlg, int nIDDlgItem);
+
+/* ************************** Caret support **********************************/
+BOOL WINAPI CreateCaret(HWND hwnd, HBITMAP hBitmap, int nWidth, int nHeight);
+BOOL WINAPI DestroyCaret(VOID);
+BOOL WINAPI HideCaret (HWND hwnd);
+BOOL WINAPI ShowCaret(HWND hwnd);
+BOOL WINAPI SetCaretPos(int nX, int nY);
+BOOL WINAPI GetCaretPos(LPPOINT lpPoint);
+UINT WINAPI GetCaretBlinkTime(VOID);
+BOOL WINAPI SetCaretBlinkTime(UINT uMSeconds);
+
+
+int WINAPI GetClassName(HWND hWnd, LPTSTR lpClassName, int nMaxCount);
+HWND WINAPI GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
+
+/*
+ * Dialog Box Command IDs
+ */
+#define IDOK                1
+#define IDCANCEL            2
+#define IDABORT             3
+#define IDRETRY             4
+#define IDIGNORE            5
+#define IDYES               6
+#define IDNO                7
+#define IDCLOSE         	8
+#define IDHELP          	9
+#define IDTRYAGAIN         10
+#define IDCONTINUE         11
+
+/*
+ * MessageBox() Flags
+ */
+#define MB_OK                       0x00000000L
+#define MB_OKCANCEL                 0x00000001L
+#define MB_ABORTRETRYIGNORE         0x00000002L
+#define MB_YESNOCANCEL              0x00000003L
+#define MB_YESNO                    0x00000004L
+#define MB_RETRYCANCEL              0x00000005L
+#define MB_CANCELTRYCONTINUE 		0x00000006L
+
+#define MB_ICONHAND                 0x00000010L
+#define MB_ICONQUESTION             0x00000020L
+#define MB_ICONEXCLAMATION          0x00000030L
+#define MB_ICONASTERISK             0x00000040L
+
+#define MB_USERICON                 0x00000080L
+#define MB_ICONWARNING              MB_ICONEXCLAMATION
+#define MB_ICONERROR                MB_ICONHAND
+
+#define MB_ICONINFORMATION          MB_ICONASTERISK
+#define MB_ICONSTOP                 MB_ICONHAND
+
+#define MB_DEFBUTTON1               0x00000000L
+#define MB_DEFBUTTON2               0x00000100L
+#define MB_DEFBUTTON3               0x00000200L
+#define MB_DEFBUTTON4               0x00000300L
+
+#define MB_APPLMODAL                0x00000000L
+#define MB_SYSTEMMODAL              0x00001000L
+#define MB_TASKMODAL                0x00002000L
+#define MB_HELP                     0x00004000L // Help Button
+
+#define MB_NOFOCUS                  0x00008000L
+#define MB_SETFOREGROUND            0x00010000L
+#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L
+
+#define MB_TOPMOST                  0x00040000L
+#define MB_RIGHT                    0x00080000L
+#define MB_RTLREADING               0x00100000L
+
+#define MB_TYPEMASK                 0x0000000FL
+#define MB_ICONMASK                 0x000000F0L
+#define MB_DEFMASK                  0x00000F00L
+#define MB_MODEMASK                 0x00003000L
+#define MB_MISCMASK                 0x0000C000L
+
+/* help structure not implemented, only used in MSGBOXCALLBACK below*/
+#define HELPINFO_WINDOW    0x0001
+#define HELPINFO_MENUITEM  0x0002
+typedef struct tagHELPINFO {    /* Structure pointed to by lParam of WM_HELP */
+    UINT    cbSize;             /* Size in bytes of this struct  */
+    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
+    int     iCtrlId;            /* Control Id or a Menu item Id. */
+    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
+    DWORD   dwContextId;        /* Context Id associated with this item */
+    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
+}  HELPINFO, FAR *LPHELPINFO;
+
+typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);
+
+typedef struct tagMSGBOXPARAMSA {
+    UINT        cbSize;
+    HWND        hwndOwner;
+    HINSTANCE   hInstance;
+    LPCSTR      lpszText;
+    LPCSTR      lpszCaption;
+    DWORD       dwStyle;
+    LPCSTR      lpszIcon;
+    DWORD       dwContextHelpId;
+    MSGBOXCALLBACK      lpfnMsgBoxCallback;
+    DWORD   dwLanguageId;
+} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
+
+typedef MSGBOXPARAMSA MSGBOXPARAMS;
+
+int WINAPI MessageBoxTimeout(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,
+		UINT uType, WORD wLanguageId, DWORD dwTime);
+int MessageBoxEx(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType,
+  WORD wLanguageId);
+int MessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);
+int MessageBoxIndirect( const MSGBOXPARAMS *lpMsgBoxParams);
+
+/*
+ *  Windows enumeration functions
+ */
+typedef BOOL CALLBACK (*WNDENUMPROC)(HWND, LPARAM);
+
+BOOL WINAPI EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc,
+			       LPARAM lParam);
+
+#ifdef MW_CALL_IDLE_HANDLER
+void WINAPI idle_handler(void);
+#endif
diff -urN microwin/src\include\mwtypes.h microwin-0.90/src\include\mwtypes.h
--- microwin/src\include\mwtypes.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\mwtypes.h	Mon Aug 30 09:29:30 2010
@@ -1,5 +1,10 @@
 #ifndef _MWTYPES_H
 #define _MWTYPES_H
+
+#ifdef _MSC_VER
+#define inline  __inline
+#endif
+
 /*
  * Copyright (c) 1999, 2000, 2001, 2002, 2003, 2005, 2010 Greg Haerr <greg@censoft.com>
  * Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
@@ -7,12 +12,15 @@
  * Exported Microwindows engine typedefs and defines
  */
 #include <stdint.h> 		/* for uint32_t, int32_t*/
+
 #if __ECOS
 #include <ecosmwconfig.h>	/*include the eCos configuration "translation" header */
 #endif
 
 /* configurable options*/
+#ifndef WIN32
 #define USE_ALLOCA	1			/* alloca() is available */
+#endif
 
 #if 0000	/* use if stdint.h missing*/
 /* typedef 32 bit types for 16 and 64 bit environments*/
@@ -26,7 +34,11 @@
 #endif
 
 /* compiler specific defines*/
+#ifdef _MSC_VER
+#define MWPACKED
+#else
 #define MWPACKED	__attribute__ ((aligned(1), packed))
+#endif
 
 /* force byte-packed structures*/
 #if defined(GCC_VERSION)
@@ -36,6 +48,7 @@
 #endif
 
 #if USE_ALLOCA
+
 /* alloca() is available, so use it for better performance */
 #define ALLOCA(size)	alloca(size)
 #define FREEA(pmem)
@@ -1201,6 +1214,7 @@
 	(((c) & 0xFF00FF00UL) | (((c) & 0x00FF0000UL) >> 16) | (((c) & 0x000000FFUL) << 16))
 
 #if MWPIXEL_FORMAT == MWPF_TRUECOLOR8888
+
 #define RGB2PIXEL(r,g,b)	RGB2PIXEL8888(r,g,b)
 #define COLORVALTOPIXELVAL(c)	COLOR2PIXEL8888(c)
 #define PIXELVALTOCOLORVAL(p)	PIXEL8888TOCOLORVAL(p)
@@ -1219,6 +1233,7 @@
 #endif
 
 #if (MWPIXEL_FORMAT == MWPF_TRUECOLOR888) || (MWPIXEL_FORMAT == MWPF_TRUECOLOR0888)
+
 #define RGB2PIXEL(r,g,b)	RGB2PIXEL888(r,g,b)
 #define COLORVALTOPIXELVAL(c)	COLOR2PIXEL888(c)
 #define PIXELVALTOCOLORVAL(p)	PIXEL888TOCOLORVAL(p)
diff -urN microwin/src\include\nano-X.h microwin-0.90/src\include\nano-X.h
--- microwin/src\include\nano-X.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\nano-X.h	Mon Aug 30 09:29:10 2010
@@ -13,6 +13,7 @@
 #endif
 
 #include "mwtypes.h"			/* exported engine MW* types*/
+#include "device.h"
 
 /*
  * The following typedefs are inherited from the Microwindows
@@ -865,8 +866,8 @@
 GR_IMAGE_ID	GrLoadImageFromFile(char *path, int flags);
 void		GrDrawImageFromBuffer(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x,
 			GR_COORD y, GR_SIZE width, GR_SIZE height,
-			void *buffer, int size, int flags);
-GR_IMAGE_ID	GrLoadImageFromBuffer(void *buffer, int size, int flags);
+			const void *buffer, int size, int flags);
+GR_IMAGE_ID	GrLoadImageFromBuffer(const void *buffer, int size, int flags);
 void		GrDrawImageToFit(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x,
 			GR_COORD y, GR_SIZE width, GR_SIZE height,
 			GR_IMAGE_ID imageid);
diff -urN microwin/src\include\nanowm.h microwin-0.90/src\include\nanowm.h
--- microwin/src\include\nanowm.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\nanowm.h	Mon Aug 30 09:47:12 2010
@@ -22,7 +22,7 @@
 #if WMDEBUG
 #define Dprintf printf
 #else
-#define Dprintf(ignore...)
+#define Dprintf		DPRINTF
 #endif
 
 /* The different window types which can be used in windowlist->type */
diff -urN microwin/src\include\swap.h microwin-0.90/src\include\swap.h
--- microwin/src\include\swap.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\swap.h	Mon Aug 30 09:43:18 2010
@@ -145,7 +145,7 @@
 /* ********************************************************************* */
 /* Cygwin (on Win32)                                                     */
 /* ********************************************************************* */
-#elif defined(__CYGWIN__)
+#elif defined(__CYGWIN__) || defined(_MSC_VER)
 /* Cygwin only works on Win32 on x86.  Therefore it is always little-endian */
 # if MW_CPU_BIG_ENDIAN
 #  error MW_CPU_BIG_ENDIAN and your OS disagree about your CPUs byte-order.  Did you accidentally set BIGENDIAN in the config file?
diff -urN microwin/src\include\windef.h microwin-0.90/src\include\windef.h
--- microwin/src\include\windef.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\windef.h	Wed Dec 31 16:00:00 1969
@@ -1,182 +0,0 @@
-/* windef.h*/
-/*
- * Copyright (c) 1999 Greg Haerr <greg@censoft.com>
- *
- * Win32 API base type definitions
- */
-
-#define _WINDEF_H
-
-
-#ifdef VXWORKS
-/* Don't include the internal Tornado header file <ntcontext.h>, **
-** as the definitions in it conflict with these definitions.     */
-#define __INCntcontexth
-/* Bring in the core VxWorks definitions as they could conflict **
-** with the ones below if they are brought in later.            */
-#include <vxWorks.h>
-#endif
-
-
-#ifndef NULL
-#define NULL    ((void *)0)
-#endif
-
-#ifndef FALSE
-#define FALSE               0
-#endif
-
-#ifndef TRUE
-#define TRUE                1
-#endif
-
-#ifndef NOMINMAX
-#ifndef max
-#define max(a,b)            (((a) > (b)) ? (a) : (b))
-#endif
-
-#ifndef min
-#define min(a,b)            (((a) < (b)) ? (a) : (b))
-#endif
-#endif  /* NOMINMAX */
-
-#define CALLBACK
-#define WINAPI
-#define WINAPIV
-#define APIENTRY    	WINAPI
-#define APIPRIVATE
-#define PASCAL
-
-#define FAR
-#define NEAR
-#define CONST		const
-#define CDECL
-
-#define VOID void
-typedef void *PVOID;
-typedef char CHAR;
-typedef short SHORT;
-typedef long LONG;
-typedef SHORT *PSHORT;  
-typedef LONG *PLONG;    
-
-#ifndef VXWORKS
-typedef unsigned char 		UCHAR;
-typedef unsigned short 		USHORT;
-typedef uint32_t		ULONG;
-#ifndef __ITRON_TYPES_h_ /* FIXME RTEMS hack*/
-typedef unsigned int		UINT;
-#endif
-
-#ifndef __ITRON_TYPES_h_
-#ifndef COMMON_H	 /* MiniGUI hack*/
-typedef int			BOOL;
-#endif
-#endif
-
-#endif /* !VXWORKS*/
-
-typedef ULONG *			PULONG;
-typedef USHORT *		PUSHORT;
-typedef UCHAR *			PUCHAR;
-typedef char *			PSZ;
-#ifndef __ITRON_TYPES_h_
-typedef int                 	INT;
-#endif
-typedef unsigned int        	*PUINT;
-
-typedef uint32_t       DWORD;
-typedef unsigned char       BYTE;
-typedef unsigned short      WORD;
-
-typedef float               FLOAT;
-typedef FLOAT               *PFLOAT;
-typedef BOOL NEAR           *PBOOL;
-typedef BOOL FAR            *LPBOOL;
-typedef BYTE NEAR           *PBYTE;
-typedef BYTE FAR            *LPBYTE;
-typedef int NEAR            *PINT;
-typedef int FAR             *LPINT;
-typedef WORD NEAR           *PWORD;
-typedef WORD FAR            *LPWORD;
-typedef long FAR            *LPLONG;
-typedef DWORD NEAR          *PDWORD;
-typedef DWORD FAR           *LPDWORD;
-typedef void FAR            *LPVOID;
-typedef CONST void FAR      *LPCVOID;
-
-typedef unsigned short WCHAR;
-typedef WCHAR *PWCHAR;
-typedef WCHAR *LPWCH, *PWCH;
-typedef CONST WCHAR *LPCWCH, *PCWCH;
-typedef WCHAR *NWPSTR;
-typedef WCHAR *LPWSTR, *PWSTR;
-typedef CONST WCHAR *LPCWSTR, *PCWSTR;
-
-typedef CHAR *PCHAR;
-typedef CHAR *LPCH, *PCH;
-typedef CONST CHAR *LPCCH, *PCCH;
-typedef CHAR *NPSTR;
-typedef CHAR *LPSTR, *PSTR;
-typedef CONST CHAR *LPCSTR, *PCSTR;
-typedef char TCHAR, *PTCHAR;
-typedef unsigned char TBYTE , *PTBYTE ;
-typedef LPSTR LPTCH, PTCH;
-typedef LPSTR PTSTR, LPTSTR;
-typedef LPCSTR LPCTSTR;
-
-#define __TEXT(quote) quote
-#define TEXT(quote) __TEXT(quote)
-
-typedef int (FAR WINAPI *FARPROC)();
-typedef int (NEAR WINAPI *NEARPROC)();
-typedef int (WINAPI *PROC)();
-
-typedef UINT WPARAM;
-typedef LONG LPARAM;
-typedef LONG LRESULT;
-typedef LONG HRESULT;
-
-#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
-#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
-#define LOWORD(l)           ((WORD)(l))
-#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
-#define LOBYTE(w)           ((BYTE)(w))
-#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))
-
-#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
-
-typedef DWORD   COLORREF;
-typedef DWORD   *LPCOLORREF;
-
-/* handle typedef*/
-typedef PVOID HANDLE;
-
-typedef HANDLE *PHANDLE;
-typedef HANDLE NEAR         *SPHANDLE;
-typedef HANDLE FAR          *LPHANDLE;
-typedef HANDLE              HGLOBAL;
-typedef HANDLE              HLOCAL;
-typedef HANDLE              GLOBALHANDLE;
-typedef HANDLE              LOCALHANDLE;
-
-typedef WORD                ATOM;
-
-typedef struct hwnd *	HWND;
-typedef struct hdc *	HDC;
-typedef struct hcursor *HCURSOR;
-typedef struct hgdiobj *HGDIOBJ;
-typedef struct hgdiobj *HBRUSH;
-typedef struct hgdiobj *HPEN;
-typedef struct hgdiobj *HFONT;
-typedef struct hgdiobj *HBITMAP;
-typedef struct hgdiobj *HRGN;
-typedef struct hgdiobj *HPALETTE;
-typedef HANDLE		HICON;
-typedef HANDLE		HINSTANCE;
-typedef HANDLE		HMODULE;
-typedef HANDLE		HMENU;
-
-/* moved to winuser.h for resource compiler*/
-/*typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);*/
-
diff -urN microwin/src\include\windows.h microwin-0.90/src\include\windows.h
--- microwin/src\include\windows.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\windows.h	Wed Dec 31 16:00:00 1969
@@ -1,166 +0,0 @@
-#ifndef _WINDOWS_H
-#define _WINDOWS_H
-/* windows.h*/
-/*
- * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
- *
- * Microwindows Win32 API master public header file
- * Modifications:
- *  Date        Author                  Description
- *  2004/12/07  Gabriele Brugnoni       added lpfnWndProc param on wnd struct, so
- *                                      SetWindowLong(GWL_WNDPROC) may works on multiple wnd.
- *  2010/04/23	Ludwig Ertl				Added support for window Props
- */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "mwtypes.h"
-#include "windef.h"
-#include "wingdi.h"
-#include "winfont.h"
-#include "winkbd.h"
-#include "winuser.h"	/* now includes winctl.h for resource compiler*/
-#include "winres.h"
-#include "windlg.h"
-
-
-/* external routines*/
-int WINAPI 	WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
-    			LPSTR lpCmdLine, int nShowCmd);
-
-int		MwUserInit(int ac, char **av);
-
-/* Internal Microwindows non-win32 definitions*/
-
-/* GDI Objects*/
-
-typedef struct {			/* GDI object hdr*/
-	int		type;		/* OBJ_xxx type*/
-	BOOL		stockobj;	/* TRUE if stock (unallocated) object*/
-} MWGDIOBJHDR;
-
-/* gdiobj*/
-struct hgdiobj {
-	MWGDIOBJHDR	hdr;		/* all gdi object start with this hdr*/
-	/* additional data...*/		/* allocated per object type*/
-};
-
-typedef struct {
-	MWGDIOBJHDR	hdr;
-	int		style;		/* pen style*/
-	COLORREF	color;		/* pen color*/
-} MWPENOBJ;
-
-typedef struct {
-	MWGDIOBJHDR	hdr;
-	int		style;		/* brush style*/
-	COLORREF	color;		/* brush color*/
-} MWBRUSHOBJ;
-
-typedef struct {
-	MWGDIOBJHDR	hdr;
-	PMWFONT		pfont;		/* allocated font*/
-	char		name[32];	/* font name (stock objects only)*/
-} MWFONTOBJ;
-
-typedef struct {
-	MWGDIOBJHDR	hdr;
-	int		width;		/* width*/
-	int		height;		/* height*/
-	int		planes;		/* # planes*/
-	int		bpp;		/* bits per pixel*/
-	int		data_format;/* MWIF_ image data format*/
-	int		linelen;	/* bytes per line (to be deprecated)*/
-	int		pitch;		/* bytes per line*/
-	int		size;		/* allocated size in bytes*/
-	char 		bits[1];	/* beginning of bitmap*/
-} MWBITMAPOBJ;
-
-typedef struct {
-	MWGDIOBJHDR   	hdr;
-	MWCLIPREGION  *	rgn;		/* clip region*/
-} MWRGNOBJ;
-
-/* device context*/
-struct hdc {
-	struct _mwscreendevice *psd;	/* screen or memory device*/
-	HWND		hwnd;		/* associated window*/
-	DWORD		flags;		/* clipping flags*/
-	int		bkmode;		/* background mode*/
-	UINT		textalign;	/* text alignment flags*/
-	MWCOLORVAL	bkcolor;	/* text background color*/
-	MWCOLORVAL	textcolor;	/* text color*/
-	MWBRUSHOBJ *	brush;		/* current brush*/
-	MWPENOBJ *	pen;		/* current pen*/
-	MWFONTOBJ *	font;		/* current font*/
-	MWBITMAPOBJ *	bitmap;		/* current bitmap (mem dc's only)*/
-	MWRGNOBJ *	region;		/* user specified clip region*/
-	int		drawmode;	/* rop2 drawing mode */
-	POINT		pt;		/* current pen pos in client coords*/
-};
-
-/* cursor*/
-struct hcursor {
-	int		usecount;	/* use counter */
-	MWCURSOR	cursor;		/* software cursor definition*/
-};
-
-/* built-in scrollbars*/
-typedef struct {
-	int		minPos;        /* min value of scroll range.*/
-	int		maxPos;        /* max value of scroll range.*/
-	int		curPos;        /* current scroll pos.*/
-	int     trackPos;      /* current scroll box track position */
-	int		pageStep;      /* steps per page.*/
-	int		barStart;      /* start pixel of bar.*/
-	int		barLen;        /* length of bar.*/
-	int		status;        /* status of scroll bar.*/
-	RECT		rc;	       /* screen coordinates position*/
-} MWSCROLLBARINFO, *PMWSCROLLBARINFO;
-
-/* window*/
-struct hwnd {
-	RECT		winrect;	/* window rect in screen coords*/
-	RECT		clirect;	/* client rect in screen coords*/
-	RECT		restorerc;	/* restore rect from maximized*/
-	DWORD		style;		/* window style*/
-	DWORD		exstyle;	/* window extended style*/
-	PWNDCLASS	pClass;		/* window class*/
-	WNDPROC     	lpfnWndProc;	/* default window procedure (initialized from pClass) */
-	struct hwnd	*parent;	/* z-order parent window */
-	struct hwnd	*owner;		/* owner window*/
-	struct hwnd	*children;	/* first child window */
-	struct hwnd	*siblings;	/* next sibling window */
-	struct hwnd	*next;		/* next window in complete list */
-	struct hcursor	*cursor;	/* cursor for this window */
-	struct hdc *	owndc;		/* owndc if CS_OWNDC*/
-	int		unmapcount;	/* count of reasons not really mapped */
-	int		id;		/* window id */
-	LPTSTR		szTitle;	/* window title*/
-	int		gotPaintMsg;	/* window had WM_PAINT PostMessage*/
-	int		paintSerial;	/* experimental serial # for alphblend*/
-	int		paintNC;	/* experimental NC paint handling*/
-	int		nEraseBkGnd;	/* for InvalidateXX erase bkgnd flag */
-	HBRUSH		paintBrush;	/* brush created to paint some controls */
-	HPEN		paintPen;	/* pen created to paint some controls */
-	MWCLIPREGION *	update;		/* update region in screen coords*/
-	DWORD		userdata;	/* setwindowlong user data*/
-	DWORD		userdata2;	/* additional user data (will remove)*/
-	MWLISTHEAD  	props;		/* windows property list */
-	MWSCROLLBARINFO	hscroll;	/* NC scrollbars*/
-	MWSCROLLBARINFO	vscroll;
-	HINSTANCE	hInstance;	/* hInstance */
-	int		nextrabytes;	/* # window extra bytes*/
-	char		extrabytes[1];	/* window extra bytes - must be last*/
-};
-
-/* misc apis - will move to another header file*/
-DWORD WINAPI	GetTickCount(VOID);
-VOID WINAPI	Sleep(DWORD dwMilliseconds);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _WINDOWS_H*/
diff -urN microwin/src\include\windowsx.h microwin-0.90/src\include\windowsx.h
--- microwin/src\include\windowsx.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\windowsx.h	Wed Dec 31 16:00:00 1969
@@ -1,55 +0,0 @@
-#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)
-#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
-    (void)(fn)((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))
-
-#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (LPCREATESTRUCT)(lParam)) ? 0L : (LRESULT)-1L)
-#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
-    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0L, (LPARAM)(LPCREATESTRUCT)(lpCreateStruct))
-
-#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
-    ((fn)(hwnd), 0L)
-#define FORWARD_WM_DESTROY(hwnd, fn) \
-    (void)(fn)((hwnd), WM_DESTROY, 0L, 0L)
-
-#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
-    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
-#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
-   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)
-
-#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
-#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
-    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
-
-#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
-
-#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
-#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
-    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
-
-#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
-#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
-    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
-
-#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (HWND)(wParam)), 0L)
-#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
-    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)
-
-#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (HWND)(wParam)), 0L)
-#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
-    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)
-
-#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
-    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
-#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
-    (void)(fn)((hwnd), WM_SETTEXT, 0L, (LPARAM)(LPCTSTR)(lpszText))
-
-#define HANDLE_MSG(hwnd, message, fn)    \
-    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))
diff -urN microwin/src\include\winerror.h microwin-0.90/src\include\winerror.h
--- microwin/src\include\winerror.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\winerror.h	Wed Dec 31 16:00:00 1969
@@ -1,65 +0,0 @@
-#ifndef _WINERROR_
-#define _WINERROR_
-
-extern DWORD lastWIN32Error;
-
-#define GetLastError() lastWIN32Error
-#define SetLastError(dwErr) lastWIN32Error=dwErr
-
-//
-// MessageId: ERROR_SUCCESS
-//
-// MessageText:
-//
-//  The operation completed successfully.
-//
-#define ERROR_SUCCESS                    0L
-
-//
-// MessageId: ERROR_OUTOFMEMORY
-//
-// MessageText:
-//
-//  Not enough storage is available to complete this operation.
-//
-#define ERROR_OUTOFMEMORY                14L
-
-//
-// MessageId: ERROR_INVALID_PARAMETER
-//
-// MessageText:
-//
-//  The parameter is incorrect.
-//
-#define ERROR_INVALID_PARAMETER          87L    // dderror
-
-
-// MessageId: ERROR_IO_PENDING
-//
-// MessageText:
-//
-//  Overlapped I/O operation is in progress.
-//
-#define ERROR_IO_PENDING                 997L    // dderror
-
-//
-// MessageId: ERROR_INSUFFICIENT_BUFFER
-//
-// MessageText:
-//
-//  The data area passed to a system call is too
-//  small.
-//
-#define ERROR_INSUFFICIENT_BUFFER        122L    // dderror
-
-//
-// MessageId: ERROR_IO_PENDING
-//
-// MessageText:
-//
-//  Overlapped I/O operation is in progress.
-//
-#define ERROR_IO_PENDING                 997L    // dderror
-
-
-#endif
diff -urN microwin/src\include\wingdi.h microwin-0.90/src\include\wingdi.h
--- microwin/src\include\wingdi.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\wingdi.h	Wed Dec 31 16:00:00 1969
@@ -1,467 +0,0 @@
-/* wingdi.h*/
-/*
- * Copyright (c) 1999,2000,2001,2005 Greg Haerr <greg@censoft.com>
- *
- * Win32 GDI structures and API
- */
-
-#ifndef _WINGDI_H_
-#define _WINGDI_H_
-
-#include "device.h"
-
-/* portable coordinate definition*/
-typedef MWCOORD	GDICOORD;
-
-/* inherit RECT and POINT from mwtypes.h*/
-typedef MWRECT	RECT;
-typedef MWPOINT	POINT;
-
-#if 0000
-typedef struct  tagRECT {
-    GDICOORD left;
-    GDICOORD top;
-    GDICOORD right;
-    GDICOORD bottom;
-} RECT;
-
-typedef struct  tagPOINT {
-    GDICOORD x;
-    GDICOORD y;
-} POINT; 
-#endif
-
-typedef RECT NEAR *PRECT, FAR *LPRECT;
-
-typedef POINT NEAR *PPOINT, FAR *LPPOINT;
-
-typedef struct  tagSIZE {
-    GDICOORD cx;
-    GDICOORD cy;
-} SIZE, NEAR *PSIZE, FAR *LPSIZE;
-
-/* GetDCEx flags*/
-#define DCX_WINDOW           0x00000001L
-#define DCX_CACHE            0x00000002L
-#define DCX_NORESETATTRS     0x00000004L
-#define DCX_CLIPCHILDREN     0x00000008L
-#define DCX_CLIPSIBLINGS     0x00000010L
-#define DCX_PARENTCLIP       0x00000020L
-#define DCX_EXCLUDERGN       0x00000040L
-#define DCX_INTERSECTRGN     0x00000080L
-#define DCX_EXCLUDEUPDATE    0x00000100L
-#define DCX_INTERSECTUPDATE  0x00000200L
-#define DCX_LOCKWINDOWUPDATE 0x00000400L
-#define DCX_VALIDATE         0x00200000L
-#define DCX_DEFAULTCLIP      0x80000000L	/* microwin only*/
-
-HDC WINAPI	GetDCEx(HWND hwnd,HRGN hrgnClip,DWORD flags);
-HDC WINAPI	GetDC(HWND hWnd);
-HDC WINAPI 	GetWindowDC(HWND hWnd);
-int WINAPI 	ReleaseDC(HWND hWnd, HDC hDC);
-BOOL WINAPI	DeleteDC(HDC hdc);
-
-typedef struct tagPAINTSTRUCT {
-    HDC         hdc;
-    BOOL        fErase;			/* indicates bkgnd needs erasing*/
-    RECT        rcPaint;		/* nyi*/
-    BOOL        fRestore;		/* nyi*/
-    BOOL        fIncUpdate;		/* nyi*/
-    BYTE        rgbReserved[32];
-} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, FAR *LPPAINTSTRUCT;
-
-HDC WINAPI 	BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
-BOOL WINAPI 	EndPaint(HWND hWnd, CONST PAINTSTRUCT *lpPaint);
-
-typedef HANDLE HDWP;
-
-HDWP BeginDeferWindowPos(int nNumWindows);
-HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter,
-		int x, int y, int cx, int cy, UINT uFlags);
-BOOL EndDeferWindowPos(HDWP hWinPosInfo);
-
-
-#define RGB(r,g,b)	    MWRGB(r,g,b)
-#define GetRValue(rgb)      ((BYTE)(rgb))
-#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
-#define GetBValue(rgb)      ((BYTE)((rgb)>>16))
-
-/* Background Modes */
-#define TRANSPARENT	1
-#define OPAQUE		2
-
-/* Text Alignment*/
-#define TA_NOUPDATECP                0
-#define TA_UPDATECP                  1
-
-#define TA_LEFT                      0
-#define TA_RIGHT                     2
-#define TA_CENTER                    6
-
-#define TA_TOP                       0
-#define TA_BOTTOM                    8
-#define TA_BASELINE                  24
-#define TA_RTLREADING                256
-#define TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
-
-COLORREF WINAPI	SetTextColor(HDC, COLORREF);
-COLORREF WINAPI GetTextColor(HDC hdc);
-COLORREF WINAPI	SetBkColor(HDC, COLORREF);
-int WINAPI 	SetBkMode(HDC, int);
-UINT WINAPI     SetTextAlign(HDC hdc, UINT fMode);
-UINT WINAPI		GetTextAlign(HDC hdc);
-
-/* Binary raster ops*/
-#define R2_BLACK            (MWROP_CLEAR+1)		/*  0       */
-#define R2_NOTMERGEPEN      (MWROP_NOR+1)		/* DPon     */
-#define R2_MASKNOTPEN       (MWROP_ANDINVERTED+1)	/* DPna     */
-#define R2_NOTCOPYPEN       (MWROP_COPYINVERTED+1)	/* Pn       */
-#define R2_MASKPENNOT       (MWROP_ANDREVERSE+1)	/* PDna     */
-#define R2_NOT              (MWROP_INVERT+1)		/* Dn       */
-#define R2_XORPEN           (MWROP_XOR+1)		/* DPx      */
-#define R2_NOTMASKPEN       (MWROP_NAND+1)		/* DPan     */
-#define R2_MASKPEN          (MWROP_AND+1)		/* DPa      */
-#define R2_NOTXORPEN        (MWROP_EQUIV+1)		/* DPxn     */
-#define R2_NOP              (MWROP_NOOP+1)		/* D        */
-#define R2_MERGENOTPEN      (MWROP_ORINVERTED+1)	/* DPno     */
-#define R2_COPYPEN          (MWROP_COPY+1)		/* P        */
-#define R2_MERGEPENNOT      (MWROP_ORREVERSE+1)	/* PDno     */
-#define R2_MERGEPEN         (MWROP_OR+1)		/* DPo      */
-#define R2_WHITE            (MWROP_SET+1)		/*  1       */
-#define R2_LAST             16
-
-int WINAPI	SetROP2(HDC hdc, int fnDrawMode);
-
-#define GDI_ERROR	(0xFFFFFFFFL)
-#define CLR_INVALID     0xFFFFFFFF
-
-COLORREF WINAPI GetPixel(HDC hdc, int x, int y);
-COLORREF WINAPI	SetPixel(HDC hdc, int x, int y, COLORREF crColor);
-BOOL WINAPI 	MoveToEx(HDC hdc, int x, int y, LPPOINT lpPoint);
-BOOL WINAPI 	LineTo(HDC hdc, int x, int y);
-BOOL WINAPI	Polyline(HDC hdc, CONST POINT *lppt, int cPoints);
-BOOL WINAPI	PolyPolygon(HDC hdc, CONST POINT *lpPoints, LPINT lpPolyCounts,
-			int nCount);
-BOOL WINAPI	Rectangle(HDC hdc, int nLeft, int nTop, int nRight,int nBottom);
-BOOL WINAPI	Ellipse(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
-			int nBottomRect);
-BOOL WINAPI	Arc(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
-			int nBottomRect, int nXStartArc, int nYStartArc,
-			int nXEndArc, int nYEndArc);
-BOOL WINAPI	Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
-			int nBottomRect, int nXRadial1, int nYRadial1,
-			int nXRadial2, int nYRadial2);
-BOOL WINAPI	Polygon(HDC hdc, CONST POINT *lpPoints, int nCount);
-int WINAPI	FillRect(HDC hDC, CONST RECT *lprc, HBRUSH hbr);
-BOOL WINAPI	DrawFocusRect(HDC hdc, LPRECT prect);
-
-/* ExTextOut options*/
-#define ETO_OPAQUE	0x0002
-#define ETO_CLIPPED	0x0004		/* nyi*/
-
-BOOL WINAPI	TextOut(HDC hdc, int x, int y, LPCSTR lpszString, int cbString);
-BOOL WINAPI	TextOutW(HDC hdc, int x, int y, LPCWSTR lpszString, int cbString);
-BOOL WINAPI	ExtTextOut(HDC hdc, int x, int y, UINT fuOptions,
-			CONST RECT *lprc, LPCSTR lpszString, UINT cbCount,
-			CONST INT *lpDx);
-BOOL WINAPI	ExtTextOutW(HDC hdc, int x, int y, UINT fuOptions,
-			CONST RECT *lprc, LPCWSTR lpszString, UINT cbCount,
-			CONST INT *lpDx);
-LONG WINAPI TabbedTextOut ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
-            int ntabs, LPINT lpTabStops, int nTabOrigin );
-DWORD WINAPI GetTabbedTextExtent ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
-            int ntabs, LPINT lpTabStops );
-
-/* DrawText options*/
-#define DT_TOP              0x00000000
-#define DT_LEFT             0x00000000
-#define DT_CENTER           0x00000001
-#define DT_RIGHT            0x00000002
-#define DT_VCENTER          0x00000004
-#define DT_BOTTOM           0x00000008
-#define DT_WORDBREAK        0x00000010
-#define DT_SINGLELINE       0x00000020
-#define DT_EXPANDTABS       0x00000040
-#define DT_TABSTOP          0x00000080
-#define DT_NOCLIP           0x00000100
-#define DT_EXTERNALLEADING  0x00000200
-#define DT_CALCRECT         0x00000400
-#define DT_NOPREFIX         0x00000800
-#define DT_INTERNAL         0x00001000
-#define DT_EDITCONTROL      0x00002000
-#define DT_PATH_ELLIPSIS    0x00004000
-#define DT_END_ELLIPSIS     0x00008000
-#define DT_MODIFYSTRING     0x00010000
-#define DT_RTLREADING       0x00020000
-#define DT_WORD_ELLIPSIS    0x00040000
-
-int WINAPI	DrawTextA(HDC hdc, LPCSTR lpString, int nCount, LPRECT lpRect,
-			UINT uFormat);
-int WINAPI	DrawTextW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect,
-			UINT uFormat);
-#define DrawText DrawTextA
-
-BOOL WINAPI	DrawDIB(HDC hdc,int x, int y,PMWIMAGEHDR pimage); /* microwin*/
-
-/* GetSysColor, FillRect colors*/
-#define COLOR_SCROLLBAR         0
-#define COLOR_BACKGROUND        1
-#define COLOR_ACTIVECAPTION     2
-#define COLOR_INACTIVECAPTION   3
-#define COLOR_MENU              4
-#define COLOR_WINDOW            5
-#define COLOR_WINDOWFRAME       6
-#define COLOR_MENUTEXT          7
-#define COLOR_WINDOWTEXT        8
-#define COLOR_CAPTIONTEXT       9
-#define COLOR_ACTIVEBORDER      10
-#define COLOR_INACTIVEBORDER    11
-#define COLOR_APPWORKSPACE      12
-#define COLOR_HIGHLIGHT         13
-#define COLOR_HIGHLIGHTTEXT     14
-#define COLOR_BTNFACE           15
-#define COLOR_BTNSHADOW         16
-#define COLOR_GRAYTEXT          17
-#define COLOR_BTNTEXT           18
-#define COLOR_INACTIVECAPTIONTEXT 19
-#define COLOR_BTNHIGHLIGHT      20
-#define COLOR_3DDKSHADOW        21
-#define COLOR_3DLIGHT           22
-#define COLOR_INFOTEXT          23
-#define COLOR_INFOBK            24
-#define COLOR_DESKTOP           COLOR_BACKGROUND
-#define COLOR_3DFACE            COLOR_BTNFACE
-#define COLOR_3DSHADOW          COLOR_BTNSHADOW
-#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
-#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
-#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
-#define COLOR_ALTERNATEBUTTONFACE	25
-#define COLOR_HOTLIGHT                  26
-#define COLOR_GRADIENTACTIVECAPTION     27
-#define COLOR_GRADIENTINACTIVECAPTION   28
-
-DWORD WINAPI	GetSysColor(int nIndex);
-COLORREF WINAPI	SetSysColor(int nIndex, COLORREF crColor);/* Microwindows only*/
-
-/* Stock Logical Objects */
-#define WHITE_BRUSH         0
-#define LTGRAY_BRUSH        1
-#define GRAY_BRUSH          2
-#define DKGRAY_BRUSH        3
-#define BLACK_BRUSH         4
-#define NULL_BRUSH          5
-#define HOLLOW_BRUSH        NULL_BRUSH
-#define WHITE_PEN           6
-#define BLACK_PEN           7
-#define NULL_PEN            8
-#define OEM_FIXED_FONT      10
-#define ANSI_FIXED_FONT     11
-#define ANSI_VAR_FONT       12
-#define SYSTEM_FONT         13
-#define DEVICE_DEFAULT_FONT 14
-#define DEFAULT_PALETTE     15
-#define SYSTEM_FIXED_FONT   16
-#define DEFAULT_GUI_FONT    17
-#define DC_BRUSH            18
-#define DC_PEN              19
-#define STOCK_LAST          19
-
-/* Object types*/
-#define OBJ_PEN             1
-#define OBJ_BRUSH           2
-#define OBJ_DC              3
-#define OBJ_METADC          4
-#define OBJ_PAL             5
-#define OBJ_FONT            6
-#define OBJ_BITMAP          7
-#define OBJ_REGION          8
-#define OBJ_METAFILE        9
-#define OBJ_MEMDC           10
-#define OBJ_EXTPEN          11
-#define OBJ_ENHMETADC       12
-#define OBJ_ENHMETAFILE     13
-
-HGDIOBJ WINAPI	GetStockObject(int nObject);
-HGDIOBJ WINAPI	SelectObject(HDC hdc, HGDIOBJ hObject);
-BOOL WINAPI	DeleteObject(HGDIOBJ hObject);
-int WINAPI	SelectClipRgn(HDC hdc, HRGN hrgn);
-int WINAPI	ExtSelectClipRgn(HDC hdc, HRGN hrgn, int fnMode);
-int WINAPI	GetUpdateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
-BOOL WINAPI	GetUpdateRect(HWND hwnd, LPRECT lpRect, BOOL bErase);
-
-/* Brush Styles */
-#define BS_SOLID            0
-#define BS_NULL             1
-#define BS_HOLLOW           BS_NULL
-
-HBRUSH WINAPI	CreateSolidBrush(COLORREF crColor);
-
-/* Pen Styles */
-#define PS_SOLID            0
-#define PS_NULL             5
-
-HPEN WINAPI	CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
-
-HBITMAP WINAPI	CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight);
-
-/* constants for the biCompression field */
-#define BI_RGB        0L
-#define BI_RLE8       1L
-#define BI_RLE4       2L
-#define BI_BITFIELDS  3L
-
-#pragma pack(2)
-typedef struct tagBITMAPINFOHEADER { // bmih
-    DWORD  PACKEDDATA biSize;
-    LONG   PACKEDDATA biWidth;
-    LONG   PACKEDDATA biHeight;
-    WORD   PACKEDDATA biPlanes;
-    WORD   PACKEDDATA biBitCount;
-    DWORD  PACKEDDATA biCompression;
-    DWORD  PACKEDDATA biSizeImage;
-    LONG   PACKEDDATA biXPelsPerMeter;
-    LONG   PACKEDDATA biYPelsPerMeter;
-    DWORD  PACKEDDATA biClrUsed;
-    DWORD  PACKEDDATA biClrImportant;
-} BITMAPINFOHEADER;
-#pragma pack()
-
-typedef struct tagRGBQUAD { // rgbq
-    BYTE    rgbBlue;
-    BYTE    rgbGreen;
-    BYTE    rgbRed;
-    BYTE    rgbReserved;
-} RGBQUAD;
-
-typedef struct tagBITMAPINFO { // bmi
-    BITMAPINFOHEADER bmiHeader;
-    RGBQUAD          bmiColors[1];
-} BITMAPINFO;
-
-
-/* DIB color table identifiers */
-
-#define DIB_RGB_COLORS      0 /* color table in RGBs */
-#define DIB_PAL_COLORS      1 /* color table in palette indices */
-
-HBITMAP CreateDIBSection(
-  HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage,
-  VOID **ppvBits, HANDLE hSection, DWORD dwOffset);
-HDC WINAPI	CreateCompatibleDC(HDC hdc);
-
-/* BitBlit raster opcodes*/
-#define SRCCOPY         (DWORD)MWROP_COPY	  /* source                   */
-#define SRCPAINT        (DWORD)MWROP_OR		  /* source OR dest           */
-#define SRCAND          (DWORD)MWROP_AND	  /* source AND dest          */
-#define SRCINVERT       (DWORD)MWROP_XOR	  /* source XOR dest          */
-#define SRCERASE        (DWORD)MWROP_ANDREVERSE	  /* source AND (NOT dest )   */
-#define NOTSRCCOPY      (DWORD)MWROP_COPYINVERTED /* (NOT source)             */
-#define NOTSRCERASE     (DWORD)MWROP_NOR	  /* (NOT src) AND (NOT dest) */
-#define MERGEPAINT      (DWORD)MWROP_ORINVERTED   /* (NOT source) OR dest     */
-#define DSTINVERT       (DWORD)MWROP_INVERT	  /* (NOT dest)               */
-#define BLACKNESS       (DWORD)MWROP_CLEAR	  /* BLACK                    */
-#define WHITENESS       (DWORD)MWROP_SET	  /* WHITE                    */
-#if 0
-#define MERGECOPY       (DWORD)0x00C000CA /* (source AND pattern)     */
-#define PATCOPY         (DWORD)0x00F00021 /* pattern                  */
-#define PATPAINT        (DWORD)0x00FB0A09 /* DPSnoo                   */
-#define PATINVERT       (DWORD)0x005A0049 /* pattern XOR dest         */
-#endif
-
-BOOL WINAPI	BitBlt(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,
-			HDC hdcSrc,int nXSrc,int nYSrc,DWORD dwRop);
-BOOL WINAPI	StretchBlt(HDC hdcDest,int nXOriginDest,int nYOriginDest,
-			int nWidthDest,int nHeightDest,HDC hdcSrc,
-			int nXOriginSrc,int nYOriginSrc,int nWidthSrc,
-			int nHeightSrc, DWORD dwRop);
-
-/* Palette entry flags*/
-#define PC_RESERVED	0x01
-#define PC_EXPLICIT	0x02
-#define PC_NOCOLLAPSE	0x04
-
-typedef struct tagPALETTEENTRY {
-	BYTE	peRed;
-	BYTE	peGreen;
-	BYTE	peBlue;
-	BYTE	peFlags;
-} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;
-
-UINT WINAPI	GetSystemPaletteEntries(HDC hdc,UINT iStartIndex,UINT nEntries,
-			LPPALETTEENTRY lppe);
-
-/* GetDeviceCaps parameters*/
-#define HORZRES       8     /* Horizontal width in pixels               */
-#define VERTRES       10    /* Vertical height in pixels                */
-#define BITSPIXEL     12    /* Number of bits per pixel                 */
-#define PLANES        14    /* Number of planes                         */
-#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
-#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */
-#define SIZEPALETTE  104    /* Number of entries in physical palette    */
-
-int WINAPI	GetDeviceCaps(HDC hdc, int nIndex);
-
-/* Region flags*/
-#define ERRORREGION		MWREGION_ERROR
-#define NULLREGION		MWREGION_NULL
-#define SIMPLEREGION		MWREGION_SIMPLE
-#define COMPLEXREGION		MWREGION_COMPLEX
-/* kluge for VxWorks*/
-#ifdef ERROR
-#undef ERROR
-#endif
-#define ERROR			ERRORREGION
-#define RGN_ERROR		ERRORREGION
-
-/* CombineRgn() Styles */
-#define RGN_AND             1
-#define RGN_OR              2
-#define RGN_XOR             3
-#define RGN_DIFF            4
-#define RGN_COPY            5
-#define RGN_MIN             RGN_AND
-#define RGN_MAX             RGN_COPY
-
-/* GetRegionData/ExtCreateRegion */
-#define RDH_RECTANGLES  1
-typedef struct _RGNDATAHEADER {
-    DWORD   dwSize;
-    DWORD   iType;
-    DWORD   nCount;
-    DWORD   nRgnSize;
-    RECT    rcBound;
-} RGNDATAHEADER, *PRGNDATAHEADER;
-
-typedef struct _RGNDATA {
-    RGNDATAHEADER   rdh;
-    char            Buffer[1];
-} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
-
-/* Region entry points*/
-INT  WINAPI OffsetRgn(HRGN hrgn, INT x, INT y );
-INT  WINAPI GetRgnBox(HRGN hrgn, LPRECT rect );
-HRGN WINAPI CreateRectRgn(INT left, INT top, INT right, INT bottom);
-HRGN WINAPI CreateRectRgnIndirect(const RECT* rect );
-VOID WINAPI SetRectRgn(HRGN hrgn, INT left, INT top, INT right, INT bottom );
-HRGN WINAPI CreateRoundRectRgn(INT left, INT top, INT right, INT bottom,
-		INT ellipse_width, INT ellipse_height );
-HRGN WINAPI CreateEllipticRgn(INT left, INT top, INT right, INT bottom );
-HRGN WINAPI CreateEllipticRgnIndirect(const RECT *rect );
-HRGN WINAPI CreatePolygonRgn(const POINT *points, INT count, INT mode);
-DWORD WINAPI GetRegionData(HRGN hrgn, DWORD count, LPRGNDATA rgndata);
-BOOL WINAPI PtInRegion(HRGN hrgn, INT x, INT y );
-BOOL WINAPI RectInRegion(HRGN hrgn, const RECT *rect );
-BOOL WINAPI EqualRgn(HRGN hrgn1, HRGN hrgn2 );
-INT  WINAPI CombineRgn(HRGN hDest, HRGN hSrc1, HRGN hSrc2, INT mode);
-BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
-
-/* Rect entry points*/
-BOOL WINAPI IntersectRect(LPRECT dest, const RECT *src1, const RECT *src2 );
-BOOL WINAPI UnionRect(LPRECT dest, const RECT *src1, const RECT *src2 );
-BOOL WINAPI EqualRect(const RECT* rect1, const RECT* rect2 );
-BOOL WINAPI SubtractRect(LPRECT dest, const RECT *src1, const RECT *src2 );
-
-/* GDI math stuff */
-int WINAPI MulDiv(int nMultiplicand, int nMultiplier, int nDivisor);
-
-#endif
diff -urN microwin/src\include\winuser.h microwin-0.90/src\include\winuser.h
--- microwin/src\include\winuser.h	Thu Aug 26 19:41:58 2010
+++ microwin-0.90/src\include\winuser.h	Wed Dec 31 16:00:00 1969
@@ -1,732 +0,0 @@
-/* winuser.h*/
-/*
- * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
- *
- * Win32 USER structures and API
- */
-#include "winctl.h"	/* required compatibility for resource compiler*/
-
-/* moved from windef.h for resource compiler*/
-typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
-typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
-
-/* win api*/
-LRESULT WINAPI 	DefWindowProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam);
-
-/* Class styles*/
-#define CS_VREDRAW          0x0001
-#define CS_HREDRAW          0x0002
-#define CS_DBLCLKS          0x0008
-#define CS_OWNDC            0x0020
-#define CS_CLASSDC          0x0040
-#define CS_PARENTDC         0x0080
-#define CS_NOCLOSE          0x0200
-#define CS_SAVEBITS         0x0800
-#define CS_BYTEALIGNCLIENT  0x1000
-#define CS_BYTEALIGNWINDOW  0x2000
-#define CS_GLOBALCLASS      0x4000
-
-typedef struct tagWNDCLASSA {
-    MWLIST	link;			/* microwin*/
-    UINT        style;
-    WNDPROC     lpfnWndProc;
-    int         cbClsExtra;		/* nyi*/
-    int         cbWndExtra;
-    HINSTANCE   hInstance;		/* nyi*/
-    HICON       hIcon;			/* nyi*/
-    HCURSOR     hCursor;		/* nyi*/
-    HBRUSH      hbrBackground;
-    LPCSTR      lpszMenuName;		/* nyi*/
-    LPCSTR      lpszClassName;
-    CHAR	szClassName[40];	/* microwin*/
-} WNDCLASS, *PWNDCLASS, NEAR *NPWNDCLASS, FAR *LPWNDCLASS;
-
-ATOM WINAPI	RegisterClass(CONST WNDCLASS *lpWndClass);
-BOOL WINAPI UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance);
-
-/*
- * Message structure
- */
-typedef struct tagMSG {
-    MWLIST	link;			/* microwin*/
-    HWND        hwnd;
-    UINT        message;
-    WPARAM      wParam;
-    LPARAM      lParam;
-    DWORD       time;
-    POINT       pt;
-} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;
-
-#define POINTSTOPOINT(pt, pts)                          \
-        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
-          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }
-
-#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
-#define MAKEWPARAM(l, h)      (WPARAM)MAKELONG(l, h)
-#define MAKELPARAM(l, h)      (LPARAM)MAKELONG(l, h)
-#define MAKELRESULT(l, h)     (LRESULT)MAKELONG(l, h)
-
-/* window messages*/
-#define WM_NULL                         0x0000
-#define WM_CREATE                       0x0001
-#define WM_DESTROY                      0x0002
-#define WM_NCDESTROY			WM_DESTROY
-#define WM_MOVE                         0x0003
-#define WM_SIZE                         0x0005
-#define WM_ACTIVATE                     0x0006
-#define WM_SETFOCUS                     0x0007
-#define WM_KILLFOCUS                    0x0008
-#define WM_ENABLE                       0x000A
-#define WM_SETREDRAW					0x000B
-#define WM_SETTEXT                      0x000C
-#define WM_GETTEXT                      0x000D
-#define WM_GETTEXTLENGTH                0x000E
-#define WM_PAINT                        0x000F
-#define WM_CLOSE                        0x0010
-#define WM_QUIT                         0x0012
-#define WM_ERASEBKGND                   0x0014
-#define WM_SHOWWINDOW                   0x0018
-#define WM_CTLCOLOR                     0x0019
-#define WM_NEXTDLGCTL                   0x0028
-#define WM_DRAWITEM                     0x002B
-#define WM_MEASUREITEM                  0x002C
-#define WM_DELETEITEM 					0x002D
-#define WM_VKEYTOITEM					0x002E
-#define WM_CHARTOITEM					0x002F
-#define WM_SETFONT          		0x0030
-#define WM_GETFONT      		0x0031
-#define WM_COMPAREITEM					0x0039
-#define WM_WINDOWPOSCHANGED             0x0047
-#define WM_NOTIFY                       0x004E
-#define WM_NCCALCSIZE                   0x0083
-#define WM_NCHITTEST                    0x0084
-#define WM_NCPAINT                      0x0085
-#define WM_GETDLGCODE                   0x0087
-#define WM_NCMOUSEMOVE                  0x00A0
-#define WM_NCLBUTTONDOWN                0x00A1
-#define WM_NCLBUTTONUP                  0x00A2
-#define WM_NCLBUTTONDBLCLK              0x00A3
-#define WM_NCRBUTTONDOWN                0x00A4
-#define WM_NCRBUTTONUP                  0x00A5
-#define WM_NCRBUTTONDBLCLK              0x00A6
-#define WM_KEYFIRST                     0x0100
-#define WM_KEYDOWN                      0x0100
-#define WM_KEYUP                        0x0101
-#define WM_CHAR                         0x0102
-#define WM_DEADCHAR                     0x0103	/* notimp*/
-#define WM_SYSKEYDOWN                   0x0104	/* nyi*/
-#define WM_SYSKEYUP                     0x0105	/* nyi*/
-#define WM_SYSCHAR                      0x0106
-#define WM_SYSDEADCHAR                  0x0107	/* notimp*/
-#define WM_KEYLAST                      0x0108
-#define WM_INITDIALOG	                0x0110
-#define WM_COMMAND                      0x0111
-#define WM_SYSCOMMAND                   0x0112
-#define WM_TIMER                        0x0113
-#define WM_HSCROLL                      0x0114
-#define WM_VSCROLL                      0x0115
-
-#define WM_ENTERIDLE                    0x0121
-
-#define WM_CTLCOLORMSGBOX               0x0132
-#define WM_CTLCOLOREDIT                 0x0133
-#define WM_CTLCOLORLISTBOX              0x0134
-#define WM_CTLCOLORBTN                  0x0135
-#define WM_CTLCOLORDLG                  0x0136
-#define WM_CTLCOLORSCROLLBAR            0x0137
-#define WM_CTLCOLORSTATIC               0x0138
-
-#define WM_MOUSEFIRST                   0x0200
-#define WM_MOUSEMOVE                    0x0200
-#define WM_LBUTTONDOWN                  0x0201
-#define WM_LBUTTONUP                    0x0202
-#define WM_LBUTTONDBLCLK                0x0203
-#define WM_RBUTTONDOWN                  0x0204
-#define WM_RBUTTONUP                    0x0205
-#define WM_RBUTTONDBLCLK                0x0206
-#define WM_MBUTTONDOWN                  0x0207
-#define WM_MBUTTONUP                    0x0208
-#define WM_MBUTTONDBLCLK                0x0209
-#define WM_MOUSEWHEEL                   0x020A
-#define WM_MOUSELAST                    0x020A
-#define WM_HOTKEY                       0x0312
-
-#define WM_CARET_CREATE    		0x03E0 /* Microwindows only*/
-#define WM_CARET_DESTROY   		0x03E1 /* Microwindows only*/
-#define WM_CARET_BLINK      		0x03E2 /* Microwindows only*/
-#define WM_FDINPUT                      0x03F0 /* Microwindows only*/
-#define WM_FDOUTPUT                     0x03F1 /* Microwindows only*/
-#define WM_FDEXCEPT                     0x03F2 /* Microwindows only*/
-#define WM_USER                         0x0400
-
-/*
- * System Menu Command Values
- */
-#define SC_SIZE         0xF000
-#define SC_MOVE         0xF010
-#define SC_MINIMIZE     0xF020
-#define SC_MAXIMIZE     0xF030
-#define SC_NEXTWINDOW   0xF040
-#define SC_PREVWINDOW   0xF050
-#define SC_CLOSE        0xF060
-#define SC_VSCROLL      0xF070
-#define SC_HSCROLL      0xF080
-#define SC_MOUSEMENU    0xF090
-#define SC_KEYMENU      0xF100
-#define SC_ARRANGE      0xF110
-#define SC_RESTORE      0xF120
-#define SC_TASKLIST     0xF130
-#define SC_SCREENSAVE   0xF140
-#define SC_HOTKEY       0xF150
-
-/* WM_ACTIVATE state values*/
-#define WA_INACTIVE     0
-#define WA_ACTIVE       1
-#define WA_CLICKACTIVE  2
-
-/* WM_NCHITTEST codes*/
-#define HTERROR             (-2)
-#define HTTRANSPARENT       (-1)
-#define HTNOWHERE           0
-#define HTCLIENT            1
-#define HTCAPTION           2
-#define HTSYSMENU           3
-#define HTGROWBOX           4
-#define HTSIZE              HTGROWBOX
-#define HTMENU              5
-#define HTHSCROLL           6
-#define HTVSCROLL           7
-#define HTMINBUTTON         8
-#define HTMAXBUTTON         9
-#define HTLEFT              10
-#define HTRIGHT             11
-#define HTTOP               12
-#define HTTOPLEFT           13
-#define HTTOPRIGHT          14
-#define HTBOTTOM            15
-#define HTBOTTOMLEFT        16
-#define HTBOTTOMRIGHT       17
-#define HTBORDER            18
-#define HTREDUCE            HTMINBUTTON
-#define HTZOOM              HTMAXBUTTON
-#define HTSIZEFIRST         HTLEFT
-#define HTSIZELAST          HTBOTTOMRIGHT
-#define HTOBJECT            19
-#define HTCLOSE             20
-#define HTHELP              21
-
-/* WM_SIZE wparam values*/
-#define SIZE_RESTORED       0
-#define SIZE_MINIMIZED      1
-#define SIZE_MAXIMIZED      2
-#define SIZE_MAXSHOW        3
-#define SIZE_MAXHIDE        4
-
-LRESULT WINAPI  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hwnd, UINT Msg,
-			WPARAM wParam, LPARAM lParam);
-LRESULT WINAPI	SendMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
-BOOL WINAPI	PostMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
-BOOL WINAPI	PostThreadMessage(DWORD dwThreadId, UINT Msg, WPARAM wParam,
-			LPARAM lParam);
-VOID WINAPI	PostQuitMessage(int nExitCode);
-
-/* PeekMessage options*/
-#define PM_NOREMOVE		0x0000
-#define PM_REMOVE		0x0001
-#define PM_NOYIELD		0x0002
-
-BOOL WINAPI	PeekMessage(LPMSG lpMsg, HWND hwnd, UINT uMsgFilterMin,
-			UINT uMsgFilterMax, UINT wRemoveMsg);
-BOOL WINAPI 	GetMessage(LPMSG lpMsg,HWND hwnd,UINT wMsgFilterMin,
-			UINT wMsgFilterMax);
-BOOL WINAPI 	TranslateMessage(CONST MSG *lpMsg);
-LONG WINAPI	DispatchMessage(CONST MSG *lpMsg);
-
-/* Hotkey stuff */
-BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk);
-BOOL UnregisterHotKey(HWND hWnd, int id);
-BOOL MwDeliverHotkey (WPARAM VK_Code, BOOL pressed);
-
-/* note: the following struct is in reverse order from the
- * microsoft version since WINAPI is cdecl in this implementation
- */
-typedef struct tagCREATESTRUCT {
-    DWORD       dwExStyle;
-    LPCSTR      lpszClass;
-    LPCSTR      lpszName;
-    LONG        style;
-    int         x;
-    int         y;
-    int         cx;
-    int         cy;
-    HWND        hwndParent;
-    HMENU       hMenu;
-    HINSTANCE   hInstance;
-    LPVOID      lpCreateParams;
-} CREATESTRUCT, *LPCREATESTRUCT;
-
-typedef struct tagCOMPAREITEMSTRUCT {
-	UINT	CtlType;
-	UINT	CtlID;
-	HWND	hwndItem;
-	UINT	itemID1;
-	DWORD	itemData1;
-	UINT	itemID2;
-	DWORD	itemData2;
-	DWORD	dwLocaleId;
-} COMPAREITEMSTRUCT,*LPCOMPAREITEMSTRUCT;
-typedef struct tagDELETEITEMSTRUCT {
-	UINT CtlType;
-	UINT CtlID;
-	UINT itemID;
-	HWND hwndItem;
-	UINT itemData;
-} DELETEITEMSTRUCT,*PDELETEITEMSTRUCT,*LPDELETEITEMSTRUCT;
-typedef struct tagNMHDR
-{
-    HWND  hwndFrom;
-    UINT  idFrom;
-    UINT  code;         // NM_ code
-}   NMHDR;
-typedef NMHDR FAR * LPNMHDR;
-
-/* Button codes for MW_MOUSEMOVED:
- * Please note that they differ from normal Windows codes
- */
-#define MK_LBUTTON	MWBUTTON_L
-#define MK_RBUTTON	MWBUTTON_R
-#define MK_MBUTTON 	MWBUTTON_M
-
-/*
- * Window Styles
- */
-#define WS_OVERLAPPED       0x00000000L
-#define WS_POPUP            0x80000000L
-#define WS_CHILD            0x40000000L
-#define WS_MINIMIZE         0x20000000L
-#define WS_VISIBLE          0x10000000L
-#define WS_DISABLED         0x08000000L
-#define WS_CLIPSIBLINGS     0x04000000L
-#define WS_CLIPCHILDREN     0x02000000L
-#define WS_MAXIMIZE         0x01000000L
-#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
-#define WS_BORDER           0x00800000L
-#define WS_DLGFRAME         0x00400000L
-#define WS_VSCROLL          0x00200000L
-#define WS_HSCROLL          0x00100000L
-#define WS_SYSMENU          0x00080000L
-#define WS_THICKFRAME       0x00040000L
-#define WS_GROUP            0x00020000L
-#define WS_TABSTOP          0x00010000L
-
-#define WS_MINIMIZEBOX      0x00020000L
-#define WS_MAXIMIZEBOX      0x00010000L
-
-#define WS_TILED            WS_OVERLAPPED
-#define WS_ICONIC           WS_MINIMIZE
-#define WS_SIZEBOX          WS_THICKFRAME
-#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW
-
-/*
- * Common Window Styles
- */
-#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
-                             WS_CAPTION        | \
-                             WS_SYSMENU        | \
-                             WS_THICKFRAME     | \
-                             WS_MINIMIZEBOX    | \
-                             WS_MAXIMIZEBOX)
-
-#define WS_POPUPWINDOW      (WS_POPUP          | \
-                             WS_BORDER         | \
-                             WS_SYSMENU)
-
-#define WS_CHILDWINDOW      (WS_CHILD)
-
-/*
- * Extended Window Styles
- */
-#define WS_EX_DLGMODALFRAME     0x00000001L
-#define WS_EX_NOPARENTNOTIFY    0x00000004L
-#define WS_EX_TOPMOST           0x00000008L
-#define WS_EX_ACCEPTFILES       0x00000010L
-#define WS_EX_TRANSPARENT       0x00000020L
-#define WS_EX_MDICHILD          0x00000040L
-#define WS_EX_TOOLWINDOW        0x00000080L
-#define WS_EX_WINDOWEDGE        0x00000100L
-#define WS_EX_CLIENTEDGE        0x00000200L
-#define WS_EX_CONTEXTHELP       0x00000400L
-
-#define WS_EX_RIGHT             0x00001000L
-#define WS_EX_LEFT              0x00000000L
-#define WS_EX_RTLREADING        0x00002000L
-#define WS_EX_LTRREADING        0x00000000L
-#define WS_EX_LEFTSCROLLBAR     0x00004000L
-#define WS_EX_RIGHTSCROLLBAR    0x00000000L
-
-#define WS_EX_CONTROLPARENT     0x00010000L
-#define WS_EX_STATICEDGE        0x00020000L
-#define WS_EX_APPWINDOW         0x00040000L
-#define WS_EX_LAYERED		0x00080000L
-
-#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
-#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
-
-#define CW_USEDEFAULT       ((int)0x80000000)
-
-#define HWND_DESKTOP        ((HWND)0)
-
-#define CreateWindow(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)\
-		CreateWindowEx(0L, lpClassName, lpWindowName, dwStyle, x, y,\
-		nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)
-
-HWND WINAPI	CreateWindowEx(DWORD dwExStyle, LPCSTR lpClassName,
-    			LPCSTR lpWindowName, DWORD dwStyle, int X, int Y,
-			int nWidth, int nHeight, HWND hwndParent, HMENU hMenu,
-			HINSTANCE hInstance, LPVOID lpParam);
-BOOL WINAPI 	DestroyWindow(HWND hwnd);
-BOOL WINAPI	IsWindow(HWND hwnd);
-#define IsWindowVisible(hwnd)	((BOOL)((hwnd)->unmapcount == 0))
-
-/*
- * ShowWindow() Commands
- */
-#define SW_HIDE             0
-#define SW_SHOWNORMAL       1
-#define SW_NORMAL           1
-#define SW_SHOWMINIMIZED    2
-#define SW_SHOWMAXIMIZED    3
-#define SW_MAXIMIZE         3
-#define SW_SHOWNOACTIVATE   4
-#define SW_SHOW             5
-#define SW_MINIMIZE         6
-#define SW_SHOWMINNOACTIVE  7
-#define SW_SHOWNA           8
-#define SW_RESTORE          9
-#define SW_SHOWDEFAULT      10
-#define SW_FORCEMINIMIZE    11
-#define SW_MAX              11
-
-BOOL WINAPI 	ShowWindow(HWND hwnd, int nCmdShow);
-BOOL WINAPI	InvalidateRect(HWND hwnd, CONST RECT *lpRect, BOOL bErase);
-BOOL WINAPI	InvalidateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
-BOOL WINAPI	ValidateRect(HWND hwnd, CONST RECT *lprc);
-BOOL WINAPI	ValidateRgn(HWND hwnd, HRGN hrgn);
-BOOL WINAPI	UpdateWindow(HWND hwnd);
-
-BOOL WINAPI	SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey,
-			BYTE bAlpha, DWORD dwFlags);
-#define LWA_COLORKEY	0x00000001
-#define LWA_ALPHA	0x00000002
-
-HWND WINAPI	GetFocus(VOID);
-HWND WINAPI	SetFocus(HWND hwnd);
-BOOL WINAPI	SetForegroundWindow(HWND hwnd);
-HWND WINAPI	SetActiveWindow(HWND hwnd);
-HWND WINAPI	GetActiveWindow(VOID);
-BOOL WINAPI	BringWindowToTop(HWND hwnd);
-HWND WINAPI	GetDesktopWindow(VOID);
-HWND WINAPI	GetParent(HWND hwnd);
-BOOL WINAPI	EnableWindow(HWND hwnd, BOOL bEnable);
-#define IsWindowEnabled(hwnd)	((BOOL)(((hwnd)->style&WS_DISABLED) == 0))
-
-BOOL WINAPI	AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu,
-			DWORD dwExStyle);
-BOOL WINAPI	GetClientRect(HWND hwnd, LPRECT lpRect);
-BOOL WINAPI	GetWindowRect(HWND hwnd, LPRECT lpRect);
-
-BOOL WINAPI 	ClientToScreen(HWND hwnd, LPPOINT lpPoint);
-BOOL WINAPI 	ScreenToClient(HWND hwnd, LPPOINT lpPoint);
-int  WINAPI	MapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lpPoints,
-			UINT cPoints);
-
-BOOL WINAPI	SetRect(LPRECT lprc,int xLeft,int yTop,int xRight,int yBottom);
-BOOL WINAPI	SetRectEmpty(LPRECT lprc);
-BOOL WINAPI	CopyRect(LPRECT lprcDst, CONST RECT *lprcSrc);
-BOOL WINAPI	IsRectEmpty(CONST RECT *lprc);
-BOOL WINAPI	InflateRect(LPRECT lprc, int dx, int dy);
-BOOL WINAPI	OffsetRect(LPRECT lprc, int dx, int dy);
-/* The bcc compiler doesn't work passing structs by value, so we have this*/
-#if ELKS
-#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, *(long *)&(pt))
-#else
-#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, pt)
-#endif
-BOOL WINAPI	MwPTINRECT(CONST RECT *lprc, POINT pt);
-
-/*
- * Window field offsets for GetWindowLong()
- */
-#define GWL_WNDPROC         (-4)
-#define GWL_HINSTANCE       (-6)
-#define GWL_HWNDPARENT      (-8)
-#define GWL_STYLE           (-16)
-#define GWL_EXSTYLE         (-20)
-#define GWL_USERDATA        (-21)
-#define GWL_ID              (-12)
-
-/*
- * Class field offsets for GetClassLong()
- */
-#define GCL_MENUNAME        (-8)
-#define GCL_HBRBACKGROUND   (-10)
-#define GCL_HCURSOR         (-12)
-#define GCL_HICON           (-14)
-#define GCL_HMODULE         (-16)
-#define GCL_CBWNDEXTRA      (-18)
-#define GCL_CBCLSEXTRA      (-20)
-#define GCL_WNDPROC         (-24)
-#define GCL_STYLE           (-26)
-#define GCW_ATOM            (-32)
-#define GCL_HICONSM         (-34)
-
-LONG WINAPI	GetWindowLong(HWND hwnd, int nIndex);
-LONG WINAPI	SetWindowLong(HWND hwnd, int nIndex, LONG lNewLong);
-WORD WINAPI	GetWindowWord(HWND hwnd, int nIndex);
-WORD WINAPI	SetWindowWord(HWND hwnd, int nIndex, WORD wNewWord);
-BOOL WINAPI SetProp(HWND hWnd, LPCSTR lpString, HANDLE hData);
-HANDLE WINAPI GetProp(HWND hWnd, LPCSTR lpString);
-HANDLE WINAPI RemoveProp(HWND hWnd, LPCSTR lpString);
-
-#define GetDlgCtrlID(hwnd)	((int)(hwnd)->id)
-DWORD WINAPI	GetClassLong(HWND hwnd, int nIndex);
-int WINAPI	GetWindowTextLength(HWND hwnd);
-int WINAPI	GetWindowText(HWND hwnd, LPSTR lpString, int nMaxCount);
-BOOL WINAPI	SetWindowText(HWND hwnd, LPCSTR lpString);
-
-BOOL WINAPI 	MoveWindow(HWND hwnd, int x, int y, int nWidth, int nHeight,
-    			BOOL bRepaint);
-
-/* SetWindowPos Flags*/
-#define SWP_NOSIZE          0x0001
-#define SWP_NOMOVE          0x0002
-#define SWP_NOZORDER        0x0004
-#define SWP_NOREDRAW        0x0008
-#define SWP_NOACTIVATE      0x0010	/* nyi*/
-#define SWP_FRAMECHANGED    0x0020	/* nyi*/
-#define SWP_SHOWWINDOW      0x0040
-#define SWP_HIDEWINDOW      0x0080
-#define SWP_NOCOPYBITS      0x0100	/* nyi*/
-#define SWP_NOOWNERZORDER   0x0200	/* nyi*/
-#define SWP_NOSENDCHANGING  0x0400	/* nyi*/
-#define SWP_DRAWFRAME       SWP_FRAMECHANGED
-#define SWP_NOREPOSITION    SWP_NOOWNERZORDER
-#define SWP_DEFERERASE      0x2000	/* nyi*/
-#define SWP_ASYNCWINDOWPOS  0x4000	/* nyi*/
-
-#define HWND_TOP        ((HWND)0)	/* nyi*/
-#define HWND_BOTTOM     ((HWND)1)	/* nyi*/
-#define HWND_TOPMOST    ((HWND)-1)	/* nyi*/
-#define HWND_NOTOPMOST  ((HWND)-2)	/* nyi*/
-
-/* WM_WINDOWPOSCHANGED message*/
-typedef struct tagWINDOWPOS {
-	HWND    hwnd;
-	HWND    hwndInsertAfter;
-	int     x;
-	int     y;
-	int     cx;
-	int     cy;
-	UINT    flags;
-} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;
-
-BOOL WINAPI	SetWindowPos(HWND hwnd, HWND hwndInsertAfter, int x, int y,
-			int cx, int cy, UINT fuFlags);
-
-typedef struct tagWINDOWPLACEMENT {
-    UINT  length;
-    UINT  flags;
-    UINT  showCmd;
-    POINT ptMinPosition;
-    POINT ptMaxPosition;
-    RECT  rcNormalPosition;
-} WINDOWPLACEMENT;
-typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
-BOOL SetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
-BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
-
-BOOL WINAPI	GetCursorPos(LPPOINT lpPoint);
-HWND WINAPI	GetCapture(VOID);
-HWND WINAPI	SetCapture(HWND hwnd);
-BOOL WINAPI	ReleaseCapture(VOID);
-
-#define GW_HWNDNEXT 2
-#define GW_HWNDPREV 3
-#define GW_CHILD 5
-#define GW_HWNDFIRST 0
-#define GW_HWNDLAST 1
-#define GW_OWNER 4
-
-HWND GetWindow(HWND hWnd,  UINT uCmd);
-HWND GetMenu (HWND hWnd);
-HWND GetForegroundWindow(VOID);
-HWND WindowFromPoint(POINT pt);
-
-/*
- * WM_NCCALCSIZE parameter structure
- */
-typedef struct tagNCCALCSIZE_PARAMS {
-    RECT       rgrc[3];
-    /*PWINDOWPOS lppos;*/		/* removed for microwin*/
-} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
-
-typedef FARPROC TIMERPROC;
-
-UINT WINAPI	SetTimer(HWND hwnd, UINT idTimer, UINT uTimeout,
-			TIMERPROC lpTimerFunc);
-BOOL WINAPI	KillTimer(HWND hwnd, UINT idTimer);
-UINT		MwGetNextTimeoutValue(void);
-void		MwHandleTimers(void);
-
-/* GetSystemMetrics indices*/
-#define SM_CXSCREEN             0
-#define SM_CYSCREEN             1
-#define SM_CXVSCROLL            2
-#define SM_CYHSCROLL            3
-#define SM_CYCAPTION            4
-#define SM_CXBORDER             5
-#define SM_CYBORDER             6
-#define SM_CXDLGFRAME           7
-#define SM_CYDLGFRAME           8
-#define SM_CXFIXEDFRAME		SM_CXDLGFRAME
-#define SM_CYFIXEDFRAME		SM_CYDLGFRAME
-#define SM_CYMENU               15
-#define SM_CYVSCROLL            20
-#define SM_CXHSCROLL            21
-#define SM_CXFRAME              32
-#define SM_CYFRAME              33
-#define SM_CXSIZEFRAME		SM_CXFRAME
-#define SM_CYSIZEFRAME		SM_CYFRAME
-
-int WINAPI	GetSystemMetrics(int nIndex);
-
-#define SPI_SETWORKAREA            47
-#define SPI_GETWORKAREA            48
-
-BOOL WINAPI SystemParametersInfo (UINT uiAction,  UINT uiParam, PVOID pvParam, UINT fWinIni);
-
-HWND WINAPI	GetDlgItem(HWND hDlg, int nIDDlgItem);
-
-/* ************************** Caret support **********************************/
-BOOL WINAPI CreateCaret(HWND hwnd, HBITMAP hBitmap, int nWidth, int nHeight);
-BOOL WINAPI DestroyCaret(VOID);
-BOOL WINAPI HideCaret (HWND hwnd);
-BOOL WINAPI ShowCaret(HWND hwnd);
-BOOL WINAPI SetCaretPos(int nX, int nY);
-BOOL WINAPI GetCaretPos(LPPOINT lpPoint);
-UINT WINAPI GetCaretBlinkTime(VOID);
-BOOL WINAPI SetCaretBlinkTime(UINT uMSeconds);
-
-
-int WINAPI GetClassName(HWND hWnd, LPTSTR lpClassName, int nMaxCount);
-HWND WINAPI GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
-
-/*
- * Dialog Box Command IDs
- */
-#define IDOK                1
-#define IDCANCEL            2
-#define IDABORT             3
-#define IDRETRY             4
-#define IDIGNORE            5
-#define IDYES               6
-#define IDNO                7
-#define IDCLOSE         	8
-#define IDHELP          	9
-#define IDTRYAGAIN         10
-#define IDCONTINUE         11
-
-/*
- * MessageBox() Flags
- */
-#define MB_OK                       0x00000000L
-#define MB_OKCANCEL                 0x00000001L
-#define MB_ABORTRETRYIGNORE         0x00000002L
-#define MB_YESNOCANCEL              0x00000003L
-#define MB_YESNO                    0x00000004L
-#define MB_RETRYCANCEL              0x00000005L
-#define MB_CANCELTRYCONTINUE 		0x00000006L
-
-#define MB_ICONHAND                 0x00000010L
-#define MB_ICONQUESTION             0x00000020L
-#define MB_ICONEXCLAMATION          0x00000030L
-#define MB_ICONASTERISK             0x00000040L
-
-#define MB_USERICON                 0x00000080L
-#define MB_ICONWARNING              MB_ICONEXCLAMATION
-#define MB_ICONERROR                MB_ICONHAND
-
-#define MB_ICONINFORMATION          MB_ICONASTERISK
-#define MB_ICONSTOP                 MB_ICONHAND
-
-#define MB_DEFBUTTON1               0x00000000L
-#define MB_DEFBUTTON2               0x00000100L
-#define MB_DEFBUTTON3               0x00000200L
-#define MB_DEFBUTTON4               0x00000300L
-
-#define MB_APPLMODAL                0x00000000L
-#define MB_SYSTEMMODAL              0x00001000L
-#define MB_TASKMODAL                0x00002000L
-#define MB_HELP                     0x00004000L // Help Button
-
-#define MB_NOFOCUS                  0x00008000L
-#define MB_SETFOREGROUND            0x00010000L
-#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L
-
-#define MB_TOPMOST                  0x00040000L
-#define MB_RIGHT                    0x00080000L
-#define MB_RTLREADING               0x00100000L
-
-#define MB_TYPEMASK                 0x0000000FL
-#define MB_ICONMASK                 0x000000F0L
-#define MB_DEFMASK                  0x00000F00L
-#define MB_MODEMASK                 0x00003000L
-#define MB_MISCMASK                 0x0000C000L
-
-/* help structure not implemented, only used in MSGBOXCALLBACK below*/
-#define HELPINFO_WINDOW    0x0001
-#define HELPINFO_MENUITEM  0x0002
-typedef struct tagHELPINFO {    /* Structure pointed to by lParam of WM_HELP */
-    UINT    cbSize;             /* Size in bytes of this struct  */
-    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
-    int     iCtrlId;            /* Control Id or a Menu item Id. */
-    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
-    DWORD   dwContextId;        /* Context Id associated with this item */
-    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
-}  HELPINFO, FAR *LPHELPINFO;
-
-typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);
-
-typedef struct tagMSGBOXPARAMSA {
-    UINT        cbSize;
-    HWND        hwndOwner;
-    HINSTANCE   hInstance;
-    LPCSTR      lpszText;
-    LPCSTR      lpszCaption;
-    DWORD       dwStyle;
-    LPCSTR      lpszIcon;
-    DWORD       dwContextHelpId;
-    MSGBOXCALLBACK      lpfnMsgBoxCallback;
-    DWORD   dwLanguageId;
-} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
-
-typedef MSGBOXPARAMSA MSGBOXPARAMS;
-
-int WINAPI MessageBoxTimeout(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,
-		UINT uType, WORD wLanguageId, DWORD dwTime);
-int MessageBoxEx(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType,
-  WORD wLanguageId);
-int MessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);
-int MessageBoxIndirect( const MSGBOXPARAMS *lpMsgBoxParams);
-
-/*
- *  Windows enumeration functions
- */
-typedef BOOL CALLBACK (*WNDENUMPROC)(HWND, LPARAM);
-
-BOOL WINAPI EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc,
-			       LPARAM lParam);
-
-#ifdef MW_CALL_IDLE_HANDLER
-void WINAPI idle_handler(void);
-#endif
diff -urN microwin/src\mwin\include\windef.h microwin-0.90/src\mwin\include\windef.h
--- microwin/src\mwin\include\windef.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\mwin\include\windef.h	Wed Aug 25 14:48:30 2010
@@ -0,0 +1,184 @@
+/* windef.h*/
+/*
+ * Copyright (c) 1999 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 API base type definitions
+ */
+
+#define _WINDEF_H
+
+
+#ifdef VXWORKS
+/* Don't include the internal Tornado header file <ntcontext.h>, **
+** as the definitions in it conflict with these definitions.     */
+#define __INCntcontexth
+/* Bring in the core VxWorks definitions as they could conflict **
+** with the ones below if they are brought in later.            */
+#include <vxWorks.h>
+#endif
+
+
+#ifndef NULL
+#define NULL    ((void *)0)
+#endif
+
+#ifndef FALSE
+#define FALSE               0
+#endif
+
+#ifndef TRUE
+#define TRUE                1
+#endif
+
+#ifndef NOMINMAX
+#ifndef max
+#define max(a,b)            (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef min
+#define min(a,b)            (((a) < (b)) ? (a) : (b))
+#endif
+#endif  /* NOMINMAX */
+
+#define CALLBACK
+#ifndef WINAPI
+#define WINAPI
+#endif
+#define WINAPIV
+#define APIENTRY    	WINAPI
+#define APIPRIVATE
+#define PASCAL
+
+#define FAR
+#define NEAR
+#define CONST		const
+#define CDECL
+
+#define VOID void
+typedef void *PVOID;
+typedef char CHAR;
+typedef short SHORT;
+typedef long LONG;
+typedef SHORT *PSHORT;  
+typedef LONG *PLONG;    
+
+#ifndef VXWORKS
+typedef unsigned char 		UCHAR;
+typedef unsigned short 		USHORT;
+typedef uint32_t		ULONG;
+#ifndef __ITRON_TYPES_h_ /* FIXME RTEMS hack*/
+typedef unsigned int		UINT;
+#endif
+
+#ifndef __ITRON_TYPES_h_
+#ifndef COMMON_H	 /* MiniGUI hack*/
+typedef int			BOOL;
+#endif
+#endif
+
+#endif /* !VXWORKS*/
+
+typedef ULONG *			PULONG;
+typedef USHORT *		PUSHORT;
+typedef UCHAR *			PUCHAR;
+typedef char *			PSZ;
+#ifndef __ITRON_TYPES_h_
+typedef int                 	INT;
+#endif
+typedef unsigned int        	*PUINT;
+
+typedef uint32_t       DWORD;
+typedef unsigned char       BYTE;
+typedef unsigned short      WORD;
+
+typedef float               FLOAT;
+typedef FLOAT               *PFLOAT;
+typedef BOOL NEAR           *PBOOL;
+typedef BOOL FAR            *LPBOOL;
+typedef BYTE NEAR           *PBYTE;
+typedef BYTE FAR            *LPBYTE;
+typedef int NEAR            *PINT;
+typedef int FAR             *LPINT;
+typedef WORD NEAR           *PWORD;
+typedef WORD FAR            *LPWORD;
+typedef long FAR            *LPLONG;
+typedef DWORD NEAR          *PDWORD;
+typedef DWORD FAR           *LPDWORD;
+typedef void FAR            *LPVOID;
+typedef CONST void FAR      *LPCVOID;
+
+typedef unsigned short WCHAR;
+typedef WCHAR *PWCHAR;
+typedef WCHAR *LPWCH, *PWCH;
+typedef CONST WCHAR *LPCWCH, *PCWCH;
+typedef WCHAR *NWPSTR;
+typedef WCHAR *LPWSTR, *PWSTR;
+typedef CONST WCHAR *LPCWSTR, *PCWSTR;
+
+typedef CHAR *PCHAR;
+typedef CHAR *LPCH, *PCH;
+typedef CONST CHAR *LPCCH, *PCCH;
+typedef CHAR *NPSTR;
+typedef CHAR *LPSTR, *PSTR;
+typedef CONST CHAR *LPCSTR, *PCSTR;
+typedef char TCHAR, *PTCHAR;
+typedef unsigned char TBYTE , *PTBYTE ;
+typedef LPSTR LPTCH, PTCH;
+typedef LPSTR PTSTR, LPTSTR;
+typedef LPCSTR LPCTSTR;
+
+#define __TEXT(quote) quote
+#define TEXT(quote) __TEXT(quote)
+
+typedef int (FAR WINAPI *FARPROC)();
+typedef int (NEAR WINAPI *NEARPROC)();
+typedef int (WINAPI *PROC)();
+
+typedef UINT WPARAM;
+typedef LONG LPARAM;
+typedef LONG LRESULT;
+typedef LONG HRESULT;
+
+#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
+#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
+#define LOWORD(l)           ((WORD)(l))
+#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
+#define LOBYTE(w)           ((BYTE)(w))
+#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))
+
+#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
+
+typedef DWORD   COLORREF;
+typedef DWORD   *LPCOLORREF;
+
+/* handle typedef*/
+typedef PVOID HANDLE;
+
+typedef HANDLE *PHANDLE;
+typedef HANDLE NEAR         *SPHANDLE;
+typedef HANDLE FAR          *LPHANDLE;
+typedef HANDLE              HGLOBAL;
+typedef HANDLE              HLOCAL;
+typedef HANDLE              GLOBALHANDLE;
+typedef HANDLE              LOCALHANDLE;
+
+typedef WORD                ATOM;
+
+typedef struct hwnd *	HWND;
+typedef struct hdc *	HDC;
+typedef struct hcursor *HCURSOR;
+typedef struct hgdiobj *HGDIOBJ;
+typedef struct hgdiobj *HBRUSH;
+typedef struct hgdiobj *HPEN;
+typedef struct hgdiobj *HFONT;
+typedef struct hgdiobj *HBITMAP;
+typedef struct hgdiobj *HRGN;
+typedef struct hgdiobj *HPALETTE;
+typedef HANDLE		HICON;
+typedef HANDLE		HINSTANCE;
+typedef HANDLE		HMODULE;
+typedef HANDLE		HMENU;
+
+/* moved to winuser.h for resource compiler*/
+/*typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);*/
+
diff -urN microwin/src\mwin\include\windows.h microwin-0.90/src\mwin\include\windows.h
--- microwin/src\mwin\include\windows.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\mwin\include\windows.h	Wed Aug 25 14:48:30 2010
@@ -0,0 +1,167 @@
+#ifndef __WINDOWS_H__
+#define __WINDOWS_H__
+
+/* windows.h*/
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Microwindows Win32 API master public header file
+ * Modifications:
+ *  Date        Author                  Description
+ *  2004/12/07  Gabriele Brugnoni       added lpfnWndProc param on wnd struct, so
+ *                                      SetWindowLong(GWL_WNDPROC) may works on multiple wnd.
+ *  2010/04/23	Ludwig Ertl				Added support for window Props
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mwtypes.h"
+#include "windef.h"
+#include "wingdi.h"
+#include "winfont.h"
+#include "winkbd.h"
+#include "winuser.h"	/* now includes winctl.h for resource compiler*/
+#include "winres.h"
+#include "windlg.h"
+
+
+/* external routines*/
+int WINAPI 	WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
+    			LPSTR lpCmdLine, int nShowCmd);
+
+int		MwUserInit(int ac, char **av);
+
+/* Internal Microwindows non-win32 definitions*/
+
+/* GDI Objects*/
+
+typedef struct {			/* GDI object hdr*/
+	int		type;		/* OBJ_xxx type*/
+	BOOL		stockobj;	/* TRUE if stock (unallocated) object*/
+} MWGDIOBJHDR;
+
+/* gdiobj*/
+struct hgdiobj {
+	MWGDIOBJHDR	hdr;		/* all gdi object start with this hdr*/
+	/* additional data...*/		/* allocated per object type*/
+};
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		style;		/* pen style*/
+	COLORREF	color;		/* pen color*/
+} MWPENOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		style;		/* brush style*/
+	COLORREF	color;		/* brush color*/
+} MWBRUSHOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	PMWFONT		pfont;		/* allocated font*/
+	char		name[32];	/* font name (stock objects only)*/
+} MWFONTOBJ;
+
+typedef struct {
+	MWGDIOBJHDR	hdr;
+	int		width;		/* width*/
+	int		height;		/* height*/
+	int		planes;		/* # planes*/
+	int		bpp;		/* bits per pixel*/
+	int		data_format;/* MWIF_ image data format*/
+	int		linelen;	/* bytes per line (to be deprecated)*/
+	int		pitch;		/* bytes per line*/
+	int		size;		/* allocated size in bytes*/
+	char 		bits[1];	/* beginning of bitmap*/
+} MWBITMAPOBJ;
+
+typedef struct {
+	MWGDIOBJHDR   	hdr;
+	MWCLIPREGION  *	rgn;		/* clip region*/
+} MWRGNOBJ;
+
+/* device context*/
+struct hdc {
+	struct _mwscreendevice *psd;	/* screen or memory device*/
+	HWND		hwnd;		/* associated window*/
+	DWORD		flags;		/* clipping flags*/
+	int		bkmode;		/* background mode*/
+	UINT		textalign;	/* text alignment flags*/
+	MWCOLORVAL	bkcolor;	/* text background color*/
+	MWCOLORVAL	textcolor;	/* text color*/
+	MWBRUSHOBJ *	brush;		/* current brush*/
+	MWPENOBJ *	pen;		/* current pen*/
+	MWFONTOBJ *	font;		/* current font*/
+	MWBITMAPOBJ *	bitmap;		/* current bitmap (mem dc's only)*/
+	MWRGNOBJ *	region;		/* user specified clip region*/
+	int		drawmode;	/* rop2 drawing mode */
+	POINT		pt;		/* current pen pos in client coords*/
+};
+
+/* cursor*/
+struct hcursor {
+	int		usecount;	/* use counter */
+	MWCURSOR	cursor;		/* software cursor definition*/
+};
+
+/* built-in scrollbars*/
+typedef struct {
+	int		minPos;        /* min value of scroll range.*/
+	int		maxPos;        /* max value of scroll range.*/
+	int		curPos;        /* current scroll pos.*/
+	int     trackPos;      /* current scroll box track position */
+	int		pageStep;      /* steps per page.*/
+	int		barStart;      /* start pixel of bar.*/
+	int		barLen;        /* length of bar.*/
+	int		status;        /* status of scroll bar.*/
+	RECT		rc;	       /* screen coordinates position*/
+} MWSCROLLBARINFO, *PMWSCROLLBARINFO;
+
+/* window*/
+struct hwnd {
+	RECT		winrect;	/* window rect in screen coords*/
+	RECT		clirect;	/* client rect in screen coords*/
+	RECT		restorerc;	/* restore rect from maximized*/
+	DWORD		style;		/* window style*/
+	DWORD		exstyle;	/* window extended style*/
+	PWNDCLASS	pClass;		/* window class*/
+	WNDPROC     	lpfnWndProc;	/* default window procedure (initialized from pClass) */
+	struct hwnd	*parent;	/* z-order parent window */
+	struct hwnd	*owner;		/* owner window*/
+	struct hwnd	*children;	/* first child window */
+	struct hwnd	*siblings;	/* next sibling window */
+	struct hwnd	*next;		/* next window in complete list */
+	struct hcursor	*cursor;	/* cursor for this window */
+	struct hdc *	owndc;		/* owndc if CS_OWNDC*/
+	int		unmapcount;	/* count of reasons not really mapped */
+	int		id;		/* window id */
+	LPTSTR		szTitle;	/* window title*/
+	int		gotPaintMsg;	/* window had WM_PAINT PostMessage*/
+	int		paintSerial;	/* experimental serial # for alphblend*/
+	int		paintNC;	/* experimental NC paint handling*/
+	int		nEraseBkGnd;	/* for InvalidateXX erase bkgnd flag */
+	HBRUSH		paintBrush;	/* brush created to paint some controls */
+	HPEN		paintPen;	/* pen created to paint some controls */
+	MWCLIPREGION *	update;		/* update region in screen coords*/
+	DWORD		userdata;	/* setwindowlong user data*/
+	DWORD		userdata2;	/* additional user data (will remove)*/
+	MWLISTHEAD  	props;		/* windows property list */
+	MWSCROLLBARINFO	hscroll;	/* NC scrollbars*/
+	MWSCROLLBARINFO	vscroll;
+	HINSTANCE	hInstance;	/* hInstance */
+	int		nextrabytes;	/* # window extra bytes*/
+	char		extrabytes[1];	/* window extra bytes - must be last*/
+};
+
+/* misc apis - will move to another header file*/
+DWORD WINAPI	GetTickCount(VOID);
+VOID WINAPI	Sleep(DWORD dwMilliseconds);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WINDOWS_H__ */
diff -urN microwin/src\mwin\include\windowsx.h microwin-0.90/src\mwin\include\windowsx.h
--- microwin/src\mwin\include\windowsx.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\mwin\include\windowsx.h	Wed Aug 25 14:48:30 2010
@@ -0,0 +1,63 @@
+#ifndef __WINDOWSX_H__
+#define __WINDOWSX_H__
+
+#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
+#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
+
+#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(LOWORD(wParam)), (HWND)(lParam), (UINT)HIWORD(wParam)), 0L)
+#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
+    (void)(fn)((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))
+
+#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (LPCREATESTRUCT)(lParam)) ? 0L : (LRESULT)-1L)
+#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
+    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0L, (LPARAM)(LPCREATESTRUCT)(lpCreateStruct))
+
+#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
+    ((fn)(hwnd), 0L)
+#define FORWARD_WM_DESTROY(hwnd, fn) \
+    (void)(fn)((hwnd), WM_DESTROY, 0L, 0L)
+
+#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
+    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
+#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
+   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)
+
+#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), FALSE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), TRUE, (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+
+#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam), (UINT)(wParam)), 0L)
+#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
+    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))
+
+#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (HWND)(wParam)), 0L)
+#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
+    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)
+
+#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (HWND)(wParam)), 0L)
+#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
+    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)
+
+#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
+    ((fn)((hwnd), (LPCTSTR)(lParam)), 0L)
+#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
+    (void)(fn)((hwnd), WM_SETTEXT, 0L, (LPARAM)(LPCTSTR)(lpszText))
+
+#define HANDLE_MSG(hwnd, message, fn)    \
+    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))
+
+#endif /* __WINDOWSX_H__ */
diff -urN microwin/src\mwin\include\wingdi.h microwin-0.90/src\mwin\include\wingdi.h
--- microwin/src\mwin\include\wingdi.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\mwin\include\wingdi.h	Wed Aug 25 14:48:30 2010
@@ -0,0 +1,447 @@
+/* wingdi.h*/
+/*
+ * Copyright (c) 1999,2000,2001,2005 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 GDI structures and API
+ */
+
+#ifndef __WINGDI_H__
+#define __WINGDI_H__
+
+/* portable coordinate definition*/
+typedef MWCOORD	GDICOORD;
+
+/* inherit RECT and POINT from mwtypes.h*/
+typedef MWRECT	RECT;
+typedef MWPOINT	POINT;
+
+#if 0000
+typedef struct  tagRECT {
+    GDICOORD left;
+    GDICOORD top;
+    GDICOORD right;
+    GDICOORD bottom;
+} RECT;
+
+typedef struct  tagPOINT {
+    GDICOORD x;
+    GDICOORD y;
+} POINT; 
+#endif
+
+typedef RECT NEAR *PRECT, FAR *LPRECT;
+
+typedef POINT NEAR *PPOINT, FAR *LPPOINT;
+
+typedef struct  tagSIZE {
+    GDICOORD cx;
+    GDICOORD cy;
+} SIZE, NEAR *PSIZE, FAR *LPSIZE;
+
+typedef struct tagRGBQUAD {
+  BYTE rgbBlue;
+  BYTE rgbGreen;
+  BYTE rgbRed;
+  BYTE rgbReserved;
+} RGBQUAD;
+
+typedef struct tagBITMAPINFOHEADER {
+  DWORD biSize;
+  LONG  biWidth;
+  LONG  biHeight;
+  WORD  biPlanes;
+  WORD  biBitCount;
+  DWORD biCompression;
+  DWORD biSizeImage;
+  LONG  biXPelsPerMeter;
+  LONG  biYPelsPerMeter;
+  DWORD biClrUsed;
+  DWORD biClrImportant;
+} BITMAPINFOHEADER, *PBITMAPINFOHEADER;
+
+typedef struct tagBITMAPINFO {
+  BITMAPINFOHEADER bmiHeader;
+  RGBQUAD          bmiColors[1];
+} BITMAPINFO, *PBITMAPINFO;
+
+/* GetDCEx flags*/
+#define DCX_WINDOW           0x00000001L
+#define DCX_CACHE            0x00000002L
+#define DCX_NORESETATTRS     0x00000004L
+#define DCX_CLIPCHILDREN     0x00000008L
+#define DCX_CLIPSIBLINGS     0x00000010L
+#define DCX_PARENTCLIP       0x00000020L
+#define DCX_EXCLUDERGN       0x00000040L
+#define DCX_INTERSECTRGN     0x00000080L
+#define DCX_EXCLUDEUPDATE    0x00000100L
+#define DCX_INTERSECTUPDATE  0x00000200L
+#define DCX_LOCKWINDOWUPDATE 0x00000400L
+#define DCX_VALIDATE         0x00200000L
+#define DCX_DEFAULTCLIP      0x80000000L	/* microwin only*/
+
+HDC WINAPI	GetDCEx(HWND hwnd,HRGN hrgnClip,DWORD flags);
+HDC WINAPI	GetDC(HWND hWnd);
+HDC WINAPI 	GetWindowDC(HWND hWnd);
+int WINAPI 	ReleaseDC(HWND hWnd, HDC hDC);
+BOOL WINAPI	DeleteDC(HDC hdc);
+
+typedef struct tagPAINTSTRUCT {
+    HDC         hdc;
+    BOOL        fErase;			/* indicates bkgnd needs erasing*/
+    RECT        rcPaint;		/* nyi*/
+    BOOL        fRestore;		/* nyi*/
+    BOOL        fIncUpdate;		/* nyi*/
+    BYTE        rgbReserved[32];
+} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, FAR *LPPAINTSTRUCT;
+
+HDC WINAPI 	BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
+BOOL WINAPI 	EndPaint(HWND hWnd, CONST PAINTSTRUCT *lpPaint);
+
+typedef HANDLE HDWP;
+
+HDWP BeginDeferWindowPos(int nNumWindows);
+HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter,
+		int x, int y, int cx, int cy, UINT uFlags);
+BOOL EndDeferWindowPos(HDWP hWinPosInfo);
+
+
+#define RGB(r,g,b)	    MWRGB(r,g,b)
+#define GetRValue(rgb)      ((BYTE)(rgb))
+#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
+#define GetBValue(rgb)      ((BYTE)((rgb)>>16))
+
+/* Background Modes */
+#define TRANSPARENT	1
+#define OPAQUE		2
+
+/* Text Alignment*/
+#define TA_NOUPDATECP                0
+#define TA_UPDATECP                  1
+
+#define TA_LEFT                      0
+#define TA_RIGHT                     2
+#define TA_CENTER                    6
+
+#define TA_TOP                       0
+#define TA_BOTTOM                    8
+#define TA_BASELINE                  24
+#define TA_RTLREADING                256
+#define TA_MASK       (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING)
+
+COLORREF WINAPI	SetTextColor(HDC, COLORREF);
+COLORREF WINAPI GetTextColor(HDC hdc);
+COLORREF WINAPI	SetBkColor(HDC, COLORREF);
+int WINAPI 	SetBkMode(HDC, int);
+UINT WINAPI     SetTextAlign(HDC hdc, UINT fMode);
+UINT WINAPI		GetTextAlign(HDC hdc);
+
+/* Binary raster ops*/
+#define R2_BLACK            (MWROP_CLEAR+1)		/*  0       */
+#define R2_NOTMERGEPEN      (MWROP_NOR+1)		/* DPon     */
+#define R2_MASKNOTPEN       (MWROP_ANDINVERTED+1)	/* DPna     */
+#define R2_NOTCOPYPEN       (MWROP_COPYINVERTED+1)	/* Pn       */
+#define R2_MASKPENNOT       (MWROP_ANDREVERSE+1)	/* PDna     */
+#define R2_NOT              (MWROP_INVERT+1)		/* Dn       */
+#define R2_XORPEN           (MWROP_XOR+1)		/* DPx      */
+#define R2_NOTMASKPEN       (MWROP_NAND+1)		/* DPan     */
+#define R2_MASKPEN          (MWROP_AND+1)		/* DPa      */
+#define R2_NOTXORPEN        (MWROP_EQUIV+1)		/* DPxn     */
+#define R2_NOP              (MWROP_NOOP+1)		/* D        */
+#define R2_MERGENOTPEN      (MWROP_ORINVERTED+1)	/* DPno     */
+#define R2_COPYPEN          (MWROP_COPY+1)		/* P        */
+#define R2_MERGEPENNOT      (MWROP_ORREVERSE+1)	/* PDno     */
+#define R2_MERGEPEN         (MWROP_OR+1)		/* DPo      */
+#define R2_WHITE            (MWROP_SET+1)		/*  1       */
+#define R2_LAST             16
+
+int WINAPI	SetROP2(HDC hdc, int fnDrawMode);
+
+#define GDI_ERROR	(0xFFFFFFFFL)
+#define CLR_INVALID     0xFFFFFFFF
+
+COLORREF WINAPI GetPixel(HDC hdc, int x, int y);
+COLORREF WINAPI	SetPixel(HDC hdc, int x, int y, COLORREF crColor);
+BOOL WINAPI 	MoveToEx(HDC hdc, int x, int y, LPPOINT lpPoint);
+BOOL WINAPI 	LineTo(HDC hdc, int x, int y);
+BOOL WINAPI	Polyline(HDC hdc, CONST POINT *lppt, int cPoints);
+BOOL WINAPI	PolyPolygon(HDC hdc, CONST POINT *lpPoints, LPINT lpPolyCounts,
+			int nCount);
+BOOL WINAPI	Rectangle(HDC hdc, int nLeft, int nTop, int nRight,int nBottom);
+BOOL WINAPI	Ellipse(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect);
+BOOL WINAPI	Arc(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect, int nXStartArc, int nYStartArc,
+			int nXEndArc, int nYEndArc);
+BOOL WINAPI	Pie(HDC hdc, int nLeftRect, int nTopRect, int nRightRect,
+			int nBottomRect, int nXRadial1, int nYRadial1,
+			int nXRadial2, int nYRadial2);
+BOOL WINAPI	Polygon(HDC hdc, CONST POINT *lpPoints, int nCount);
+int WINAPI	FillRect(HDC hDC, CONST RECT *lprc, HBRUSH hbr);
+BOOL WINAPI	DrawFocusRect(HDC hdc, LPRECT prect);
+
+/* ExTextOut options*/
+#define ETO_OPAQUE	0x0002
+#define ETO_CLIPPED	0x0004		/* nyi*/
+
+BOOL WINAPI	TextOut(HDC hdc, int x, int y, LPCSTR lpszString, int cbString);
+BOOL WINAPI	TextOutW(HDC hdc, int x, int y, LPCWSTR lpszString, int cbString);
+BOOL WINAPI	ExtTextOut(HDC hdc, int x, int y, UINT fuOptions,
+			CONST RECT *lprc, LPCSTR lpszString, UINT cbCount,
+			CONST INT *lpDx);
+BOOL WINAPI	ExtTextOutW(HDC hdc, int x, int y, UINT fuOptions,
+			CONST RECT *lprc, LPCWSTR lpszString, UINT cbCount,
+			CONST INT *lpDx);
+LONG WINAPI TabbedTextOut ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
+            int ntabs, LPINT lpTabStops, int nTabOrigin );
+DWORD WINAPI GetTabbedTextExtent ( HDC hdc, int x, int y, LPCTSTR lpszString, int cbString,
+            int ntabs, LPINT lpTabStops );
+
+/* DrawText options*/
+#define DT_TOP              0x00000000
+#define DT_LEFT             0x00000000
+#define DT_CENTER           0x00000001
+#define DT_RIGHT            0x00000002
+#define DT_VCENTER          0x00000004
+#define DT_BOTTOM           0x00000008
+#define DT_WORDBREAK        0x00000010
+#define DT_SINGLELINE       0x00000020
+#define DT_EXPANDTABS       0x00000040
+#define DT_TABSTOP          0x00000080
+#define DT_NOCLIP           0x00000100
+#define DT_EXTERNALLEADING  0x00000200
+#define DT_CALCRECT         0x00000400
+#define DT_NOPREFIX         0x00000800
+#define DT_INTERNAL         0x00001000
+#define DT_EDITCONTROL      0x00002000
+#define DT_PATH_ELLIPSIS    0x00004000
+#define DT_END_ELLIPSIS     0x00008000
+#define DT_MODIFYSTRING     0x00010000
+#define DT_RTLREADING       0x00020000
+#define DT_WORD_ELLIPSIS    0x00040000
+
+int WINAPI	DrawTextA(HDC hdc, LPCSTR lpString, int nCount, LPRECT lpRect,
+			UINT uFormat);
+int WINAPI	DrawTextW(HDC hdc, LPCWSTR lpString, int nCount, LPRECT lpRect,
+			UINT uFormat);
+#define DrawText DrawTextA
+
+BOOL WINAPI	DrawDIB(HDC hdc,int x, int y,PMWIMAGEHDR pimage); /* microwin*/
+
+/* GetSysColor, FillRect colors*/
+#define COLOR_SCROLLBAR         0
+#define COLOR_BACKGROUND        1
+#define COLOR_ACTIVECAPTION     2
+#define COLOR_INACTIVECAPTION   3
+#define COLOR_MENU              4
+#define COLOR_WINDOW            5
+#define COLOR_WINDOWFRAME       6
+#define COLOR_MENUTEXT          7
+#define COLOR_WINDOWTEXT        8
+#define COLOR_CAPTIONTEXT       9
+#define COLOR_ACTIVEBORDER      10
+#define COLOR_INACTIVEBORDER    11
+#define COLOR_APPWORKSPACE      12
+#define COLOR_HIGHLIGHT         13
+#define COLOR_HIGHLIGHTTEXT     14
+#define COLOR_BTNFACE           15
+#define COLOR_BTNSHADOW         16
+#define COLOR_GRAYTEXT          17
+#define COLOR_BTNTEXT           18
+#define COLOR_INACTIVECAPTIONTEXT 19
+#define COLOR_BTNHIGHLIGHT      20
+#define COLOR_3DDKSHADOW        21
+#define COLOR_3DLIGHT           22
+#define COLOR_INFOTEXT          23
+#define COLOR_INFOBK            24
+#define COLOR_DESKTOP           COLOR_BACKGROUND
+#define COLOR_3DFACE            COLOR_BTNFACE
+#define COLOR_3DSHADOW          COLOR_BTNSHADOW
+#define COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
+#define COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
+#define COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
+#define COLOR_ALTERNATEBUTTONFACE	25
+#define COLOR_HOTLIGHT                  26
+#define COLOR_GRADIENTACTIVECAPTION     27
+#define COLOR_GRADIENTINACTIVECAPTION   28
+
+DWORD WINAPI	GetSysColor(int nIndex);
+COLORREF WINAPI	SetSysColor(int nIndex, COLORREF crColor);/* Microwindows only*/
+
+/* Stock Logical Objects */
+#define WHITE_BRUSH         0
+#define LTGRAY_BRUSH        1
+#define GRAY_BRUSH          2
+#define DKGRAY_BRUSH        3
+#define BLACK_BRUSH         4
+#define NULL_BRUSH          5
+#define HOLLOW_BRUSH        NULL_BRUSH
+#define WHITE_PEN           6
+#define BLACK_PEN           7
+#define NULL_PEN            8
+#define OEM_FIXED_FONT      10
+#define ANSI_FIXED_FONT     11
+#define ANSI_VAR_FONT       12
+#define SYSTEM_FONT         13
+#define DEVICE_DEFAULT_FONT 14
+#define DEFAULT_PALETTE     15
+#define SYSTEM_FIXED_FONT   16
+#define DEFAULT_GUI_FONT    17
+#define DC_BRUSH            18
+#define DC_PEN              19
+#define STOCK_LAST          19
+
+/* Object types*/
+#define OBJ_PEN             1
+#define OBJ_BRUSH           2
+#define OBJ_DC              3
+#define OBJ_METADC          4
+#define OBJ_PAL             5
+#define OBJ_FONT            6
+#define OBJ_BITMAP          7
+#define OBJ_REGION          8
+#define OBJ_METAFILE        9
+#define OBJ_MEMDC           10
+#define OBJ_EXTPEN          11
+#define OBJ_ENHMETADC       12
+#define OBJ_ENHMETAFILE     13
+
+HGDIOBJ WINAPI	GetStockObject(int nObject);
+HGDIOBJ WINAPI	SelectObject(HDC hdc, HGDIOBJ hObject);
+BOOL WINAPI	DeleteObject(HGDIOBJ hObject);
+int WINAPI	SelectClipRgn(HDC hdc, HRGN hrgn);
+int WINAPI	ExtSelectClipRgn(HDC hdc, HRGN hrgn, int fnMode);
+int WINAPI	GetUpdateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
+BOOL WINAPI	GetUpdateRect(HWND hwnd, LPRECT lpRect, BOOL bErase);
+
+/* Brush Styles */
+#define BS_SOLID            0
+#define BS_NULL             1
+#define BS_HOLLOW           BS_NULL
+
+HBRUSH WINAPI	CreateSolidBrush(COLORREF crColor);
+
+/* Pen Styles */
+#define PS_SOLID            0
+#define PS_NULL             5
+
+HPEN WINAPI	CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
+
+HBITMAP WINAPI	CreateCompatibleBitmap(HDC hdc, int nWidth, int nHeight);
+HDC WINAPI	CreateCompatibleDC(HDC hdc);
+
+/* BitBlit raster opcodes*/
+#define SRCCOPY         (DWORD)MWROP_COPY	  /* source                   */
+#define SRCPAINT        (DWORD)MWROP_OR		  /* source OR dest           */
+#define SRCAND          (DWORD)MWROP_AND	  /* source AND dest          */
+#define SRCINVERT       (DWORD)MWROP_XOR	  /* source XOR dest          */
+#define SRCERASE        (DWORD)MWROP_ANDREVERSE	  /* source AND (NOT dest )   */
+#define NOTSRCCOPY      (DWORD)MWROP_COPYINVERTED /* (NOT source)             */
+#define NOTSRCERASE     (DWORD)MWROP_NOR	  /* (NOT src) AND (NOT dest) */
+#define MERGEPAINT      (DWORD)MWROP_ORINVERTED   /* (NOT source) OR dest     */
+#define DSTINVERT       (DWORD)MWROP_INVERT	  /* (NOT dest)               */
+#define BLACKNESS       (DWORD)MWROP_CLEAR	  /* BLACK                    */
+#define WHITENESS       (DWORD)MWROP_SET	  /* WHITE                    */
+#if 0
+#define MERGECOPY       (DWORD)0x00C000CA /* (source AND pattern)     */
+#define PATCOPY         (DWORD)0x00F00021 /* pattern                  */
+#define PATPAINT        (DWORD)0x00FB0A09 /* DPSnoo                   */
+#define PATINVERT       (DWORD)0x005A0049 /* pattern XOR dest         */
+#endif
+
+BOOL WINAPI	BitBlt(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,
+			HDC hdcSrc,int nXSrc,int nYSrc,DWORD dwRop);
+BOOL WINAPI	StretchBlt(HDC hdcDest,int nXOriginDest,int nYOriginDest,
+			int nWidthDest,int nHeightDest,HDC hdcSrc,
+			int nXOriginSrc,int nYOriginSrc,int nWidthSrc,
+			int nHeightSrc, DWORD dwRop);
+
+/* Palette entry flags*/
+#define PC_RESERVED	0x01
+#define PC_EXPLICIT	0x02
+#define PC_NOCOLLAPSE	0x04
+
+typedef struct tagPALETTEENTRY {
+	BYTE	peRed;
+	BYTE	peGreen;
+	BYTE	peBlue;
+	BYTE	peFlags;
+} PALETTEENTRY, *PPALETTEENTRY, FAR *LPPALETTEENTRY;
+
+UINT WINAPI	GetSystemPaletteEntries(HDC hdc,UINT iStartIndex,UINT nEntries,
+			LPPALETTEENTRY lppe);
+
+/* GetDeviceCaps parameters*/
+#define HORZRES       8     /* Horizontal width in pixels               */
+#define VERTRES       10    /* Vertical height in pixels                */
+#define BITSPIXEL     12    /* Number of bits per pixel                 */
+#define PLANES        14    /* Number of planes                         */
+#define LOGPIXELSX    88    /* Logical pixels/inch in X                 */
+#define LOGPIXELSY    90    /* Logical pixels/inch in Y                 */
+#define SIZEPALETTE  104    /* Number of entries in physical palette    */
+
+//int WINAPI	GetDeviceCaps(HDC hdc, int nIndex);
+
+/* Region flags*/
+#define ERRORREGION		MWREGION_ERROR
+#define NULLREGION		MWREGION_NULL
+#define SIMPLEREGION		MWREGION_SIMPLE
+#define COMPLEXREGION		MWREGION_COMPLEX
+/* kluge for VxWorks*/
+#ifdef ERROR
+#undef ERROR
+#endif
+#define ERROR			ERRORREGION
+#define RGN_ERROR		ERRORREGION
+
+/* CombineRgn() Styles */
+#define RGN_AND             1
+#define RGN_OR              2
+#define RGN_XOR             3
+#define RGN_DIFF            4
+#define RGN_COPY            5
+#define RGN_MIN             RGN_AND
+#define RGN_MAX             RGN_COPY
+
+/* GetRegionData/ExtCreateRegion */
+#define RDH_RECTANGLES  1
+typedef struct _RGNDATAHEADER {
+    DWORD   dwSize;
+    DWORD   iType;
+    DWORD   nCount;
+    DWORD   nRgnSize;
+    RECT    rcBound;
+} RGNDATAHEADER, *PRGNDATAHEADER;
+
+typedef struct _RGNDATA {
+    RGNDATAHEADER   rdh;
+    char            Buffer[1];
+} RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;
+
+/* Region entry points*/
+INT  WINAPI OffsetRgn(HRGN hrgn, INT x, INT y );
+INT  WINAPI GetRgnBox(HRGN hrgn, LPRECT rect );
+HRGN WINAPI CreateRectRgn(INT left, INT top, INT right, INT bottom);
+HRGN WINAPI CreateRectRgnIndirect(const RECT* rect );
+VOID WINAPI SetRectRgn(HRGN hrgn, INT left, INT top, INT right, INT bottom );
+HRGN WINAPI CreateRoundRectRgn(INT left, INT top, INT right, INT bottom,
+		INT ellipse_width, INT ellipse_height );
+HRGN WINAPI CreateEllipticRgn(INT left, INT top, INT right, INT bottom );
+HRGN WINAPI CreateEllipticRgnIndirect(const RECT *rect );
+HRGN WINAPI CreatePolygonRgn(const POINT *points, INT count, INT mode);
+DWORD WINAPI GetRegionData(HRGN hrgn, DWORD count, LPRGNDATA rgndata);
+BOOL WINAPI PtInRegion(HRGN hrgn, INT x, INT y );
+BOOL WINAPI RectInRegion(HRGN hrgn, const RECT *rect );
+BOOL WINAPI EqualRgn(HRGN hrgn1, HRGN hrgn2 );
+INT  WINAPI CombineRgn(HRGN hDest, HRGN hSrc1, HRGN hSrc2, INT mode);
+BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
+
+/* Rect entry points*/
+BOOL WINAPI IntersectRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+BOOL WINAPI UnionRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+BOOL WINAPI EqualRect(const RECT* rect1, const RECT* rect2 );
+BOOL WINAPI SubtractRect(LPRECT dest, const RECT *src1, const RECT *src2 );
+
+/* GDI math stuff */
+int WINAPI MulDiv(int nMultiplicand, int nMultiplier, int nDivisor);
+
+#endif /*  __WINGDI_H__ */
diff -urN microwin/src\mwin\include\winuser.h microwin-0.90/src\mwin\include\winuser.h
--- microwin/src\mwin\include\winuser.h	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\mwin\include\winuser.h	Mon Aug 30 09:50:04 2010
@@ -0,0 +1,713 @@
+/* winuser.h*/
+/*
+ * Copyright (c) 1999, 2000 Greg Haerr <greg@censoft.com>
+ *
+ * Win32 USER structures and API
+ */
+#include "winctl.h"	/* required compatibility for resource compiler*/
+
+/* moved from windef.h for resource compiler*/
+typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
+typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
+
+/* win api*/
+LRESULT WINAPI 	DefWindowProc(HWND hwnd,UINT msg,WPARAM wParam,LPARAM lParam);
+
+/* Class styles*/
+#define CS_VREDRAW          0x0001
+#define CS_HREDRAW          0x0002
+#define CS_DBLCLKS          0x0008
+#define CS_OWNDC            0x0020
+#define CS_CLASSDC          0x0040
+#define CS_PARENTDC         0x0080
+#define CS_NOCLOSE          0x0200
+#define CS_SAVEBITS         0x0800
+#define CS_BYTEALIGNCLIENT  0x1000
+#define CS_BYTEALIGNWINDOW  0x2000
+#define CS_GLOBALCLASS      0x4000
+
+typedef struct tagWNDCLASSA {
+    MWLIST	link;			/* microwin*/
+    UINT        style;
+    WNDPROC     lpfnWndProc;
+    int         cbClsExtra;		/* nyi*/
+    int         cbWndExtra;
+    HINSTANCE   hInstance;		/* nyi*/
+    HICON       hIcon;			/* nyi*/
+    HCURSOR     hCursor;		/* nyi*/
+    HBRUSH      hbrBackground;
+    LPCSTR      lpszMenuName;		/* nyi*/
+    LPCSTR      lpszClassName;
+    CHAR	szClassName[40];	/* microwin*/
+} WNDCLASS, *PWNDCLASS, NEAR *NPWNDCLASS, FAR *LPWNDCLASS;
+
+ATOM WINAPI	RegisterClass(CONST WNDCLASS *lpWndClass);
+BOOL WINAPI UnregisterClass(LPCSTR lpClassName, HINSTANCE hInstance);
+
+/*
+ * Message structure
+ */
+typedef struct tagMSG {
+    MWLIST	link;			/* microwin*/
+    HWND        hwnd;
+    UINT        message;
+    WPARAM      wParam;
+    LPARAM      lParam;
+    DWORD       time;
+    POINT       pt;
+} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;
+
+#define POINTSTOPOINT(pt, pts)                          \
+        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
+          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }
+
+#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
+#define MAKEWPARAM(l, h)      (WPARAM)MAKELONG(l, h)
+#define MAKELPARAM(l, h)      (LPARAM)MAKELONG(l, h)
+#define MAKELRESULT(l, h)     (LRESULT)MAKELONG(l, h)
+
+/* window messages*/
+#define WM_NULL                         0x0000
+#define WM_CREATE                       0x0001
+#define WM_DESTROY                      0x0002
+#define WM_NCDESTROY			WM_DESTROY
+#define WM_MOVE                         0x0003
+#define WM_SIZE                         0x0005
+#define WM_ACTIVATE                     0x0006
+#define WM_SETFOCUS                     0x0007
+#define WM_KILLFOCUS                    0x0008
+#define WM_ENABLE                       0x000A
+#define WM_SETREDRAW					0x000B
+#define WM_SETTEXT                      0x000C
+#define WM_GETTEXT                      0x000D
+#define WM_GETTEXTLENGTH                0x000E
+#define WM_PAINT                        0x000F
+#define WM_CLOSE                        0x0010
+#define WM_QUIT                         0x0012
+#define WM_ERASEBKGND                   0x0014
+#define WM_SHOWWINDOW                   0x0018
+#define WM_CTLCOLOR                     0x0019
+#define WM_NEXTDLGCTL                   0x0028
+#define WM_DRAWITEM                     0x002B
+#define WM_MEASUREITEM                  0x002C
+#define WM_DELETEITEM 					0x002D
+#define WM_VKEYTOITEM					0x002E
+#define WM_CHARTOITEM					0x002F
+#define WM_SETFONT          		0x0030
+#define WM_GETFONT      		0x0031
+#define WM_COMPAREITEM					0x0039
+#define WM_WINDOWPOSCHANGED             0x0047
+#define WM_NCCALCSIZE                   0x0083
+#define WM_NCHITTEST                    0x0084
+#define WM_NCPAINT                      0x0085
+#define WM_GETDLGCODE                   0x0087
+#define WM_NCMOUSEMOVE                  0x00A0
+#define WM_NCLBUTTONDOWN                0x00A1
+#define WM_NCLBUTTONUP                  0x00A2
+#define WM_NCLBUTTONDBLCLK              0x00A3
+#define WM_NCRBUTTONDOWN                0x00A4
+#define WM_NCRBUTTONUP                  0x00A5
+#define WM_NCRBUTTONDBLCLK              0x00A6
+#define WM_KEYFIRST                     0x0100
+#define WM_KEYDOWN                      0x0100
+#define WM_KEYUP                        0x0101
+#define WM_CHAR                         0x0102
+#define WM_DEADCHAR                     0x0103	/* notimp*/
+#define WM_SYSKEYDOWN                   0x0104	/* nyi*/
+#define WM_SYSKEYUP                     0x0105	/* nyi*/
+#define WM_SYSCHAR                      0x0106
+#define WM_SYSDEADCHAR                  0x0107	/* notimp*/
+#define WM_KEYLAST                      0x0108
+#define WM_INITDIALOG	                0x0110
+#define WM_COMMAND                      0x0111
+#define WM_SYSCOMMAND                   0x0112
+#define WM_TIMER                        0x0113
+#define WM_HSCROLL                      0x0114
+#define WM_VSCROLL                      0x0115
+
+#define WM_ENTERIDLE                    0x0121
+
+#define WM_CTLCOLORMSGBOX               0x0132
+#define WM_CTLCOLOREDIT                 0x0133
+#define WM_CTLCOLORLISTBOX              0x0134
+#define WM_CTLCOLORBTN                  0x0135
+#define WM_CTLCOLORDLG                  0x0136
+#define WM_CTLCOLORSCROLLBAR            0x0137
+#define WM_CTLCOLORSTATIC               0x0138
+
+#define WM_MOUSEFIRST                   0x0200
+#define WM_MOUSEMOVE                    0x0200
+#define WM_LBUTTONDOWN                  0x0201
+#define WM_LBUTTONUP                    0x0202
+#define WM_LBUTTONDBLCLK                0x0203
+#define WM_RBUTTONDOWN                  0x0204
+#define WM_RBUTTONUP                    0x0205
+#define WM_RBUTTONDBLCLK                0x0206
+#define WM_MBUTTONDOWN                  0x0207
+#define WM_MBUTTONUP                    0x0208
+#define WM_MBUTTONDBLCLK                0x0209
+#define WM_MOUSEWHEEL                   0x020A
+#define WM_MOUSELAST                    0x020A
+#define WM_HOTKEY                       0x0312
+
+#define WM_CARET_CREATE    		0x03E0 /* Microwindows only*/
+#define WM_CARET_DESTROY   		0x03E1 /* Microwindows only*/
+#define WM_CARET_BLINK      		0x03E2 /* Microwindows only*/
+#define WM_FDINPUT                      0x03F0 /* Microwindows only*/
+#define WM_FDOUTPUT                     0x03F1 /* Microwindows only*/
+#define WM_FDEXCEPT                     0x03F2 /* Microwindows only*/
+#define WM_USER                         0x0400
+
+/*
+ * System Menu Command Values
+ */
+#define SC_SIZE         0xF000
+#define SC_MOVE         0xF010
+#define SC_MINIMIZE     0xF020
+#define SC_MAXIMIZE     0xF030
+#define SC_NEXTWINDOW   0xF040
+#define SC_PREVWINDOW   0xF050
+#define SC_CLOSE        0xF060
+#define SC_VSCROLL      0xF070
+#define SC_HSCROLL      0xF080
+#define SC_MOUSEMENU    0xF090
+#define SC_KEYMENU      0xF100
+#define SC_ARRANGE      0xF110
+#define SC_RESTORE      0xF120
+#define SC_TASKLIST     0xF130
+#define SC_SCREENSAVE   0xF140
+#define SC_HOTKEY       0xF150
+
+/* WM_ACTIVATE state values*/
+#define WA_INACTIVE     0
+#define WA_ACTIVE       1
+#define WA_CLICKACTIVE  2
+
+/* WM_NCHITTEST codes*/
+#define HTERROR             (-2)
+#define HTTRANSPARENT       (-1)
+#define HTNOWHERE           0
+#define HTCLIENT            1
+#define HTCAPTION           2
+#define HTSYSMENU           3
+#define HTGROWBOX           4
+#define HTSIZE              HTGROWBOX
+#define HTMENU              5
+#define HTHSCROLL           6
+#define HTVSCROLL           7
+#define HTMINBUTTON         8
+#define HTMAXBUTTON         9
+#define HTLEFT              10
+#define HTRIGHT             11
+#define HTTOP               12
+#define HTTOPLEFT           13
+#define HTTOPRIGHT          14
+#define HTBOTTOM            15
+#define HTBOTTOMLEFT        16
+#define HTBOTTOMRIGHT       17
+#define HTBORDER            18
+#define HTREDUCE            HTMINBUTTON
+#define HTZOOM              HTMAXBUTTON
+#define HTSIZEFIRST         HTLEFT
+#define HTSIZELAST          HTBOTTOMRIGHT
+#define HTOBJECT            19
+#define HTCLOSE             20
+#define HTHELP              21
+
+/* WM_SIZE wparam values*/
+#define SIZE_RESTORED       0
+#define SIZE_MINIMIZED      1
+#define SIZE_MAXIMIZED      2
+#define SIZE_MAXSHOW        3
+#define SIZE_MAXHIDE        4
+
+LRESULT WINAPI  CallWindowProc(WNDPROC lpPrevWndFunc, HWND hwnd, UINT Msg,
+			WPARAM wParam, LPARAM lParam);
+LRESULT WINAPI	SendMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
+BOOL WINAPI	PostMessage(HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);
+BOOL WINAPI	PostThreadMessage(DWORD dwThreadId, UINT Msg, WPARAM wParam,
+			LPARAM lParam);
+VOID WINAPI	PostQuitMessage(int nExitCode);
+
+/* PeekMessage options*/
+#define PM_NOREMOVE		0x0000
+#define PM_REMOVE		0x0001
+#define PM_NOYIELD		0x0002
+
+BOOL WINAPI	PeekMessage(LPMSG lpMsg, HWND hwnd, UINT uMsgFilterMin,
+			UINT uMsgFilterMax, UINT wRemoveMsg);
+BOOL WINAPI 	GetMessage(LPMSG lpMsg,HWND hwnd,UINT wMsgFilterMin,
+			UINT wMsgFilterMax);
+BOOL WINAPI 	TranslateMessage(CONST MSG *lpMsg);
+LONG WINAPI	DispatchMessage(CONST MSG *lpMsg);
+
+/* note: the following struct is in reverse order from the
+ * microsoft version since WINAPI is cdecl in this implementation
+ */
+typedef struct tagCREATESTRUCT {
+    DWORD       dwExStyle;
+    LPCSTR      lpszClass;
+    LPCSTR      lpszName;
+    LONG        style;
+    int         x;
+    int         y;
+    int         cx;
+    int         cy;
+    HWND        hwndParent;
+    HMENU       hMenu;
+    HINSTANCE   hInstance;
+    LPVOID      lpCreateParams;
+} CREATESTRUCT, *LPCREATESTRUCT;
+
+typedef struct tagCOMPAREITEMSTRUCT {
+	UINT	CtlType;
+	UINT	CtlID;
+	HWND	hwndItem;
+	UINT	itemID1;
+	DWORD	itemData1;
+	UINT	itemID2;
+	DWORD	itemData2;
+	DWORD	dwLocaleId;
+} COMPAREITEMSTRUCT,*LPCOMPAREITEMSTRUCT;
+
+typedef struct tagDELETEITEMSTRUCT {
+	UINT CtlType;
+	UINT CtlID;
+	UINT itemID;
+	HWND hwndItem;
+	UINT itemData;
+} DELETEITEMSTRUCT,*PDELETEITEMSTRUCT,*LPDELETEITEMSTRUCT;
+
+/*
+ * Window Styles
+ */
+#define WS_OVERLAPPED       0x00000000L
+#define WS_POPUP            0x80000000L
+#define WS_CHILD            0x40000000L
+#define WS_MINIMIZE         0x20000000L
+#define WS_VISIBLE          0x10000000L
+#define WS_DISABLED         0x08000000L
+#define WS_CLIPSIBLINGS     0x04000000L
+#define WS_CLIPCHILDREN     0x02000000L
+#define WS_MAXIMIZE         0x01000000L
+#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
+#define WS_BORDER           0x00800000L
+#define WS_DLGFRAME         0x00400000L
+#define WS_VSCROLL          0x00200000L
+#define WS_HSCROLL          0x00100000L
+#define WS_SYSMENU          0x00080000L
+#define WS_THICKFRAME       0x00040000L
+#define WS_GROUP            0x00020000L
+#define WS_TABSTOP          0x00010000L
+
+#define WS_MINIMIZEBOX      0x00020000L
+#define WS_MAXIMIZEBOX      0x00010000L
+
+#define WS_TILED            WS_OVERLAPPED
+#define WS_ICONIC           WS_MINIMIZE
+#define WS_SIZEBOX          WS_THICKFRAME
+#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW
+
+/*
+ * Common Window Styles
+ */
+#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
+                             WS_CAPTION        | \
+                             WS_SYSMENU        | \
+                             WS_THICKFRAME     | \
+                             WS_MINIMIZEBOX    | \
+                             WS_MAXIMIZEBOX)
+
+#define WS_POPUPWINDOW      (WS_POPUP          | \
+                             WS_BORDER         | \
+                             WS_SYSMENU)
+
+#define WS_CHILDWINDOW      (WS_CHILD)
+
+/*
+ * Extended Window Styles
+ */
+#define WS_EX_DLGMODALFRAME     0x00000001L
+#define WS_EX_NOPARENTNOTIFY    0x00000004L
+#define WS_EX_TOPMOST           0x00000008L
+#define WS_EX_ACCEPTFILES       0x00000010L
+#define WS_EX_TRANSPARENT       0x00000020L
+#define WS_EX_MDICHILD          0x00000040L
+#define WS_EX_TOOLWINDOW        0x00000080L
+#define WS_EX_WINDOWEDGE        0x00000100L
+#define WS_EX_CLIENTEDGE        0x00000200L
+#define WS_EX_CONTEXTHELP       0x00000400L
+
+#define WS_EX_RIGHT             0x00001000L
+#define WS_EX_LEFT              0x00000000L
+#define WS_EX_RTLREADING        0x00002000L
+#define WS_EX_LTRREADING        0x00000000L
+#define WS_EX_LEFTSCROLLBAR     0x00004000L
+#define WS_EX_RIGHTSCROLLBAR    0x00000000L
+
+#define WS_EX_CONTROLPARENT     0x00010000L
+#define WS_EX_STATICEDGE        0x00020000L
+#define WS_EX_APPWINDOW         0x00040000L
+#define WS_EX_LAYERED		0x00080000L
+
+#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
+#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
+
+#define CW_USEDEFAULT       ((int)0x80000000)
+
+#define HWND_DESKTOP        ((HWND)0)
+
+#define CreateWindow(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)\
+		CreateWindowEx(0L, lpClassName, lpWindowName, dwStyle, x, y,\
+		nWidth, nHeight, hwndParent, hMenu, hInstance, lpParam)
+
+HWND WINAPI	CreateWindowEx(DWORD dwExStyle, LPCSTR lpClassName,
+    			LPCSTR lpWindowName, DWORD dwStyle, int X, int Y,
+			int nWidth, int nHeight, HWND hwndParent, HMENU hMenu,
+			HINSTANCE hInstance, LPVOID lpParam);
+BOOL WINAPI 	DestroyWindow(HWND hwnd);
+BOOL WINAPI	IsWindow(HWND hwnd);
+#define IsWindowVisible(hwnd)	((BOOL)((hwnd)->unmapcount == 0))
+
+/*
+ * ShowWindow() Commands
+ */
+#define SW_HIDE             0
+#define SW_SHOWNORMAL       1
+#define SW_NORMAL           1
+#define SW_SHOWMINIMIZED    2
+#define SW_SHOWMAXIMIZED    3
+#define SW_MAXIMIZE         3
+#define SW_SHOWNOACTIVATE   4
+#define SW_SHOW             5
+#define SW_MINIMIZE         6
+#define SW_SHOWMINNOACTIVE  7
+#define SW_SHOWNA           8
+#define SW_RESTORE          9
+#define SW_SHOWDEFAULT      10
+#define SW_FORCEMINIMIZE    11
+#define SW_MAX              11
+
+BOOL WINAPI 	ShowWindow(HWND hwnd, int nCmdShow);
+BOOL WINAPI	InvalidateRect(HWND hwnd, CONST RECT *lpRect, BOOL bErase);
+BOOL WINAPI	InvalidateRgn(HWND hwnd, HRGN hrgn, BOOL bErase);
+BOOL WINAPI	ValidateRect(HWND hwnd, CONST RECT *lprc);
+BOOL WINAPI	ValidateRgn(HWND hwnd, HRGN hrgn);
+BOOL WINAPI	UpdateWindow(HWND hwnd);
+
+BOOL WINAPI	SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey,
+			BYTE bAlpha, DWORD dwFlags);
+#define LWA_COLORKEY	0x00000001
+#define LWA_ALPHA	0x00000002
+
+HWND WINAPI	GetFocus(VOID);
+HWND WINAPI	SetFocus(HWND hwnd);
+BOOL WINAPI	SetForegroundWindow(HWND hwnd);
+HWND WINAPI	SetActiveWindow(HWND hwnd);
+HWND WINAPI	GetActiveWindow(VOID);
+BOOL WINAPI	BringWindowToTop(HWND hwnd);
+HWND WINAPI	GetDesktopWindow(VOID);
+HWND WINAPI	GetParent(HWND hwnd);
+BOOL WINAPI	EnableWindow(HWND hwnd, BOOL bEnable);
+#define IsWindowEnabled(hwnd)	((BOOL)(((hwnd)->style&WS_DISABLED) == 0))
+
+BOOL WINAPI	AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu,
+			DWORD dwExStyle);
+BOOL WINAPI	GetClientRect(HWND hwnd, LPRECT lpRect);
+BOOL WINAPI	GetWindowRect(HWND hwnd, LPRECT lpRect);
+
+BOOL WINAPI 	ClientToScreen(HWND hwnd, LPPOINT lpPoint);
+BOOL WINAPI 	ScreenToClient(HWND hwnd, LPPOINT lpPoint);
+int  WINAPI	MapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lpPoints,
+			UINT cPoints);
+
+BOOL WINAPI	SetRect(LPRECT lprc,int xLeft,int yTop,int xRight,int yBottom);
+BOOL WINAPI	SetRectEmpty(LPRECT lprc);
+BOOL WINAPI	CopyRect(LPRECT lprcDst, CONST RECT *lprcSrc);
+BOOL WINAPI	IsRectEmpty(CONST RECT *lprc);
+BOOL WINAPI	InflateRect(LPRECT lprc, int dx, int dy);
+BOOL WINAPI	OffsetRect(LPRECT lprc, int dx, int dy);
+/* The bcc compiler doesn't work passing structs by value, so we have this*/
+#if ELKS
+#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, *(long *)&(pt))
+#else
+#define		PtInRect(lprc,pt)	MwPTINRECT(lprc, pt)
+#endif
+BOOL WINAPI	MwPTINRECT(CONST RECT *lprc, POINT pt);
+
+/*
+ * Window field offsets for GetWindowLong()
+ */
+#define GWL_WNDPROC         (-4)
+#define GWL_HINSTANCE       (-6)
+#define GWL_HWNDPARENT      (-8)
+#define GWL_STYLE           (-16)
+#define GWL_EXSTYLE         (-20)
+#define GWL_USERDATA        (-21)
+#define GWL_ID              (-12)
+
+/*
+ * Class field offsets for GetClassLong()
+ */
+#define GCL_MENUNAME        (-8)
+#define GCL_HBRBACKGROUND   (-10)
+#define GCL_HCURSOR         (-12)
+#define GCL_HICON           (-14)
+#define GCL_HMODULE         (-16)
+#define GCL_CBWNDEXTRA      (-18)
+#define GCL_CBCLSEXTRA      (-20)
+#define GCL_WNDPROC         (-24)
+#define GCL_STYLE           (-26)
+#define GCW_ATOM            (-32)
+#define GCL_HICONSM         (-34)
+
+LONG WINAPI	GetWindowLong(HWND hwnd, int nIndex);
+LONG WINAPI	SetWindowLong(HWND hwnd, int nIndex, LONG lNewLong);
+WORD WINAPI	GetWindowWord(HWND hwnd, int nIndex);
+WORD WINAPI	SetWindowWord(HWND hwnd, int nIndex, WORD wNewWord);
+BOOL WINAPI SetProp(HWND hWnd, LPCSTR lpString, HANDLE hData);
+HANDLE WINAPI GetProp(HWND hWnd, LPCSTR lpString);
+HANDLE WINAPI RemoveProp(HWND hWnd, LPCSTR lpString);
+
+#define GetDlgCtrlID(hwnd)	((int)(hwnd)->id)
+DWORD WINAPI	GetClassLong(HWND hwnd, int nIndex);
+int WINAPI	GetWindowTextLength(HWND hwnd);
+int WINAPI	GetWindowText(HWND hwnd, LPSTR lpString, int nMaxCount);
+BOOL WINAPI	SetWindowText(HWND hwnd, LPCSTR lpString);
+
+BOOL WINAPI 	MoveWindow(HWND hwnd, int x, int y, int nWidth, int nHeight,
+    			BOOL bRepaint);
+
+/* SetWindowPos Flags*/
+#define SWP_NOSIZE          0x0001
+#define SWP_NOMOVE          0x0002
+#define SWP_NOZORDER        0x0004
+#define SWP_NOREDRAW        0x0008
+#define SWP_NOACTIVATE      0x0010	/* nyi*/
+#define SWP_FRAMECHANGED    0x0020	/* nyi*/
+#define SWP_SHOWWINDOW      0x0040
+#define SWP_HIDEWINDOW      0x0080
+#define SWP_NOCOPYBITS      0x0100	/* nyi*/
+#define SWP_NOOWNERZORDER   0x0200	/* nyi*/
+#define SWP_NOSENDCHANGING  0x0400	/* nyi*/
+#define SWP_DRAWFRAME       SWP_FRAMECHANGED
+#define SWP_NOREPOSITION    SWP_NOOWNERZORDER
+#define SWP_DEFERERASE      0x2000	/* nyi*/
+#define SWP_ASYNCWINDOWPOS  0x4000	/* nyi*/
+
+#define HWND_TOP        ((HWND)0)	/* nyi*/
+#define HWND_BOTTOM     ((HWND)1)	/* nyi*/
+#define HWND_TOPMOST    ((HWND)-1)	/* nyi*/
+#define HWND_NOTOPMOST  ((HWND)-2)	/* nyi*/
+
+/* WM_WINDOWPOSCHANGED message*/
+typedef struct tagWINDOWPOS {
+	HWND    hwnd;
+	HWND    hwndInsertAfter;
+	int     x;
+	int     y;
+	int     cx;
+	int     cy;
+	UINT    flags;
+} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;
+
+BOOL WINAPI	SetWindowPos(HWND hwnd, HWND hwndInsertAfter, int x, int y,
+			int cx, int cy, UINT fuFlags);
+
+typedef struct tagWINDOWPLACEMENT {
+    UINT  length;
+    UINT  flags;
+    UINT  showCmd;
+    POINT ptMinPosition;
+    POINT ptMaxPosition;
+    RECT  rcNormalPosition;
+} WINDOWPLACEMENT;
+typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;
+BOOL SetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
+BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl);
+
+BOOL WINAPI	GetCursorPos(LPPOINT lpPoint);
+HWND WINAPI	GetCapture(VOID);
+HWND WINAPI	SetCapture(HWND hwnd);
+BOOL WINAPI	ReleaseCapture(VOID);
+
+#define GW_HWNDNEXT 2
+#define GW_HWNDPREV 3
+#define GW_CHILD 5
+#define GW_HWNDFIRST 0
+#define GW_HWNDLAST 1
+#define GW_OWNER 4
+
+HWND GetWindow(HWND hWnd,  UINT uCmd);
+HWND GetMenu (HWND hWnd);
+HWND GetForegroundWindow(VOID);
+HWND WindowFromPoint(POINT pt);
+
+/*
+ * WM_NCCALCSIZE parameter structure
+ */
+typedef struct tagNCCALCSIZE_PARAMS {
+    RECT       rgrc[3];
+    /*PWINDOWPOS lppos;*/		/* removed for microwin*/
+} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;
+
+typedef FARPROC TIMERPROC;
+
+UINT WINAPI	SetTimer(HWND hwnd, UINT idTimer, UINT uTimeout,
+			TIMERPROC lpTimerFunc);
+BOOL WINAPI	KillTimer(HWND hwnd, UINT idTimer);
+UINT		MwGetNextTimeoutValue(void);
+void		MwHandleTimers(void);
+
+/* GetSystemMetrics indices*/
+#define SM_CXSCREEN             0
+#define SM_CYSCREEN             1
+#define SM_CXVSCROLL            2
+#define SM_CYHSCROLL            3
+#define SM_CYCAPTION            4
+#define SM_CXBORDER             5
+#define SM_CYBORDER             6
+#define SM_CXDLGFRAME           7
+#define SM_CYDLGFRAME           8
+#define SM_CXFIXEDFRAME		SM_CXDLGFRAME
+#define SM_CYFIXEDFRAME		SM_CYDLGFRAME
+#define SM_CYMENU               15
+#define SM_CYVSCROLL            20
+#define SM_CXHSCROLL            21
+#define SM_CXFRAME              32
+#define SM_CYFRAME              33
+#define SM_CXSIZEFRAME		SM_CXFRAME
+#define SM_CYSIZEFRAME		SM_CYFRAME
+
+int WINAPI	GetSystemMetrics(int nIndex);
+
+#define SPI_SETWORKAREA            47
+#define SPI_GETWORKAREA            48
+
+BOOL WINAPI SystemParametersInfo (UINT uiAction,  UINT uiParam, PVOID pvParam, UINT fWinIni);
+
+HWND WINAPI	GetDlgItem(HWND hDlg, int nIDDlgItem);
+
+/* ************************** Caret support **********************************/
+BOOL WINAPI CreateCaret(HWND hwnd, HBITMAP hBitmap, int nWidth, int nHeight);
+BOOL WINAPI DestroyCaret(VOID);
+BOOL WINAPI HideCaret (HWND hwnd);
+BOOL WINAPI ShowCaret(HWND hwnd);
+BOOL WINAPI SetCaretPos(int nX, int nY);
+BOOL WINAPI GetCaretPos(LPPOINT lpPoint);
+UINT WINAPI GetCaretBlinkTime(VOID);
+BOOL WINAPI SetCaretBlinkTime(UINT uMSeconds);
+
+
+int WINAPI GetClassName(HWND hWnd, LPTSTR lpClassName, int nMaxCount);
+HWND WINAPI GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
+
+/*
+ * Dialog Box Command IDs
+ */
+#define IDOK                1
+#define IDCANCEL            2
+#define IDABORT             3
+#define IDRETRY             4
+#define IDIGNORE            5
+#define IDYES               6
+#define IDNO                7
+#define IDCLOSE         	8
+#define IDHELP          	9
+#define IDTRYAGAIN         10
+#define IDCONTINUE         11
+
+/*
+ * MessageBox() Flags
+ */
+#define MB_OK                       0x00000000L
+#define MB_OKCANCEL                 0x00000001L
+#define MB_ABORTRETRYIGNORE         0x00000002L
+#define MB_YESNOCANCEL              0x00000003L
+#define MB_YESNO                    0x00000004L
+#define MB_RETRYCANCEL              0x00000005L
+#define MB_CANCELTRYCONTINUE 		0x00000006L
+
+#define MB_ICONHAND                 0x00000010L
+#define MB_ICONQUESTION             0x00000020L
+#define MB_ICONEXCLAMATION          0x00000030L
+#define MB_ICONASTERISK             0x00000040L
+
+#define MB_USERICON                 0x00000080L
+#define MB_ICONWARNING              MB_ICONEXCLAMATION
+#define MB_ICONERROR                MB_ICONHAND
+
+#define MB_ICONINFORMATION          MB_ICONASTERISK
+#define MB_ICONSTOP                 MB_ICONHAND
+
+#define MB_DEFBUTTON1               0x00000000L
+#define MB_DEFBUTTON2               0x00000100L
+#define MB_DEFBUTTON3               0x00000200L
+#define MB_DEFBUTTON4               0x00000300L
+
+#define MB_APPLMODAL                0x00000000L
+#define MB_SYSTEMMODAL              0x00001000L
+#define MB_TASKMODAL                0x00002000L
+#define MB_HELP                     0x00004000L // Help Button
+
+#define MB_NOFOCUS                  0x00008000L
+#define MB_SETFOREGROUND            0x00010000L
+#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L
+
+#define MB_TOPMOST                  0x00040000L
+#define MB_RIGHT                    0x00080000L
+#define MB_RTLREADING               0x00100000L
+
+#define MB_TYPEMASK                 0x0000000FL
+#define MB_ICONMASK                 0x000000F0L
+#define MB_DEFMASK                  0x00000F00L
+#define MB_MODEMASK                 0x00003000L
+#define MB_MISCMASK                 0x0000C000L
+
+/* help structure not implemented, only used in MSGBOXCALLBACK below*/
+#define HELPINFO_WINDOW    0x0001
+#define HELPINFO_MENUITEM  0x0002
+typedef struct tagHELPINFO {    /* Structure pointed to by lParam of WM_HELP */
+    UINT    cbSize;             /* Size in bytes of this struct  */
+    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
+    int     iCtrlId;            /* Control Id or a Menu item Id. */
+    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
+    DWORD   dwContextId;        /* Context Id associated with this item */
+    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
+}  HELPINFO, FAR *LPHELPINFO;
+
+typedef void (CALLBACK *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);
+
+typedef struct tagMSGBOXPARAMSA {
+    UINT        cbSize;
+    HWND        hwndOwner;
+    HINSTANCE   hInstance;
+    LPCSTR      lpszText;
+    LPCSTR      lpszCaption;
+    DWORD       dwStyle;
+    LPCSTR      lpszIcon;
+    DWORD       dwContextHelpId;
+    MSGBOXCALLBACK      lpfnMsgBoxCallback;
+    DWORD   dwLanguageId;
+} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
+
+typedef MSGBOXPARAMSA MSGBOXPARAMS;
+
+int WINAPI MessageBoxTimeout(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,
+		UINT uType, WORD wLanguageId, DWORD dwTime);
+int MessageBoxEx(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType,
+  WORD wLanguageId);
+int MessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType);
+int MessageBoxIndirect( const MSGBOXPARAMS *lpMsgBoxParams);
+
+/*
+ *  Windows enumeration functions
+ */
+typedef BOOL CALLBACK (*WNDENUMPROC)(HWND, LPARAM);
+
+BOOL WINAPI EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc,
+			       LPARAM lParam);
+
+#ifdef MW_CALL_IDLE_HANDLER
+void WINAPI idle_handler(void);
+#endif
diff -urN microwin/src\mwin\winfont.c microwin-0.90/src\mwin\winfont.c
--- microwin/src\mwin\winfont.c	Thu Aug 26 19:42:04 2010
+++ microwin-0.90/src\mwin\winfont.c	Wed Aug 25 14:53:22 2010
@@ -11,6 +11,11 @@
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef WIN32
+  #define strcasecmp stricmp  
+  #define strncasecmp strnicmp  
+#endif
+
 HFONT WINAPI
 CreateFont(int nHeight, int nWidth, int nEscapement, int nOrientation,
 	int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut,
@@ -199,7 +204,7 @@
 	lpSize->cx = width;
 	lpSize->cy = height;
 
-	/*printf("<MWIN>: lpszStr=\"%s\", cchString=%d, lpsize->cx=%d, lpSize->cy=%d\n", lpszStr, cchString, lpSize->cx, lpSize->cy);*/
+	/*DPRINTF("<MWIN>: lpszStr=\"%s\", cchString=%d, lpsize->cx=%d, lpSize->cy=%d\n", lpszStr, cchString, lpSize->cx, lpSize->cy);*/
 	return TRUE;
 }
 
diff -urN microwin/src\mwin\winlib\caret.c microwin-0.90/src\mwin\winlib\caret.c
--- microwin/src\mwin\winlib\caret.c	Thu Aug 26 19:42:04 2010
+++ microwin-0.90/src\mwin\winlib\caret.c	Wed Aug 25 14:54:36 2010
@@ -10,7 +10,6 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#include <sys/time.h>
 #ifndef __ECOS
 #include <malloc.h>
 #endif
diff -urN microwin/src\mwin\winlib\combobox.c microwin-0.90/src\mwin\winlib\combobox.c
--- microwin/src\mwin\winlib\combobox.c	Thu Aug 26 19:42:04 2010
+++ microwin-0.90/src\mwin\winlib\combobox.c	Wed Aug 25 14:54:36 2010
@@ -38,10 +38,6 @@
 #include "windowsx.h"
 #include "mwsystem.h"
 
-#if PSP
-#define fprintf(...) do {} while(0)
-#endif
-
 #define WinMalloc(n)	malloc((n))
 #define WinFree(p)	free(p)
 
@@ -255,7 +251,7 @@
         */
         if ((lp->wStyle & 0x0F) != CBS_SIMPLE && wParam != (WPARAM)lp->ListBoxControl && wParam != 0)
            SendMessage(hWnd, CB_SHOWDROPDOWN, 0, 0L);
-        fprintf(stderr," 385: WM_KILLFOCUS\n");
+        DPRINTF(" 385: WM_KILLFOCUS\n");
         break;
 
 #if 0	/* jmt: fix: no WM_KEYDOWN */
@@ -429,12 +425,12 @@
 
            if ((lp->wStyle & 0x0F) == CBS_SIMPLE)
 	   {
-	     	fprintf(stderr," 528: wEditWidth = lpcs->cx=%d\n",lpcs->cx);
+	     	DPRINTF(" 528: wEditWidth = lpcs->cx=%d\n",lpcs->cx);
 	     	wEditWidth = lpcs->cx;
 	   }
            else /* ?if ((lp->wStyle & 0xf) == CBS_DROPDOWN) */
 	   {
-		fprintf(stderr," 533: wEditWidth = lp->ButtonRect.left - 5=%d;\n",lp->ButtonRect.left - 5);
+		DPRINTF(" 533: wEditWidth = lp->ButtonRect.left - 5=%d;\n",lp->ButtonRect.left - 5);
                 wEditWidth = lp->ButtonRect.left - 4;
                 wEditHeight -= 4;
                 dwStyle &= ~WS_BORDER;
@@ -586,7 +582,7 @@
 
               ClientToScreen(hWnd, &cp);
 
-	      fprintf(stderr," (1)lp->ListBoxRect:(%d,%d,%d,%d)\n",
+	      DPRINTF(" (1)lp->ListBoxRect:(%d,%d,%d,%d)\n",
 			  lp->ListBoxRect.left,
 			  lp->ListBoxRect.top,
 			  lp->ListBoxRect.right,
@@ -594,7 +590,7 @@
 
               OffsetRect(&lp->ListBoxRect, cp.x - lp->ListBoxRect.left, cp.y - lp->ListBoxRect.top);
 
-	      fprintf(stderr," (2)lp->ListBoxRect:(%d,%d,%d,%d)\n",
+	      DPRINTF(" (2)lp->ListBoxRect:(%d,%d,%d,%d)\n",
 			  lp->ListBoxRect.left,
 			  lp->ListBoxRect.top,
 			  lp->ListBoxRect.right,
@@ -624,14 +620,14 @@
 		    lp->ListBoxRect.bottom =
 		      lp->ListBoxRect.top + ((lp->uHeight-2) * nitems);
 #endif
-	      	    fprintf(stderr," (2.5)lp->ListBoxRect:(%d,%d,%d,%d)\n",
+	      	    DPRINTF(" (2.5)lp->ListBoxRect:(%d,%d,%d,%d)\n",
 			  lp->ListBoxRect.left,
 			  lp->ListBoxRect.top,
 			  lp->ListBoxRect.right,
 			  lp->ListBoxRect.bottom);
 
 /* jmt: twine->mwin bug fixed: */
-	      	    fprintf(stderr," 706: fixed: SetWindowPos(lp->ListBoxControl,,%d,%d,...)\n",cp.x,cp.y);
+	      	    DPRINTF(" 706: fixed: SetWindowPos(lp->ListBoxControl,,%d,%d,...)\n",cp.x,cp.y);
 #if 0	/* twine->mwin bug */
 		    SetWindowPos(lp->ListBoxControl,HWND_TOP,0,0,
 				 lp->ListBoxRect.right - lp->ListBoxRect.left,
@@ -673,7 +669,7 @@
                 hwndNewFocus = WindowFromPoint(cpScreen);
              }
 
-	     fprintf(stderr," (3)lp->ListBoxRect:(%d,%d,%d,%d)\n",
+	     DPRINTF(" (3)lp->ListBoxRect:(%d,%d,%d,%d)\n",
 			  lp->ListBoxRect.left,
 			  lp->ListBoxRect.top,
 			  lp->ListBoxRect.right,
@@ -692,7 +688,7 @@
                   else {
                        SendMessage(lp->hWndParent, WM_COMMAND, GET_WM_COMMAND_MPS(lp->nID,hWnd,CBN_CLOSEUP));
 
-	      	       fprintf(stderr," 802: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
+	      	       DPRINTF(" 802: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
 
                        SetWindowPos(lp->ListBoxControl, 0,
                                0, 0, 0, 0,
@@ -803,7 +799,7 @@
 /* ecw */     SendMessage(lp->hWndParent, WM_COMMAND, GET_WM_COMMAND_MPS(lp->nID,hWnd,CBN_SELENDOK));
               SendMessage(lp->hWndParent, WM_COMMAND, GET_WM_COMMAND_MPS(lp->nID,hWnd,CBN_CLOSEUP));
 
-	      fprintf(stderr," 844: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
+	      DPRINTF(" 844: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
 
               SetWindowPos(lp->ListBoxControl, 0,
                            0, 0, 0, 0,
@@ -1306,7 +1302,7 @@
 
                SendMessage(lp->hWndParent,WM_COMMAND, GET_WM_COMMAND_MPS(lp->nID,hWnd,CBN_DROPDOWN));
 
-	       fprintf(stderr," 1330: SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
+	       DPRINTF(" 1330: SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
 
                SetWindowPos(lp->ListBoxControl, HWND_TOP,
                             0, 0, 0, 0,
@@ -1322,7 +1318,7 @@
 
                  SendMessage(lp->hWndParent, WM_COMMAND, GET_WM_COMMAND_MPS(lp->nID,hWnd,CBN_CLOSEUP));
 /* test: */
-  	         fprintf(stderr," 1343: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
+  	         DPRINTF(" 1343: (hide) SetWindowPos(lp->ListBoxControl, , 0, 0, 0, 0,..)\n");
 
                  SetWindowPos(lp->ListBoxControl, 0,
                               0, 0, 0, 0,
diff -urN microwin/src\mwin\winlib\edit.c microwin-0.90/src\mwin\winlib\edit.c
--- microwin/src\mwin\winlib\edit.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\edit.c	Wed Aug 25 14:54:36 2010
@@ -344,8 +344,7 @@
     {
 	if ( ((BYTE)string [pos + 1] >= 0x40 && (BYTE)string [pos + 1] <= 0x7e) ||
 	     ((BYTE)string [pos + 1] >= 0xa1 && (BYTE)string [pos + 1] <= 0xfe)) {
-	    /*fprintf(stderr,"true\n");
-	    fflush(stderr);*/
+	    /*DPRINTF("true\n");*/
 	    return TRUE;
 	}
     }
@@ -559,10 +558,8 @@
 
             pSLEditData = (PSLEDITDATA) (pCtrl->userdata2);
 
-#ifdef _DEBUG
             if (pSLEditData->startPos > pSLEditData->dataEnd)
-                fprintf (stderr, "ASSERT failure: %s.\n", "Edit Paint");
-#endif
+                DPRINTF("ASSERT failure: %s.\n", "Edit Paint");
             
             dispBuffer = ALLOCA(dispLen + 1);
 
diff -urN microwin/src\mwin\winlib\listbox.c microwin-0.90/src\mwin\winlib\listbox.c
--- microwin/src\mwin\winlib\listbox.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\listbox.c	Wed Aug 25 14:54:36 2010
@@ -726,7 +726,7 @@
 #endif
 #ifdef _DEBUG
 	if (!newItem)
-		EPRINTF("ASSERT failed: return value of lstGetItem"
+		DPRINTF("ASSERT failed: return value of lstGetItem"
 			" in lstSelectItem.\n");
 #endif
 
diff -urN microwin/src\mwin\winlib\medit.c microwin-0.90/src\mwin\winlib\medit.c
--- microwin/src\mwin\winlib\medit.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\medit.c	Wed Aug 25 14:54:36 2010
@@ -50,7 +50,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/time.h>
 #define MWINCLUDECOLORS
 #include "windows.h"	/* windef.h, winuser.h */
 #include "wintools.h"
@@ -140,7 +139,7 @@
 
 #define PIXEL_invalid (-1)
 extern HWND sg_hCaretWnd;
-extern HWND rootwp;
+extern HWND roothwnd;
 
 static int GetSysCharHeight (HWND hwnd) 
 {
@@ -224,7 +223,7 @@
 
 BOOL ExcludeWindowStyle (HWND hWnd, DWORD dwStyle)
 {
-    	if (hWnd == rootwp/*HWND_DESKTOP*/)
+    	if (hWnd == roothwnd/*HWND_DESKTOP*/)
         	return FALSE;
 
         hWnd->style &= ~dwStyle;
@@ -234,7 +233,7 @@
 BOOL IncludeWindowStyle (HWND hWnd, DWORD dwStyle)
 {
 
-    	if (hWnd == rootwp/*HWND_DESKTOP*/)
+    	if (hWnd == roothwnd/*HWND_DESKTOP*/)
         	return FALSE;
 
         hWnd->style |= dwStyle;
@@ -436,8 +435,7 @@
     {
 	if ( ((BYTE)string [pos + 1] >= 0x40 && (BYTE)string [pos + 1] <= 0x7e) ||
 	     ((BYTE)string [pos + 1] >= 0xa1 && (BYTE)string [pos + 1] <= 0xfe)) {
-	    /*fprintf(stderr,"true\n");
-	    fflush(stderr);*/
+	    /*DPRINTF("true\n");*/
 	    return TRUE;
 	}
     }
@@ -531,7 +529,7 @@
 	int lineNO=0;
 	PLINEDATA  pLineData;
 	if (!(pMLEditData->head = malloc (sizeof (LINEDATA)))) {
-		fprintf (stderr, "EDITLINE: malloc error!\n");
+		DPRINTF("EDITLINE: malloc error!\n");
 		return ;
 	}
 	pMLEditData->head->previous = NULL;
@@ -587,7 +585,7 @@
         case WM_CREATE:
 	{
             if (!(pMLEditData = malloc (sizeof (MLEDITDATA)))) {
-                fprintf (stderr, "EDIT: malloc error!\n");
+                DPRINTF("EDIT: malloc error!\n");
                 return -1;
             }
 
@@ -788,7 +786,7 @@
 
 #ifdef _DEBUG
        	    	if (pMLEditData->dispPos > pLineData->dataEnd)
-        	        fprintf (stderr, "ASSERT failure: %s.\n", "Edit Paint");
+        	        DPRINTF("ASSERT failure: %s.\n", "Edit Paint");
 #endif
             
                 dispBuffer = alloca (LEN_MLEDIT_BUFFER+1);
diff -urN microwin/src\mwin\winlib\newedit.c microwin-0.90/src\mwin\winlib\newedit.c
--- microwin/src\mwin\winlib\newedit.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\newedit.c	Wed Aug 25 14:54:36 2010
@@ -179,7 +179,7 @@
 	//nl = (rc.bottom - rc.top + charH - 1) / charH;
 
 	if (!(pSLEditData = malloc(sizeof(SLEDITDATA)))) {
-		EPRINTF("EDIT: malloc error!\n");
+		DPRINTF("EDIT: malloc error!\n");
 		return -1;
 	}
 
@@ -221,7 +221,7 @@
 	pSLEditData->hardLimit = -1;
 
 	pSLEditData->buffer =
-		(EDITCHAR *) calloc(SZEDITCHAR, pSLEditData->bufferLen);
+		(EDITCHAR *) malloc(SZEDITCHAR * pSLEditData->bufferLen);
 
 	/* undo information */
 	pSLEditData->lastOp = EDIT_OP_NONE;
@@ -296,7 +296,7 @@
 
 	newbuff = (EDITCHAR *) malloc(len * SZEDITCHAR);
 	if (newbuff == NULL) {
-		EPRINTF("Unable to allocate buffer for EDIT control.\n");
+		DPRINTF("Unable to allocate buffer for EDIT control.\n");
 		return FALSE;
 	}
 
@@ -607,7 +607,7 @@
 	pSLEditData->caretRow =
 		pSLEditData->epY / pSLEditData->charHeight -
 		pSLEditData->scrollRow;
-	if (pSLEditData->cLines > 1 && pSLEditData->caretRow >= pSLEditData->cLines - 1) {
+	if (pSLEditData->caretRow >= pSLEditData->cLines - 1) {
 		int delta = pSLEditData->caretRow - pSLEditData->cLines + 2;
 		pSLEditData->scrollRow += delta;
 		pSLEditData->caretRow -= delta;
@@ -1505,7 +1505,7 @@
 	int i, chars, inserting;
 	PSLEDITDATA pSLEditData = (PSLEDITDATA) (hWnd->userdata2);
 	DWORD dwStyle = hWnd->style;
-	BOOL isPasting = (((LPARAM) wParam == -1) && lParam == -1);
+	BOOL isPasting = (((int32_t) wParam == -1) && ((int32_t) lParam == -1));
 
 
 	if (dwStyle & ES_READONLY)
@@ -1542,9 +1542,6 @@
 			charBuffer[0] = '\n';
 			break;
 		}
-
-		if ((dwStyle & ES_NUMBER) && !isdigit(charBuffer[0]))
-			return 0;
 	}
 
 	//  If there is a selection, remove it.
@@ -1580,7 +1577,7 @@
 			pSLEditData->buffer[i] = pSLEditData->buffer[i + 1];
 	} else if (inserting > 0) {
 		for (i = pSLEditData->dataEnd - 1;
-		     i > pSLEditData->editPos - 1 && i - inserting>=0; i--)
+		     i > pSLEditData->editPos - 1; i--)
 			pSLEditData->buffer[i] =
 				pSLEditData->buffer[i - inserting];
 	}
@@ -1701,10 +1698,11 @@
 			int len;
 
 			pSLEditData = (PSLEDITDATA) (pCtrl->userdata2);
-			len = min((int) wParam, pSLEditData->dataEnd+1);
+			len = min((int) wParam, pSLEditData->dataEnd);
 			//memcpy_fromedit (buffer, pSLEditData->buffer, len);
-			return GdConvertEncoding(pSLEditData->buffer, MWTF_UC16, len,
-					  buffer, mwTextCoding)?strlen(buffer):0;
+			GdConvertEncoding(pSLEditData->buffer, MWTF_UC16, len,
+					  buffer, mwTextCoding);
+			return strlen(buffer);
 		}
 
 	case WM_SETTEXT:
diff -urN microwin/src\mwin\winlib\newlistbox.c microwin-0.90/src\mwin\winlib\newlistbox.c
--- microwin/src\mwin\winlib\newlistbox.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\newlistbox.c	Wed Aug 25 14:54:36 2010
@@ -15,6 +15,11 @@
 #include <stdlib.h>
 #include "windows.h"
 
+#ifdef WIN32
+  #define strcasecmp stricmp  
+  #define strncasecmp strnicmp  
+#endif
+
 /* FIXME: Some definitions that are currently not defined in microwindows */
 #define UINT_PTR UINT
 #define STDCALL
diff -urN microwin/src\mwin\winlib\progbar.c microwin-0.90/src\mwin\winlib\progbar.c
--- microwin/src\mwin\winlib\progbar.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\progbar.c	Wed Aug 25 14:54:36 2010
@@ -206,7 +206,7 @@
 	    cr = GetSysColor(COLOR_BTNSHADOW);
 	FillBox (hdc, x + ((w - maxw)>>1), y + ((h - charh) > 1), maxw,
 		charh - 1, cr);
-	FillBox (hdc, x, y, (int)((LONG)w*d/100L), h, BLUE);
+	FillBox (hdc, x, y, (int)((int32_t)w*d/100L), h, BLUE);
         SetTextColor (hdc, WHITE);
         SetBkMode (hdc, TRANSPARENT);
         sprintf (szText, "%d%%", d);
diff -urN microwin/src\mwin\winlib\scrlbar.c microwin-0.90/src\mwin\winlib\scrlbar.c
--- microwin/src\mwin\winlib\scrlbar.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\scrlbar.c	Wed Aug 25 14:54:36 2010
@@ -206,7 +206,7 @@
 
         	Draw3dUpFrame (hdc, rcVBar.left, start, rcVBar.right,
 	    		start + pData->barLen);
-		/*printf("barv:(l,t,r,b):(%d,%d,%d,%d)\n",
+		/*DPRINTF("barv:(l,t,r,b):(%d,%d,%d,%d)\n",
         		rcVBar.left, start, rcVBar.right,
 	    		start + pData->barLen);*/
 
@@ -277,7 +277,7 @@
 
         	Draw3dUpFrame (hdc, start, rcHBar.top, start + pData->barLen,
 	    		rcHBar.bottom);
-		/*printf("barh:(l,t,r,b):(%d,%d,%d,%d)\n",
+		/*DPRINTF("barh:(l,t,r,b):(%d,%d,%d,%d)\n",
         		start, rcHBar.top, start + pData->barLen,
 	    		rcHBar.bottom);*/
 	}
@@ -409,7 +409,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			newThumbPos = ((pt.y - moveTop) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveTop,itemMoveable,moveRange,newThumbPos);
 
                 	if ( newThumbPos >= pData->minPos &&
@@ -440,7 +440,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			newThumbPos = ((pt.x - moveLeft) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveLeft,itemMoveable,moveRange,newThumbPos);
 			    
 			if ( newThumbPos >= pData->minPos &&
@@ -477,7 +477,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			newThumbPos = ((pt.y - moveTop) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveTop,itemMoveable,moveRange,newThumbPos);
 
 			if ( newThumbPos >= pData->minPos &&
@@ -505,7 +505,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			newThumbPos = ((pt.x - moveLeft) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveLeft,itemMoveable,moveRange,newThumbPos);
 				    
 			if ( newThumbPos >= pData->minPos &&
@@ -1017,7 +1017,7 @@
 			if( (moveRange % MWM_MINBARLEN) )
 				pData->maxPos++;
 		}     
-		printf("maxPos=%d\n",pData->maxPos);
+		DPRINTF("maxPos=%d\n",pData->maxPos);
 
 		pData->curPos=0;             /* current scroll pos.*/
 
@@ -1025,7 +1025,7 @@
 		pData->pageStep=1;
 		if ( (pData->maxPos - 2) > 1)
 			pData->pageStep = pData->maxPos - 2;
-		printf("pageStep=%d\n",pData->pageStep);
+		DPRINTF("pageStep=%d\n",pData->pageStep);
 
 		pData->barStart=0;           /* start pixel of bar.*/
 		pData->barLen=MWM_MINBARLEN; /* length of bar.*/
diff -urN microwin/src\mwin\winlib\windlg.c microwin-0.90/src\mwin\winlib\windlg.c
--- microwin/src\mwin\winlib\windlg.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winlib\windlg.c	Wed Aug 25 14:54:36 2010
@@ -17,6 +17,10 @@
 #include "wintools.h"
 #include "wintern.h"
 #include "device.h"
+#ifdef WIN32
+  #define strcasecmp stricmp  
+  #define strncasecmp strnicmp  
+#endif
 
 #define DEFAULT_FONT			DEFAULT_GUI_FONT
 #define DEFDLG_FONT_QUALITY		ANTIALIASED_QUALITY
@@ -29,9 +33,9 @@
 					 (MwGetTopWindow((hCtrl)) == (hDlg)))
 
 #define MulDiv(x,m,d)	( ((((x)<0) && ((m)<0)) || (((x)>=0) && ((m)>=0))) ? \
-			  ((((LONG)(x)*(LONG)(m))+(LONG)((d)/2))/(LONG)(d)) : \
-			  ((((LONG)(x)*(LONG)(m))-(LONG)((d)/2))/(LONG)(d)) )
-#define MulDivRD(x,m,d)	( ((LONG)(x) * (LONG)(m))/(LONG)(d) )
+			  ((((int32_t)(x)*(int32_t)(m))+(int32_t)((d)/2))/(int32_t)(d)) : \
+			  ((((int32_t)(x)*(int32_t)(m))-(int32_t)((d)/2))/(int32_t)(d)) )
+#define MulDivRD(x,m,d)	( ((int32_t)(x) * (int32_t)(m))/(int32_t)(d) )
 
 /*
  *  Struct with information about DLG
@@ -491,6 +495,9 @@
 		"BUTTON", "EDIT", "STATIC", "LISTBOX", "SCROLLBAR", "COMBOBOX"
 	};
 
+	if ((pItem->szClassName == NULL) || (strlen(pItem->szClassName) < 2))
+		return "";
+
 	if ((pItem->szClassName[0] == (TCHAR) - 1)) {
 		unsigned idx = ((unsigned char) pItem->szClassName[1]) -
 			DLGITEM_CLASS_FIRSTID;
@@ -501,9 +508,6 @@
 		return "";
 	}
 
-	if ((pItem->szClassName == NULL) || (strlen(pItem->szClassName) < 2))
-		return "";
-
 	return pItem->szClassName;
 }
 
@@ -574,10 +578,6 @@
 				EPRINTF("WARN: mwDialogProc: WM_NCDESTROY without dlgParams\n");
 			break;
 
-        case WM_CLOSE:
-                EndDialog (hWnd, 0);
-                return 0;
-
 		case WM_SETFONT:
 			pData = DLG_PMWDLGDATA(hWnd);
 			if (pData == NULL)
@@ -1133,7 +1133,7 @@
 /*
  *  Get base units of dialogs
  */
-LONG
+LONG WINAPI
 GetDialogBaseUnits(VOID)
 {
 	HDC hdc;
diff -urN microwin/src\mwin\winmain.c microwin-0.90/src\mwin\winmain.c
--- microwin/src\mwin\winmain.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winmain.c	Mon Aug 30 10:30:04 2010
@@ -113,7 +113,12 @@
 	rootwp->hInstance = hInstance;
 
 	/* call windows main program entry point*/
-	WinMain(hInstance, NULL, (LPSTR)((PMWAPPINSTANCE)hInstance)->szCmdLine, SW_SHOW);
+#ifdef WIN32
+	MWinMain
+#else
+	WinMain
+#endif
+		(hInstance, NULL, (LPSTR)((PMWAPPINSTANCE)hInstance)->szCmdLine, SW_SHOW);
 
 	mwFreeInstance(hInstance);
 	MwClose();
@@ -280,7 +285,7 @@
 
 #endif /* UNIX | DOS_DJGPP*/
 
-#if MSDOS | _MINIX
+#if MSDOS | _MINIX | WIN32
 void
 MwSelect(BOOL mayWait)
 {
@@ -747,4 +752,10 @@
 	for(i=0; i < dwMilliseconds; i++)
 		for(j=0; j < loops_per_ms; j++)
 			k = i * j;
+}
+
+void GrClose(void)
+{
+	/* Shutdown Microwindows */
+	MwTerminate();
 }
diff -urN microwin/src\mwin\winsbar.c microwin-0.90/src\mwin\winsbar.c
--- microwin/src\mwin\winsbar.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\mwin\winsbar.c	Wed Aug 25 14:53:22 2010
@@ -187,7 +187,7 @@
 
         	Draw3dUpFrame (hdc, rcVBar.left, start, rcVBar.right,
 	    		start + hwnd->vscroll.barLen);
-		/*printf("barv:(l,t,r,b):(%d,%d,%d,%d)\n",
+		/*DPRINTF("barv:(l,t,r,b):(%d,%d,%d,%d)\n",
         		rcVBar.left, start, rcVBar.right,
 	    		start + hwnd->vscroll.barLen);*/
 	}
@@ -258,7 +258,7 @@
 
         	Draw3dUpFrame (hdc, start, rcHBar.top, start + hwnd->hscroll.barLen,
 	    		rcHBar.bottom);
-		/*printf("barh:(l,t,r,b):(%d,%d,%d,%d)\n",
+		/*DPRINTF("barh:(l,t,r,b):(%d,%d,%d,%d)\n",
         		start, rcHBar.top, start + hwnd->hscroll.barLen,
 	    		rcHBar.bottom);*/
 
@@ -398,7 +398,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			hwnd->vscroll.trackPos = ((pt.y - moveTop) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveTop,itemMoveable,moveRange,hwnd->vscroll.trackPos);
 
                 	if ( hwnd->vscroll.trackPos >= hwnd->vscroll.minPos &&
@@ -425,7 +425,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			hwnd->hscroll.trackPos = ((pt.x - moveLeft) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveLeft,itemMoveable,moveRange,hwnd->hscroll.trackPos);
     
 			if ( hwnd->hscroll.trackPos >= hwnd->hscroll.minPos &&
@@ -458,7 +458,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			hwnd->vscroll.trackPos = ((pt.y - moveTop) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveTop,itemMoveable,moveRange,hwnd->vscroll.trackPos);
 
 			if ( hwnd->vscroll.trackPos >= hwnd->vscroll.minPos &&
@@ -482,7 +482,7 @@
 			itemMoveable = itemCount - itemVisible + 1;
 
 			hwnd->hscroll.trackPos = ((pt.x - moveLeft) * itemMoveable) / moveRange;
-			printf("((%d-%d)*%d)/%d=%d\n",
+			DPRINTF("((%d-%d)*%d)/%d=%d\n",
 				pt.y,moveLeft,itemMoveable,moveRange,hwnd->hscroll.trackPos);
     
 			if ( hwnd->hscroll.trackPos >= hwnd->hscroll.minPos &&
@@ -744,7 +744,8 @@
     return TRUE;
 }
 
-BOOL  SetScrollInfo (HWND hWnd, int iSBar, 
+BOOL WINAPI
+SetScrollInfo (HWND hWnd, int iSBar, 
                 LPCSCROLLINFO lpsi, BOOL fRedraw)
 {
     PMWSCROLLBARINFO pSBar;
@@ -807,7 +808,8 @@
     return TRUE;
 }
 
-BOOL  GetScrollInfo(HWND hWnd, int iSBar, LPSCROLLINFO lpsi)
+BOOL WINAPI
+GetScrollInfo(HWND hWnd, int iSBar, LPSCROLLINFO lpsi)
 {
     PMWSCROLLBARINFO pSBar;
     HWND pWin;
diff -urN microwin/src\nanox\client.c microwin-0.90/src\nanox\client.c
--- microwin/src\nanox\client.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\nanox\client.c	Wed Aug 25 14:59:08 2010
@@ -33,7 +33,9 @@
 #include <sys/shm.h>
 #endif
 #include <sys/time.h>
+#ifndef NONETWORK
 #include <sys/socket.h>
+#endif
 #if ELKS
 #include <linuxmt/na.h>
 #include <linuxmt/time.h>
@@ -61,6 +63,8 @@
 #include "nxproto.h"
 #include "lock.h"
 
+#ifndef NONETWORK
+
 #ifndef ADDR_FAM
 /**
  * Default to unix socket for client/server.
@@ -149,14 +153,14 @@
 				/* We should maybe produce an event here,
 				 * if possible.
 				 */
-				EPRINTF("nxclient: lost connection to Nano-X "
+				DPRINTF("nxclient: lost connection to Nano-X "
 					"server\n");
 				exit(1);
 			}
 			if ( errno == EINTR || errno == EAGAIN )
 				continue;
 
-			EPRINTF("nxclient: bad readblock %d, errno %d\n", i, errno);
+			DPRINTF("nxclient: bad readblock %d, errno %d\n", i, errno);
 			return -1;
 		}
 		v += i;
@@ -238,11 +242,11 @@
 			CheckForClientData(&event);
 			QueueEvent(&event);
 		} else {
-			EPRINTF("nxclient %d: Wrong packet type %d "
+			DPRINTF("nxclient %d: Wrong packet type %d "
 				"(expected %d)\n", getpid(),b, packettype);
 		}
 	}
-	EPRINTF("nxclient %d: Corrupted packet\n", getpid());
+	DPRINTF("nxclient %d: Corrupted packet\n", getpid());
 	return -1;
 }
 
@@ -349,7 +353,7 @@
 	name.sin_family = AF_INET;
 	name.sin_port = htons(GR_NUM_SOCKET);	/* AF_INET socket 6600*/
 	if (!(he = gethostbyname(sockaddr))) {
-		EPRINTF("nxclient: Can't resolve address for server %s\n", sockaddr);
+		DPRINTF("nxclient: Can't resolve address for server %s\n", sockaddr);
 		close(nxSocket);
 		nxSocket = -1;
 		return -1;
@@ -381,16 +385,17 @@
 		req.tv_nsec = 0;
 #endif
 		nanosleep(&req, NULL);
-		EPRINTF("nxclient: retry connect attempt %d\n", tries);
+		DPRINTF("nxclient: retry connect attempt %d\n", tries);
 	}
 	if (ret == -1) {
 		close(nxSocket);
 		nxSocket = -1;
 		return -1;
 	}
-
+#ifdef HAVE_FILEIO
 	setbuf(stdout, NULL);
 	setbuf(stderr, NULL);
+#endif
 
 	/*
 	 * By Performing the 'GrOpen' without allocating a buffer, just
@@ -419,7 +424,7 @@
 mySignalhandler(int sig)
 {
 	if (sig == SIGALRM) {
-		EPRINTF("Oops! nxFlushReq() timed out, exiting\n");
+		DPRINTF("Oops! nxFlushReq() timed out, exiting\n");
 		exit(127);
 	}
 }
@@ -491,8 +496,8 @@
 GrDefaultErrorHandler(GR_EVENT *ep)
 {
 	if (ep->type == GR_EVENT_TYPE_ERROR) {
-		EPRINTF("nxclient %d: Error (%s) ", getpid(), ep->error.name);
-		EPRINTF(nxErrorStrings[ep->error.code], ep->error.id);
+		DPRINTF("nxclient %d: Error (%s) ", getpid(), ep->error.name);
+		DPRINTF(nxErrorStrings[ep->error.code], ep->error.id);
 		GrClose();
 		exit(1);
 	}
@@ -1027,7 +1032,7 @@
 		if(errno == EINTR) {
 			ep->type = GR_EVENT_TYPE_NONE;
 		} else {
-			EPRINTF("nxclient: select failed\n");
+			DPRINTF("nxclient: select failed\n");
 			GrClose();
 			exit(1);
 		}
@@ -3157,7 +3162,7 @@
 }
 #endif /* MW_FEATURE_IMAGES && defined(HAVE_FILEIO) */
 
-#if MW_FEATURE_IMAGES && defined(HAVE_FILEIO)
+#if MW_FEATURE_IMAGES && HAVE_FILEIO
 /**
  * Loads the specified image file into a newly created server image buffer
  * and returns the ID of the buffer. The image type is automatically detected
@@ -3270,9 +3275,6 @@
 
 }
 
-#endif /* MW_FEATURE_IMAGES */
-
-#if MW_FEATURE_IMAGES
 /**
  * Destroys the specified image buffer and reclaims the memory used by it.
  *
@@ -3370,7 +3372,7 @@
  * @ingroup nanox_image
  */
 GR_IMAGE_ID
-GrLoadImageFromBuffer(void *buffer, int size, int flags)
+GrLoadImageFromBuffer(const void *buffer, int size, int flags)
 {
 	nxLoadImageFromBufferReq *req;
 	int bufid;
@@ -3419,7 +3421,7 @@
  */
 void
 GrDrawImageFromBuffer(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
-      GR_SIZE width, GR_SIZE height, void *buffer, int size, int flags)
+      GR_SIZE width, GR_SIZE height, const void *buffer, int size, int flags)
 {
 	nxDrawImageFromBufferReq *req;
 	int bufid;
@@ -3892,14 +3894,14 @@
 	ReadBlock(&key,sizeof(key));
 
 	if (!key) {
-		EPRINTF("nxclient: no shared memory support on server\n");
+		DPRINTF("nxclient: no shared memory support on server\n");
 		UNLOCK(&nxGlobalLock);
 		return;
 	}
 
 	shmid = shmget(key, shmsize, 0);
 	if (shmid == -1) {
-		EPRINTF("nxclient: Can't shmget key %d: %m\n", key);
+		DPRINTF("nxclient: Can't shmget key %d: %m\n", key);
 		UNLOCK(&nxGlobalLock);
 		return;
 	}
@@ -4865,5 +4867,4 @@
 }
 #endif /*HAVE_FREETYPE_2_SUPPORT*/
 
-
-
+#endif /* NONETWORK*/
diff -urN microwin/src\nanox\clientfb.c microwin-0.90/src\nanox\clientfb.c
--- microwin/src\nanox\clientfb.c	Thu Aug 26 19:42:06 2010
+++ microwin-0.90/src\nanox\clientfb.c	Wed Aug 25 14:59:08 2010
@@ -77,14 +77,14 @@
 		fbdev = "/dev/fb0";
 	frame_fd = open(fbdev, O_RDWR);
 	if (frame_fd < 0) {
-		printf("Can't open framebuffer device\n");
+		DPRINTF("Can't open framebuffer device\n");
 		UNLOCK(&nxGlobalLock);
 		return NULL;
 	}
 
 	/* Get the type of video hardware */
 	if (ioctl(frame_fd, FBIOGET_FSCREENINFO, &finfo) < 0 ) {
-		printf("Couldn't get fb hardware info\n");
+		DPRINTF("Couldn't get fb hardware info\n");
 		goto err;
 	}
 
@@ -96,7 +96,7 @@
 		case FB_VISUAL_DIRECTCOLOR:
 			break;
 		default:
-			printf("Unsupported fb color map\n");
+			DPRINTF("Unsupported fb color map\n");
 			goto err;
 	}
 
@@ -112,7 +112,7 @@
 		0);
 #endif
 	if (frame_map == (unsigned char *)-1) {
-		printf("Unable to memory map the video hardware\n");
+		DPRINTF("Unable to memory map the video hardware\n");
 		frame_map = NULL;
 		goto err;
 	}
diff -urN microwin/src\nanox\error.c microwin-0.90/src\nanox\error.c
--- microwin/src\nanox\error.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\error.c	Wed Aug 25 14:59:08 2010
@@ -17,12 +17,14 @@
 #include "device.h"
 
 #if MW_FEATURE_GDERROR
+
 /**
  * Write error message to stderr stream.
  */
 int
 GdError(const char *format, ...)
 {
+#if HAVE_FILEIO
 	va_list args;
 	char 	buf[1024];
 
@@ -35,6 +37,7 @@
 	write(2, buf, strlen(buf));
 #endif
 	va_end(args);
+#endif
 	return -1;
 }
 
diff -urN microwin/src\nanox\nxproto.c microwin-0.90/src\nanox\nxproto.c
--- microwin/src\nanox\nxproto.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\nxproto.c	Wed Aug 25 14:59:08 2010
@@ -22,6 +22,8 @@
 LOCK_EXTERN(nxGlobalLock);	/* global lock for threads safety*/
 #endif
 
+#ifdef HAVE_FILEIO
+
 /* Allocate a request buffer of passed size and fill in header fields*/
 void *
 nxAllocReq(int type, long size, long extra)
@@ -61,7 +63,7 @@
 		newsize = SZREQBUF;
 	reqbuf.buffer = malloc(newsize);
 	if(!reqbuf.buffer) {
-		EPRINTF("nxFlushReq: Can't allocate initial request buffer\n");
+		DPRINTF("nxFlushReq: Can't allocate initial request buffer\n");
 		exit(1);
 	}
 	reqbuf.bufptr = reqbuf.buffer;
@@ -92,7 +94,7 @@
 		if ( written < 0 ) {
 			if ( errno == EAGAIN || errno == EINTR )
 				continue;
-			EPRINTF("nxFlushReq: write failed: %m\n");
+			DPRINTF("nxFlushReq: write failed: %m\n");
 			exit(1);
 		}
 		buf += written;
@@ -167,7 +169,7 @@
 
 			if ( reqbuf.buffer + newsize > reqbuf.bufmax ) {
 				/* Shared memory too small, critical */
-				EPRINTF("nxFlushReq: shm region too small\n");
+				DPRINTF("nxFlushReq: shm region too small\n");
 				exit(1);
 			}
 			UNLOCK(&nxGlobalLock);
@@ -184,7 +186,7 @@
 	if(reqbuf.bufptr + newsize >= reqbuf.bufmax) {
 		reqbuf.buffer = GdRealloc(reqbuf.buffer, reqbuf.bufmax - reqbuf.buffer, newsize);
 		if(!reqbuf.buffer) {
-		       EPRINTF("nxFlushReq: Can't reallocate request buffer\n");
+		       DPRINTF("nxFlushReq: Can't reallocate request buffer\n");
 			exit(1);
 		}
 		reqbuf.bufptr = reqbuf.buffer;
@@ -209,3 +211,5 @@
 
 	return nbytes;
 }
+
+#endif /* HAVE_FILEIO */
diff -urN microwin/src\nanox\nxtransform.c microwin-0.90/src\nanox\nxtransform.c
--- microwin/src\nanox\nxtransform.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\nxtransform.c	Wed Aug 25 14:59:08 2010
@@ -21,6 +21,8 @@
 	return CalcTransformationCoefficientsBetter(data, trans);
 }
 
+#ifdef HAVE_FILEIO
+
 /* Provide a standard way for saving the transform data in a file */
 int
 GrSaveTransformData(GR_TRANSFORM * trans, char *filename)
@@ -41,6 +43,8 @@
 
 	return 0;
 }
+
+#endif
 
 int
 GrLoadTransformData(char *filename, GR_TRANSFORM * trans)
diff -urN microwin/src\nanox\serv.h microwin-0.90/src\nanox\serv.h
--- microwin/src\nanox\serv.h	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\serv.h	Wed Aug 25 15:02:08 2010
@@ -10,7 +10,9 @@
  * These definitions are not to be used by clients.
  */
 
+#ifndef MWSYSTEM_H_INCLUDED 
 #include "mwsystem.h"
+#endif
 
 
 #if __ECOS && !defined(_NO_SVR_MAPPING)
@@ -129,9 +131,12 @@
 #define GrXorRegion             SVR_GrXorRegion
 #endif
 
+#ifndef	_NANO_X_H
 #include "nano-X.h"
+#endif
+#ifndef _DEVICE_H
 #include "device.h"
-
+#endif
 
 /*
  * Define the server-side mutex code.  This is a regular mutex (as defined
@@ -141,7 +146,9 @@
 #if NONETWORK
 /* Use a server-side mutex. */
 
+#ifndef __LOCK_H__
 #include "lock.h"
+#endif
 
 LOCK_EXTERN(gr_server_mutex);
 
diff -urN microwin/src\nanox\srvevent.c microwin-0.90/src\nanox\srvevent.c
--- microwin/src\nanox\srvevent.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\srvevent.c	Wed Aug 25 14:59:08 2010
@@ -38,8 +38,8 @@
 GrDefaultErrorHandler(GR_EVENT *ep)
 {
 	if (ep->type == GR_EVENT_TYPE_ERROR) {
-		EPRINTF("nxclient: Error (%s) ", ep->error.name);
-		EPRINTF(nxErrorStrings[ep->error.code], ep->error.id);
+		DPRINTF("nxclient: Error (%s) ", ep->error.name);
+		DPRINTF(nxErrorStrings[ep->error.code], ep->error.id);
 		GrClose();
 		exit(1);
 	}
@@ -80,10 +80,10 @@
 {
 	GR_EVENT_ERROR	*ep;		/* event to describe error */
 
-	EPRINTF("nano-X: GsError ");
+	DPRINTF("nano-X: GsError ");
 	if(curfunc)
-		EPRINTF("(%s) ", curfunc);
-	EPRINTF(nxErrorStrings[code], id);
+		DPRINTF("(%s) ", curfunc);
+	DPRINTF(nxErrorStrings[code], id);
 
 	/* if no clients, nothing to report*/
 	if (!curclient)
@@ -336,76 +336,79 @@
 	 * subwindow by seeing if it is a child of the grabbed button.
 	 */
 	wp = mousewp;
-	subwid = wp->id;
+	if (wp)
+	{
+		subwid = wp->id;
 
-	if (grabbuttonwp) {
+		if (grabbuttonwp) {
 #if 0
-		while ((wp != rootwp) && (wp != grabbuttonwp))
-			wp = wp->parent;
-		if (wp != grabbuttonwp)
-			subwid = grabbuttonwp->id;
+			while ((wp != rootwp) && (wp != grabbuttonwp))
+				wp = wp->parent;
+			if (wp != grabbuttonwp)
+				subwid = grabbuttonwp->id;
 #endif
-		wp = grabbuttonwp;
-	}
+			wp = grabbuttonwp;
+		}
+
+		while (wp) {
+			for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
+				if ((ecp->eventmask & eventmask) == 0)
+					continue;
 
-	for (;;) {
-		for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
-			if ((ecp->eventmask & eventmask) == 0)
-				continue;
+				client = ecp->client;
 
-			client = ecp->client;
+				/*
+				 * If this is a button down, the buttons are not
+				 * yet grabbed, and this client is enabled for both
+				 * button down and button up events, then implicitly
+				 * grab the window for him.
+				 */
+				if ((type == GR_EVENT_TYPE_BUTTON_DOWN)
+					&& (grabbuttonwp == NULL))
+				{
+					tempmask = GR_EVENT_MASK_BUTTON_UP;
+					if (ecp->eventmask & tempmask) {
+						DPRINTF("nano-X: implicit grab on window %d\n", wp->id);
+						grabbuttonwp = wp;
+					}
+				}
+
+				ep = (GR_EVENT_BUTTON *) GsAllocEvent(client);
+				if (ep == NULL)
+					continue;
+
+				ep->type = type;
+				ep->wid = wp->id;
+				ep->subwid = subwid;
+				ep->rootx = cursorx;
+				ep->rooty = cursory;
+				ep->x = cursorx - wp->x;
+				ep->y = cursory - wp->y;
+				ep->buttons = buttons;
+				ep->changebuttons = changebuttons;
+				ep->modifiers = modifiers;
+				ep->time = GsGetTickCount();
+			}
 
 			/*
-			 * If this is a button down, the buttons are not
-			 * yet grabbed, and this client is enabled for both
-			 * button down and button up events, then implicitly
-			 * grab the window for him.
+			 * Events do not propagate if the window was grabbed.
+			 * Also release the grab if the buttons are now all released,
+			 * which can cause various events.
 			 */
-			if ((type == GR_EVENT_TYPE_BUTTON_DOWN)
-				&& (grabbuttonwp == NULL))
-			{
-				tempmask = GR_EVENT_MASK_BUTTON_UP;
-				if (ecp->eventmask & tempmask) {
-					DPRINTF("nano-X: implicit grab on window %d\n", wp->id);
-					grabbuttonwp = wp;
+			if (grabbuttonwp) {
+				if (buttons == 0) {
+					DPRINTF("nano-X: implicit ungrab on window %d\n", grabbuttonwp->id);
+					grabbuttonwp = NULL;
+					GrMoveCursor(cursorx, cursory);
 				}
+				return;
 			}
 
-			ep = (GR_EVENT_BUTTON *) GsAllocEvent(client);
-			if (ep == NULL)
-				continue;
-
-			ep->type = type;
-			ep->wid = wp->id;
-			ep->subwid = subwid;
-			ep->rootx = cursorx;
-			ep->rooty = cursory;
-			ep->x = cursorx - wp->x;
-			ep->y = cursory - wp->y;
-			ep->buttons = buttons;
-			ep->changebuttons = changebuttons;
-			ep->modifiers = modifiers;
-			ep->time = GsGetTickCount();
-		}
+			if ((wp == rootwp) || (wp->nopropmask & eventmask))
+				return;
 
-		/*
-		 * Events do not propagate if the window was grabbed.
-		 * Also release the grab if the buttons are now all released,
-		 * which can cause various events.
-		 */
-		if (grabbuttonwp) {
-			if (buttons == 0) {
-				DPRINTF("nano-X: implicit ungrab on window %d\n", grabbuttonwp->id);
-				grabbuttonwp = NULL;
-				GrMoveCursor(cursorx, cursory);
-			}
-			return;
+			wp = wp->parent;
 		}
-
-		if ((wp == rootwp) || (wp->nopropmask & eventmask))
-			return;
-
-		wp = wp->parent;
 	}
 }
 
@@ -437,53 +440,56 @@
 		return;
 
 	wp = mousewp;
-	subwid = wp->id;
+	if (wp)
+	{
+		subwid = wp->id;
 
-	if (grabbuttonwp) {
+		if (grabbuttonwp) {
 #if 0
-		while ((wp != rootwp) && (wp != grabbuttonwp))
-			wp = wp->parent;
-		if (wp != grabbuttonwp)
-			subwid = grabbuttonwp->id;
+			while ((wp != rootwp) && (wp != grabbuttonwp))
+				wp = wp->parent;
+			if (wp != grabbuttonwp)
+				subwid = grabbuttonwp->id;
 #endif
-		wp = grabbuttonwp;
-	}
+			wp = grabbuttonwp;
+		}
 
-	for (;;) {
-		for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
-			if ((ecp->eventmask & eventmask) == 0)
-				continue;
+		for (;;) {
+			for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
+				if ((ecp->eventmask & eventmask) == 0)
+					continue;
 
-			client = ecp->client;
+				client = ecp->client;
 
-			/*
-			 * If the event is for just the latest position,
-			 * then search the event queue for an existing
-			 * event of this type (if any), and free it.
-			 */
-			if (type == GR_EVENT_TYPE_MOUSE_POSITION) 
-				GsFreePositionEvent(client, wp->id, subwid);
+				/*
+				 * If the event is for just the latest position,
+				 * then search the event queue for an existing
+				 * event of this type (if any), and free it.
+				 */
+				if (type == GR_EVENT_TYPE_MOUSE_POSITION) 
+					GsFreePositionEvent(client, wp->id, subwid);
 
-			ep = (GR_EVENT_MOUSE *) GsAllocEvent(client);
-			if (ep == NULL)
-				continue;
-
-			ep->type = type;
-			ep->wid = wp->id;
-			ep->subwid = subwid;
-			ep->rootx = cursorx;
-			ep->rooty = cursory;
-			ep->x = cursorx - wp->x;
-			ep->y = cursory - wp->y;
-			ep->buttons = buttons;
-			ep->modifiers = modifiers;
-		}
+				ep = (GR_EVENT_MOUSE *) GsAllocEvent(client);
+				if (ep == NULL)
+					continue;
 
-		if ((wp == rootwp) || grabbuttonwp ||
-			(wp->nopropmask & eventmask))
-				return;
+				ep->type = type;
+				ep->wid = wp->id;
+				ep->subwid = subwid;
+				ep->rootx = cursorx;
+				ep->rooty = cursory;
+				ep->x = cursorx - wp->x;
+				ep->y = cursory - wp->y;
+				ep->buttons = buttons;
+				ep->modifiers = modifiers;
+			}
+
+			if ((wp == rootwp) || grabbuttonwp ||
+				(wp->nopropmask & eventmask))
+					return;
 
-		wp = wp->parent;
+			wp = wp->parent;
+		}
 	}
 }
 
@@ -595,20 +601,23 @@
 		} else
 			kwp = focuswp;
 		wp = mousewp;
-		subwid = wp->id;
-
-		/*
-		 * See if the actual window the pointer is in is a descendant of
-		 * the focus window.  If not, then ignore it, and force the input
-		 * into the focus window itself.
-		 */
-		tempwp = wp;
-		while (tempwp != kwp && tempwp != rootwp)
-			tempwp = tempwp->parent;
-
-		if (tempwp != kwp) {
-			wp = kwp;
+		if (wp)
+		{
 			subwid = wp->id;
+
+			/*
+			 * See if the actual window the pointer is in is a descendant of
+			 * the focus window.  If not, then ignore it, and force the input
+			 * into the focus window itself.
+			 */
+			tempwp = wp;
+			while (tempwp != kwp && tempwp != rootwp)
+				tempwp = tempwp->parent;
+
+			if (tempwp != kwp) {
+				wp = kwp;
+				subwid = wp->id;
+			}
 		}
 	}
 
@@ -617,7 +626,7 @@
 	 * the keyboard event.  However, do not go beyond the focus window,
 	 * and only give the event to one client.
 	 */
-	for (;;) {
+	while (wp) {
 		for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
 
 			if ((ecp->eventmask & eventmask) == 0)
diff -urN microwin/src\nanox\srvfunc.c microwin-0.90/src\nanox\srvfunc.c
--- microwin/src\nanox\srvfunc.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\srvfunc.c	Wed Aug 25 14:59:08 2010
@@ -899,7 +899,7 @@
 		return;
 	}
 
-/*printf("grreparent: pid %d wid %d (oldpid %d) realized %d,%d\n", pwid, wid, wp->parent->id, pwp->realized, wp->realized);*/
+/*DPRINTF("grreparent: pid %d wid %d (oldpid %d) realized %d,%d\n", pwid, wid, wp->parent->id, pwp->realized, wp->realized);*/
 	x += pwp->x;
 	y += pwp->y;
 	offx = x - wp->x;
@@ -2961,7 +2961,7 @@
 	SERVER_UNLOCK();
 }
 
-#if MW_FEATURE_IMAGES && defined(HAVE_FILEIO)
+#if MW_FEATURE_IMAGES && HAVE_FILEIO
 /* Load an image file from disk and display it at the specified coordinates*/
 void
 GrDrawImageFromFile(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
@@ -3019,7 +3019,7 @@
 /* Draw an image from a buffer */
 void
 GrDrawImageFromBuffer(GR_DRAW_ID id, GR_GC_ID gc, GR_COORD x, GR_COORD y,
-	GR_SIZE width, GR_SIZE height, void *buffer, int size, int flags)
+	GR_SIZE width, GR_SIZE height, const void *buffer, int size, int flags)
 {
 	GR_DRAWABLE	*dp;
 
@@ -3038,7 +3038,7 @@
 
 /* load image from the given buffer and cache it*/
 GR_IMAGE_ID
-GrLoadImageFromBuffer(void *buffer, int size, int flags)
+GrLoadImageFromBuffer(const void *buffer, int size, int flags)
 {
 	GR_IMAGE_ID	id;
 	GR_IMAGE *	imagep;
@@ -3255,7 +3255,7 @@
 		 * exposure event instead for proper display.
 		 */
 		if (GdRectInRegion(clipregion, &rc) != MWRECT_ALLIN) {
-EPRINTF("nano-X: skipping blit, sending expose event\n");
+DPRINTF("nano-X: skipping blit, sending expose event\n");
 			GsDeliverExposureEvent(swp, dp->x+x, dp->y+y,
 				width, height);
 			SERVER_UNLOCK();
diff -urN microwin/src\nanox\srvmain.c microwin-0.90/src\nanox\srvmain.c
--- microwin/src\nanox\srvmain.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\srvmain.c	Wed Aug 25 14:59:08 2010
@@ -5,6 +5,7 @@
  *
  * Main module of graphics server.
  */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <signal.h>
@@ -128,7 +129,7 @@
 static void
 usage(void)
 {
-	printf("Usage: %s [-e] [-p] [-A] [-NLRD] [-x #] [-y #]"
+	DPRINTF("Usage: %s [-e] [-p] [-A] [-NLRD] [-x #] [-y #]"
 #if FONTMAPPER
 		" [-c <fontconfig-file>"
 #endif
@@ -331,7 +332,7 @@
 GsClose(int fd)
 {
 	GsDropClient(fd);
-	if(!persistent_mode && connectcount == 0)
+	if(!persistent_mode && connectcount <= 0)
 		GsTerminate();
 }
 
@@ -435,106 +436,12 @@
 #endif
 
 
-#if WIN32
-static void
-HandleKeyMessage(MSG *msg, GR_EVENT_TYPE keyType)
-{
-	int keystatus = -1;
-	MWKEY mwkey = msg->wParam; // virtual-key code
-	MWKEYMOD modifiers = 0;
-	unsigned char scanCode;
-	int repeat, extended, context, previous;
-
-	repeat = msg->lParam & 0xffff;
-	scanCode = (msg->lParam >> 16) & 0xff;
-	previous = msg->lParam & 0x40000000L;
-	context = msg->lParam & 0x20000000L;
-	extended = msg->lParam & 0x1000000L;
-	if (extended) {
-	}
-	GsDeliverKeyboardEvent(0, keyType, mwkey, modifiers, scanCode);
-}
-
-extern HWND winRootWindow;
-extern MSG *winMouseMsg;
-
-void
-GsSelect(GR_TIMEOUT timeout)
-{
-	MSG msg;
-	int mouseevents = 0;
-	int keybdevents = 0;
-	GR_EVENT_GENERAL *gp;
-
-	if (winRootWindow == NULL)
-		goto err_exit;
-
-	if (timeout == 0) {
-		if (!PeekMessage(&msg, winRootWindow, 0, 0, PM_REMOVE)) {
-			Sleep(20);
-			return;
-		}
-	} else if (timeout == -1) {
-		if (GetMessage(&msg, winRootWindow, 0, 0) < 0)
-			goto err_exit;
-	} else {
-		while (1) {
-			if (PeekMessage(&msg, winRootWindow, 0, 0, PM_REMOVE))
-				break;
-			Sleep(20);
-			if (timeout < 20) {
-				/* Timeout has occured.
-				** Currently return a timeout event regardless of whether client
-				** has selected for it.
-				*/
-				if ((gp = (GR_EVENT_GENERAL *)GsAllocEvent(curclient)) != NULL)
-					gp->type = GR_EVENT_TYPE_TIMEOUT;
-				return;
-			}
-			timeout -= 20;
-		}
-	}
-
-	switch (msg.message) {
-	case WM_KEYDOWN:
-	case WM_SYSKEYDOWN:
-		HandleKeyMessage(&msg, GR_EVENT_TYPE_KEY_DOWN);
-		break;
-	case WM_KEYUP:
-	case WM_SYSKEYUP:
-		HandleKeyMessage(&msg, GR_EVENT_TYPE_KEY_UP);
-		break;
-	case WM_MOUSEMOVE:
-	case WM_LBUTTONDOWN:
-	case WM_LBUTTONUP:
-	case WM_LBUTTONDBLCLK:
-	case WM_MBUTTONDOWN:
-	case WM_MBUTTONUP:
-	case WM_MBUTTONDBLCLK:
-	case WM_RBUTTONDOWN:
-	case WM_RBUTTONUP:
-	case WM_RBUTTONDBLCLK:
-		winMouseMsg = &msg;
-		GsCheckMouseEvent();
-		winMouseMsg = NULL;
-		break;
-	}
-
-	TranslateMessage(&msg);
-	DispatchMessage(&msg);
-	return;
-
-err_exit:
-	GsTerminate();
-}
-#elif VXWORKS
+#if defined(VXWORKS) || defined(WIN32) || defined(EMBEDDED)
 
 #define POLLTIME	100   /* polling sleep interval (in msec) */
 #define MAX_MOUSEEVENTS	10    /* max number of mouse event to get in 1 select */
 #define MAX_KEYBDEVENTS	10    /* max number of mouse event to get in 1 select */
 
-extern void GdSleep(int dwMilliseconds);
-
 void 
 GsSelect(GR_TIMEOUT timeout)
 {
@@ -927,7 +834,7 @@
 #endif /* NONETWORK */
 	} else
 		if(errno != EINTR)
-			EPRINTF("Select() call in main failed\n");
+			DPRINTF("Select() call in main failed\n");
 }
 
 #if NONETWORK
@@ -1110,7 +1017,7 @@
 	/* return if timed-out or something went wrong */
 	if (rc < 0) {
 	        if (errno != ETIMEDOUT)
-		        EPRINTF (" rc= %d, errno=%d\n", rc, errno);
+		        DPRINTF (" rc= %d, errno=%d\n", rc, errno);
 		else {
 		        /* timeout handling */
 #if MW_FEATURE_TIMERS
@@ -1160,7 +1067,9 @@
 	GdAddTimer(50, CheckVtChange, NULL);
 }
 #endif
-  
+
+static GR_WINDOW svrMainWindow;
+
 /*
  * Initialize the graphics and mouse devices at startup.
  * Returns nonzero with a message printed if the initialization failed.
@@ -1187,14 +1096,12 @@
 	/* If needed, initialize the server mutex. */
 	SERVER_LOCK_INIT();
 
+#if HAVE_FILEIO
 	setbuf(stdout, NULL);
 	setbuf(stderr, NULL);
+#endif
 
-	wp = (GR_WINDOW *) malloc(sizeof(GR_WINDOW));
-	if (wp == NULL) {
-		EPRINTF("Cannot allocate root window\n");
-		return -1;
-	}
+	wp = &svrMainWindow;
 
 	startTicks = GsGetTickCount();
 
@@ -1219,53 +1126,47 @@
 #endif
 
 	if (GsOpenSocket() < 0) {
-		EPRINTF("Cannot bind to named socket\n");
-		free(wp);
+		DPRINTF("Cannot bind to named socket\n");
 		return -1;
 	}
 #endif
 
 	if ((keyb_fd = GdOpenKeyboard()) == -1) {
-		EPRINTF("Cannot initialise keyboard\n");
+		DPRINTF("Cannot initialise keyboard\n");
 		/*GsCloseSocket();*/
-		free(wp);
 		return -1;
 	}
 
 #ifdef MW_FEATURE_TWO_KEYBOARDS
 	if ((keyb2_fd = GdOpenKeyboard2()) == -1) {
-		EPRINTF("Cannot initialise second keyboard\n");
+		DPRINTF("Cannot initialise second keyboard\n");
 		/*GsCloseSocket();*/
-		free(wp);
 		return -1;
 	}
 #endif
 
 	if ((psd = GdOpenScreen()) == NULL) {
-		EPRINTF("Cannot initialise screen\n");
+		DPRINTF("Cannot initialise screen\n");
 		/*GsCloseSocket();*/
 		GdCloseKeyboard();
-		free(wp);
 		return -1;
 	}
 	GdSetPortraitMode(psd, portraitmode);
 
 	if ((mouse_fd = GdOpenMouse()) == -1) {
-		EPRINTF("Cannot initialise mouse\n");
+		DPRINTF("Cannot initialise mouse\n");
 		/*GsCloseSocket();*/
 		GdCloseScreen(psd);
 		GdCloseKeyboard();
-		free(wp);
 		return -1;
 	}
 
 #if HAVE_VNCSERVER
         if (!GdOpenVNC(psd, Argc, Argv)) {
-                EPRINTF("Cannot open VNC Socket\n");
+                DPRINTF("Cannot open VNC Socket\n");
                 GdCloseMouse();
                 GdCloseScreen(psd);
                 GdCloseKeyboard();
-                free(wp);
                 return -1;
         }
 #endif        
@@ -1374,7 +1275,8 @@
 	GdCloseVNC();
 #endif
 
-	GdCloseScreen(rootwp->psd);
+	if (rootwp)
+		GdCloseScreen(rootwp->psd);
 	GdCloseMouse();
 	GdCloseKeyboard();
 #if VTSWITCH
@@ -1415,7 +1317,7 @@
 GrBell(void)
 {
 	SERVER_LOCK();
-#if !PSP
+#if !PSP && HAVE_FILEIO
 	write(2, "\7", 1);
 #endif
 	SERVER_UNLOCK();
diff -urN microwin/src\nanox\srvnet.c microwin-0.90/src\nanox\srvnet.c
--- microwin/src\nanox\srvnet.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\srvnet.c	Wed Aug 25 14:59:08 2010
@@ -57,7 +57,7 @@
 static void
 GrNotImplementedWrapper(void *r)
 {
-    EPRINTF("nano-X: Function %s() not implemented\n", curfunc);
+    DPRINTF("nano-X: Function %s() not implemented\n", curfunc);
 }
 #endif
 
@@ -1758,7 +1758,7 @@
 
 	if ( current_shm_cmds == 0 || current_shm_cmds_size < req->size ) {
 		/* No or short shm present serverside, bug or mischief */
-		EPRINTF("nano-X: Ill behaved client assumes shm ok\n");
+		DPRINTF("nano-X: Ill behaved client assumes shm ok\n");
 		if ( req->reply ) {
 			reply = 0;
 			GsWrite(current_fd, &reply, 1);
@@ -1775,7 +1775,7 @@
 		if ( pr->reqType < GrTotalNumCalls ) {
 			GrFunctions[pr->reqType].func(pr);
 		} else {
-			EPRINTF("nano-X: Error bad shm function!\n");
+			DPRINTF("nano-X: Error bad shm function!\n");
 		}
 		do_req += length;
 	}
@@ -1885,7 +1885,7 @@
 	socklen_t size = sizeof(sckt);
 
 	if((i = accept(un_sock, (struct sockaddr *) &sckt, &size)) == -1) {
-		EPRINTF("nano-X: Error accept failed (%d)\n", errno);
+		DPRINTF("nano-X: Error accept failed (%d)\n", errno);
 		return;
 	}
 	GsAcceptClientFd(i);
@@ -2138,7 +2138,7 @@
 
 		clipwp = NULL;	/* reset clip window*/
 		--connectcount;
-	} else EPRINTF("nano-X: trying to drop non-existent client %d.\n", fd);
+	} else DPRINTF("nano-X: trying to drop non-existent client %d.\n", fd);
 }
 
 /*
@@ -2160,8 +2160,8 @@
 		e = read(fd, ((char *)buf) + n, c - n);
 		if(e <= 0) {
 			if (e == 0)
-				EPRINTF("nano-X: client closed socket: %d\n", fd);
-			else EPRINTF("nano-X: GsRead failed %d %d: %d\r\n",
+				DPRINTF("nano-X: client closed socket: %d\n", fd);
+			else DPRINTF("nano-X: GsRead failed %d %d: %d\r\n",
 			       e, n, errno);
 			GsClose(fd);
 			return -1;
@@ -2222,7 +2222,7 @@
 	len = GetReqAlignedLen((nxReq *)&buf[0]);
 	if(len > sizeof(nxReq)) {
 		if(len > MAXREQUESTSZ) {
-			EPRINTF("nano-X: GsHandleClient request too large: %ld > %d\n",
+			DPRINTF("nano-X: GsHandleClient request too large: %ld > %d\n",
 				len, MAXREQUESTSZ);
 			exit(1);
 		}
@@ -2237,6 +2237,6 @@
 		/*DPRINTF("HandleClient %s\n", curfunc);*/
 		GrFunctions[req->reqType].func(req);
 	} else {
-		EPRINTF("nano-X: GsHandleClient bad function\n");
+		DPRINTF("nano-X: GsHandleClient bad function\n");
 	}
 }
diff -urN microwin/src\nanox\srvutil.c microwin-0.90/src\nanox\srvutil.c
--- microwin/src\nanox\srvutil.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\srvutil.c	Wed Aug 25 14:59:08 2010
@@ -163,7 +163,7 @@
 		GsError(GR_ERROR_ILLEGAL_ON_ROOT_WINDOW, wp->id);
 		return;
 	}
-/*printf("RealizeWindow %d, map %d realized %d, parent_realized %d\n",
+/*DPRINTF("RealizeWindow %d, map %d realized %d, parent_realized %d\n",
 wp->id, wp->mapped, wp->realized, wp->parent->realized);*/
 
 #define OLDWAY 0
@@ -1186,9 +1186,12 @@
 	/*
 	 * It needs redefining, so do it.
 	 */
-	curcursor = cp;
-	GdMoveCursor(cursorx - cp->cursor.hotx, cursory - cp->cursor.hoty);
-	GdSetCursor(&cp->cursor);
+	if (cp)
+	{
+		curcursor = cp;
+		GdMoveCursor(cursorx - cp->cursor.hotx, cursory - cp->cursor.hoty);
+		GdSetCursor(&cp->cursor);
+	}
 }
 
 /*
@@ -1207,13 +1210,15 @@
 	if (!oldwp)
 		oldwp = mousewp;
 
-	newwp = GsFindVisibleWindow(cursorx, cursory);
-	if (oldwp != newwp) {
-		GsDeliverGeneralEvent(oldwp, GR_EVENT_TYPE_MOUSE_EXIT, NULL);
-		GsDeliverGeneralEvent(newwp, GR_EVENT_TYPE_MOUSE_ENTER, NULL);
+	newwp = GsFindVisibleWindow(cursorx, cursory);\
+	if (newwp)
+	{
+		if (oldwp != newwp) {
+			GsDeliverGeneralEvent(oldwp, GR_EVENT_TYPE_MOUSE_EXIT, NULL);
+			GsDeliverGeneralEvent(newwp, GR_EVENT_TYPE_MOUSE_ENTER, NULL);
+		}
+		mousewp = newwp;
 	}
-
-	mousewp = newwp;
 #endif
 #if 0
 	GR_WINDOW	*wp;		/* newest window for mouse */
@@ -1252,7 +1257,7 @@
 	 * Walk upwards from the current window containing the mouse
 	 * looking for the first window which would accept a keyboard event.
 	 */
-	for (wp = mousewp; ;wp = wp->parent) {
+	for (wp = mousewp; wp != NULL; wp = wp->parent) {
 		if (wp->props & GR_WM_PROPS_NOFOCUS)
 			continue;
 		for (ecp = wp->eventclients; ecp; ecp = ecp->next) {
@@ -1290,7 +1295,7 @@
 {
 	GR_WINDOW	*oldfocus;
 
-	if (wp == focuswp)
+	if (wp == focuswp || wp == NULL)
 		return;
 
 	GsDeliverGeneralEvent(focuswp, GR_EVENT_TYPE_FOCUS_OUT, wp);
diff -urN microwin/src\nanox\wmaction.c microwin-0.90/src\nanox\wmaction.c
--- microwin/src\nanox\wmaction.c	Thu Aug 26 19:42:10 2010
+++ microwin-0.90/src\nanox\wmaction.c	Wed Aug 25 14:59:08 2010
@@ -19,7 +19,7 @@
 	GR_WM_PROPERTIES props;
 	GR_BOOL active;
 
-	Dprintf("wm_container_exposure window %d\n", window->wid);
+	DPRINTF("wm_container_exposure window %d\n", window->wid);
 
 	GrGetWindowInfo(window->wid, &info);
 	GrGetWMProperties(window->clientid, &props);
@@ -42,7 +42,7 @@
 
 void wm_container_exposure(win *window, GR_EVENT_EXPOSURE *event)
 {
-	Dprintf("wm_container_exposure window %d\n", window->wid);
+	DPRINTF("wm_container_exposure window %d\n", window->wid);
 
 	wm_redraw_ncarea(window);
 }
@@ -62,7 +62,7 @@
 	GR_WINDOW_INFO	info;
 	GR_WINDOW_INFO	cinfo;
 	GR_GC_ID        gc;
-	Dprintf("wm_container_buttondown window %d\n", window->wid);
+	DPRINTF("wm_container_buttondown window %d\n", window->wid);
 
 	if(window->active)
 		return;
@@ -192,7 +192,7 @@
 	GR_COORD	cxborder = 0, cyborder = 0;
 	GR_WINDOW_INFO	info;
 
-	Dprintf("wm_container_buttonup window %d\n", window->wid);
+	DPRINTF("wm_container_buttonup window %d\n", window->wid);
 
 	GrGetWindowInfo(window->wid, &info);
 
@@ -273,7 +273,7 @@
 	GR_RECT r;
 	GR_WINDOW_INFO info;
 
-	Dprintf("wm_container_mousemoved window %d\n", window->wid);
+	DPRINTF("wm_container_mousemoved window %d\n", window->wid);
 
 	GrGetWindowInfo(window->wid, &info);
 
@@ -422,7 +422,7 @@
 	struct clientinfo *ci = pwin->data;
 	GR_WM_PROPERTIES prop;
 
-	Dprintf("topbar_exposure window %d\n", window->wid);
+	DPRINTF("topbar_exposure window %d\n", window->wid);
 
 	GrGetWMProperties(ci->cid, &prop);
 	if (prop.title) {
@@ -433,7 +433,7 @@
 
 void closebutton_exposure(win *window, GR_EVENT_EXPOSURE *event)
 {
-	Dprintf("closebutton_exposure window %d\n", window->wid);
+	DPRINTF("closebutton_exposure window %d\n", window->wid);
 
 	GrBitmap(window->wid, buttonsgc, 0, 0, TITLE_BAR_HEIGHT, TITLE_BAR_HEIGHT,
 		window->active ? closebutton_pressed : closebutton_notpressed);
@@ -443,7 +443,7 @@
 {
 	struct position *pos;
 
-	Dprintf("topbar_buttondown window %d\n", window->wid);
+	DPRINTF("topbar_buttondown window %d\n", window->wid);
 
 	GrRaiseWindow(window->pid);
 
@@ -466,7 +466,7 @@
 	GR_WINDOW_INFO wi;
 	struct pos_size *pos;
 
-	Dprintf("resizebar_buttondown window %d\n", window->wid);
+	DPRINTF("resizebar_buttondown window %d\n", window->wid);
 
 	GrRaiseWindow(window->pid);
 
@@ -491,7 +491,7 @@
 
 void closebutton_buttondown(win *window, GR_EVENT_BUTTON *event)
 {
-	Dprintf("closebutton_buttondown window %d\n", window->wid);
+	DPRINTF("closebutton_buttondown window %d\n", window->wid);
 
 	GrRaiseWindow(window->pid);
 
@@ -502,7 +502,7 @@
 
 void topbar_buttonup(win *window, GR_EVENT_BUTTON *event)
 {
-	Dprintf("topbar_buttonup window %d\n", window->wid);
+	DPRINTF("topbar_buttonup window %d\n", window->wid);
 
 	window->active = GR_FALSE;
 }
@@ -512,7 +512,7 @@
 	win *pwin = wm_find_window(window->pid);
 	struct clientinfo *ci = pwin->data;
 
-	Dprintf("closebutton_buttonup window %d\n", window->wid);
+	DPRINTF("closebutton_buttonup window %d\n", window->wid);
 
 	window->active = GR_FALSE;
 	closebutton_exposure(window, NULL);
@@ -524,7 +524,7 @@
 	struct position *pos;
 	GR_WM_PROPERTIES props;
 
-	Dprintf("topbar_mousemoved window %d\n", window->wid);
+	DPRINTF("topbar_mousemoved window %d\n", window->wid);
 
 	if(!window->active)
 		return;
@@ -552,7 +552,7 @@
 	GR_SIZE newwidth;
 	struct pos_size *pos;
 
-	Dprintf("leftbar_mousemoved window %d\n", window->wid);
+	DPRINTF("leftbar_mousemoved window %d\n", window->wid);
 
 	if(!window->active)
 		return;
@@ -571,7 +571,7 @@
 	GR_SIZE newwidth, newheight;
 	struct pos_size *pos;
 
-	Dprintf("leftresize_mousemoved window %d\n", window->wid);
+	DPRINTF("leftresize_mousemoved window %d\n", window->wid);
 
 	if(!window->active) return;
 
@@ -590,7 +590,7 @@
 	GR_SIZE newheight;
 	struct pos_size *pos;
 
-	Dprintf("bottombar_mousemoved window %d\n", window->wid);
+	DPRINTF("bottombar_mousemoved window %d\n", window->wid);
 
 	if(!window->active)
 		return;
@@ -605,7 +605,7 @@
 	GR_SIZE newwidth, newheight;
 	struct pos_size *pos;
 
-	Dprintf("rightresize_mousemoved window %d\n", window->wid);
+	DPRINTF("rightresize_mousemoved window %d\n", window->wid);
 
 	if(!window->active)
 		return;
@@ -621,7 +621,7 @@
 	GR_SIZE newwidth;
 	struct pos_size *pos;
 
-	Dprintf("rightbar_mousemoved window %d\n", window->wid);
+	DPRINTF("rightbar_mousemoved window %d\n", window->wid);
 
 	if(!window->active)
 		return;
diff -urN microwin/src\nanox.bkl microwin-0.90/src\nanox.bkl
--- microwin/src\nanox.bkl	Wed Dec 31 16:00:00 1969
+++ microwin-0.90/src\nanox.bkl	Mon Aug 30 12:36:18 2010
@@ -0,0 +1,208 @@
+<?xml version="1.0"?>
+<!-- Master bakefile for nano-X -->
+<makefile>
+  <requires version="0.2.8"/>
+  <include file="presets/simple.bkl"/>
+
+  <if cond="PLATFORM_UNIX=='1'">
+    <set var="EXEEXT" overwrite="1">.elf</set>
+  </if>
+
+  <set var="EMBEDFLAG">
+    <if cond="PLATFORM_WIN32=='1'"></if>
+    <if cond="PLATFORM_WIN32=='0'">EMBEDDED</if>
+  </set>
+
+  <set var="FLOATFLAG">
+    HAVEFLOAT=0
+  </set>
+  
+  /* Bduild Advanced Samples (only on sophisticated platforms) */    
+  <set var="ADVANCED">
+    <if cond="PLATFORM_WIN32=='1'">1</if>
+  </set>
+    
+	<!-- Make nano-X tools -->
+  <set var="BUILDDIR">bin</set>
+
+  <if cond="ADVANCED=='1'">
+    <exe id="convbdf" template="simple">
+      <app-type>console</app-type>
+      <sources>fonts/convbdf.c</sources>
+    </exe>
+      
+    <set var="CONVBDF">..$(DIRSEP)bin$(DIRSEP)convbdf.exe</set>
+    
+    <action id="fonts$(DIRSEP)X6x13.c">
+      <command>
+        cd fonts
+        $(CONVBDF) -c X6x13.bdf
+        cd ..
+      </command>
+      <clean-files>
+        $(RM) fonts$(DIRSEP)X6x13.c
+      </clean-files>
+      <depends>convbdf</depends>
+    </action>
+  </if>
+
+	<!-- Make nano-X drivers & library -->
+  <set var="BUILDDIR">lib</set>
+	
+	<lib id="nxbase" template="simple">
+	  <include>include</include>
+    <define>$(EMBEDFLAG)</define>
+    <define>$(FLOATFLAG)</define>
+    <define>GENMEM_LINEAR8</define>
+    <define>MW_NOSIGNALS=1</define>
+	  <define>SCREEN_WIDTH=640</define>
+	  <define>SCREEN_HEIGHT=512</define>
+	  <define>MWPIXEL_FORMAT=MWPF_PALETTE</define>
+	  <define>MW_FEATURE_IMAGES=1</define>
+	  <define>MW_FEATURE_TIMERS=1</define>
+	  <define>HAVE_GIF_SUPPORT=1</define>
+	  <define>HAVE_BMP_SUPPORT=1</define>
+    <define>MW_FEATURE_GDERROR</define>
+	  <sources>
+	    drivers/fb.c
+	    drivers/fblin1.c
+	    drivers/fblin2.c
+	    drivers/fblin4.c
+	    drivers/fblin8.c
+	    drivers/fblin16.c
+	    drivers/fblin24.c
+	    drivers/fblin32.c
+	    drivers/fblin32alpha.c
+	    drivers/fbportrait_down.c
+	    drivers/fbportrait_left.c
+	    drivers/fbportrait_right.c
+	    drivers/genfont.c
+	    drivers/genmem.c
+      drivers/hbf.c
+	    engine/convblit_8888.c
+	    engine/convblit_mask.c
+	    engine/devarc.c
+	    engine/devblit.c
+	    engine/devclip.c
+	    engine/devdraw.c
+  		engine/devfont.c
+  		engine/devimage.c
+  		engine/devimage_stretch.c
+  		engine/devkbd.c
+  		engine/devlist.c
+  		engine/devmouse.c
+  		engine/devopen.c 
+  		engine/devpal1.c
+  		engine/devpal2.c
+  		engine/devpal4.c
+  		engine/devpal8.c
+  		engine/devpoly.c
+  		engine/devrgn.c
+  		engine/devrgn2.c
+  		engine/devstipple.c
+  		engine/devtimer.c
+	    engine/error.c
+  		engine/font_dbcs.c
+    	engine/font_fnt.c
+    	engine/font_pcf.c
+    	engine/font_hzk.c
+  		engine/image_bmp.c
+  		engine/image_gif.c
+  		engine/image_jpeg.c
+  		engine/image_png.c
+  		engine/image_pnm.c
+  		engine/image_tiff.c
+  		engine/image_xpm.c
+  		engine/selfont.c
+	    fonts/X6x13.c
+	    fonts/winFreeSansSerif11x13.c
+	    fonts/winFreeSystem14x16.c
+	    drivers/kbd_win32.c
+	    drivers/mou_win32.c
+	    drivers/scr_fb8.c
+  		drivers/osglue.c
+	  </sources>
+	</lib>
+	
+	<lib id="nanox" template="simple">
+	  <include>include</include>
+    <define>$(EMBEDFLAG)</define>
+    <define>$(FLOATFLAG)</define>
+    <define>GENMEM_LINEAR8</define>
+    <define>NONETWORK=1</define>
+    <define>NANOWM=1</define>
+    <define>MW_NOSIGNALS=1</define>
+	  <define>SCREEN_WIDTH=640</define>
+	  <define>SCREEN_HEIGHT=512</define>
+	  <define>MWPIXEL_FORMAT=MWPF_PALETTE</define>
+	  <define>MW_FEATURE_IMAGES=1</define>
+	  <define>MW_FEATURE_TIMERS=1</define>
+	  <define>HAVE_GIF_SUPPORT=1</define>
+	  <define>HAVE_BMP_SUPPORT=1</define>
+	  <sources>
+	    nanox/clientfb.c
+	    nanox/error.c
+	    nanox/nxdraw.c
+	    nanox/nxproto.c
+	    nanox/nxtransform.c
+  		nanox/nxutil.c
+  		nanox/srvclip.c
+  		nanox/srvevent.c
+  		nanox/srvutil.c
+  		nanox/srvfunc.c
+  		nanox/srvmain.c
+  		nanox/wmaction.c
+  		nanox/wmclients.c
+  		nanox/wmevents.c
+  		nanox/wmutil.c
+	  </sources>
+	</lib>
+	
+	<!-- Make Microwindows API library -->
+	<lib id="mwin" template="simple">
+	  <include>include</include>
+	  <include>mwin/include</include>
+    <define>$(EMBEDFLAG)</define>
+    <define>$(FLOATFLAG)</define>
+    <define>NONETWORK=1</define>
+    <define>MW_NOSIGNALS=1</define>
+	  <sources>
+	    mwin/winclip.c
+	    mwin/windefw.c
+	    mwin/winevent.c
+	    mwin/winexpos.c
+	    mwin/winfont.c
+	    mwin/wingdi.c
+  		mwin/winmain.c
+  		mwin/winres.c
+  		mwin/winsbar.c
+  		mwin/winuser.c
+  		mwin/winlib/button.c
+  		mwin/winlib/caret.c
+  		mwin/winlib/combobox.c
+  		mwin/winlib/draw3d.c
+  		mwin/winlib/edit.c
+  		mwin/winlib/fastfill.c
+  		mwin/winlib/graph3d.c
+  		mwin/winlib/insetr.c 
+  		mwin/winlib/medit.c
+  		mwin/winlib/mwuser.c
+  		mwin/winlib/newedit.c 
+  		mwin/winlib/newlistbox.c
+  		mwin/winlib/progbar.c
+  		mwin/winlib/ptinsid.c
+  		mwin/winlib/scrlbar.c 
+  		mwin/winlib/static.c
+  		mwin/winlib/windlg.c	  
+      mwin/winresbmp.c
+	  </sources>
+	</lib>
+	
+  
+	<!-- Make Nano-X and Microwindows demos -->
+  <subproject id="demos">
+    <dir>demos</dir>
+    <installable>no</installable>
+  </subproject>
+    
+</makefile>
