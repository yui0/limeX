diff -Nuarp nxlib-0.47dev.orig/ChProperty.c nxlib-0.47dev/ChProperty.c
--- nxlib-0.47dev.orig/ChProperty.c	2011-02-20 05:43:38.000000000 +0900
+++ nxlib-0.47dev/ChProperty.c	2013-02-25 15:11:07.000000000 +0900
@@ -34,6 +34,7 @@ XChangeProperty(Display * display, Windo
 	if(!nelements || data == NULL)
 		return 1;
 
+	printf("XChangeProperty called [Atom:%x,m:%x,d:%x]\n", type, mode, *data);
 	win = window_list[hash];
 	if (!win) {
 		win = window_list[hash] =
@@ -79,13 +80,14 @@ XChangeProperty(Display * display, Windo
 	}
 
 	switch (mode) {
-	case PropModeAppend:
-	case PropModePrepend:
+	case PropModeAppend:	// 2
+	case PropModePrepend:	// 1
 		if (prop->data) {
 			int f8 = prop->format / 8;
 			char *p;
 			int bytes;
 
+			//printf("XChangeProperty: %d,%d\n", format, bytes);
 			if (type != prop->type || format != prop->format)
 				return 0;
 
@@ -111,13 +113,17 @@ XChangeProperty(Display * display, Windo
 		}
 		/* Fall through */
 
-	case PropModeReplace:
-		if (prop->data)
-			Xfree(prop->data);
+	case PropModeReplace:	// 0
+		if (prop->data) Xfree(prop->data);
+		if (format<0 || format/8 > 4) {
+			printf("XChangeProperty: format[%d]\n", format);
+			format = 8;
+		}
 		prop->bytes = nelements * (format / 8);
 		prop->data = (unsigned char *) Xmalloc(prop->bytes+1); /* +1 for string '\0'*/
 		prop->data[prop->bytes] = '\0';
 
+		//printf("XChangeProperty: [%x,%d,%x]\n", prop,nelements,prop->bytes);
 		memcpy(prop->data, data, prop->bytes);
 
 		prop->property = property;
diff -Nuarp nxlib-0.47dev.orig/ChSaveSet.c nxlib-0.47dev/ChSaveSet.c
--- nxlib-0.47dev.orig/ChSaveSet.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/ChSaveSet.c	2013-02-25 14:49:23.000000000 +0900
@@ -0,0 +1,22 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// required for rasp
+int XChangeSaveSet(Display *dpy, Window win, int mode)
+{
+	printf("XChangeSaveSet called...\n");
+	return 1;
+}
+
+int XAddToSaveSet(Display *dpy, Window win)
+{
+	return XChangeSaveSet(dpy, win, SetModeInsert);
+}
+
+int XRemoveFromSaveSet(Display *dpy, Window win)
+{
+	return XChangeSaveSet(dpy, win, SetModeDelete);
+}
diff -Nuarp nxlib-0.47dev.orig/ChWindow.c nxlib-0.47dev/ChWindow.c
--- nxlib-0.47dev.orig/ChWindow.c	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/ChWindow.c	2013-02-25 15:09:02.000000000 +0900
@@ -1,3 +1,7 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
 #include "nxlib.h"
 
 int
@@ -6,3 +10,36 @@ XResizeWindow(Display *dpy, Window w, un
 	GrResizeWindow(w, width, height);
 	return 1;
 }
+
+//#define AllMaskBits (CWX|CWY|CWWidth|CWHeight|\
+//		     CWBorderWidth|CWSibling|CWStackMode)
+int XConfigureWindow(Display *dpy, Window w, unsigned int mask, XWindowChanges *changes)
+{
+	GR_WINDOW_INFO wp;
+	GrGetWindowInfo(w, &wp);
+
+	printf("XConfigureWindow called...");
+	//mask &= AllMaskBits;
+	if (mask & (CWX|CWY)) {
+		printf(" XY(%d,%d)", mask&CWX? changes->x: wp.x, mask&CWY? changes->y: wp.y);
+		GrMoveWindow(w, mask&CWX? changes->x: wp.x, mask&CWY? changes->y: wp.y);
+	}
+	if (mask & (CWWidth|CWHeight)) {
+		printf(" WH(%d,%d)", mask&CWWidth? changes->width: wp.width, mask&CWHeight? changes->height: wp.height);
+		GrResizeWindow(w, mask&CWWidth? changes->width: wp.width, mask&CWHeight? changes->height: wp.height);
+	}
+	if (mask & CWBorderWidth) {
+		printf(" BW(%d)", changes->border_width);
+		XSetWindowBorderWidth(dpy, w, changes->border_width);
+	}
+
+	if (mask & CWSibling) {
+		printf(" Sib(%d)", changes->sibling);
+	}
+	if (mask & CWStackMode) {
+		printf(" Stc(%d)", changes->stack_mode);
+	}
+	printf("\n");
+
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/ClassHint.c nxlib-0.47dev/ClassHint.c
--- nxlib-0.47dev.orig/ClassHint.c	2010-01-25 13:03:16.000000000 +0900
+++ nxlib-0.47dev/ClassHint.c	2013-02-25 15:35:20.000000000 +0900
@@ -1,9 +1,122 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
 #include "nxlib.h"
 #include "X11/Xutil.h"
+#include "X11/Xatom.h"
+#include <string.h>
 
-XClassHint *
-XAllocClassHint(void)
+XClassHint *XAllocClassHint(void)
 {
 	return (XClassHint *) Xcalloc(1, sizeof(XClassHint));
 }
 
+// required for xine
+Status XGetClassHint(Display *dpy, Window w, XClassHint *classhint)
+{
+	int len_name, len_class;
+
+	Atom actual_type;
+	int actual_format;
+	unsigned long nitems;
+	unsigned long leftover;
+	unsigned char *data = NULL;
+
+	printf("XGetClassHint called...\n");
+	if (XGetWindowProperty(dpy, w, XA_WM_CLASS, 0L, (long)BUFSIZ, False,
+		XA_STRING, &actual_type, &actual_format,
+			&nitems, &leftover, &data) != Success) return 0;
+
+	if ( (actual_type == XA_STRING) && (actual_format == 8) ) {
+		len_name = strlen((char *) data);
+		if (! (classhint->res_name = Xmalloc((unsigned)(len_name+1)))) {
+			Xfree((char *) data);
+			return 0;
+		}
+		strcpy(classhint->res_name, (char *) data);
+		if (len_name == nitems) len_name--;
+		len_class = strlen((char *) (data+len_name+1));
+		if (! (classhint->res_class = Xmalloc((unsigned)(len_class+1)))) {
+			Xfree(classhint->res_name);
+			classhint->res_name = (char *) NULL;
+			Xfree((char *) data);
+			return 0;
+		}
+		strcpy(classhint->res_class, (char *) (data+len_name+1));
+		Xfree( (char *) data);
+		return 1;
+	}
+	if (data) Xfree( (char *) data);
+	return 0;
+}
+
+// required for rasp
+Status XGetTransientForHint(Display *dpy, Window w, Window *propWindow)
+{
+	Atom actual_type;
+	int actual_format;
+	unsigned long nitems;
+	unsigned long leftover;
+	Window *data = NULL;
+
+	printf("XGetTransientForHint called..\n");
+	if (XGetWindowProperty(dpy, w, XA_WM_TRANSIENT_FOR, 0L, 1L, False,
+		XA_WINDOW, &actual_type, &actual_format,
+		&nitems, &leftover, (unsigned char **)&data) != Success) {
+		*propWindow = None;
+		return 0;
+	}
+	if ((actual_type==XA_WINDOW) && (actual_format==32) && (nitems != 0)) {
+		*propWindow = *data;
+		Xfree((char*)data);
+		return 1;
+	}
+
+	*propWindow = None;
+	if (data) Xfree((char*)data);
+	return 0;
+}
+
+// required for xloadimage
+#define safe_strlen(s) ((s) ? strlen(s) : 0)
+int XSetClassHint(Display *dpy, Window w, XClassHint *classhint)
+{
+	char *class_string;
+	char *s;
+	int len_nm, len_cl;
+
+	printf("XSetClassHint called..\n");
+	len_nm = safe_strlen(classhint->res_name);
+	len_cl = safe_strlen(classhint->res_class);
+	if ((class_string = s = Xmalloc((unsigned) (len_nm + len_cl + 2)))) {
+		if (len_nm) {
+			strcpy(s, classhint->res_name);
+			s += len_nm + 1;
+		} else {
+			*s++ = '\0';
+		}
+		if (len_cl) strcpy(s, classhint->res_class);
+		else *s = '\0';
+		XChangeProperty(dpy, w, XA_WM_CLASS, XA_STRING, 8,
+			PropModeReplace, (unsigned char *)class_string,
+			len_nm+len_cl+2);
+		Xfree(class_string);
+	}
+	return 1;
+}
+
+// old routine
+int XSetNormalHints(Display *dpy, Window w, XSizeHints *hints)
+{
+	printf("XSetNormalHints called...\n");
+	return 0;
+	//return XSetSizeHints(dpy, w, hints, XA_WM_NORMAL_HINTS);
+}
+
+int XSetTransientForHint(Display *dpy, Window w, Window propWindow)
+{
+	printf("XSetTransientForHint called..\n");
+	return XChangeProperty(dpy, w, XA_WM_TRANSIENT_FOR, XA_WINDOW, 32,
+		PropModeReplace, (unsigned char*)&propWindow, 1);
+}
diff -Nuarp nxlib-0.47dev.orig/Colormap.c nxlib-0.47dev/Colormap.c
--- nxlib-0.47dev.orig/Colormap.c	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/Colormap.c	2013-02-25 15:26:08.000000000 +0900
@@ -149,3 +149,17 @@ XFreeColormap(Display * display, Colorma
 #endif
 	return 1;
 }
+
+#include "X11/Xutil.h"
+// required for Qt
+Status XGetRGBColormaps(Display *display, Window w, XStandardColormap **std_colormap, int *count, Atom property)
+{
+	printf("XGetRGBColormaps called...\n");
+//	*std_colormap = _nxDefaultColormap(display);
+	return 0;
+}
+
+XStandardColormap *XAllocStandardColormap()
+{
+	return calloc(1, sizeof(XStandardColormap));
+}
diff -Nuarp nxlib-0.47dev.orig/Colorname.c nxlib-0.47dev/Colorname.c
--- nxlib-0.47dev.orig/Colorname.c	2010-12-10 04:03:09.000000000 +0900
+++ nxlib-0.47dev/Colorname.c	2013-02-25 15:07:10.000000000 +0900
@@ -82,7 +82,12 @@ XAllocNamedColor(Display * dpy, Colormap
 	int r = 0, g = 0, b = 0;
 
 	/* first look up color in rgb.txt color database */
-	c = GrGetColorByName((char *) colorname, &r, &g, &b);
+	if (!strncmp(colorname, "rgb:", 4)) {
+		sscanf(&colorname[4], "%x/%x/%x", &r, &g, &b);
+	} else {
+		/* first look up color in rgb.txt color database */
+		c = GrGetColorByName((char *) colorname, &r, &g, &b);
+	}
 //DPRINTF("XAllocNamedColor %s = %x\n", colorname, c);
 
 	hard_def->red = exact_def->red = r << 8;
diff -Nuarp nxlib-0.47dev.orig/Context.c nxlib-0.47dev/Context.c
--- nxlib-0.47dev.orig/Context.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Context.c	2013-02-25 15:26:56.000000000 +0900
@@ -0,0 +1,175 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#if 0
+#include <stdio.h>
+#include <stdlib.h>
+
+void* xalloc(size_t sz)
+{
+	void* p;
+	p = calloc(1, sz);
+	if (!p) exit(1);
+	return p;
+}
+/* Iterator */
+typedef struct _iterator {
+	void* element;
+	struct _iterator* next;
+} Iterator;
+/* Linked List */
+typedef struct _list {
+	int element_size;
+	struct _iterator* head;
+	struct _iterator* tail;
+} List;
+
+/* Linked Listの生成 */
+#define list_alloc(list, type) \
+	list = xalloc(sizeof(List)); \
+	list->element_size = sizeof(type);
+
+/* Iteratorに格納する要素のalloc */
+void* list_new_element(List* list)
+{
+	return xalloc(list->element_size);
+}
+/* Iteratorの取得 */
+Iterator* get_iterator(List* list)
+{
+	return list->head;
+}
+/* 要素を持っているか？ */
+int iterator_has_value(Iterator* ite)
+{
+	return ite != NULL;
+}
+/* 次の要素を取得する */
+void* iterator_next(Iterator* ite)
+{
+	return ite->next;
+}
+/* Linked Listにオブジェクトを追加する */
+void list_add(List* list, void* new_element)
+{
+	if (list->tail == NULL) {
+		/* 最初の要素 */
+		list->tail = list->head = xalloc(sizeof(Iterator));
+	} else {
+		Iterator* old_tail = list->tail;
+		old_tail->next = xalloc(sizeof(Iterator));
+		list->tail = old_tail->next;
+	}
+	list->tail->element = new_element;
+}
+/* Linked Listを開放する */
+void list_free(List* list)
+{
+	Iterator* it = get_iterator(list);
+	while (1) {
+		Iterator* old_it = it;
+		if (it == NULL) break;
+		free(it->element);
+		it = it->next;
+		free(old_it);
+	}
+}
+/* なんちゃって foreach */
+#define foreach(it, list) for(it = get_iterator(list); iterator_has_value(it); it = iterator_next(it))
+
+
+typedef struct _point {
+    int x;
+    int y;
+} Point;                        /* 適当な構造体サンプル */
+int main(int argc, char** argv)
+{
+    List* list;
+    Iterator* it;
+    int i;
+    list_alloc(list, Point);    /* リストを作る */
+    for (i = 0; i < 10; i++) {
+        Point* p1 = list_new_element(list);  /* リストに格納するelementの領域を貰う */
+        p1->x = i;
+        p1->y = i;
+        list_add(list, p1);     /* Point構造体をリストに追加する */
+    }
+    foreach (it, list) {        /* なんちゃってforeachの使い方 */
+        Point* p = it->element;
+        printf("point: (%d, %d)\n", p->x, p->y);
+    }
+    list_free(list);
+    return 0;
+}
+#endif
+
+
+#include "nxlib.h"
+#include "X11/Xutil.h"
+
+typedef struct _XCList {
+	Display *display;
+	XID rid;
+	XContext context;
+	XPointer data;
+
+	struct _XCList	*prev;
+	struct _XCList	*next;
+} XCList;
+
+XCList xcl;
+
+int XFindContext(Display *display, XID rid, XContext context, XPointer *data)
+{
+	printf("XFindContext called...\n");
+	XCList *p = &xcl;
+	while (p->next) {
+		if (p->display == display && p->rid == rid && p->context == context) {
+			*data = p->data;
+			return 0;
+		}
+		p=p->next;
+	}
+	return XCNOENT;
+}
+
+int XSaveContext(Display *display, XID rid, XContext context, XPointer data)
+{
+	printf("XSaveContext called...\n");
+	XCList *p = &xcl;
+	while (p->next) {
+		if (p->display == display && p->rid == rid && p->context == context) {
+			p->data = data;	// over write
+			return 0;
+		}
+		p=p->next;
+	}
+
+	p->next = calloc(1, sizeof(XCList));	// with 0 clear
+	if (!p->next) return XCNOMEM;
+	p->next->prev=p;
+	p=p->next;
+
+	p->display = display;
+	p->rid = rid;
+	p->context = context;
+	p->data = data;
+	return 0;
+}
+
+int XDeleteContext(Display *display, XID rid, XContext context)
+{
+	printf("XDeleteContext called...\n");
+	XCList *p = &xcl;
+	while (p->next) {
+		if (p->display == display && p->rid == rid && p->context == context) {
+			p->prev->next = p->next;
+			p->next->prev = p->prev;
+			free(p);
+			return 0;
+		}
+		p=p->next;
+	}
+	return XCNOENT;
+}
diff -Nuarp nxlib-0.47dev.orig/CrGC.c nxlib-0.47dev/CrGC.c
--- nxlib-0.47dev.orig/CrGC.c	2010-12-10 04:02:09.000000000 +0900
+++ nxlib-0.47dev/CrGC.c	2013-02-25 15:05:29.000000000 +0900
@@ -100,10 +100,10 @@ setupGC(Display * dpy, GC gc, unsigned l
 		XSetSubwindowMode(dpy, gc, values->subwindow_mode);
 
 	if (valuemask & GCPlaneMask)
-		DPRINTF("XCreatGC: GCPlaneMask not implemented\n");
+		DPRINTF("XCreateGC: GCPlaneMask not implemented\n");
 
 	if (valuemask & GCArcMode)
-		DPRINTF("XCreatGC: GCArcMode not implemented\n");
+		DPRINTF("XCreateGC: GCArcMode not implemented\n");
 }
 
 /* note: unused Drawable d */
diff -Nuarp nxlib-0.47dev.orig/CrPixmap.c nxlib-0.47dev/CrPixmap.c
--- nxlib-0.47dev.orig/CrPixmap.c	2010-12-10 04:02:19.000000000 +0900
+++ nxlib-0.47dev/CrPixmap.c	2013-02-25 16:23:34.000000000 +0900
@@ -5,10 +5,11 @@ XCreatePixmap(Display * dpy, Drawable d,
 	unsigned int height, unsigned int depth)
 {
 	/* Drawable ignored with nano-X */
-DPRINTF("XCreatePixmap %d,%d depth %d\n", width, height, depth);
+	DPRINTF("XCreatePixmap %d,%d depth %d\n", width, height, depth);
 	// FIXME depth ignored in pixmap
 	if (depth == 1) DPRINTF("XCreatePixmap created with depth 1\n");
 	return GrNewPixmap(width, height, NULL);
+	//return GrNewPixmapEx(width, height, 0, NULL);
 }
 
 int
diff -Nuarp nxlib-0.47dev.orig/ErrorHandler.c nxlib-0.47dev/ErrorHandler.c
--- nxlib-0.47dev.orig/ErrorHandler.c	2010-12-10 04:02:24.000000000 +0900
+++ nxlib-0.47dev/ErrorHandler.c	2013-02-25 15:03:03.000000000 +0900
@@ -2,6 +2,12 @@
 
 static XIOErrorHandler _errorfunc = 0;
 
+//static XErrorHandler _XErrorFunction = 0;
+//long _libX__XErrorFunctionFlag = 0;
+//void *_libX__XErrorFunctionPtr = 0;
+// from Xlibinit.h
+int (*_XErrorFunction)(Display*, XErrorEvent*) = 0;
+
 void
 _nxErrorHandler(GR_EVENT * event)
 {
@@ -22,3 +28,13 @@ XSetIOErrorHandler(XIOErrorHandler handl
 	_errorfunc = handle;
 	return prev;
 }
+
+//int XSetErrorHandler( int (*handler)(Display*, XErrorEvent*) )
+XErrorHandler XSetErrorHandler(XErrorHandler handler)
+{
+//	XErrorHandler old = _XErrorFunction;
+	printf("XSetErrorHandler called [%x]\n", (unsigned int)handler);
+	_XErrorFunction = handler;
+//	return old;
+	return 0;
+}
diff -Nuarp nxlib-0.47dev.orig/Extension.c nxlib-0.47dev/Extension.c
--- nxlib-0.47dev.orig/Extension.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Extension.c	2013-02-25 14:46:41.000000000 +0900
@@ -0,0 +1,150 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+#include <string.h>
+
+// from /usr/include/X11/extensions/shapestr.h
+#define SHAPENAME "SHAPE"
+#define SHAPE_MAJOR_VERSION	1	/* current version numbers */
+#define SHAPE_MINOR_VERSION	1
+
+typedef struct _EXT_Manage {
+	char *name;
+	char ver;
+	int event;
+	int error;
+} EXT_Manage;
+EXT_Manage exmanage[] = {
+	{ SHAPENAME, SHAPE_MAJOR_VERSION, LASTEvent+1, 0, },
+	{ NULL, 0, 0, 0 }
+};
+
+Bool XQueryExtension(Display *dpy, _Xconst char *name,
+	int *major_opcode, int *first_event, int *first_error)
+{
+	EXT_Manage *p = exmanage;
+	printf("XQueryExtension called [%s]\n", name);
+
+	while (p->name) {
+		if (!strcmp(p->name, name)) {
+			if (major_opcode) *major_opcode = p->ver;
+			if (first_event) *first_event = p->event;
+			if (first_error) *first_error = p->error;
+			return 1;
+		}
+		p++;
+	}
+
+	return 0;
+}
+
+// This codes run from extutil.c in libXext
+// required for Qt
+XExtCodes *XInitExtension(Display *dpy, _Xconst char *name)
+{
+	printf("XInitExtension called [%s]\n", name);
+	return 0;
+}
+
+static int ext = 0;
+XExtCodes *XAddExtension(Display *dpy)
+{
+	XExtCodes *codes = calloc(1, sizeof(XExtCodes));
+	if (codes) {
+		//codes->major_opcode = ext;
+		codes->extension = ext++;
+	}
+	printf("XAddExtension called [#%d]\n", codes ? codes->extension : -1);
+	return codes;
+	/*printf("XAddExtension called\n");
+	return 0;*/
+}
+
+int (*XESetCloseDisplay(Display *dpy, int extension, int (*proc)()))()
+{
+	printf("XESetCloseDisplay called [#%d]\n", extension);
+	return NULL;
+}
+
+// from libXi
+int /*XDeviceInfo **/XListInputDevices(Display *dpy, int *ndevices)
+{
+	return NULL;
+}
+int XFreeDeviceList()
+{
+	return NULL;
+}
+
+int /*XExtDisplayInfo **/XextFindDisplay(/*XExtensionInfo *extinfo, Display *dpy*/)
+{
+	return NULL;
+}
+#if 0
+int XextAddDisplay()
+{
+	return NULL;
+}
+
+int XRenderFreePicture()
+{
+	return NULL;
+}
+int XRenderFreeGlyphSet()
+{
+	return NULL;
+}
+int XRenderCompositeText32()
+{
+	return NULL;
+}
+int XRenderCompositeText16()
+{
+	return NULL;
+}
+int XRenderCompositeText8()
+{
+	return NULL;
+}
+#endif
+
+Bool XSyncQueryExtension(Display *dpy, int *event_base, int *error_base)
+{
+	printf("XSyncQueryExtension called\n");
+	//*event_base = *error_base = 0; //segfault
+	return 0;
+}
+Bool XShmQueryExtension(Display *dpy, int *event_base, int *error_base)
+{
+	printf("XShmQueryExtension called\n");
+	return 0;
+}
+// required for qt4
+Bool XkbQueryExtension(Display *dpy, int *event_base, int *error_base)
+{
+	printf("XkbQueryExtension called\n");
+	return 0;
+}
+
+// required for OpenGL
+XExtData **XEHeadOfExtensionList(XEDataObject object)
+{
+	return *(XExtData ***)&object;
+}
+
+int XAddToExtensionList(XExtData **structure, XExtData *ext_data)
+{
+	ext_data->next = *structure;
+	*structure = ext_data;
+	return 1;
+}
+
+XExtData *XFindOnExtensionList(XExtData **structure, int number)
+{
+	XExtData *ext;
+	ext = *structure;
+	while (ext && (ext->number != number)) ext = ext->next;
+	return ext;
+}
diff -Nuarp nxlib-0.47dev.orig/FontCursor.c nxlib-0.47dev/FontCursor.c
--- nxlib-0.47dev.orig/FontCursor.c	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/FontCursor.c	2013-02-25 16:23:28.000000000 +0900
@@ -53,6 +53,7 @@ XCreateGlyphCursor(Display * display, Fo
 	GrGetGCTextSize(gc, &ch[1], 1, GR_TFTOP, &tw[1], &th[1], &tb[1]);
 
 	cursor = GrNewPixmap(tw[1] * 2, th[1], 0);
+	//cursor = GrNewPixmapEx(tw[1] * 2, th[1], 0, 0);
 
 	/* Draw the mask first, to avoid having to switch fonts in the GC */
 	GrText(cursor, gc, tw[1], 0, &ch[1], 1, GR_TFTOP|GR_TFASCII);
diff -Nuarp nxlib-0.47dev.orig/FontInfo.c nxlib-0.47dev/FontInfo.c
--- nxlib-0.47dev.orig/FontInfo.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/FontInfo.c	2013-02-25 15:30:23.000000000 +0900
@@ -0,0 +1,36 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+int XFreeFontInfo(char **names, XFontStruct *info, int actualCount)
+{
+	int i;
+	if (names) {
+		Xfree(names[0]-1);
+		for (i = 1; i < actualCount; i++) {
+			Xfree(names[i]);
+		}
+		Xfree((char*)names);
+	}
+	if (info) {
+		for (i = 0; i < actualCount; i++) {
+			if (info[i].per_char)
+				Xfree((char*)info[i].per_char);
+			if (info[i].properties)
+				Xfree((char*)info[i].properties);
+		}
+		Xfree((char*)info);
+	}
+	return 1;
+}
+
+#include "X11/Xlcint.h"
+#include "X11/Xlib.h"
+XFontSetExtents *XExtentsOfFontSet(XFontSet font_set)
+{
+	//printf("XExtentsOfFontSet called...\n");
+	if (!font_set) return NULL;
+	return &font_set->core.font_set_extents;
+}
diff -Nuarp nxlib-0.47dev.orig/GetGCVals.c nxlib-0.47dev/GetGCVals.c
--- nxlib-0.47dev.orig/GetGCVals.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/GetGCVals.c	2013-02-25 14:47:37.000000000 +0900
@@ -0,0 +1,83 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// All gc fields except GCClipMask and GCDashList
+#define ValidGCValuesBits (GCFunction | GCPlaneMask | GCForeground | \
+			   GCBackground | GCLineWidth | GCLineStyle | \
+			   GCCapStyle | GCJoinStyle | GCFillStyle | \
+			   GCFillRule | GCTile | GCStipple | \
+			   GCTileStipXOrigin | GCTileStipYOrigin | \
+			   GCFont | GCSubwindowMode | GCGraphicsExposures | \
+			   GCClipXOrigin | GCClipYOrigin | GCDashOffset | \
+			   GCArcMode)
+
+Status XGetGCValues(Display *dpy, GC gc, unsigned long valuemask, XGCValues *values)
+{
+	XGCValues *vp = (XGCValues *)gc->ext_data;
+
+	if (valuemask == ValidGCValuesBits) {
+		char dashes = values->dashes;
+		Pixmap clip_mask = values->clip_mask;
+		*values = *vp;
+		values->dashes = dashes;
+		values->clip_mask = clip_mask;
+		return True;
+	}
+	if (valuemask & ~ValidGCValuesBits) return False;
+
+	if (valuemask & GCFunction)
+		values->function = vp->function;
+
+	if (valuemask & GCPlaneMask)
+		values->plane_mask = vp->plane_mask;
+
+	if (valuemask & GCForeground)
+		values->foreground = vp->foreground;
+	if (valuemask & GCBackground)
+		values->background = vp->background;
+
+	if (valuemask & GCLineWidth)
+		values->line_width = vp->line_width;
+	if (valuemask & GCLineStyle)
+		values->line_style = vp->line_style;
+	if (valuemask & GCCapStyle)
+		values->cap_style = vp->cap_style;
+	if (valuemask & GCJoinStyle)
+		values->join_style = vp->join_style;
+	if (valuemask & GCFillStyle)
+		values->fill_style = vp->fill_style;
+	if (valuemask & GCFillRule)
+		values->fill_rule = vp->fill_rule;
+
+	if (valuemask & GCTile)
+		values->tile = vp->tile;
+	if (valuemask & GCStipple)
+		values->stipple = vp->stipple;
+
+	if (valuemask & GCTileStipXOrigin)
+		values->ts_x_origin = vp->ts_x_origin;
+	if (valuemask & GCTileStipYOrigin)
+		values->ts_y_origin = vp->ts_y_origin;
+
+	if (valuemask & GCFont)
+		values->font = vp->font;
+	if (valuemask & GCSubwindowMode)
+		values->subwindow_mode = vp->subwindow_mode;
+	if (valuemask & GCGraphicsExposures)
+		values->graphics_exposures = vp->graphics_exposures;
+
+	if (valuemask & GCClipXOrigin)
+		values->clip_x_origin = vp->clip_x_origin;
+	if (valuemask & GCClipYOrigin)
+		values->clip_y_origin = vp->clip_y_origin;
+
+	if (valuemask & GCDashOffset)
+		values->dash_offset = vp->dash_offset;
+	if (valuemask & GCArcMode)
+		values->arc_mode = vp->arc_mode;
+
+	return True;
+}
diff -Nuarp nxlib-0.47dev.orig/GetPntMap.c nxlib-0.47dev/GetPntMap.c
--- nxlib-0.47dev.orig/GetPntMap.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/GetPntMap.c	2013-02-25 14:48:35.000000000 +0900
@@ -0,0 +1,76 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+#include <string.h>
+
+// required for opera
+int XGetPointerMapping(Display *dpy, unsigned char *map, int nmap)
+{
+	printf("XGetPointerMapping called..\n");
+	if (!map) return 0;
+	strcpy((char*)map, "123456789");
+	return 9;
+	//return NULL;
+}
+
+// required for gvim
+int XDisplayKeycodes(Display *dpy,
+	int *min_keycode_return, int *max_keycode_return)
+{
+	// look up StrKeysym.c
+	*min_keycode_return = /*dpy->min_keycode*/9;
+	*max_keycode_return = /*dpy->max_keycode*/113;
+	return 1;
+}
+
+KeySym *XGetKeyboardMapping(Display *dpy, /*KeyCode*/unsigned int first_keycode,
+	int count, int *keysyms_per_keycode)
+{
+	int kc = first_keycode;
+	KeySym *p, *ks = Xcalloc(1, count);
+	if (!ks) return 0;
+
+	//printf("XGetKeyboardMapping called [%x,c:%d]", kc, count);
+	printf("XGetKeyboardMapping called [%x,c:%d]\n", kc, count);
+	p = ks;
+	//*keysyms_per_keycode = 0;
+	for (; count>0; count--) {
+		*p = XKeycodeToKeysym(dpy, kc, 0);
+		p++;
+		/*printf(" %0x >", kc);
+		if ((*p = XKeycodeToKeysym(dpy, kc, 0))) {
+			printf(" %0x", *p);
+			*(keysyms_per_keycode)++, p++;
+		}*/
+		kc++;
+	}
+	/*printf(" [c:%d]\n", *keysyms_per_keycode);
+	if (!(*keysyms_per_keycode)) return 0;*/
+	*keysyms_per_keycode = 2;
+
+	return ks;
+}
+
+XModifierKeymap *XGetModifierMapping(Display *display)
+{
+	XModifierKeymap *modmap;
+	printf("XGetModifierMapping called..\n");
+
+	modmap = (XModifierKeymap *)Xcalloc(1, sizeof(XModifierKeymap));
+	modmap->max_keypermod = 0;
+	modmap->modifiermap = NULL;
+	//modmap->modifiermap = (KeyCode*)Xmalloc(1);
+	return modmap;
+}
+
+int XFreeModifiermap(XModifierKeymap *map)
+{
+	printf("XFreeModifiermap called..\n");
+	if (map) {
+		if (map->modifiermap) Xfree((char *) map->modifiermap);
+		Xfree((char *) map);
+	}
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/GetWMProps.c nxlib-0.47dev/GetWMProps.c
--- nxlib-0.47dev.orig/GetWMProps.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/GetWMProps.c	2013-02-25 15:31:18.000000000 +0900
@@ -0,0 +1,125 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+#include "X11/Xutil.h"
+#include "X11/Xatom.h"
+//#include <string.h>
+
+// from GetTxtProp.c
+// required for kaffeine
+Status XGetTextProperty(Display *display, Window window, XTextProperty *tp, Atom property)
+{
+	Atom actual_type;
+	int actual_format = 0;
+	unsigned long nitems = 0L, leftover = 0L;
+	unsigned char *prop = NULL;
+
+	printf("XGetTextProperty called..\n");
+	if (XGetWindowProperty(display, window, property, 0L, 1000000L, False,
+		AnyPropertyType, &actual_type, &actual_format, &nitems, &leftover,
+		&prop) == Success && actual_type != None) {
+		/* okay, fill it in */
+		tp->value = prop;
+		tp->encoding = actual_type;
+		tp->format = actual_format;
+		tp->nitems = nitems;
+		return True;
+	}
+
+	tp->value = NULL;
+	tp->encoding = None;
+	tp->format = 0;
+	tp->nitems = 0;
+	return False;
+}
+
+Status XGetWMName(Display *dpy, Window w, XTextProperty *tp)
+{
+	return XGetTextProperty(dpy, w, tp, XA_WM_NAME);
+}
+
+Status XGetWMIconName(Display *dpy, Window w, XTextProperty *tp)
+{
+	return XGetTextProperty(dpy, w, tp, XA_WM_ICON_NAME);
+}
+
+Status XGetWMClientMachine(Display *dpy, Window w, XTextProperty *tp)
+{
+	return XGetTextProperty(dpy, w, tp, XA_WM_CLIENT_MACHINE);
+}
+
+#define NumPropWMHintsElements 9 /* number of elements in this structure */
+XWMHints *XGetWMHints(Display *dpy, Window w)
+{
+	XWMHints *prop;
+	//XWMHints *hints;
+	Atom actual_type;
+	int actual_format;
+	unsigned long leftover;
+	unsigned long nitems;
+
+	printf("XGetWMHints called..\n");
+	if (XGetWindowProperty(dpy, w, XA_WM_HINTS, 0L,
+		NumPropWMHintsElements, False, XA_WM_HINTS, &actual_type,
+		&actual_format, &nitems, &leftover, (unsigned char **)&prop)
+		!= Success) return NULL;
+
+	/* If the property is undefined on the window, return null pointer. */
+	/* pre-R3 bogusly truncated window_group, don't fail on them */
+	if ((actual_type != XA_WM_HINTS) ||
+		(nitems < (NumPropWMHintsElements-1)) || (actual_format != 32)) {
+		if (prop) Xfree((char*)prop);
+		return NULL;
+	}
+	return prop;
+#if 0
+	/* static copies not allowed in library, due to reentrancy constraint*/
+	if ((hints = (XWMHints*)Xcalloc(1, (unsigned)sizeof(XWMHints)))) {
+		hints->flags = prop->flags;
+		hints->input = (prop->input ? True : False);
+		hints->initial_state = cvtINT32toInt(prop->initialState);
+		hints->icon_pixmap = prop->iconPixmap;
+		hints->icon_window = prop->iconWindow;
+		hints->icon_x = cvtINT32toInt(prop->iconX);
+		hints->icon_y = cvtINT32toInt(prop->iconY);
+		hints->icon_mask = prop->iconMask;
+		if (nitems >= NumPropWMHintsElements)
+			hints->window_group = prop->windowGroup;
+		else
+			hints->window_group = 0;
+	}
+	Xfree((char *)prop);
+	return hints;
+#endif
+}
+
+Status XGetCommand(Display *dpy, Window w, char ***argvp, int *argcp)
+{
+	XTextProperty tp;
+	int argc;
+	char **argv;
+
+	printf("XGetCommand called..\n");
+	if (!XGetTextProperty(dpy, w, &tp, XA_WM_COMMAND)) return 0;
+
+	if (tp.encoding != XA_STRING || tp.format != 8) {
+		if (tp.value) Xfree((char*) tp.value);
+		return 0;
+	}
+
+	// ignore final <NUL> if present since UNIX WM_COMMAND is nul-terminated
+	if (tp.nitems && (tp.value[tp.nitems - 1] == '\0')) tp.nitems--;
+
+	// create a string list and return if successful
+	if (!XTextPropertyToStringList(&tp, &argv, &argc)) {
+		if (tp.value) Xfree((char*) tp.value);
+		return 0;
+	}
+
+	if (tp.value) Xfree((char*) tp.value);
+	*argvp = argv;
+	*argcp = argc;
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/Grab.c nxlib-0.47dev/Grab.c
--- nxlib-0.47dev.orig/Grab.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Grab.c	2013-02-25 14:46:11.000000000 +0900
@@ -0,0 +1,30 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// required for Xt
+int XGrabButton(Display *display, unsigned int button, unsigned int modifiers,
+	Window grab_window, Bool owner_events, unsigned int event_mask,
+	int pointer_mode, int keyboard_mode, Window confine_to, Cursor cursor)
+{
+	printf("XGrabButton called...\n");
+	return 0;
+}
+
+// required for rasp
+int XGrabKey(Display *dpy, int key, unsigned int modifiers, Window grab_window,
+	Bool owner_events, int pointer_mode, int keyboard_mode)
+
+{
+	printf("XGrabKey called...\n");
+	return 0;
+}
+
+/*int XGrabKeyboard(Display *display, Window w, Bool owner_events,
+	int pointer_mode, int keyboard_mode, Time time)
+{
+	printf("XGrabKeyboard called...\n");
+	return 0;
+}*/
diff -Nuarp nxlib-0.47dev.orig/IM.c nxlib-0.47dev/IM.c
--- nxlib-0.47dev.orig/IM.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/IM.c	2013-02-25 15:29:22.000000000 +0900
@@ -0,0 +1,452 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include <string.h>
+#include "nxlib.h"
+//#include "Xutil.h"
+#include "X11/Xlcint.h"
+
+#if 0
+typedef enum {
+	CREATE_IC = 1,
+	SET_ICVAL = 2,
+	GET_ICVAL = 3
+} XICOp_t;
+
+char *_SetICValueData(XIC ic, XIMArg *values, XICOp_t mode)
+{
+	XIMArg *p;
+	char *return_name = NULL;
+
+	for (p = values; p != NULL && p->name != NULL; p++) {
+		if (!strcmp(p->name, XNInputStyle)) {
+			if (mode == CREATE_IC)
+				ic->core.input_style = (XIMStyle)p->value;
+		} else if (!strcmp(p->name, XNClientWindow)) {
+			ic->core.client_window = (Window)p->value;
+		} else if (!strcmp(p->name, XNFocusWindow)) {
+			ic->core.focus_window = (Window)p->value;
+		} else if (!strcmp(p->name, XNPreeditAttributes)
+			|| !strcmp(p->name, XNStatusAttributes)) {
+			return_name = _SetICValueData(ic, (XIMArg*)p->value, mode);
+			if (return_name) break;
+		} else {
+			return_name = p->name;
+			break;
+		}
+	}
+	return return_name;
+}
+
+char *_GetICValueData(XIC ic, XIMArg *values, XICOp_t mode)
+{
+	XIMArg *p;
+	char *return_name = NULL;
+
+	for (p = values; p->name != NULL; p++) {
+		if (!strcmp(p->name, XNInputStyle)) {
+			*((XIMStyle *)(p->value)) = ic->core.input_style;
+		} else if (!strcmp(p->name, XNClientWindow)) {
+			*((Window *)(p->value)) = ic->core.client_window;
+		} else if (!strcmp(p->name, XNFocusWindow)) {
+			*((Window *)(p->value)) = ic->core.focus_window;
+		} else if (!strcmp(p->name, XNFilterEvents)) {
+			*((unsigned long *)(p->value))= ic->core.filter_events;
+		} else if (!strcmp(p->name, XNPreeditAttributes)
+			|| !strcmp(p->name, XNStatusAttributes)) {
+			return_name = _GetICValueData(ic, (XIMArg*)p->value, mode);
+			if (return_name) break;
+		} else {
+			return_name = p->name;
+			break;
+		}
+	}
+	return return_name;
+}
+
+char *_SetICValues(XIC ic, XIMArg *args)
+{
+	char *ret;
+	if (!ic) return args->name;
+	ret = _SetICValueData(ic, args, SET_ICVAL);
+	return ret;
+}
+
+char *_GetICValues(XIC ic, XIMArg *args)
+{
+	char *ret;
+	if (!ic) return args->name;
+	ret = _GetICValueData(ic, args, GET_ICVAL);
+	return ret;
+}
+
+int _MbLookupString(XIC xic, XKeyEvent *ev, char *buffer, int bytes,
+	KeySym *keysym, Status *status)
+{
+	XComposeStatus NotSupportedYet;
+	int length;
+
+	length = XLookupString(ev, buffer, bytes, keysym, &NotSupportedYet);
+	if (keysym && *keysym == NoSymbol) {
+		*status = XLookupNone;
+	} else if (length > 0) {
+		*status = XLookupBoth;
+	} else {
+		*status = XLookupKeySym;
+	}
+	return length;
+}
+
+int _WcLookupString(XIC xic, XKeyEvent *ev, wchar_t * buffer, int wlen,
+	KeySym *keysym, Status *status)
+{
+	XComposeStatus NotSupportedYet;
+	int length;
+	/* In single-byte, mb_len = wc_len */
+	char *mb_buf = (char *)Xmalloc(wlen);
+
+	length = XLookupString(ev, mb_buf, wlen, keysym, &NotSupportedYet);
+	if (keysym && *keysym == NoSymbol) {
+		*status = XLookupNone;
+	} else if (length > 0) {
+		*status = XLookupBoth;
+	} else {
+		*status = XLookupKeySym;
+	}
+	mbstowcs(buffer, mb_buf, length);
+	XFree(mb_buf);
+	return length;
+}
+
+static _Xconst XICMethodsRec local_ic_methods = {
+//	_DestroyIC, 		/* destroy */
+//	_SetFocus,		/* set_focus */
+//	_UnsetFocus,		/* unset_focus */
+	NULL,	 		/* destroy */
+	NULL,			/* set_focus */
+	NULL,			/* unset_focus */
+	_SetICValues,		/* set_values */
+	_GetICValues,		/* get_values */
+//	_MbReset,		/* mb_reset */
+//	_WcReset,		/* wc_reset */
+	NULL,			/* mb_reset */
+	NULL,			/* wc_reset */
+	NULL,			/* utf8_reset */		/* ??? */
+	_MbLookupString,	/* mb_lookup_string */
+	_WcLookupString,	/* wc_lookup_string */
+	NULL			/* utf8_lookup_string */	/* ??? */
+};
+
+Status _CloseIM(XIM im)
+{
+	printf("_CloseIM called [%x]\n", (int)im);
+	/*StaticXIM im = (StaticXIM)xim;
+	_XlcCloseConverter(im->private->ctom_conv);
+	_XlcCloseConverter(im->private->ctow_conv);
+	XFree(im->private);*/
+	XFree(im->core.im_name);
+	if (im->core.res_name) XFree(im->core.res_name);
+	if (im->core.res_class) XFree(im->core.res_class);
+	return 1; /*bugID 4163122*/
+}
+
+char *_SetIMValues(XIM xim, XIMArg *arg)
+{
+	printf("_SetIMValues called [%s]\n", arg->name);
+	return arg->name;	/* evil */
+}
+
+char *_GetIMValues(XIM xim, XIMArg *values)
+{
+	XIMArg *p;
+	XIMStyles *styles;
+
+	printf("_GetIMValues called [%s]\n", values->name);
+	for (p = values; p->name != NULL; p++) {
+		if (strcmp(p->name, XNQueryInputStyle) == 0) {
+			styles = (XIMStyles*)Xmalloc(sizeof(XIMStyles));
+			*(XIMStyles**)p->value = styles;
+			styles->count_styles = 1;
+			styles->supported_styles =
+				(XIMStyle*)Xmalloc(styles->count_styles * sizeof(XIMStyle));
+			styles->supported_styles[0] = (XIMPreeditNone | XIMStatusNone);
+		} else {
+			break;
+		}
+	}
+	return p->name;
+}
+
+XIC _CreateIC(XIM im, XIMArg *arg)
+{
+	XIC ic;
+
+	printf("_CreateIC called [%x]\n", (int)im);
+	if (!(ic = Xcalloc(1, sizeof(XICRec)))) return NULL;
+
+	ic->methods = (XICMethods)&local_ic_methods;
+	ic->core.im = im;
+	ic->core.filter_events = KeyPressMask;
+
+	if ((_SetICValueData(ic, arg, CREATE_IC) != NULL)
+		|| (!(ic->core.input_style))) {
+		XFree(ic);
+		return 0;
+	}
+
+	return ic;
+}
+
+static _Xconst XIMMethodsRec local_im_methods = {
+	_CloseIM,	/* close */
+	_SetIMValues,	/* set_values */
+	_GetIMValues, 	/* get_values */
+	_CreateIC,	/* create_ic */
+	NULL,		/* ctstombs */
+	NULL		/* ctstowcs */
+};
+#endif
+
+// XrmDatabase rdb??
+XIM XOpenIM(Display *dpy,
+	struct _XrmHashBucketRec *rdb, char *res_name, char *res_class)
+{
+	XIM im;
+	//XIMStaticXIMRec *local_impart;
+
+	printf("XOpenIM called <name:%s, class:%s>\n", res_name, res_class);
+	//printf("XOpenIM called...\n");
+	//if (!(im = Xmalloc(sizeof(XIM)))) return 0;
+	if (!(im = Xcalloc(1, sizeof(XIM)))) return 0;
+	//if (!(local_impart = Xcalloc(1, sizeof(XIMRec)))) return 0;
+	//im->private = local_impart;
+	//im->methods        = (XIMMethods)&local_im_methods;
+	//im->core.display   = dpy;
+
+#if 0
+	// @im=kimera
+	strcpy(im->core.im_name, "kimera");
+
+	//im->private = local_impart;
+	im->methods        = (XIMMethods)&local_im_methods;
+	//im->core.lcd       = lcd;
+	im->core.ic_chain  = (XIC)NULL;
+	im->core.display   = dpy;
+	im->core.rdb       = rdb;
+	im->core.res_name  = NULL;
+	im->core.res_class = NULL;
+
+/*	local_impart->ctom_conv = ctom_conv;
+	local_impart->ctow_conv = ctow_conv;*/
+	/*local_impart->ctom_conv = NULL;
+	local_impart->ctow_conv = NULL;*/
+
+	if (res_name && *res_name) {
+		im->core.res_name  = (char*)Xmalloc(strlen(res_name)+1);
+		strcpy(im->core.res_name, res_name);
+	}
+	if (res_class && *res_class) {
+		im->core.res_class = (char*)Xmalloc(strlen(res_class)+1);
+		strcpy(im->core.res_class, res_class);
+	}
+#endif
+
+	return im;
+}
+
+Status XCloseIM(XIM im)
+{
+	printf("XCloseIM called.. %x\n", (int)im);
+	/*StaticXIM im = (StaticXIM)xim;
+	_XlcCloseConverter(im->private->ctom_conv);
+	_XlcCloseConverter(im->private->ctow_conv);
+	XFree(im->private);
+	XFree(im->core.im_name);
+	if (im->core.res_name) XFree(im->core.res_name);
+	if (im->core.res_class) XFree(im->core.res_class);*/
+	if (im) Xfree(im);
+	return 1; /*bugID 4163122*/
+}
+
+// Return the Display associated with the input method.
+Display *XDisplayOfIM(XIM im)
+{
+	printf("XDisplayOfIM called.. %x\n", (int)im);
+	return im->core.display;
+}
+
+// Return the Locale associated with the input method.
+char *XLocaleOfIM(XIM im)
+{
+	printf("XLocaleOfIM called.. %x\n", (int)im);
+	return im ? im->core.lcd->core->name : 0;
+}
+
+
+#if 0
+void _XIMCountNestedList(XIMArg *args, int *total_count)
+{
+	for (; args->name; args++) {
+		if (!strcmp(args->name, XNVaNestedList))
+			_XIMCountNestedList((XIMArg *)args->value, total_count);
+		else
+			++(*total_count);
+	}
+}
+
+void _XIMCountVaList(va_list var, int *total_count)
+{
+	char *attr;
+	*total_count = 0;
+
+	for (attr = va_arg(var, char*); attr; attr = va_arg(var, char*)) {
+		if (!strcmp(attr, XNVaNestedList)) {
+			_XIMCountNestedList(va_arg(var, XIMArg*), total_count);
+		} else {
+			(void)va_arg(var, XIMArg*);
+			++(*total_count);
+		}
+	}
+}
+
+int _XIMNestedListToNestedList(
+	XIMArg *nlist,   /* This is the new list */
+	XIMArg *list)    /* The original list */
+{
+	XIMArg *ptr = list;
+
+	while (ptr->name) {
+		if (!strcmp(ptr->name, XNVaNestedList)) {
+			nlist += _XIMNestedListToNestedList(nlist, (XIMArg *)ptr->value);
+		} else {
+			nlist->name = ptr->name;
+			nlist->value = ptr->value;
+			ptr++;
+			nlist++;
+		}
+	}
+	return ptr - list;
+}
+
+void _XIMVaToNestedList(va_list var, int max_count, XIMArg **args_return)
+{
+	XIMArg *args;
+	char   *attr;
+
+	if (max_count <= 0) {
+		*args_return = (XIMArg *)NULL;
+		return;
+	}
+
+	args = (XIMArg *)Xmalloc((unsigned)(max_count + 1) * sizeof(XIMArg));
+	*args_return = args;
+	if (!args) return;
+
+	for (attr = va_arg(var, char*); attr; attr = va_arg(var, char*)) {
+		if (!strcmp(attr, XNVaNestedList)) {
+			args += _XIMNestedListToNestedList(args, va_arg(var, XIMArg*));
+		} else {
+			args->name = attr;
+			args->value = va_arg(var, XPointer);
+			args++;
+		}
+	}
+	args->name = (char*)NULL;
+}
+
+char *XSetIMValues(XIM im, ...)
+{
+	printf("XSetIMValues called\n");
+//	return 0;
+
+	va_list var;
+	int     total_count;
+	XIMArg *args;
+	char   *ret;
+
+	// so count the stuff dangling here
+	va_start(var, im);
+	_XIMCountVaList(var, &total_count);
+	va_end(var);
+
+	// now package it up so we can send it along
+	va_start(var, im);
+	_XIMVaToNestedList(var, total_count, &args);
+	va_end(var);
+
+	ret = (*im->methods->set_values) (im, args);
+	if (args) Xfree((char *)args);
+	return ret;
+}
+
+char *XGetIMValues(XIM im, ...)
+{
+	va_list var;
+	int     total_count;
+	XIMArg *args;
+	char   *ret;
+
+	// so count the stuff dangling here
+	va_start(var, im);
+	_XIMCountVaList(var, &total_count);
+	va_end(var);
+
+	// now package it up so we can send it along
+	va_start(var, im);
+	_XIMVaToNestedList(var, total_count, &args);
+	va_end(var);
+
+	ret = (*im->methods->get_values) (im, args);
+	if (args) Xfree((char *)args);
+	return ret;
+}
+
+// Create an input context within the input method,
+// and return a pointer to the input context.
+XIC XCreateIC(XIM im, ...)
+{
+	va_list var;
+	int     total_count;
+	XIMArg *args;
+	XIC     ic;
+	printf("XCreateIC called..\n");
+
+	// so count the stuff dangling here
+	va_start(var, im);
+	_XIMCountVaList(var, &total_count);
+	va_end(var);
+
+	// now package it up so we can send it along
+	va_start(var, im);
+	_XIMVaToNestedList(var, total_count, &args);
+	va_end(var);
+
+	ic = (XIC) (*im->methods->create_ic) (im, args);
+	if (args) Xfree((char *)args);
+	if (ic) {
+		ic->core.next = im->core.ic_chain;
+		im->core.ic_chain = ic;
+	}
+	return ic;
+}
+#endif
+XIC XCreateIC(XIM im, ...)
+{
+	XIC ic;
+	printf("XCreateIC called...\n");
+	if (!(ic = Xcalloc(1, sizeof(XICRec)))) return 0;
+	return ic;
+}
+
+int XmbLookupString(XIC ic, XKeyPressedEvent *e,
+	char *buff, int len, KeySym *ks, Status *status)
+{
+	printf("XmbLookupString called..\n");
+	*status = XLookupBoth;
+	return XLookupString(e, buff, len, ks, status);
+
+	/*if (ic->core.im)
+		return (*ic->methods->mb_lookup_string) (ic, e, buff, len, ks, status);
+	return XLookupNone;*/
+}
diff -Nuarp nxlib-0.47dev.orig/Image.c nxlib-0.47dev/Image.c
--- nxlib-0.47dev.orig/Image.c	2011-02-20 05:43:14.000000000 +0900
+++ nxlib-0.47dev/Image.c	2013-02-25 14:59:54.000000000 +0900
@@ -124,14 +124,44 @@ computePitch(int bpp, int width, int *pi
 	*bytesperpixel = bytespp;
 }
 
+void setImageFunc(XImage *image)
+{
+	image->f.create_image = XCreateImage;
+	image->f.destroy_image = destroy_image;
+	image->f.sub_image = 0;		//FIXME
+	image->f.add_pixel = 0;
+	switch (image->bits_per_pixel) {
+	case 1:
+		image->f.get_pixel = get_pixel1;
+		image->f.put_pixel = put_pixel1;
+		break;
+	case 8:
+		image->f.get_pixel = get_pixel8;
+		image->f.put_pixel = put_pixel8;
+		break;
+	case 16:
+		image->f.get_pixel = get_pixel16;
+		image->f.put_pixel = put_pixel16;
+		break;
+	case 32:
+		image->f.get_pixel = get_pixel32;
+		image->f.put_pixel = put_pixel32;
+		break;
+	default:
+		printf("createImageStruct: unsupported bpp\n");
+	}
+
+	return;
+}
+
 static XImage *
 createImageStruct(unsigned int width, unsigned int height, unsigned int depth,
 	int format, int bytes_per_line, int bitmap_pad, unsigned long red_mask,
 	unsigned long green_mask, unsigned long blue_mask)
 {
-	XImage *image = (XImage *) Xcalloc(sizeof(XImage), 1);
-	if (!image)
-		return 0;
+	//XImage *image = (XImage *) Xcalloc(sizeof(XImage), 1);
+	XImage *image = (XImage *) Xcalloc(1, sizeof(XImage));
+	if (!image) return 0;
 
 	image->width = width;
 	image->height = height;
@@ -162,6 +192,7 @@ createImageStruct(unsigned int width, un
 	image->green_mask = green_mask;
 	image->blue_mask = blue_mask;
 
+#if 0
 	image->f.create_image = XCreateImage;
 	image->f.destroy_image = destroy_image;
 	image->f.sub_image = 0;		//FIXME
@@ -186,6 +217,8 @@ createImageStruct(unsigned int width, un
 	default:
 		DPRINTF("createImageStruct: unsupported bpp\n");
 	}
+#endif
+	setImageFunc(image);
 
 	return image;
 }
@@ -206,7 +239,7 @@ XCreateImage(Display * display, Visual *
 		depth = sizeof(GR_PIXELVAL) * 8;
 	}
 	if (depth != display->screens[0].root_depth) {
-		DPRINTF("XCreateImage: depth != hw_format\n");
+		printf("XCreateImage: depth[%d] != hw_format[%d]\n", depth, display->screens[0].root_depth);
 		//if (depth == 1)	//FIXME
 			//depth = sizeof(GR_PIXELVAL) * 8;
 	}
@@ -225,6 +258,14 @@ XCreateImage(Display * display, Visual *
 	return image;
 }
 
+/*unsigned int Ones(unsigned long mask)
+{
+	register unsigned long y;
+	y = (mask >> 1) &033333333333;
+	y = mask - y - ((y >>1) & 033333333333);
+	return ((unsigned int) (((y + (y >> 3)) & 030707070707) % 077));
+}*/
+
 /*
  * Create an image, (always in GR_PIXELVAL format), and initialize
  * using GrReadArea.
@@ -245,19 +286,43 @@ XGetImage(Display * display, Drawable d,
 	if (x < 0 || (x + width) > winfo.width || y < 0 || (y + height) > winfo.height) {
 		/* Error - BadMatch */
 		DPRINTF("XGetImage: Image out of bounds\n");
-		DPRINTF("    %d %d - %d %d is out of bounds on %d, %d - %d %d\n",
-		       x, y, width, height, 0, 0, winfo.width, winfo.height);
+		printf("    %d %d - %d %d is out of bounds on %d %d - %d %d\n",
+		       x, y, x+width, y+height, 0, 0, winfo.width, winfo.height);
+{
+//extern XErrorHandler _XErrorFunction;
+extern int (*_XErrorFunction)(Display*, XErrorEvent*);
+		XErrorEvent ev;
+//		ev.type = BadMatch;
+		ev.display = display;
+		ev.serial = XNextRequest;
+//		ev.request_code = <X11/Xproto.h>
+		ev.error_code = BadMatch;
+		if (_XErrorFunction) _XErrorFunction(display, &ev);
+}
 		return NULL;
 	}
 
-	if (format == XYPixmap)
-		DPRINTF("XGetImage warning: broken for XYPixmap\n");
-
-	/* 
-	 * create XImage in GrReadArea compatible format,
-	 * which is always sizeof(GR_PIXELVAL), not hw display format
-	 */
-	depth = sizeof(GR_PIXELVAL) * 8;
+	if (format == XYPixmap) {
+		/*depth = Ones(plane_mask &
+			(((unsigned long)0xFFFFFFFF) >> (32 - sizeof(GR_PIXELVAL)*8)));*/
+		//depth = sizeof(GR_PIXELVAL) * 8;
+		depth = 1;	// for Qt (Mask)
+		printf("XGetImage warning: broken for XYPixmap (bpp %d)\n", depth);
+
+		visual = XDefaultVisual(display, 0);
+		image = createImageStruct(width, height, 1, format, 0, 0,
+			visual->red_mask, visual->green_mask, visual->blue_mask);
+		if (!image) return NULL;
+		image->data = (char *)malloc(width/*image->bytes_per_line*/ * height);
+		memset(image->data, 0xff, width/*image->bytes_per_line*/ * height);
+		return image;
+	} else {
+		/*
+		* create XImage in GrReadArea compatible format,
+		* which is always sizeof(GR_PIXELVAL), not hw display format
+		*/
+		depth = sizeof(GR_PIXELVAL) * 8;
+	}
 #if 0
 	if (depth <= 8)
 		drawsize = 1;
@@ -269,13 +334,14 @@ XGetImage(Display * display, Drawable d,
 	drawsize = sizeof(GR_PIXELVAL);
 
 	visual = XDefaultVisual(display, 0);
-	image = createImageStruct(width, height, depth, format, 0, 0,
+	image = createImageStruct(width, height, depth, format, 0, 0/*display->bitmap_pad*/,
 		visual->red_mask, visual->green_mask, visual->blue_mask);
 	if (!image)
 		return NULL;
 
 	src_rowsize = width * drawsize;		/* bytes per line of image*/
-	image->data = (char *) Xcalloc(src_rowsize * height, 1);
+	//image->data = (char *) Xcalloc(src_rowsize * height, 1);
+	image->data = (char *) Xcalloc(1, src_rowsize * height);
 	GrReadArea(d, x, y, width, height, (void *) image->data);
 
 	/* createImage may have padded image width, may have to copy/re-pad*/
@@ -306,6 +372,69 @@ XGetImage(Display * display, Drawable d,
 	return image;
 }
 
+#if 0
+int _XSetImage(XImage *srcimg, XImage *dstimg, int x, int y)
+{
+	unsigned long pixel;
+	int row, col;
+	int width, height, startrow, startcol;
+
+	if (x < 0) {
+		startcol = -x;
+		x = 0;
+	} else
+		startcol = 0;
+	if (y < 0) {
+		startrow = -y;
+		y = 0;
+	} else
+		startrow = 0;
+	width = dstimg->width - x;
+	if (srcimg->width < width) width = srcimg->width;
+	height = dstimg->height - y;
+	if (srcimg->height < height) height = srcimg->height;
+
+	/* this is slow, will do better later */
+	for (row = startrow; row < height; row++) {
+		for (col = startcol; col < width; col++) {
+			//pixel = XGetPixel(srcimg, col, row);
+			//XPutPixel(dstimg, x + col, y + row, pixel);
+			dstimg->f.put_pixel(dstimg, x + col, y + row, srcimg->f.get_pixel(srcimg, col, row));
+		}
+	}
+	return 1;
+}
+#endif
+
+XImage *XGetSubImage(Display *dpy, Drawable d, int x, int y,
+	unsigned int width, unsigned int height, unsigned long plane_mask,
+	int format, XImage *dest_image, int dest_x, int dest_y)
+{
+	XImage *img;
+	int i, n;
+	char *p, *s;
+
+	printf("XGetSubImage src %d,%d wxh %d,%d dst %d,%d\n",
+		x, y, width, height, dest_x, dest_y);
+	img = XGetImage(dpy, d, x, y, width, height, plane_mask, format);
+	if (!img) return NULL;
+
+	// どちらのルーチンでも大丈夫
+	//_XSetImage(img, dest_image, dest_x, dest_y);
+	n = width * sizeof(GR_PIXELVAL);
+	s = img->data;
+	p = dest_image->data + (dest_y * dest_image->bytes_per_line) + (dest_x * dest_image->depth/8);
+	for (i=0; i<height; i++) {
+		memcpy(p, s, n);
+		p += dest_image->bytes_per_line;
+		s += img->bytes_per_line;
+	}
+	//XDestroyImage(img);
+	destroy_image(img);
+
+	return dest_image;
+}
+
 /* This takes a portion of the image buffer and rearranges it to keep from 
    freaking out GrArea. This will take into account a shifted src_x 
    (or a width that is not as large as the declared image width).
@@ -460,9 +589,8 @@ putImage(Display * display, Drawable d,
 	char *src = image->data + ((src_y * (image->bytes_per_line)) + src_x);
 	nxColormap *colormap = _nxFindColormap(XDefaultColormap(display, 0));
 
-DPRINTF("putImage: bpp %d\n", image->depth);
-	if (!colormap)
-		return 0;
+	printf("putImage: bpp %d\n", image->depth);
+	if (!colormap) return 0;
 
 	dst = buffer = ALLOCA(width * height * sizeof(unsigned long));
 
@@ -477,6 +605,10 @@ DPRINTF("putImage: bpp %d\n", image->dep
 				src += 4;
 				continue;
 
+			/*case 24:
+				cl = (unsigned short) *((unsigned long *) src);
+				src += 3;
+				continue;*/
 			//case 24: FIXME
 			case 16:
 				cl = (unsigned short) *((unsigned short *) src);
@@ -524,14 +656,116 @@ DPRINTF("putImage: bpp %d\n", image->dep
 	return 1;
 }
 
-int
-XPutImage(Display * display, Drawable d, GC gc, XImage * image,
-	int src_x, int src_y, int dest_x, int dest_y, unsigned int width,
-	unsigned int height)
+int XPutImage(Display *display, Drawable d, GC gc, XImage *image,
+	int src_x, int src_y, int dest_x, int dest_y, unsigned int _width,
+	unsigned int _height)
 {
-DPRINTF("XputImage %d,%d %d,%d depth %d\n", dest_x, dest_y, width, height, image->depth);
+	long width = _width;
+	long height = _height;
+
+	// 何故かスクロールがおかしくなる
+	/*if (src_x<0) {
+		width += src_x;
+		src_x = 0;
+	}
+	if (src_y<0) {
+		height += src_y;
+		src_y = 0;
+	}
+	if (dest_x<0) {
+		printf("XPutImage warning src(%d,%d) wxh(%d,%d) dst(%d,%d)\n", src_x, src_y, width, height, dest_x, dest_y);
+		width += dest_x;
+		if (width <= 0) return 0;
+		dest_x = 0;
+	}
+	if (dest_y<0) {
+		printf("XPutImage warning src(%d,%d) wxh(%d,%d) dst(%d,%d)\n", src_x, src_y, width, height, dest_x, dest_y);
+		height += dest_y;
+		if (height <= 0) return 0;
+		dest_y = 0;
+	}*/
+
 	// FIXME bpp 1
 	if (display->screens[0].root_visual->class == TrueColor && image->depth != 1)
-		return putTrueColorImage(display, d, gc, image, src_x, src_y, dest_x, dest_y, width, height);
-	return putImage(display, d, gc, image, src_x, src_y, dest_x, dest_y, width, height);
+		return putTrueColorImage(display, d, gc, image, src_x, src_y,
+			dest_x, dest_y, width, height);
+	return putImage(display, d, gc, image, src_x, src_y, dest_x, dest_y,
+			width, height);
+}
+
+#if 0
+/*
+ * This routine initializes the image object function pointers.  The
+ * intent is to provide native (i.e. fast) routines for native format images
+ * only using the generic (i.e. slow) routines when fast ones don't exist.
+ * However, with the current rather botched external interface, clients may
+ * have to mung image attributes after the image gets created, so the fast
+ * routines always have to check to make sure the optimization is still
+ * valid, and reinit the functions if not.
+ */
+void _XInitImageFuncPtrs(XImage *image)
+{
+	image->f.create_image = XCreateImage;
+	image->f.destroy_image = _XDestroyImage;
+	if ((image->format == ZPixmap) && (image->bits_per_pixel == 8)) {
+		image->f.get_pixel = _XGetPixel8;
+		image->f.put_pixel = _XPutPixel8;
+	} else if (((image->bits_per_pixel | image->depth) == 1) &&
+		(image->byte_order == image->bitmap_bit_order)) {
+		image->f.get_pixel = _XGetPixel1;
+		image->f.put_pixel = _XPutPixel1;
+	} else if ((image->format == ZPixmap) &&
+		(image->bits_per_pixel == 32)) {
+		image->f.get_pixel = _XGetPixel32;
+		image->f.put_pixel = _XPutPixel32;
+	} else if ((image->format == ZPixmap) &&
+		(image->bits_per_pixel == 16)) {
+		image->f.get_pixel = _XGetPixel16;
+		image->f.put_pixel = _XPutPixel16;
+	} else {
+		image->f.get_pixel = _XGetPixel;
+		image->f.put_pixel = _XPutPixel;
+	}
+	image->f.sub_image = _XSubImage;
+/*	image->f.set_image = _XSetImage;*/
+	image->f.add_pixel = _XAddPixel;
+}
+#endif
+
+// required for gtk
+#define ROUNDUP(nbytes, pad) ((((nbytes) + ((pad)-1)) / (pad)) * ((pad)>>3))
+Status XInitImage(XImage *image)
+{
+	int min_bytes_per_line;
+	printf("XInitImage called..\n");
+//	return 0;
+
+	if (image->depth == 0 || image->depth > 32 ||
+		image->bits_per_pixel > 32 || image->bitmap_unit > 32 ||
+		image->bits_per_pixel < 0 || image->bitmap_unit < 0 ||
+		(image->format != XYBitmap && image->format != XYPixmap &&
+		image->format != ZPixmap) ||
+		(image->format == XYBitmap && image->depth != 1) ||
+		(image->bitmap_pad != 8 && image->bitmap_pad != 16 &&
+		image->bitmap_pad != 32) || image->xoffset < 0)
+		return 0;
+
+	// compute per line accelerator.
+	if (image->format == ZPixmap) {
+		min_bytes_per_line =
+			ROUNDUP((image->bits_per_pixel * image->width), image->bitmap_pad);
+	} else {
+		min_bytes_per_line =
+			ROUNDUP((image->width + image->xoffset), image->bitmap_pad);
+	}
+
+	if (image->bytes_per_line == 0) {
+		image->bytes_per_line = min_bytes_per_line;
+	} else if (image->bytes_per_line < min_bytes_per_line) {
+		return 0;
+	}
+	//_XInitImageFuncPtrs(image);
+	setImageFunc(image);
+
+	return 1;
 }
diff -Nuarp nxlib-0.47dev.orig/Locale.c nxlib-0.47dev/Locale.c
--- nxlib-0.47dev.orig/Locale.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Locale.c	2013-02-25 14:47:09.000000000 +0900
@@ -0,0 +1,13 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include <stdio.h>
+#include <stdlib.h>
+
+// required for Xt
+char *XSetLocaleModifiers(char *modifier_list)
+{
+	printf("XSetLocaleModifiers called [%s]\n", modifier_list);
+	return getenv("LANG");
+}
diff -Nuarp nxlib-0.47dev.orig/Makefile nxlib-0.47dev/Makefile
--- nxlib-0.47dev.orig/Makefile	2011-07-30 06:58:18.000000000 +0900
+++ nxlib-0.47dev/Makefile	2013-02-25 16:23:56.000000000 +0900
@@ -1,7 +1,5 @@
-# 9 Dec 2010
 #
-# NXLIB library makefile - X11 Conversion Library for Nano-X
-# Greg Haerr <greg@censoft.com>
+# Nano-X11 library makefile
 #
 # Note: if build fails, rebuild keysymstr.h by "make distclean", then "make"
 #
@@ -11,51 +9,30 @@
 BIGENDIAN=N
 
 # comment out to stop debug printfs
-CFLAGS += -DDEBUG=1 -g
+#CFLAGS += -DDEBUG=1 -g
 
 # Compile-time nano-X include and lib directories. (relative paths ok)
-#
-MWIN_INCLUDE=../microwin/src/include
-MWIN_LIB=../microwin/src/lib
+MWIN=../core/src
+MWIN_INCLUDE=$(MWIN)/include
+MWIN_LIB=$(MWIN)/lib
 
 # Compile-time X11 include directory
-#
-# Although X11 headers haven't changed structurally in years,
-# these locations should match headers on target system.
-# NXLIB includes local X11R6 headers in case X11 isn't installed
-# on the cross-compiling host.
-#
-# if X11 not installed:
-#	X11_INCLUDE=.
-# if X11 installed:
-#	X11_INCLUDE=/usr/include/X11
-#
 X11_INCLUDE=.
 #X11_INCLUDE=/usr/include/X11
 
 # Run-time font directory and rgb.txt file location:
-# For testing, relative paths are ok, default is local rgb.txt and fonts
-# Modify FONT_DIR_LIST in fontlist.c to add font search directories
-#
-# For release, full paths are required matching target system locations
-#	X11_RGBTXT=/usr/share/X11/rgb.txt
-#
 #X11_RGBTXT=fonts/rgb.txt
 X11_RGBTXT=/usr/share/X11/rgb.txt
+#X11_FONT_DIR1=/usr/share/X11/fonts/misc
+#X11_FONT_DIR2=/usr/share/fonts/ja/TrueType
 
 # NXLIB library name and installation directory for "make install"
-# Installation is only required when wanting to completely
-# create a libX11.so that allows unmodified changes to X11
-# application makefiles. In the normal case, and when
-# cross-compiling on a system with X11, no installation
-# is possible (as libX11.so would be replaced), and
-# the link command is changed from '-lX11' to '-lNX11 -lnano-X'
-LIBNAME=NX11
+LIBNAME=X11
 xINSTALL_DIR=.
-INSTALL_DIR=/usr/local/lib
+INSTALL_DIR=/usr/lib
 
 # set to Y to make shared libNX11.so library, shared lib dependencies
-SHAREDLIB=N
+SHAREDLIB=Y
 SOLIBREV=0.47
 SOEXTRALIBS = -L$(MWIN_LIB) -lnano-X
 
@@ -92,7 +69,10 @@ OBJS = DestWind.o MapWindow.o NextEvent.
 	ListPix.o GetGeom.o SetIFocus.o Shape.o\
 	ClassHint.o Text16.o TextExt.o\
 	AllocColor.o ParseColor.o QueryColor.o Colormap.o Colorname.o\
-	Selection.o XMisc.o Free.o stub.o
+	Selection.o XMisc.o Free.o stub.o \
+	Request.o Context.o Grab.o Screen.o Extension.o XKB.o Locale.o \
+	Resource.o GetGCVals.o Threads.o IM.o SetWMProto.o FontInfo.o \
+	GetPntMap.o GetWMProps.o ChSaveSet.o TextToStr.o QueryBest.o
 
 ifeq ($(INCLUDE_XRM), Y)
 OBJS += Quarks.o Xrm.o
diff -Nuarp nxlib-0.47dev.orig/NextEvent.c nxlib-0.47dev/NextEvent.c
--- nxlib-0.47dev.orig/NextEvent.c	2011-02-20 05:38:06.000000000 +0900
+++ nxlib-0.47dev/NextEvent.c	2013-02-25 15:24:39.000000000 +0900
@@ -106,6 +106,10 @@ translateNXEvent(Display *dpy, GR_EVENT
 				event->xcrossing.state |= Button2Mask;
 			if (pev->buttons & GR_BUTTON_R)
 				event->xcrossing.state |= Button3Mask;
+			/*if (pev->buttons & GR_BUTTON_UP)
+				event->xcrossing.state |= Button4Mask;
+			if (pev->buttons & GR_BUTTON_DOWN)
+				event->xcrossing.state |= Button5Mask;*/
 		}
 		break;
 
@@ -131,6 +135,10 @@ translateNXEvent(Display *dpy, GR_EVENT
 				event->xmotion.state |= Button2Mask;
 			if (pev->buttons & GR_BUTTON_R)
 				event->xmotion.state |= Button3Mask;
+			/*if (pev->buttons & GR_BUTTON_UP)
+				event->xmotion.state |= Button4Mask;
+			if (pev->buttons & GR_BUTTON_DOWN)
+				event->xmotion.state |= Button5Mask;*/
 		}
 		break;
 
@@ -157,12 +165,20 @@ translateNXEvent(Display *dpy, GR_EVENT
 				event->xbutton.button = Button2;
 			else if (pev->changebuttons & GR_BUTTON_R)
 				event->xbutton.button = Button3;
+			/*else if (pev->changebuttons & GR_BUTTON_UP)
+				event->xbutton.button = Button4;
+			else if (pev->changebuttons & GR_BUTTON_DOWN)
+				event->xbutton.button = Button5;*/
 			if (pev->buttons & GR_BUTTON_L)
 				event->xbutton.state |= Button1Mask;
 			if (pev->buttons & GR_BUTTON_M)
 				event->xbutton.state |= Button2Mask;
 			if (pev->buttons & GR_BUTTON_R)
 				event->xbutton.state |= Button3Mask;
+			/*if (pev->buttons & GR_BUTTON_UP)
+				event->xbutton.state |= Button4Mask;
+			if (pev->buttons & GR_BUTTON_DOWN)
+				event->xbutton.state |= Button5Mask;*/
 		}
 		break;
 	case GR_EVENT_TYPE_BUTTON_UP:
@@ -187,12 +203,20 @@ translateNXEvent(Display *dpy, GR_EVENT
 				event->xbutton.button = Button2;
 			else if (pev->changebuttons & GR_BUTTON_R)
 				event->xbutton.button = Button3;
+			/*else if (pev->changebuttons & GR_BUTTON_UP)
+				event->xbutton.button = Button4;
+			else if (pev->changebuttons & GR_BUTTON_DOWN)
+				event->xbutton.button = Button5;*/
 			if (pev->buttons & GR_BUTTON_L)
 				event->xbutton.state |= Button1Mask;
 			if (pev->buttons & GR_BUTTON_M)
 				event->xbutton.state |= Button2Mask;
 			if (pev->buttons & GR_BUTTON_R)
 				event->xbutton.state |= Button3Mask;
+			/*if (pev->buttons & GR_BUTTON_UP)
+				event->xbutton.state |= Button4Mask;
+			if (pev->buttons & GR_BUTTON_DOWN)
+				event->xbutton.state |= Button5Mask;*/
 		}
 		break;
 
diff -Nuarp nxlib-0.47dev.orig/PmapBgnd.c nxlib-0.47dev/PmapBgnd.c
--- nxlib-0.47dev.orig/PmapBgnd.c	2010-12-10 04:03:21.000000000 +0900
+++ nxlib-0.47dev/PmapBgnd.c	2013-02-25 14:37:06.000000000 +0900
@@ -1,14 +1,18 @@
 #include "nxlib.h"
 
-int
-XSetWindowBackgroundPixmap(Display * dpy, Window w, Pixmap pixmap)
+int XSetWindowBackgroundPixmap(Display *dpy, Window w, Pixmap pixmap)
 {
 	/* FIXME... if ParentRelative is specified, then we should use our */
 	/* parent's background pixmap.  That would involve a copy???      */
 
-DPRINTF("XSetWindowBackgroundPixmap %d %d\n", (int)w, (int)pixmap);
-	if (pixmap == ParentRelative)
+	printf("XSetWindowBackgroundPixmap %d %d\n", (int)w, (int)pixmap);
+	if (pixmap == ParentRelative) {
 		return 1;
+		/*GR_WINDOW_INFO wp;
+		GrGetWindowInfo(w, &wp);
+		GrGetWindowInfo(wp.parent, &wp);
+		pixmap = wp.bgpixid;*/
+	}
 
 	GrSetBackgroundPixmap(w, pixmap, GR_BACKGROUND_TILE);
 	return 1;
diff -Nuarp nxlib-0.47dev.orig/QueryBest.c nxlib-0.47dev/QueryBest.c
--- nxlib-0.47dev.orig/QueryBest.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/QueryBest.c	2013-02-25 14:36:22.000000000 +0900
@@ -0,0 +1,13 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+Status XQueryBestSize(Display *dpy, int class, Drawable which_screen, unsigned int  width, unsigned int height, unsigned int *w, unsigned int *h)
+{
+	printf("XQueryBestSize called\n");
+	*w = width;
+	*h = height;
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/Region.c nxlib-0.47dev/Region.c
--- nxlib-0.47dev.orig/Region.c	2010-12-10 04:02:32.000000000 +0900
+++ nxlib-0.47dev/Region.c	2013-02-25 14:35:46.000000000 +0900
@@ -65,16 +65,25 @@ XUnionRectWithRegion(XRectangle *rect, R
 	if (!rect->width || !rect->height)
 		return 0;
 
-	if (source != dest)
-		DPRINTF("XUnionRectWithRegion - Source and dest different FIXME\n");
-
 	/* copy rect since dimensions differ*/
 	gr_rect.x = rect->x;
 	gr_rect.y = rect->y;
 	gr_rect.width = rect->width;
 	gr_rect.height = rect->height;
 
-	GrUnionRectWithRegion(dest->rid, &gr_rect);
+	if (source != dest) {
+		/*Region r = XCreateRegion();
+		if (!r) return 0;
+		//GrUnionRectWithRegion(r->rid, &gr_rect);
+		GrSetRectRegionIndirect(r->rid, &gr_rect);
+		XUnionRegion(r, source, dest);
+		XDestroyRegion(r);*/
+
+		printf("XUnionRectWithRegion - Source and dest different FIXME\n");
+		GrUnionRectWithRegion(dest->rid, &gr_rect);
+	} else {
+		GrUnionRectWithRegion(dest->rid, &gr_rect);
+	}
 
 #if CLIENTREGIONS
 	GR_RECT extents;
@@ -84,6 +93,21 @@ XUnionRectWithRegion(XRectangle *rect, R
 #endif
 	return 1;
 }
+/*int XUnionRectWithRegion(XRectangle *rect, Region source, Region dest)
+{
+	REGION region;
+
+	if (!rect->width || !rect->height) return 0;
+	region.rects = &region.extents;
+	region.numRects = 1;
+	region.extents.x1 = rect->x;
+	region.extents.y1 = rect->y;
+	region.extents.x2 = rect->x + rect->width;
+	region.extents.y2 = rect->y + rect->height;
+	region.size = 1;
+
+	return XUnionRegion(&region, source, dest);
+}*/
 
 int
 XPointInRegion(Region region, int x, int y)
diff -Nuarp nxlib-0.47dev.orig/Request.c nxlib-0.47dev/Request.c
--- nxlib-0.47dev.orig/Request.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Request.c	2013-02-25 14:23:13.000000000 +0900
@@ -0,0 +1,19 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// required for libXrender.so
+unsigned long XNextRequest(Display *display)
+{
+	printf("XNextRequest called...\n");
+	return ++display->request;
+}
+
+// required for gdk
+long XExtendedMaxRequestSize(Display *display)
+{
+	printf("XExtendedMaxRequestSize called...\n");
+	return 0;
+}
diff -Nuarp nxlib-0.47dev.orig/Resource.c nxlib-0.47dev/Resource.c
--- nxlib-0.47dev.orig/Resource.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Resource.c	2013-02-25 14:22:58.000000000 +0900
@@ -0,0 +1,11 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+char *XResourceManagerString(Display *display)
+{
+	printf("XResourceManagerString called...\n");
+	return "LimeX:0";
+}
diff -Nuarp nxlib-0.47dev.orig/Screen.c nxlib-0.47dev/Screen.c
--- nxlib-0.47dev.orig/Screen.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Screen.c	2013-02-25 14:21:21.000000000 +0900
@@ -0,0 +1,54 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+int XDisplayHeight(Display *display, int screen_number)
+{
+//	printf("XDisplayHeight called\n");
+//	return 480;
+
+	GR_SCREEN_INFO sip;
+	GrGetScreenInfo(&sip);
+	printf("XDisplayHeight called [%d]\n", sip.vs_height);
+	return sip.vs_height;
+}
+
+int XDisplayWidth(Display *display, int screen_number)
+{
+//	printf("XDisplayWidth called\n");
+//	return 640;
+
+	GR_SCREEN_INFO sip;
+	GrGetScreenInfo(&sip);
+	printf("XDisplayWidth called [%d]\n", sip.vs_width);
+	return sip.vs_width;
+}
+
+// XListDepths - return info from connection setup
+int *XListDepths(Display *dpy, int scrnum, int *countp)
+{
+	Screen *scr;
+	int count;
+	int *depths;
+
+	printf("XListDepths called..\n");
+	if (scrnum < 0 || scrnum >= dpy->nscreens) return NULL;
+
+	scr = &dpy->screens[scrnum];
+	if ((count = scr->ndepths) > 0) {
+		Depth *dp;
+		int i;
+
+		depths = (int*) Xmalloc (count * sizeof(int));
+		if (!depths) return NULL;
+		for (i = 0, dp = scr->depths; i < count; i++, dp++)
+		depths[i] = dp->depth;
+	} else {
+		/* a screen must have a depth */
+		return NULL;
+	}
+	*countp = count;
+	return depths;
+}
diff -Nuarp nxlib-0.47dev.orig/SetAttributes.c nxlib-0.47dev/SetAttributes.c
--- nxlib-0.47dev.orig/SetAttributes.c	2010-12-10 04:00:42.000000000 +0900
+++ nxlib-0.47dev/SetAttributes.c	2013-02-25 14:18:13.000000000 +0900
@@ -4,16 +4,31 @@ int
 XChangeWindowAttributes(Display * display, Window w, unsigned long valuemask,
 			XSetWindowAttributes * attributes)
 {
-DPRINTF("XChangeWindowAttributes: valuemask 0x%X\n", (int)valuemask);
+	DPRINTF("XChangeWindowAttributes: valuemask 0x%X\n", (int)valuemask);
 
-	if (valuemask & CWBackPixel)
+	if (valuemask & CWBackPixmap)	// 1
+		XSetWindowBackgroundPixmap(display, w, attributes->background_pixmap);
+	if (valuemask & CWBackPixel)	// 2
 		XSetWindowBackground(display, w, attributes->background_pixel);
 
-	if (valuemask & CWBorderPixel)
+	if (valuemask & CWBorderPixmap)	// 4
+		XSetWindowBorderPixmap(display, w, attributes->border_pixmap);
+	if (valuemask & CWBorderPixel)	// 8
 		XSetWindowBorder(display, w, attributes->border_pixel);
 
+//http://karel.tsuda.ac.jp/lec/x/c1/
+//	if (valuemask & CWBitGravity)	// 0x10
+//		XSetWindowBorder(display, w, attributes->border_pixel);
+
+	//CWSaveUnder
 	if (valuemask & CWEventMask)
 		XSelectInput(display, w, attributes->event_mask);
+	//CWDontPropagate
+
+	if (valuemask & CWColormap)
+		XSetWindowColormap(display, w, attributes->colormap);
+	if (valuemask & CWCursor)
+		XDefineCursor(display, w, attributes->cursor);
 
 	if (valuemask & CWOverrideRedirect) {
 		GR_WM_PROPERTIES props;
diff -Nuarp nxlib-0.47dev.orig/SetIFocus.c nxlib-0.47dev/SetIFocus.c
--- nxlib-0.47dev.orig/SetIFocus.c	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/SetIFocus.c	2013-02-25 14:14:20.000000000 +0900
@@ -1,8 +1,17 @@
 #include "nxlib.h"
 
-int
-XSetInputFocus(Display *dpy, Window focus, int revert_to, Time time)
+int XSetInputFocus(Display *dpy, Window focus, int revert_to, Time time)
 {
 	GrSetFocus(focus);
 	return 1;
 }
+
+int XGetInputFocus(Display *dpy, Window *focus, int *revert_to)
+{
+	*focus = GrGetFocus();
+	printf("XGetInputFocus called [%d]\n", *focus);
+	if (*focus == 1) *revert_to = RevertToPointerRoot;
+	else if (*focus) *revert_to = RevertToParent;
+	else *revert_to = RevertToNone;
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/SetWMProps.c nxlib-0.47dev/SetWMProps.c
--- nxlib-0.47dev.orig/SetWMProps.c	2010-03-20 01:56:05.000000000 +0900
+++ nxlib-0.47dev/SetWMProps.c	2013-02-25 15:35:34.000000000 +0900
@@ -3,12 +3,42 @@
 #include "X11/Xutil.h"
 #include "X11/Xatom.h"
 
-int XSetTransientForHint(Display* display, Window w, Window prop_window) {
+void XSetTextProperty(Display *dpy, Window w, XTextProperty *tp, Atom property)
+{
+	printf("XSetTextProperty called [%s]\n", tp?tp->value:"(NULL)");
+	XChangeProperty(dpy, w, property, tp->encoding, tp->format,
+		PropModeReplace, tp->value, tp->nitems);
+}
+
+void XSetWMClientMachine(Display *dpy, Window w, XTextProperty *tp)
+{
+	XSetTextProperty(dpy, w, tp, XA_WM_CLIENT_MACHINE);
+}
+
+// ClassHint.c
+/*int XSetTransientForHint(Display* display, Window w, Window prop_window)
+{
 	XChangeProperty(display, w, XA_WM_TRANSIENT_FOR, XA_WINDOW, 32,
 		PropModeReplace, (unsigned char *)&prop_window, 1);
 	return 1;
-}
+}*/
+
+/*void XSetWMName(Display *dpy, Window w, XTextProperty *tp)
+{
+	XSetTextProperty(dpy, w, tp, XA_WM_NAME);
+}*/
+/*void XSetWMName(Display *display, Window w, XTextProperty *name)
+{
+	GR_WM_PROPERTIES props;
+
+	if (!name || !name->value) return;
 
+	props.flags = GR_WM_FLAGS_TITLE;
+	props.title = name->value;
+	GrSetWMProperties(w, &props);
+
+	XSetTextProperty(display, w, name, XA_WM_NAME);	// Add
+}*/
 void
 XSetWMName(Display * display, Window w, XTextProperty * name)
 {
@@ -16,29 +46,38 @@ XSetWMName(Display * display, Window w,
 		PropModeReplace, (unsigned char *)name->value, name->nitems);
 }
 
-/* Not used */
-void
-XSetWMIconName(Display * display, Window w, XTextProperty * name)
+void XSetWMIconName(Display *dpy, Window w, XTextProperty *tp)
 {
+	XSetTextProperty(dpy, w, tp, XA_WM_ICON_NAME);
 }
 
-/* Not used */
-void
-XSetWMNormalHints(Display * display, Window w, XSizeHints * hints)
+#define NumPropSizeElements 18		/* ICCCM version 1 */
+void XSetWMSizeHints(Display *dpy, Window w, XSizeHints *hints, Atom prop)
 {
+	printf("XSetWMSizeHints called..\n");
+	XChangeProperty(dpy, w, prop, XA_WM_SIZE_HINTS, 32, PropModeReplace,
+		(unsigned char*)hints, NumPropSizeElements);
 }
 
-/* Not used */
-int
-XSetWMHints(Display * display, Window w, XWMHints * hints)
+void XSetWMNormalHints(Display *dpy, Window w, XSizeHints *hints)
 {
-	return 1;
+	//printf("XSetWMNormalHints called\n");
+	XSetWMSizeHints(dpy, w, hints, XA_WM_NORMAL_HINTS);
+}
+
+#define NumPropWMHintsElements 9 /* number of elements in this structure */
+int XSetWMHints(Display *dpy, Window w, XWMHints *hints)
+{
+	printf("XSetWMHints called..\n");
+	//return 1;
+	return XChangeProperty(dpy, w, XA_WM_HINTS, XA_WM_HINTS, 32,
+		PropModeReplace, (unsigned char*)hints, NumPropWMHintsElements);
 }
 
 /* Not used */
-void
-XSetWMClassHints(Display * display, Window w, XClassHint * hints)
+void XSetWMClassHints(Display *display, Window w, XClassHint *hints)
 {
+	printf("XSetWMClassHints called\n");
 }
 
 XSizeHints *
@@ -82,10 +121,16 @@ XmbSetWMProperties(Display *dpy, Window
 	/* fake up XTextProperty struct members for XSetWMName*/
 	if (windowName) {
 		wname.value = (unsigned char *)windowName;
+		wname.encoding = XA_STRING;
+		wname.format = 8;
+		wname.nitems = strlen(windowName);
 		wprop = &wname;
 	}
 	if (iconName) {
 		iname.value = (unsigned char *)iconName;
+		iname.encoding = XA_STRING;
+		iname.format = 8;
+		iname.nitems = strlen(iconName);
 		iprop = &iname;
 	}
 	XSetWMProperties(dpy, w, wprop, iprop, argv, argc, sizeHints, wmHints,
diff -Nuarp nxlib-0.47dev.orig/SetWMProto.c nxlib-0.47dev/SetWMProto.c
--- nxlib-0.47dev.orig/SetWMProto.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/SetWMProto.c	2013-02-25 14:22:09.000000000 +0900
@@ -0,0 +1,49 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+#include "X11/Xatom.h"
+
+// XSetWMProtocols sets the property
+//	WM_PROTOCOLS 	type: ATOM	format: 32
+Status XSetWMProtocols(Display *dpy, Window w, Atom *protocols, int count)
+{
+	Atom prop;
+
+	prop = XInternAtom(dpy, "WM_PROTOCOLS", False);
+	if (prop == None) return False;
+
+	XChangeProperty(dpy, w, prop, XA_ATOM, 32,
+			PropModeReplace, (unsigned char *)protocols, count);
+	return True;
+}
+
+//#include <stdio.h>
+Status XGetWMProtocols(Display *dpy, Window w, Atom **protocols, int *countReturn)
+{
+	Atom *data = NULL;
+	Atom actual_type;
+	Atom prop;
+	int actual_format;
+	unsigned long leftover, nitems;
+
+	prop =  XInternAtom(dpy, "WM_PROTOCOLS", False);
+	if (prop == None) return False;
+
+	/* get the property */
+	if (XGetWindowProperty(dpy, w, prop, 0L, 1000000L, False,
+		XA_ATOM, &actual_type, &actual_format,
+		&nitems, &leftover, (unsigned char **)&data)
+		!= Success)
+	return False;
+
+	if (actual_type != XA_ATOM || actual_format != 32) {
+		if (data) Xfree((char*)data);
+		return False;
+	}
+
+	*protocols = (Atom*)data;
+	*countReturn = (int)nitems;
+	return True;
+}
diff -Nuarp nxlib-0.47dev.orig/Shape.c nxlib-0.47dev/Shape.c
--- nxlib-0.47dev.orig/Shape.c	2010-01-25 13:03:08.000000000 +0900
+++ nxlib-0.47dev/Shape.c	2013-02-25 14:07:22.000000000 +0900
@@ -23,3 +23,23 @@ XShapeCombineMask(Display *dpy, Window d
 	GrSetWindowRegion(dest, mask, mask);
 	GrDestroyRegion(mask);
 }
+
+// from /usr/include/X11/extensions/shapestr.h
+#define SHAPENAME "SHAPE"
+#define SHAPE_MAJOR_VERSION	1	/* current version numbers */
+#define SHAPE_MINOR_VERSION	1
+
+Bool XShapeQueryExtension(Display *dpy, int *event_base, int *error_base)
+{
+/*	*event_base = LASTEvent +1;
+	*error_base = 0;
+	return 1;*/
+	return XQueryExtension(dpy, SHAPENAME, NULL, event_base, error_base);
+}
+
+Status XShapeQueryVersion(Display *dpy, int *major, int *minor)
+{
+	*major = SHAPE_MAJOR_VERSION;
+	*minor = SHAPE_MINOR_VERSION;
+	return 1;
+}
diff -Nuarp nxlib-0.47dev.orig/StrKeysym.c nxlib-0.47dev/StrKeysym.c
--- nxlib-0.47dev.orig/StrKeysym.c	2010-12-10 04:05:22.000000000 +0900
+++ nxlib-0.47dev/StrKeysym.c	2013-02-25 14:07:10.000000000 +0900
@@ -1,5 +1,3 @@
-/* Portions Copyright 2003, Jordan Crouse (jordan@cosmicpenguin.net) */
-
 #include "nxlib.h"
 #include <string.h>
 #include "X11/keysym.h"
@@ -23,6 +21,7 @@ static MWKEYMOD modstate;
 static int map_loaded = 0;
 #endif /* linux*/
 
+#if 0
 /* Standard keymapings for kernel values */
 /* (from microwin/src/drivers/keymap_standard.h)*/
 /* this table should be retrieved through Microwindows*/
@@ -54,6 +53,145 @@ MWKEY_UNKNOWN,MWKEY_UNKNOWN,MWKEY_UNKNOW
 MWKEY_UNKNOWN,MWKEY_UNKNOWN,MWKEY_UNKNOWN,MWKEY_UNKNOWN,MWKEY_UNKNOWN,	/* 120*/
 MWKEY_LMETA, MWKEY_RMETA, MWKEY_MENU					/* 125*/
 };
+#else
+/*
+ * Microwindows ttyscan.c compatible scancode conversion
+ * table.  Note this is NOT the same as the Linux kernel
+ * table due to the HACK XXX in ttyscan.c after getting
+ * the kernel scancode.  FIXME
+ */
+#define UNKNOWN	0
+static MWKEY mwscan_to_mwkey[128] = {
+	UNKNOWN,	/*  0*/
+	UNKNOWN,	/*  1*/
+	UNKNOWN,	/*  2*/
+	UNKNOWN,	/*  3*/
+	UNKNOWN,	/*  4*/
+	UNKNOWN,	/*  5*/
+	UNKNOWN,	/*  6*/
+	UNKNOWN,	/*  7*/
+	UNKNOWN,	/*  8*/
+	MWKEY_ESCAPE,	/*  9*/
+	'1',		/* 10*/
+	'2',		/* 11*/
+	'3',		/* 12*/
+	'4',		/* 13*/
+	'5',		/* 14*/
+	'6',		/* 15*/
+	'7',		/* 16*/
+	'8',		/* 17*/
+	'9',		/* 18*/
+	'0',		/* 19*/
+	'-',		/* 20*/
+	UNKNOWN,	/* 21*/
+	MWKEY_BACKSPACE,/* 22*/
+	MWKEY_TAB,	/* 23*/
+	'q',		/* 24*/
+	'w',		/* 25*/
+	'e',		/* 26*/
+	'r',		/* 27*/
+	't',		/* 28*/
+	'y',		/* 29*/
+	'u',		/* 30*/
+	'i',		/* 31*/
+	'o',		/* 32*/
+	'p',		/* 33*/
+	'[',		/* 34*/
+	']',		/* 35*/
+	MWKEY_ENTER,	/* 36*/
+	MWKEY_LCTRL,	/* 37*/
+	'a',		/* 38*/
+	's',		/* 39*/
+	'd',		/* 40*/
+	'f',		/* 41*/
+	'g',		/* 42*/
+	'h',		/* 43*/
+	'j',		/* 44*/
+	'k',		/* 45*/
+	'l',		/* 46*/
+	';',		/* 47*/
+	'\'',		/* 48*/
+	'`',		/* 49*/
+	MWKEY_LSHIFT,	/* 50*/
+	'\\',		/* 51*/
+	'z',		/* 52*/
+	'x',		/* 53*/
+	'c',		/* 54*/
+	'v',		/* 55*/
+	'b',		/* 56*/
+	'n',		/* 57*/
+	'm',		/* 58*/
+	',',		/* 59*/
+	'.',		/* 60*/
+	'/',		/* 61*/
+	MWKEY_RSHIFT,	/* 62*/
+	MWKEY_KP_MULTIPLY,/* 63*/
+	MWKEY_LALT,	/* 64*/
+	' ',		/* 65*/
+	UNKNOWN,	/* 66*/
+	MWKEY_F1,	/* 67*/
+	MWKEY_F2,	/* 68*/
+	MWKEY_F3,	/* 69*/
+	MWKEY_F4,	/* 70*/
+	MWKEY_F5,	/* 71*/
+	MWKEY_F6,	/* 72*/
+	MWKEY_F7,	/* 73*/
+	MWKEY_F8,	/* 74*/
+	MWKEY_F9,	/* 75*/
+	MWKEY_F10,	/* 76*/
+	UNKNOWN,	/* 77*/
+	UNKNOWN,	/* 78*/
+	MWKEY_KP7,	/* 79*/
+	MWKEY_KP8,	/* 80*/
+	MWKEY_KP9,	/* 81*/
+	MWKEY_KP_MINUS,	/* 82*/
+	MWKEY_KP4,	/* 83*/
+	MWKEY_KP5,	/* 84*/
+	MWKEY_KP6,	/* 85*/
+	MWKEY_KP_PLUS,	/* 86*/
+	MWKEY_KP1,	/* 87*/
+	MWKEY_KP2,	/* 88*/
+	MWKEY_KP3,	/* 89*/
+	MWKEY_KP0,	/* 90*/
+	MWKEY_KP_PERIOD,/* 91*/
+	UNKNOWN,	/* 92*/
+	UNKNOWN,	/* 93*/
+	UNKNOWN,	/* 94*/
+	MWKEY_F11,	/* 95*/
+	MWKEY_F12,	/* 96*/
+	MWKEY_HOME,	/* 97*/
+	MWKEY_UP,	/* 98*/
+	MWKEY_PAGEUP,	/* 99*/
+	MWKEY_LEFT,	/*100*/
+	UNKNOWN,	/*101*/
+	MWKEY_RIGHT,	/*102*/
+	MWKEY_END,	/*103*/
+	MWKEY_DOWN,	/*104*/
+	MWKEY_PAGEDOWN,	/*105*/
+	MWKEY_INSERT,	/*106*/
+	MWKEY_DELETE,	/*107*/
+	MWKEY_KP_ENTER,	/*108*/
+	MWKEY_RCTRL,	/*109*/
+	UNKNOWN,	/*110*/
+	MWKEY_PRINT,	/*111*/
+	MWKEY_KP_DIVIDE, /*112*/
+	MWKEY_RALT,	/*113*/
+	UNKNOWN,	/*114*/
+	UNKNOWN,	/*115*/
+	UNKNOWN,	/*116*/
+	UNKNOWN,	/*117*/
+	UNKNOWN,	/*118*/
+	UNKNOWN,	/*119*/
+	UNKNOWN,	/*120*/
+	UNKNOWN,	/*121*/
+	UNKNOWN,	/*122*/
+	UNKNOWN,	/*123*/
+	UNKNOWN,	/*124*/
+	UNKNOWN,	/*125*/
+	UNKNOWN,	/*126*/
+	UNKNOWN		/*127*/
+};
+#endif
 
 /* load Linux keyboard mappings, used as first try for scancode conversion*/
 static void
@@ -281,12 +419,14 @@ XKeycodeToKeysym(Display *dpy, unsigned
 	int	i;
 	MWKEY	mwkey;
 
+	printf("XKeycodeToKeysym called [key:%x]\n", kc);
 	if (kc > 127)
 		return NoSymbol;
 
 	/* first convert scancode to mwkey*/
 	mwkey = TranslateScancode(kc);
-	
+	//printf("-> [%x]\n", mwkey);
+
 	/* then possibly convert mwkey to X KeySym*/
 	for (i=0; mwkey_to_xkey[i].nxKey != 0xffff; i++) {
 		if (mwkey == mwkey_to_xkey[i].nxKey)
@@ -328,8 +468,10 @@ XLookupString(XKeyEvent *event, char *bu
 	if(!map_loaded) {
 		/* translate Control/Shift*/
 		if ((event->state & ControlMask) && k < 256)
+			// for Ctrl-key
 			k &= 0x1f;
 		else if (event->state & ShiftMask) {
+			// for Shift-key
 			if (k >= 'a' && k <= 'z')
 				k = k-'a'+'A';
 			else switch (k) {
@@ -355,12 +497,58 @@ XLookupString(XKeyEvent *event, char *bu
 			case '.': k = '>'; break;
 			case '/': k = '?'; break;
 			}
+		/*} else if (!(k >= 0x20 && k <= 0x7e)) {
+			switch (k) {
+			case MWKEY_BACKSPACE:	k = 8; break;
+			case MWKEY_TAB:		k = 9; break;
+			case MWKEY_ENTER:	k = 0xd; break;
+			case MWKEY_ESCAPE:	k = 0x1b; break;
+			case MWKEY_DELETE:	k = 0x7f; break;
+			//default:		k = 0;
+			}*/
+			/*if (keysym) *keysym = k;
+			if (nbytes > 0) buffer[0] = '\0';
+			return 0;*/
 		}
 	}
 
-	*keysym = k;
-	if (nbytes > 0)
-		buffer[0] = '\0';
+	if (keysym) *keysym = k;
+//	if (nbytes > 0) buffer[0] = '\0';
+//	return 0;
+	if (nbytes > 0/* && k*/ /*&& (k >= 0x20 && k <= 0x7e)*/) {
+//		*status = XLookupBoth;
+		if (k >= 0x20 && k <= 0xff) {
+			buffer[0] = k;
+			//buffer[1] = 0;
+		} else {
+			switch (k) {
+			case XK_BackSpace:	buffer[0] = 8; break;
+			case XK_Tab:		buffer[0] = 9; break;
+			case XK_KP_Enter:
+			case XK_Return:		buffer[0] = 0xd; break;
+			case XK_Escape:		buffer[0] = 0x1b; break;
+			case XK_Delete:		buffer[0] = 0x7f; break;
+			case XK_KP_End:		buffer[0] = '1'; break;
+			case XK_KP_Down:	buffer[0] = '2'; break;
+			case XK_KP_Page_Down:	buffer[0] = '3'; break;
+			case XK_KP_Left:	buffer[0] = '4'; break;
+			//case XK_KP_Home:	buffer[0] = '5'; break;
+			case XK_KP_Right:	buffer[0] = '6'; break;
+			case XK_KP_Home:	buffer[0] = '7'; break;
+			case XK_KP_Up:		buffer[0] = '8'; break;
+			case XK_KP_Page_Up:	buffer[0] = '9'; break;
+			case XK_KP_Insert:	buffer[0] = '0'; break;
+			case XK_KP_Delete:	buffer[0] = '.'; break;
+			case XK_KP_Add:		buffer[0] = '+'; break;
+			case XK_KP_Subtract:	buffer[0] = '-'; break;
+			case XK_KP_Divide:	buffer[0] = '/'; break;
+			case XK_KP_Multiply:	buffer[0] = '*'; break;
+			default:		buffer[0] = 0; return 0;
+			}
+		}
+		printf("XLookupString [%x]\n", buffer[0]);
+		return 1;
+	}
 	return 0;
 }
 
@@ -370,6 +558,7 @@ XStringToKeysym(_Xconst char *string)
 {
 	int i;
 
+	printf("XStringToKeysym called [%s]\n", string);
 	for (i=0; i < NX_KEYSYMSTR_COUNT; i++)
 		if (strcmp(nxKeyStrings[i].str, string) == 0)
 			return nxKeyStrings[i].keysym;
@@ -377,15 +566,23 @@ XStringToKeysym(_Xconst char *string)
 	return NoSymbol;
 }
 
-/* translate KeySym to KeyCode*/
-KeyCode
-XKeysymToKeycode(Display *dpy, KeySym ks)
+char *XKeysymToString(KeySym ks)
 {
 	int i;
 
-	for (i=0; i<128; ++i)
-		if (mwscan_to_mwkey[i] == ks)
-			return i;
+	printf("XKeysymToString called [%x]\n", (int)ks);
+	for (i=0; i < NX_KEYSYMSTR_COUNT; i++)
+		if (nxKeyStrings[i].keysym == ks) return nxKeyStrings[i].str;
+
+	return NULL;
+}
+
+/* translate KeySym to KeyCode*/
+KeyCode XKeysymToKeycode(Display *dpy, KeySym ks)
+{
+	int i;
+	printf("XKeysymToKeycode called [%x]\n", (int)ks);
+	for (i=0; i<128; ++i) if (mwscan_to_mwkey[i] == ks) return i;
 	return NoSymbol;
 }
 
@@ -401,143 +598,3 @@ XConvertCase(KeySym in, KeySym *upper, K
 		*lower = (in >= 'A' && in <= 'A')? in-'A'+'a': in;
 	}
 }
-  
-#if 0000
-/*
- * Microwindows ttyscan.c compatible scancode conversion
- * table.  Note this is NOT the same as the Linux kernel
- * table due to the HACK XXX in ttyscan.c after getting
- * the kernel scancode.  FIXME
- */
-#define UNKNOWN	0
-static MWKEY mwscan_to_mwkey[128] = {
-	UNKNOWN,	/*  0*/
-	UNKNOWN,	/*  1*/
-	UNKNOWN,	/*  2*/
-	UNKNOWN,	/*  3*/
-	UNKNOWN,	/*  4*/
-	UNKNOWN,	/*  5*/
-	UNKNOWN,	/*  6*/
-	UNKNOWN,	/*  7*/
-	UNKNOWN,	/*  8*/
-	MWKEY_ESCAPE,	/*  9*/
-	'1',		/* 10*/
-	'2',		/* 11*/
-	'3',		/* 12*/
-	'4',		/* 13*/
-	'5',		/* 14*/
-	'6',		/* 15*/
-	'7',		/* 16*/
-	'8',		/* 17*/
-	'9',		/* 18*/
-	'0',		/* 19*/
-	'-',		/* 20*/
-	UNKNOWN,	/* 21*/
-	MWKEY_BACKSPACE,/* 22*/
-	MWKEY_TAB,	/* 23*/
-	'q',		/* 24*/
-	'w',		/* 25*/
-	'e',		/* 26*/
-	'r',		/* 27*/
-	't',		/* 28*/
-	'y',		/* 29*/
-	'u',		/* 30*/
-	'i',		/* 31*/
-	'o',		/* 32*/
-	'p',		/* 33*/
-	'[',		/* 34*/
-	']',		/* 35*/
-	MWKEY_ENTER,	/* 36*/
-	MWKEY_LCTRL,	/* 37*/
-	'a',		/* 38*/
-	's',		/* 39*/
-	'd',		/* 40*/
-	'f',		/* 41*/
-	'g',		/* 42*/
-	'h',		/* 43*/
-	'j',		/* 44*/
-	'k',		/* 45*/
-	'l',		/* 46*/
-	';',		/* 47*/
-	'\'',		/* 48*/
-	'`',		/* 49*/
-	MWKEY_LSHIFT,	/* 50*/
-	'\\',		/* 51*/
-	'z',		/* 52*/
-	'x',		/* 53*/
-	'c',		/* 54*/
-	'v',		/* 55*/
-	'b',		/* 56*/
-	'n',		/* 57*/
-	'm',		/* 58*/
-	',',		/* 59*/
-	'.',		/* 60*/
-	'/',		/* 61*/
-	MWKEY_RSHIFT,	/* 62*/
-	MWKEY_KP_MULTIPLY,/* 63*/
-	MWKEY_LALT,	/* 64*/
-	' ',		/* 65*/
-	UNKNOWN,	/* 66*/
-	MWKEY_F1,	/* 67*/
-	MWKEY_F2,	/* 68*/
-	MWKEY_F3,	/* 69*/
-	MWKEY_F4,	/* 70*/
-	MWKEY_F5,	/* 71*/
-	MWKEY_F6,	/* 72*/
-	MWKEY_F7,	/* 73*/
-	MWKEY_F8,	/* 74*/
-	MWKEY_F9,	/* 75*/
-	MWKEY_F10,	/* 76*/
-	UNKNOWN,	/* 77*/
-	UNKNOWN,	/* 78*/
-	MWKEY_KP7,	/* 79*/
-	MWKEY_KP8,	/* 80*/
-	MWKEY_KP9,	/* 81*/
-	MWKEY_KP_MINUS,	/* 82*/
-	MWKEY_KP4,	/* 83*/
-	MWKEY_KP5,	/* 84*/
-	MWKEY_KP6,	/* 85*/
-	MWKEY_KP_PLUS,	/* 86*/
-	MWKEY_KP1,	/* 87*/
-	MWKEY_KP2,	/* 88*/
-	MWKEY_KP3,	/* 89*/
-	MWKEY_KP0,	/* 90*/
-	MWKEY_KP_PERIOD,/* 91*/
-	UNKNOWN,	/* 92*/
-	UNKNOWN,	/* 93*/
-	UNKNOWN,	/* 94*/
-	MWKEY_F11,	/* 95*/
-	MWKEY_F12,	/* 96*/
-	MWKEY_HOME,	/* 97*/
-	MWKEY_UP,	/* 98*/
-	MWKEY_PAGEUP,	/* 99*/
-	MWKEY_LEFT,	/*100*/
-	UNKNOWN,	/*101*/
-	MWKEY_RIGHT,	/*102*/
-	MWKEY_END,	/*103*/
-	MWKEY_DOWN,	/*104*/
-	MWKEY_PAGEDOWN,	/*105*/
-	MWKEY_INSERT,	/*106*/
-	MWKEY_DELETE,	/*107*/
-	MWKEY_KP_ENTER,	/*108*/
-	MWKEY_RCTRL,	/*109*/
-	UNKNOWN,	/*110*/
-	MWKEY_PRINT,	/*111*/
-	MWKEY_KP_DIVIDE, /*112*/
-	MWKEY_RALT,	/*113*/
-	UNKNOWN,	/*114*/
-	UNKNOWN,	/*115*/
-	UNKNOWN,	/*116*/
-	UNKNOWN,	/*117*/
-	UNKNOWN,	/*118*/
-	UNKNOWN,	/*119*/
-	UNKNOWN,	/*120*/
-	UNKNOWN,	/*121*/
-	UNKNOWN,	/*122*/
-	UNKNOWN,	/*123*/
-	UNKNOWN,	/*124*/
-	UNKNOWN,	/*125*/
-	UNKNOWN,	/*126*/
-	UNKNOWN		/*127*/
-};
-#endif
diff -Nuarp nxlib-0.47dev.orig/Text.c nxlib-0.47dev/Text.c
--- nxlib-0.47dev.orig/Text.c	2010-02-22 07:18:48.000000000 +0900
+++ nxlib-0.47dev/Text.c	2013-02-25 13:56:49.000000000 +0900
@@ -5,8 +5,11 @@ XDrawString(Display *dpy, Drawable d, GC
 	_Xconst char *string, int length)
 {   
 	if (length > 0)
+	{
+		GrSetGCUseBackground(gc->gid, GR_FALSE);
 		GrText(d, gc->gid, x, y, (char *)string, length,
 		       GR_TFASCII|GR_TFBASELINE);
+	}
 	return 0;
 }
 
diff -Nuarp nxlib-0.47dev.orig/Text16.c nxlib-0.47dev/Text16.c
--- nxlib-0.47dev.orig/Text16.c	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/Text16.c	2013-02-25 13:56:11.000000000 +0900
@@ -4,7 +4,7 @@ int
 XDrawString16(Display *dpy, Drawable d, GC gc, int x, int y,
 	_Xconst XChar2b *string, int length)
 {   
-printf("XDrawString16 %d %x %x\n", length, string->byte1, string->byte2);
+	printf("XDrawString16 %d %x %x\n", length, string->byte1, string->byte2);
 	if (length > 0)
 		GrText(d, gc->gid, x, y, (void *)string, length, 
 		       GR_TFXCHAR2B|GR_TFBASELINE);
@@ -24,3 +24,11 @@ XDrawImageString16(Display *dpy, Drawabl
 	return 0;
 }
 
+//http://xjman.dsl.gr.jp/X11R6/X11/CH08.html
+int XDrawText16(Display *dpy, Drawable d, GC gc, int x, int y, XTextItem16 *items, int nitems)
+{
+	printf("XDrawText16 called..\n");
+//	item = items;
+//	for (i=0; i < nitems; i++) {
+	return XDrawString16(dpy, d, gc, x, y, items->chars, items->nchars);
+}
diff -Nuarp nxlib-0.47dev.orig/TextToStr.c nxlib-0.47dev/TextToStr.c
--- nxlib-0.47dev.orig/TextToStr.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/TextToStr.c	2013-02-25 15:32:13.000000000 +0900
@@ -0,0 +1,73 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+#include "X11/Xutil.h"
+#include "X11/Xatom.h"
+
+// XTextPropertyToStringList - set list and count to contain data stored in
+// null-separated STRING property.
+Status XTextPropertyToStringList(XTextProperty *tp, char ***list_r, int *count_r)
+{
+	char **list;			/* return value */
+	int nelements;			/* return value */
+	register char *cp;		/* temp variable */
+	char *start;			/* start of thing to copy */
+	int i, j;			/* iterator variables */
+	int datalen = (int) tp->nitems;	/* for convenience */
+
+	// make sure we understand how to do it
+	printf("XTextPropertyToStringList called..\n");
+	if (tp->encoding != XA_STRING ||  tp->format != 8) return False;
+
+	if (datalen == 0) {
+		*list_r = NULL;
+		*count_r = 0;
+		return True;
+	}
+
+	// walk the list to figure out how many elements there are
+	nelements = 1;			/* since null-separated */
+	for (cp = (char*)tp->value, i = datalen; i>0; cp++, i--) {
+		if (*cp == '\0') nelements++;
+	}
+
+	// allocate list and duplicate
+	list = (char**)Xmalloc(nelements * sizeof(char*));
+	if (!list) return False;
+
+	start = (char*)Xmalloc((datalen + 1) * sizeof(char));	/* for <NUL> */
+	if (!start) {
+		Xfree((char*)list);
+		return False;
+	}
+
+	// copy data
+	memcpy(start, (char*)tp->value, tp->nitems);
+	start[datalen] = '\0';
+
+	// walk down list setting value
+	for (cp = start, i = datalen + 1, j = 0; i>0; cp++, i--) {
+		if (*cp == '\0') {
+			list[j] = start;
+			start = (cp + 1);
+			j++;
+		}
+	}
+
+	// append final null pointer and then return data
+	*list_r = list;
+	*count_r = nelements;
+	return True;
+}
+
+void XFreeStringList(char **list)
+{
+	printf("XFreeStringList called..\n");
+	if (list) {
+		if (list[0]) Xfree(list[0]);
+		Xfree((char*)list);
+		list = NULL;
+	}
+}
diff -Nuarp nxlib-0.47dev.orig/Threads.c nxlib-0.47dev/Threads.c
--- nxlib-0.47dev.orig/Threads.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/Threads.c	2013-02-25 14:22:33.000000000 +0900
@@ -0,0 +1,23 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// required for openoffice.org
+Status XInitThreads()
+{
+	printf("XInitThreads called...");
+	return 1;
+}
+
+// for xine
+void XLockDisplay(Display *display)
+{
+	LockDisplay(display);
+}
+
+void XUnlockDisplay(Display *display)
+{
+	UnlockDisplay(display);
+}
diff -Nuarp nxlib-0.47dev.orig/X11/Xutil.h nxlib-0.47dev/X11/Xutil.h
--- nxlib-0.47dev.orig/X11/Xutil.h	2010-01-10 06:36:46.000000000 +0900
+++ nxlib-0.47dev/X11/Xutil.h	2013-02-25 13:50:08.000000000 +0900
@@ -611,12 +611,13 @@ extern int XRectInRegion(
 );
 
 extern int XSaveContext(
-#if NeedFunctionPrototypes
+//#if NeedFunctionPrototypes
     Display*		/* display */,
     XID			/* rid */,
     XContext		/* context */,
-    _Xconst char*	/* data */
-#endif
+//    _Xconst char*	/* data */
+    XPointer
+//#endif
 );
 
 extern int XSetClassHint(
@@ -899,7 +900,7 @@ extern int XUnionRegion(
 );
 
 extern int XWMGeometry(
-#if NeedFunctionPrototypes
+//#if NeedFunctionPrototypes
     Display*		/* display */,
     int			/* screen_number */,
     _Xconst char*	/* user_geometry */,
@@ -911,7 +912,7 @@ extern int XWMGeometry(
     int*		/* width_return */,
     int*		/* height_return */,
     int*		/* gravity_return */
-#endif
+//#endif
 );
 
 extern int XXorRegion(
diff -Nuarp nxlib-0.47dev.orig/XKB.c nxlib-0.47dev/XKB.c
--- nxlib-0.47dev.orig/XKB.c	1970-01-01 09:00:00.000000000 +0900
+++ nxlib-0.47dev/XKB.c	2013-02-25 14:21:36.000000000 +0900
@@ -0,0 +1,147 @@
+//---------------------------------------------------------
+//	©2009 Yuichiro Nakada
+//---------------------------------------------------------
+
+#include "nxlib.h"
+
+// required for Qt
+Bool XkbSetPerClientControls(Display *dpy, unsigned change, unsigned *values)
+{
+	printf("XkbSetPerClientControls called ???\n");
+	return 0;
+}
+
+// required for wine
+Bool XkbSetDetectableAutoRepeat(Display *dpy, Bool detectable, Bool *supported)
+{
+	printf("XkbSetDetectableAutoRepeat called ???\n");
+	return 0;
+}
+
+unsigned XkbKeysymToModifiers(Display *dpy, KeySym ks)
+{
+	//return XKeysymToModifiers(dpy, ks);
+	printf("XkbKeysymToModifiers called [%x]???\n", ks);
+	return 0;
+}
+
+Bool XkbUseExtension(Display *dpy, int *major, int *minor)
+{
+	printf("XkbUseExtension called...\n");
+	return 0;
+}
+
+#if 0
+struct _XKeytrans {
+	struct _XKeytrans *next;/* next on list */
+	char *string;		/* string to return when the time comes */
+	int len;		/* length of string (since NULL is legit)*/
+	KeySym key;		/* keysym rebound */
+	unsigned int state;	/* modifier state */
+	KeySym *modifiers;	/* modifier keysyms you want */
+	int mlen;		/* length of modifier list */
+};
+
+int XkbLookupKeyBinding(Display *dpy, KeySym sym, unsigned int mods,
+	char *buffer, int nbytes, int *extra_rtrn)
+{
+	struct _XKeytrans *p;
+
+	if (extra_rtrn) *extra_rtrn = 0;
+	for (p = dpy->key_bindings; p; p = p->next) {
+		if (((mods & AllMods) == p->state) && (sym == p->key)) {
+			int tmp = p->len;
+			if (tmp > nbytes) {
+				if (extra_rtrn) *extra_rtrn = (tmp-nbytes);
+				tmp = nbytes;
+			}
+			memcpy(buffer, p->string, tmp);
+			if (tmp < nbytes) buffer[tmp] = '\0';
+			return tmp;
+		}
+	}
+	return 0;
+}
+#endif
+
+int XkbTranslateKeySym(Display *dpy, KeySym *sym, unsigned int mods,
+	char *buf, int nbytes, int *extra)
+{
+	//char tmp[4];
+	char *p;
+
+	p = XKeysymToString(sym[0]);
+	nbytes = strlen(p);
+	memcpy(buf, p, nbytes);
+	printf("XkbTranslateKeySym called [%x/%s]...\n", *sym, p);
+	if (extra) *extra = 0;
+	/*if (!buf || !nbytes) {
+		buf = tmp;
+		nbytes = 4;
+	}*/
+	return nbytes;
+
+#if 0
+	XkbInfoPtr xkb;
+	XkbKSToMBFunc cvtr;
+	XPointer priv;
+	char tmp[4];
+	int n;
+
+	xkb = dpy->xkb_info;
+	if (!xkb->cvt.KSToMB) {
+		_XkbGetConverters(_XkbGetCharset(), &xkb->cvt);
+		_XkbGetConverters("ISO8859-1", &xkb->latin1cvt);
+	}
+
+	if (extra) *extra = 0;
+	if (!buf || !nbytes) {
+		buf = tmp;
+		nbytes = 4;
+	}
+
+	/* see if symbol rebound, if so, return that string. */
+	n = XkbLookupKeyBinding(dpy, *sym, mods, buf, nbytes, extra);
+	if (n) return n;
+	if (nbytes>0) buf[0] = '\0';
+
+	if (xkb->cvt.KSToUpper && (mods&LockMask)) {
+		*sym = (*xkb->cvt.KSToUpper)(*sym);
+	}
+	if (xkb->xlib_ctrls & XkbLC_ForceLatin1Lookup) {
+		cvtr = xkb->latin1cvt.KSToMB;
+		priv = xkb->latin1cvt.KSToMBPriv;
+	} else {
+		cvtr = xkb->cvt.KSToMB;
+		priv = xkb->cvt.KSToMBPriv;
+	}
+
+	n = (*cvtr)(priv, *sym, buf, nbytes, extra);
+
+	if ((!xkb->cvt.KSToUpper) && (mods&LockMask)) {
+		int i;
+		int change;
+		char ch;
+		for (i=change=0; i<n; i++) {
+			ch = toupper(buf[i]);
+			change = (change||(buf[i]!=ch));
+			buf[i] = ch;
+		}
+		if (change) {
+			if (n==1) *sym = (*xkb->cvt.MBToKS)(xkb->cvt.MBToKSPriv, buf, n, 0);
+			else *sym = NoSymbol;
+		}
+	}
+
+	if (mods&ControlMask) {
+		if (n==1) {
+			buf[0] = XkbToControl(buf[0]);
+			if (nbytes>1) buf[1] = '\0';
+			return 1;
+		}
+		if (nbytes>0) buf[0]= '\0';
+		return 0;
+	}
+	return n;
+#endif
+}
diff -Nuarp nxlib-0.47dev.orig/stub.c nxlib-0.47dev/stub.c
--- nxlib-0.47dev.orig/stub.c	2010-12-10 03:57:17.000000000 +0900
+++ nxlib-0.47dev/stub.c	2013-02-25 15:41:52.000000000 +0900
@@ -8,11 +8,12 @@
 
 /* stubbed out calls, need implementations*/
 int XScreenResourceString() { DPRINTF("XScreenResourceString called\n"); return 0; } 
-int XWMGeometry() { DPRINTF("XWMGeometry called\n"); return 0; } 
+// required for Xt
+//int XWMGeometry() { DPRINTF("XWMGeometry called\n"); return 0; }
 int XGetIconSizes() { DPRINTF("XGetIconSizes called\n"); return 0; } 
 int XQueryBestCursor() { DPRINTF("XQueryBestCursor called\n"); return 0; } 
 int XSetState() { DPRINTF("XSetState called\n"); return 0; } 
-int XResourceManagerString() { DPRINTF("XResourceManagerString called\n"); return 0; } 
+//int XResourceManagerString() { DPRINTF("XResourceManagerString called\n"); return 0; } 
 int XrmParseCommand() { DPRINTF("XrmParseCommand called\n"); return 0; } 
 int XQueryKeymap() { DPRINTF("XQueryKeymap called\n"); return 0; } 
 int XGetDefault(void *d, char *program, char *option) { DPRINTF("XGetDefault %s %s\n", program, option); return 0; } 
@@ -31,9 +32,9 @@ int XShapeGetRectangles() { DPRINTF("XSh
 int XAddConnectionWatch() { DPRINTF("XAddConnectionWatch called\n"); return 0; } 
 int XProcessInternalConnection() { DPRINTF("XProcessInternalConnection called\n"); return 0;}
 int XCopyGC() { DPRINTF("XCopyGC called\n"); return 0;}
-int XGetSubImage() { DPRINTF("XGetSubImage called\n"); return 0;}
+//int XGetSubImage() { DPRINTF("XGetSubImage called\n"); return 0;}
 int XGetMotionEvents() { DPRINTF("XGetMotionEvents called\n"); return 0;}
-int XQueryExtension() { DPRINTF("XQueryExtension called\n"); return 0; } 
+//int XQueryExtension() { DPRINTF("XQueryExtension called\n"); return 0; } 
 int XwcDrawString() { DPRINTF("XwcDrawString called\n"); return 0;}
 
 int XwcTextExtents() { DPRINTF("XwcTextExtents called\n"); return 0;}
@@ -46,22 +47,22 @@ int XGetICValues() { DPRINTF("XGetICValu
 int XFontsOfFontSet() { DPRINTF("XFontsOfFontSet called\n"); return 0;}
 int XBaseFontNameListOfFontSet() { DPRINTF("XBaseFontNameListOfFontSet called\n"); return 0;}
 int XkbLibraryVersion() { DPRINTF("XkbLibraryVersion called\n"); return 0; } 
-int XDisplayKeycodes() { DPRINTF("XDisplayKeycodes called\n"); return 0;}
-int XGetKeyboardMapping() { DPRINTF("XGetKeyboardMapping called\n"); return 0;}
+//int XDisplayKeycodes() { DPRINTF("XDisplayKeycodes called\n"); return 0;}
+//int XGetKeyboardMapping() { DPRINTF("XGetKeyboardMapping called\n"); return 0;}
 int XGetKeyboardControl() { DPRINTF("XGetKeyboardControl called\n"); return 0; } 
-int XShmQueryExtension() { DPRINTF("XShmQueryExtension called\n"); return 0; } 
+//int XShmQueryExtension() { DPRINTF("XShmQueryExtension called\n"); return 0; } 
 int XShmAttach() { DPRINTF("XShmAttach called\n"); return 0; } 
 int XShmCreateImage() { DPRINTF("XShmCreateImage called\n"); return 0; } 
 int XShmPutImage() { DPRINTF("XShmPutImage called\n"); return 0; } 
 
 /* other required*/
-int XAddExtension() { DPRINTF("XAddExtension called\n"); return 0; } 
+//int XAddExtension() { DPRINTF("XAddExtension called\n"); return 0; } 
 int XAllocColorCells() { DPRINTF("XAllocColorCells called\n"); return 0; }
 int _XAllocScratch() { DPRINTF("_XAllocScratch called\n"); return 0; } 
 int XAllowEvents() { DPRINTF("XAllowEvents called\n"); return 0; } 
 
 int _XEatData() { DPRINTF("_XEatData called\n"); return 0; } 
-int XESetCloseDisplay() { DPRINTF("XESetCloseDisplay called\n"); return 0; } 
+//int XESetCloseDisplay() { DPRINTF("XESetCloseDisplay called\n"); return 0; } 
 int XESetCopyGC() { DPRINTF("XESetCopyGC called\n"); return 0; } 
 int XESetCreateFont() { DPRINTF("XESetCreateFont called\n"); return 0; } 
 int XESetCreateGC() { DPRINTF("XESetCreateGC called\n"); return 0; } 
@@ -72,31 +73,31 @@ int XESetFlushGC() { DPRINTF("XESetFlush
 int XESetFreeFont() { DPRINTF("XESetFreeFont called\n"); return 0; } 
 int XESetFreeGC() { DPRINTF("XESetFreeGC called\n"); return 0; } 
 int XESetWireToEvent() { DPRINTF("XESetWireToEvent called\n"); return 0; } 
-int XExtentsOfFontSet() { DPRINTF("XExtentsOfFontSet called\n"); return 0; } 
+//int XExtentsOfFontSet() { DPRINTF("XExtentsOfFontSet called\n"); return 0; } 
 int XFetchName() { DPRINTF("XFetchName called\n"); return 0; }
 int _XFlush() { DPRINTF("_XFlush called\n"); return 0; } 
 int _XFlushGCCache() { DPRINTF("_XFlushGCCache called\n"); return 0; } 
 int XFreeFontSet() { DPRINTF("XFreeFontSet called\n"); return 0; } 
-int XFreeStringList() { DPRINTF("XFreeStringList called\n"); return 0; } 
+//int XFreeStringList() { DPRINTF("XFreeStringList called\n"); return 0; } 
 int _XGetBitsPerPixel() { DPRINTF("_XGetBitsPerPixel called\n"); return 0; } 
-int XGetGCValues() { DPRINTF("XGetGCVAlues called\n"); return 0; }
+//int XGetGCValues() { DPRINTF("XGetGCVAlues called\n"); return 0; }
 int XGetErrorDatabaseText() { DPRINTF("XGetErrorDatabaseText called\n"); return 0; } 
 int XGetErrorText() { DPRINTF("XGetErrorText called\n"); return 0; } 
 int _XGetScanlinePad() { DPRINTF("_XGetScanlinePad called\n"); return 0; } 
 
-int XGetWMHints() { DPRINTF("XGetWMHints called\n"); return 0; } 
+//int XGetWMHints() { DPRINTF("XGetWMHints called\n"); return 0; } 
 int XGetWMNormalHints() { DPRINTF("XGetWMNormalHints called\n"); return 0; } 
 int XGrabKeyboard() { DPRINTF("XGrabKeyboard called\n"); return 0; } 
 int XGrabPointer() { DPRINTF("XGrabPointer called\n"); return 0; } 
 int XGrabServer() { DPRINTF("XGrabServer called\n"); return 0; } 
 int XIconifyWindow() { DPRINTF("XIconifyWindow called\n"); return 0; } 
-int XInitExtension() { DPRINTF("XInitExtension called\n"); return 0; } 
+//int XInitExtension() { DPRINTF("XInitExtension called\n"); return 0; } 
 int _XInitImageFuncPtrs() { DPRINTF("_XInitImageFuncPtrs called\n"); return 0; } 
 int XKillClient() { DPRINTF("XKillClient called\n"); return 0; } 
 int XMaxRequestSize() { DPRINTF("XMaxRequestSize called\n"); return 0; } 
 int XmbDrawImageString() { DPRINTF("XmbDrawImageString called\n"); return 0; } 
 int XmbDrawString() { DPRINTF("XmbDrawString called\n"); return 0; } 
-int XmbLookupString() { DPRINTF("XmbLookupString called\n"); return 0; } 
+//int XmbLookupString() { DPRINTF("XmbLookupString called\n"); return 0; } 
 int XmbTextExtents() { DPRINTF("XmbTextExtents called\n"); return 0; } 
 
 int XParseGeometry() { DPRINTF("XParseGeometry called\n"); return 0; } 
@@ -108,14 +109,14 @@ int _XSend() { DPRINTF("_XSend called\n"
 int XSendEvent() { DPRINTF("XSendEvent called\n"); return 0; } 
 int XSetArcMode() { DPRINTF("XSetArcMode called\n"); return 0; } 
 int XSetCloseDownMode() { DPRINTF("XSetCloseDownMode called\n"); return 0; } 
-int XSetErrorHandler() { DPRINTF("XSetErrorHandler called\n"); return 0; } 
+//int XSetErrorHandler() { DPRINTF("XSetErrorHandler called\n"); return 0; } 
 int XSetFillRule() { DPRINTF("XSetFillRule called\n"); return 0; } 
 int _XSetLastRequestRead() { DPRINTF("_XSetLastRequestRead called\n"); return 0; } 
-int XSetLocaleModifiers() { DPRINTF("XSetLocaleModifiers called\n"); return 0; } 
+//int XSetLocaleModifiers() { DPRINTF("XSetLocaleModifiers called\n"); return 0; } 
 
 int XSetStandardProperties() { DPRINTF("XSetStandardProperties called\n"); return 0; } 
-int XSetNormalHints() { DPRINTF("XSetNormalHints called\n"); return 0; }
-int XSetWMProtocols() { DPRINTF("XSetWMProtocols called\n"); return 0; } 
+//int XSetNormalHints() { DPRINTF("XSetNormalHints called\n"); return 0; }
+//int XSetWMProtocols() { DPRINTF("XSetWMProtocols called\n"); return 0; } 
 int XSupportsLocale() { DPRINTF("XSupportsLocale called\n"); return 1; } 
 int XSynchronize() { DPRINTF("XSynchronize called\n"); return 0; } 
 int XUngrabKeyboard() { DPRINTF("XUngrabKeyboard called\n"); return 0; } 
@@ -128,35 +129,49 @@ int XInstallColormap() { DPRINTF("XInsta
 int XReconfigureWMWindow() { DPRINTF("XReconfigureWMWindow called\n"); return 0; } 
 int XSetWindowColormap() { DPRINTF("XSetWindowColormap called\n"); return 0; } 
 int XUninstallColormap() { DPRINTF("XUninstallColormap called\n"); return 0; } 
-int XConfigureWindow() { DPRINTF("XConfigureWindow called\n"); return 0; } 
+//int XConfigureWindow() { DPRINTF("XConfigureWindow called\n"); return 0; } 
 int XForceScreenSaver() { DPRINTF("XForceScreenSaver called\n"); return 0; } 
-int XFreeModifiermap() { DPRINTF("XFreeModifiermap called\n"); return 0; } 
-int XGetInputFocus() { DPRINTF("XGetInputFocus called\n"); return 0; } 
-int XGetModifierMapping() { DPRINTF("XGetModifierMapping called\n"); return 0; } 
+//int XFreeModifiermap() { DPRINTF("XFreeModifiermap called\n"); return 0; } 
+//int XGetInputFocus() { DPRINTF("XGetInputFocus called\n"); return 0; } 
+//int XGetModifierMapping() { DPRINTF("XGetModifierMapping called\n"); return 0; } 
 int XGetWMColormapWindows() { DPRINTF("XGetWMColormapWindows called\n"); return 0; } 
-int XKeysymToString() { DPRINTF("XKeysymToString called\n"); return 0; } 
+//int XKeysymToString() { DPRINTF("XKeysymToString called\n"); return 0; } 
 int XListHosts() { DPRINTF("XListHosts called\n"); return 0; } 
-int XSetClassHint() { DPRINTF("XSetClassHint called\n"); return 0; } 
+//int XSetClassHint() { DPRINTF("XSetClassHint called\n"); return 0; } 
 int XSetCommand() { DPRINTF("XSetCommand called\n"); return 0; } 
 int XSetWindowBorderPixmap() { DPRINTF("XSetWindowBorderPixmap called\n"); return 0; } 
-int XSetWMClientMachine() { DPRINTF("XSetWMClientMachine called\n"); return 0; } 
+//int XSetWMClientMachine() { DPRINTF("XSetWMClientMachine called\n"); return 0; } 
 int XSetWMColormapWindows() { DPRINTF("XSetWMColormapWindows called\n"); return 0; } 
 int XStoreColor() { DPRINTF("XStoreColor called\n"); return 0; }
 int XStoreColors() { DPRINTF("XStoreColors called\n"); return 0; }
 int _XUnknownNativeEvent() { DPRINTF("_XUnknownNativeEvent called\n"); return 0; }
 int Xutf8LookupString() { DPRINTF("Xutf8LookupString called\n"); return 0; }
 
-int XCreateIC() { DPRINTF("XCreateIC called\n"); return 0; } 
+//int XCreateIC() { DPRINTF("XCreateIC called\n"); return 0; } 
 int XDestroyIC() { DPRINTF("XDestroyIC called\n"); return 0; } 
 int XSetICFocus() { DPRINTF("XSetICFocus called\n"); return 0; } 
 int XSetICValues() { DPRINTF("XSetICValues called\n"); return 0; } 
 int XUnsetICFocus() { DPRINTF("XUnsetICFocus called\n"); return 0; } 
 
-int XOpenIM() { DPRINTF("XOpenIM called\n"); return 0; } 
-int XCloseIM() { DPRINTF("XCloseIM called\n"); return 0; } 
+//int XOpenIM() { DPRINTF("XOpenIM called\n"); return 0; } 
+//int XCloseIM() { DPRINTF("XCloseIM called\n"); return 0; } 
 int XGetIMValues() { DPRINTF("XGetIMValues called\n"); return 0; } 
 int XSetIMValues() { DPRINTF("XSetIMValues called\n"); return 0; } 
 int XRegisterIMInstantiateCallback() { DPRINTF("XRegisterIMInstantiateCallback called\n"); return 0; } 
 int XUnregisterIMInstantiateCallback() { DPRINTF("XUnregisterIMInstantiateCallback called\n"); return 0; } 
 int XIMOfIC() { DPRINTF("XIMOfIC called\n"); return 0; }
-int XLocaleOfIM() { DPRINTF("XLocaleOfIM called\n"); return 0; }
+//int XLocaleOfIM() { DPRINTF("XLocaleOfIM called\n"); return 0; }
+
+// required for xine
+int XResetScreenSaver() { printf("XResetScreenSaver called\n"); return 0; }
+// required for wine
+int XGetScreenSaver() { printf("XGetScreenSaver called\n"); return 0; }
+int XSetScreenSaver() { printf("XSetScreenSaver called\n"); return 0; }
+// required for gmplayer
+int _XDefaultError(/*Display *dpy, XErrorEvent *event*/)
+{
+	//if (_XPrintDefaultError(dpy, event, stderr) == 0) return 0;
+	//exit(1);
+	printf("_XDefaultError called\n");
+	return 0;
+}
